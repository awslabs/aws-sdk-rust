// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateWaveOutput  {
    /// <p>Wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
    /// <p>Wave ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Wave name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Wave description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Wave archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Wave aggregated status.</p>
    #[doc(hidden)]
    pub wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
    /// <p>Wave creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Wave last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Wave tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateWaveOutput {
    /// <p>Wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
    /// <p>Wave ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Wave name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Wave description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Wave archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Wave aggregated status.</p>
    pub fn wave_aggregated_status(&self) -> std::option::Option<& crate::model::WaveAggregatedStatus> {
        self.wave_aggregated_status.as_ref()
    }
    /// <p>Wave creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Wave last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Wave tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for UpdateWaveOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateWaveOutput");
        formatter.field("wave_id", &self.wave_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`UpdateWaveOutput`](crate::output::UpdateWaveOutput).
pub mod update_wave_output {
    
    /// A builder for [`UpdateWaveOutput`](crate::output::UpdateWaveOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) wave_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// <p>Wave ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Wave ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Wave name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Wave name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Wave description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Wave description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Wave archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Wave archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Wave aggregated status.</p>
        pub fn wave_aggregated_status(mut self, input: crate::model::WaveAggregatedStatus) -> Self {
            self.wave_aggregated_status = Some(input);
            self
        }
        /// <p>Wave aggregated status.</p>
        pub fn set_wave_aggregated_status(mut self, input: std::option::Option<crate::model::WaveAggregatedStatus>) -> Self {
            self.wave_aggregated_status = input; self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Wave tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Wave tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`UpdateWaveOutput`](crate::output::UpdateWaveOutput).
        pub fn build(self) -> crate::output::UpdateWaveOutput {
            crate::output::UpdateWaveOutput {
                wave_id: self.wave_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                wave_aggregated_status: self.wave_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("wave_id", &self.wave_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl UpdateWaveOutput {
    /// Creates a new builder-style object to manufacture [`UpdateWaveOutput`](crate::output::UpdateWaveOutput).
    pub fn builder() -> crate::output::update_wave_output::Builder {
        crate::output::update_wave_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnarchiveWaveOutput  {
    /// <p>Wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
    /// <p>Wave ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Wave name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Wave description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Wave archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Wave aggregated status.</p>
    #[doc(hidden)]
    pub wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
    /// <p>Wave creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Wave last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Wave tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UnarchiveWaveOutput {
    /// <p>Wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
    /// <p>Wave ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Wave name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Wave description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Wave archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Wave aggregated status.</p>
    pub fn wave_aggregated_status(&self) -> std::option::Option<& crate::model::WaveAggregatedStatus> {
        self.wave_aggregated_status.as_ref()
    }
    /// <p>Wave creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Wave last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Wave tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for UnarchiveWaveOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnarchiveWaveOutput");
        formatter.field("wave_id", &self.wave_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`UnarchiveWaveOutput`](crate::output::UnarchiveWaveOutput).
pub mod unarchive_wave_output {
    
    /// A builder for [`UnarchiveWaveOutput`](crate::output::UnarchiveWaveOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) wave_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// <p>Wave ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Wave ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Wave name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Wave name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Wave description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Wave description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Wave archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Wave archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Wave aggregated status.</p>
        pub fn wave_aggregated_status(mut self, input: crate::model::WaveAggregatedStatus) -> Self {
            self.wave_aggregated_status = Some(input);
            self
        }
        /// <p>Wave aggregated status.</p>
        pub fn set_wave_aggregated_status(mut self, input: std::option::Option<crate::model::WaveAggregatedStatus>) -> Self {
            self.wave_aggregated_status = input; self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Wave tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Wave tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`UnarchiveWaveOutput`](crate::output::UnarchiveWaveOutput).
        pub fn build(self) -> crate::output::UnarchiveWaveOutput {
            crate::output::UnarchiveWaveOutput {
                wave_id: self.wave_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                wave_aggregated_status: self.wave_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("wave_id", &self.wave_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl UnarchiveWaveOutput {
    /// Creates a new builder-style object to manufacture [`UnarchiveWaveOutput`](crate::output::UnarchiveWaveOutput).
    pub fn builder() -> crate::output::unarchive_wave_output::Builder {
        crate::output::unarchive_wave_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateApplicationsOutput  {
}
/// See [`DisassociateApplicationsOutput`](crate::output::DisassociateApplicationsOutput).
pub mod disassociate_applications_output {
    
    /// A builder for [`DisassociateApplicationsOutput`](crate::output::DisassociateApplicationsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DisassociateApplicationsOutput`](crate::output::DisassociateApplicationsOutput).
        pub fn build(self) -> crate::output::DisassociateApplicationsOutput {
            crate::output::DisassociateApplicationsOutput {
            }
        }
    }
    
    
}
impl DisassociateApplicationsOutput {
    /// Creates a new builder-style object to manufacture [`DisassociateApplicationsOutput`](crate::output::DisassociateApplicationsOutput).
    pub fn builder() -> crate::output::disassociate_applications_output::Builder {
        crate::output::disassociate_applications_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateApplicationsOutput  {
}
/// See [`AssociateApplicationsOutput`](crate::output::AssociateApplicationsOutput).
pub mod associate_applications_output {
    
    /// A builder for [`AssociateApplicationsOutput`](crate::output::AssociateApplicationsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`AssociateApplicationsOutput`](crate::output::AssociateApplicationsOutput).
        pub fn build(self) -> crate::output::AssociateApplicationsOutput {
            crate::output::AssociateApplicationsOutput {
            }
        }
    }
    
    
}
impl AssociateApplicationsOutput {
    /// Creates a new builder-style object to manufacture [`AssociateApplicationsOutput`](crate::output::AssociateApplicationsOutput).
    pub fn builder() -> crate::output::associate_applications_output::Builder {
        crate::output::associate_applications_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArchiveWaveOutput  {
    /// <p>Wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
    /// <p>Wave ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Wave name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Wave description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Wave archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Wave aggregated status.</p>
    #[doc(hidden)]
    pub wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
    /// <p>Wave creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Wave last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Wave tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ArchiveWaveOutput {
    /// <p>Wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
    /// <p>Wave ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Wave name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Wave description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Wave archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Wave aggregated status.</p>
    pub fn wave_aggregated_status(&self) -> std::option::Option<& crate::model::WaveAggregatedStatus> {
        self.wave_aggregated_status.as_ref()
    }
    /// <p>Wave creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Wave last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Wave tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for ArchiveWaveOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArchiveWaveOutput");
        formatter.field("wave_id", &self.wave_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ArchiveWaveOutput`](crate::output::ArchiveWaveOutput).
pub mod archive_wave_output {
    
    /// A builder for [`ArchiveWaveOutput`](crate::output::ArchiveWaveOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) wave_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// <p>Wave ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Wave ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Wave name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Wave name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Wave description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Wave description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Wave archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Wave archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Wave aggregated status.</p>
        pub fn wave_aggregated_status(mut self, input: crate::model::WaveAggregatedStatus) -> Self {
            self.wave_aggregated_status = Some(input);
            self
        }
        /// <p>Wave aggregated status.</p>
        pub fn set_wave_aggregated_status(mut self, input: std::option::Option<crate::model::WaveAggregatedStatus>) -> Self {
            self.wave_aggregated_status = input; self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Wave tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Wave tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`ArchiveWaveOutput`](crate::output::ArchiveWaveOutput).
        pub fn build(self) -> crate::output::ArchiveWaveOutput {
            crate::output::ArchiveWaveOutput {
                wave_id: self.wave_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                wave_aggregated_status: self.wave_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("wave_id", &self.wave_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl ArchiveWaveOutput {
    /// Creates a new builder-style object to manufacture [`ArchiveWaveOutput`](crate::output::ArchiveWaveOutput).
    pub fn builder() -> crate::output::archive_wave_output::Builder {
        crate::output::archive_wave_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListWavesOutput  {
    /// <p>Waves list.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::Wave>>,
    /// <p>Response next token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListWavesOutput {
    /// <p>Waves list.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::Wave]> {
        self.items.as_deref()
    }
    /// <p>Response next token.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`ListWavesOutput`](crate::output::ListWavesOutput).
pub mod list_waves_output {
    
    /// A builder for [`ListWavesOutput`](crate::output::ListWavesOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::Wave>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Waves list.</p>
        pub fn items(mut self, input: crate::model::Wave) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Waves list.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::Wave>>) -> Self {
            self.items = input; self
        }
        /// <p>Response next token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Response next token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListWavesOutput`](crate::output::ListWavesOutput).
        pub fn build(self) -> crate::output::ListWavesOutput {
            crate::output::ListWavesOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl ListWavesOutput {
    /// Creates a new builder-style object to manufacture [`ListWavesOutput`](crate::output::ListWavesOutput).
    pub fn builder() -> crate::output::list_waves_output::Builder {
        crate::output::list_waves_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateWaveOutput  {
    /// <p>Wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
    /// <p>Wave ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Wave name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Wave description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Wave archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Wave aggregated status.</p>
    #[doc(hidden)]
    pub wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
    /// <p>Wave creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Wave last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Wave tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateWaveOutput {
    /// <p>Wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
    /// <p>Wave ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Wave name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Wave description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Wave archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Wave aggregated status.</p>
    pub fn wave_aggregated_status(&self) -> std::option::Option<& crate::model::WaveAggregatedStatus> {
        self.wave_aggregated_status.as_ref()
    }
    /// <p>Wave creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Wave last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Wave tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for CreateWaveOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateWaveOutput");
        formatter.field("wave_id", &self.wave_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`CreateWaveOutput`](crate::output::CreateWaveOutput).
pub mod create_wave_output {
    
    /// A builder for [`CreateWaveOutput`](crate::output::CreateWaveOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) wave_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) wave_aggregated_status: std::option::Option<crate::model::WaveAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// <p>Wave ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Wave ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Wave name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Wave name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Wave description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Wave description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Wave archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Wave archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Wave aggregated status.</p>
        pub fn wave_aggregated_status(mut self, input: crate::model::WaveAggregatedStatus) -> Self {
            self.wave_aggregated_status = Some(input);
            self
        }
        /// <p>Wave aggregated status.</p>
        pub fn set_wave_aggregated_status(mut self, input: std::option::Option<crate::model::WaveAggregatedStatus>) -> Self {
            self.wave_aggregated_status = input; self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Wave creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Wave last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Wave tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Wave tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateWaveOutput`](crate::output::CreateWaveOutput).
        pub fn build(self) -> crate::output::CreateWaveOutput {
            crate::output::CreateWaveOutput {
                wave_id: self.wave_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                wave_aggregated_status: self.wave_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("wave_id", &self.wave_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("wave_aggregated_status", &self.wave_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl CreateWaveOutput {
    /// Creates a new builder-style object to manufacture [`CreateWaveOutput`](crate::output::CreateWaveOutput).
    pub fn builder() -> crate::output::create_wave_output::Builder {
        crate::output::create_wave_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteWaveOutput  {
}
/// See [`DeleteWaveOutput`](crate::output::DeleteWaveOutput).
pub mod delete_wave_output {
    
    /// A builder for [`DeleteWaveOutput`](crate::output::DeleteWaveOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteWaveOutput`](crate::output::DeleteWaveOutput).
        pub fn build(self) -> crate::output::DeleteWaveOutput {
            crate::output::DeleteWaveOutput {
            }
        }
    }
    
    
}
impl DeleteWaveOutput {
    /// Creates a new builder-style object to manufacture [`DeleteWaveOutput`](crate::output::DeleteWaveOutput).
    pub fn builder() -> crate::output::delete_wave_output::Builder {
        crate::output::delete_wave_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeVcenterClientsOutput  {
    /// <p>List of items returned by DescribeVcenterClients.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::VcenterClient>>,
    /// <p>Next pagination token returned from DescribeVcenterClients.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeVcenterClientsOutput {
    /// <p>List of items returned by DescribeVcenterClients.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::VcenterClient]> {
        self.items.as_deref()
    }
    /// <p>Next pagination token returned from DescribeVcenterClients.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`DescribeVcenterClientsOutput`](crate::output::DescribeVcenterClientsOutput).
pub mod describe_vcenter_clients_output {
    
    /// A builder for [`DescribeVcenterClientsOutput`](crate::output::DescribeVcenterClientsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::VcenterClient>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>List of items returned by DescribeVcenterClients.</p>
        pub fn items(mut self, input: crate::model::VcenterClient) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>List of items returned by DescribeVcenterClients.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::VcenterClient>>) -> Self {
            self.items = input; self
        }
        /// <p>Next pagination token returned from DescribeVcenterClients.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Next pagination token returned from DescribeVcenterClients.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeVcenterClientsOutput`](crate::output::DescribeVcenterClientsOutput).
        pub fn build(self) -> crate::output::DescribeVcenterClientsOutput {
            crate::output::DescribeVcenterClientsOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl DescribeVcenterClientsOutput {
    /// Creates a new builder-style object to manufacture [`DescribeVcenterClientsOutput`](crate::output::DescribeVcenterClientsOutput).
    pub fn builder() -> crate::output::describe_vcenter_clients_output::Builder {
        crate::output::describe_vcenter_clients_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteVcenterClientOutput  {
}
/// See [`DeleteVcenterClientOutput`](crate::output::DeleteVcenterClientOutput).
pub mod delete_vcenter_client_output {
    
    /// A builder for [`DeleteVcenterClientOutput`](crate::output::DeleteVcenterClientOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteVcenterClientOutput`](crate::output::DeleteVcenterClientOutput).
        pub fn build(self) -> crate::output::DeleteVcenterClientOutput {
            crate::output::DeleteVcenterClientOutput {
            }
        }
    }
    
    
}
impl DeleteVcenterClientOutput {
    /// Creates a new builder-style object to manufacture [`DeleteVcenterClientOutput`](crate::output::DeleteVcenterClientOutput).
    pub fn builder() -> crate::output::delete_vcenter_client_output::Builder {
        crate::output::delete_vcenter_client_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSourceServerReplicationTypeOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl UpdateSourceServerReplicationTypeOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for UpdateSourceServerReplicationTypeOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSourceServerReplicationTypeOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`UpdateSourceServerReplicationTypeOutput`](crate::output::UpdateSourceServerReplicationTypeOutput).
pub mod update_source_server_replication_type_output {
    
    /// A builder for [`UpdateSourceServerReplicationTypeOutput`](crate::output::UpdateSourceServerReplicationTypeOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`UpdateSourceServerReplicationTypeOutput`](crate::output::UpdateSourceServerReplicationTypeOutput).
        pub fn build(self) -> crate::output::UpdateSourceServerReplicationTypeOutput {
            crate::output::UpdateSourceServerReplicationTypeOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl UpdateSourceServerReplicationTypeOutput {
    /// Creates a new builder-style object to manufacture [`UpdateSourceServerReplicationTypeOutput`](crate::output::UpdateSourceServerReplicationTypeOutput).
    pub fn builder() -> crate::output::update_source_server_replication_type_output::Builder {
        crate::output::update_source_server_replication_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateReplicationConfigurationOutput  {
    /// <p>Replication Configuration Source Server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Replication Configuration Staging Area subnet ID.</p>
    #[doc(hidden)]
    pub staging_area_subnet_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
    #[doc(hidden)]
    pub associate_default_security_group: std::option::Option<bool>,
    /// <p>Replication Configuration Replication Server Security Group IDs.</p>
    #[doc(hidden)]
    pub replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Replication Configuration Replication Server instance type.</p>
    #[doc(hidden)]
    pub replication_server_instance_type: std::option::Option<std::string::String>,
    /// <p>Replication Configuration use Dedicated Replication Server.</p>
    #[doc(hidden)]
    pub use_dedicated_replication_server: std::option::Option<bool>,
    /// <p>Replication Configuration use default large Staging Disks.</p>
    #[doc(hidden)]
    pub default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
    /// <p>Replication Configuration replicated disks.</p>
    #[doc(hidden)]
    pub replicated_disks: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationReplicatedDisk>>,
    /// <p>Replication Configuration EBS encryption.</p>
    #[doc(hidden)]
    pub ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
    /// <p>Replication Configuration EBS encryption key ARN.</p>
    #[doc(hidden)]
    pub ebs_encryption_key_arn: std::option::Option<std::string::String>,
    /// <p>Replication Configuration set bandwidth throttling.</p>
    #[doc(hidden)]
    pub bandwidth_throttling: i64,
    /// <p>Replication Configuration data plane routing.</p>
    #[doc(hidden)]
    pub data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
    /// <p>Replication Configuration create Public IP.</p>
    #[doc(hidden)]
    pub create_public_ip: std::option::Option<bool>,
    /// <p>Replication Configuration Staging Area tags.</p>
    #[doc(hidden)]
    pub staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateReplicationConfigurationOutput {
    /// <p>Replication Configuration Source Server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Replication Configuration name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Replication Configuration Staging Area subnet ID.</p>
    pub fn staging_area_subnet_id(&self) -> std::option::Option<& str> {
        self.staging_area_subnet_id.as_deref()
    }
    /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
    pub fn associate_default_security_group(&self) -> std::option::Option<bool> {
        self.associate_default_security_group
    }
    /// <p>Replication Configuration Replication Server Security Group IDs.</p>
    pub fn replication_servers_security_groups_i_ds(&self) -> std::option::Option<& [std::string::String]> {
        self.replication_servers_security_groups_i_ds.as_deref()
    }
    /// <p>Replication Configuration Replication Server instance type.</p>
    pub fn replication_server_instance_type(&self) -> std::option::Option<& str> {
        self.replication_server_instance_type.as_deref()
    }
    /// <p>Replication Configuration use Dedicated Replication Server.</p>
    pub fn use_dedicated_replication_server(&self) -> std::option::Option<bool> {
        self.use_dedicated_replication_server
    }
    /// <p>Replication Configuration use default large Staging Disks.</p>
    pub fn default_large_staging_disk_type(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDefaultLargeStagingDiskType> {
        self.default_large_staging_disk_type.as_ref()
    }
    /// <p>Replication Configuration replicated disks.</p>
    pub fn replicated_disks(&self) -> std::option::Option<& [crate::model::ReplicationConfigurationReplicatedDisk]> {
        self.replicated_disks.as_deref()
    }
    /// <p>Replication Configuration EBS encryption.</p>
    pub fn ebs_encryption(&self) -> std::option::Option<& crate::model::ReplicationConfigurationEbsEncryption> {
        self.ebs_encryption.as_ref()
    }
    /// <p>Replication Configuration EBS encryption key ARN.</p>
    pub fn ebs_encryption_key_arn(&self) -> std::option::Option<& str> {
        self.ebs_encryption_key_arn.as_deref()
    }
    /// <p>Replication Configuration set bandwidth throttling.</p>
    pub fn bandwidth_throttling(&self) -> i64 {
        self.bandwidth_throttling
    }
    /// <p>Replication Configuration data plane routing.</p>
    pub fn data_plane_routing(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDataPlaneRouting> {
        self.data_plane_routing.as_ref()
    }
    /// <p>Replication Configuration create Public IP.</p>
    pub fn create_public_ip(&self) -> std::option::Option<bool> {
        self.create_public_ip
    }
    /// <p>Replication Configuration Staging Area tags.</p>
    pub fn staging_area_tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.staging_area_tags.as_ref()
    }
}
impl  std::fmt::Debug for UpdateReplicationConfigurationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateReplicationConfigurationOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("name", &self.name);
        formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
        formatter.field("associate_default_security_group", &self.associate_default_security_group);
        formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
        formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
        formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
        formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
        formatter.field("replicated_disks", &self.replicated_disks);
        formatter.field("ebs_encryption", &self.ebs_encryption);
        formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
        formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
        formatter.field("data_plane_routing", &self.data_plane_routing);
        formatter.field("create_public_ip", &self.create_public_ip);
        formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`UpdateReplicationConfigurationOutput`](crate::output::UpdateReplicationConfigurationOutput).
pub mod update_replication_configuration_output {
    
    /// A builder for [`UpdateReplicationConfigurationOutput`](crate::output::UpdateReplicationConfigurationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) staging_area_subnet_id: std::option::Option<std::string::String>,
        pub(crate) associate_default_security_group: std::option::Option<bool>,
        pub(crate) replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) replication_server_instance_type: std::option::Option<std::string::String>,
        pub(crate) use_dedicated_replication_server: std::option::Option<bool>,
        pub(crate) default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
        pub(crate) replicated_disks: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationReplicatedDisk>>,
        pub(crate) ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
        pub(crate) ebs_encryption_key_arn: std::option::Option<std::string::String>,
        pub(crate) bandwidth_throttling: std::option::Option<i64>,
        pub(crate) data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
        pub(crate) create_public_ip: std::option::Option<bool>,
        pub(crate) staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Replication Configuration Source Server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration Source Server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Replication Configuration name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Replication Configuration name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Replication Configuration Staging Area subnet ID.</p>
        pub fn staging_area_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_area_subnet_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration Staging Area subnet ID.</p>
        pub fn set_staging_area_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.staging_area_subnet_id = input; self
        }
        /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
        pub fn associate_default_security_group(mut self, input: bool) -> Self {
            self.associate_default_security_group = Some(input);
            self
        }
        /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
        pub fn set_associate_default_security_group(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_default_security_group = input; self
        }
        /// Appends an item to `replication_servers_security_groups_i_ds`.
        ///
        /// To override the contents of this collection use [`set_replication_servers_security_groups_i_ds`](Self::set_replication_servers_security_groups_i_ds).
        ///
        /// <p>Replication Configuration Replication Server Security Group IDs.</p>
        pub fn replication_servers_security_groups_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.replication_servers_security_groups_i_ds.unwrap_or_default();
                            v.push(input.into());
                            self.replication_servers_security_groups_i_ds = Some(v);
                            self
        }
        /// <p>Replication Configuration Replication Server Security Group IDs.</p>
        pub fn set_replication_servers_security_groups_i_ds(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.replication_servers_security_groups_i_ds = input; self
        }
        /// <p>Replication Configuration Replication Server instance type.</p>
        pub fn replication_server_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_server_instance_type = Some(input.into());
            self
        }
        /// <p>Replication Configuration Replication Server instance type.</p>
        pub fn set_replication_server_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.replication_server_instance_type = input; self
        }
        /// <p>Replication Configuration use Dedicated Replication Server.</p>
        pub fn use_dedicated_replication_server(mut self, input: bool) -> Self {
            self.use_dedicated_replication_server = Some(input);
            self
        }
        /// <p>Replication Configuration use Dedicated Replication Server.</p>
        pub fn set_use_dedicated_replication_server(mut self, input: std::option::Option<bool>) -> Self {
            self.use_dedicated_replication_server = input; self
        }
        /// <p>Replication Configuration use default large Staging Disks.</p>
        pub fn default_large_staging_disk_type(mut self, input: crate::model::ReplicationConfigurationDefaultLargeStagingDiskType) -> Self {
            self.default_large_staging_disk_type = Some(input);
            self
        }
        /// <p>Replication Configuration use default large Staging Disks.</p>
        pub fn set_default_large_staging_disk_type(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>) -> Self {
            self.default_large_staging_disk_type = input; self
        }
        /// Appends an item to `replicated_disks`.
        ///
        /// To override the contents of this collection use [`set_replicated_disks`](Self::set_replicated_disks).
        ///
        /// <p>Replication Configuration replicated disks.</p>
        pub fn replicated_disks(mut self, input: crate::model::ReplicationConfigurationReplicatedDisk) -> Self {
            let mut v = self.replicated_disks.unwrap_or_default();
                            v.push(input);
                            self.replicated_disks = Some(v);
                            self
        }
        /// <p>Replication Configuration replicated disks.</p>
        pub fn set_replicated_disks(mut self, input: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationReplicatedDisk>>) -> Self {
            self.replicated_disks = input; self
        }
        /// <p>Replication Configuration EBS encryption.</p>
        pub fn ebs_encryption(mut self, input: crate::model::ReplicationConfigurationEbsEncryption) -> Self {
            self.ebs_encryption = Some(input);
            self
        }
        /// <p>Replication Configuration EBS encryption.</p>
        pub fn set_ebs_encryption(mut self, input: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>) -> Self {
            self.ebs_encryption = input; self
        }
        /// <p>Replication Configuration EBS encryption key ARN.</p>
        pub fn ebs_encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = Some(input.into());
            self
        }
        /// <p>Replication Configuration EBS encryption key ARN.</p>
        pub fn set_ebs_encryption_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = input; self
        }
        /// <p>Replication Configuration set bandwidth throttling.</p>
        pub fn bandwidth_throttling(mut self, input: i64) -> Self {
            self.bandwidth_throttling = Some(input);
            self
        }
        /// <p>Replication Configuration set bandwidth throttling.</p>
        pub fn set_bandwidth_throttling(mut self, input: std::option::Option<i64>) -> Self {
            self.bandwidth_throttling = input; self
        }
        /// <p>Replication Configuration data plane routing.</p>
        pub fn data_plane_routing(mut self, input: crate::model::ReplicationConfigurationDataPlaneRouting) -> Self {
            self.data_plane_routing = Some(input);
            self
        }
        /// <p>Replication Configuration data plane routing.</p>
        pub fn set_data_plane_routing(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>) -> Self {
            self.data_plane_routing = input; self
        }
        /// <p>Replication Configuration create Public IP.</p>
        pub fn create_public_ip(mut self, input: bool) -> Self {
            self.create_public_ip = Some(input);
            self
        }
        /// <p>Replication Configuration create Public IP.</p>
        pub fn set_create_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.create_public_ip = input; self
        }
        /// Adds a key-value pair to `staging_area_tags`.
        ///
        /// To override the contents of this collection use [`set_staging_area_tags`](Self::set_staging_area_tags).
        ///
        /// <p>Replication Configuration Staging Area tags.</p>
        pub fn staging_area_tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.staging_area_tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.staging_area_tags = Some(hash_map);
                            self
        }
        /// <p>Replication Configuration Staging Area tags.</p>
        pub fn set_staging_area_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.staging_area_tags = input; self
        }
        /// Consumes the builder and constructs a [`UpdateReplicationConfigurationOutput`](crate::output::UpdateReplicationConfigurationOutput).
        pub fn build(self) -> crate::output::UpdateReplicationConfigurationOutput {
            crate::output::UpdateReplicationConfigurationOutput {
                source_server_id: self.source_server_id
                ,
                name: self.name
                ,
                staging_area_subnet_id: self.staging_area_subnet_id
                ,
                associate_default_security_group: self.associate_default_security_group
                ,
                replication_servers_security_groups_i_ds: self.replication_servers_security_groups_i_ds
                ,
                replication_server_instance_type: self.replication_server_instance_type
                ,
                use_dedicated_replication_server: self.use_dedicated_replication_server
                ,
                default_large_staging_disk_type: self.default_large_staging_disk_type
                ,
                replicated_disks: self.replicated_disks
                ,
                ebs_encryption: self.ebs_encryption
                ,
                ebs_encryption_key_arn: self.ebs_encryption_key_arn
                ,
                bandwidth_throttling: self.bandwidth_throttling
                    .unwrap_or_default()
                ,
                data_plane_routing: self.data_plane_routing
                ,
                create_public_ip: self.create_public_ip
                ,
                staging_area_tags: self.staging_area_tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("name", &self.name);
            formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
            formatter.field("associate_default_security_group", &self.associate_default_security_group);
            formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
            formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
            formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
            formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
            formatter.field("replicated_disks", &self.replicated_disks);
            formatter.field("ebs_encryption", &self.ebs_encryption);
            formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
            formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
            formatter.field("data_plane_routing", &self.data_plane_routing);
            formatter.field("create_public_ip", &self.create_public_ip);
            formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl UpdateReplicationConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateReplicationConfigurationOutput`](crate::output::UpdateReplicationConfigurationOutput).
    pub fn builder() -> crate::output::update_replication_configuration_output::Builder {
        crate::output::update_replication_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateLaunchConfigurationOutput  {
    /// <p>Launch configuration Source Server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Launch configuration name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Launch configuration EC2 Launch template ID.</p>
    #[doc(hidden)]
    pub ec2_launch_template_id: std::option::Option<std::string::String>,
    /// <p>Launch disposition for launch configuration.</p>
    #[doc(hidden)]
    pub launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
    /// <p>Launch configuration Target instance type right sizing method.</p>
    #[doc(hidden)]
    pub target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
    /// <p>Copy Private IP during Launch Configuration.</p>
    #[doc(hidden)]
    pub copy_private_ip: std::option::Option<bool>,
    /// <p>Copy Tags during Launch Configuration.</p>
    #[doc(hidden)]
    pub copy_tags: std::option::Option<bool>,
    /// <p>Launch configuration OS licensing.</p>
    #[doc(hidden)]
    pub licensing: std::option::Option<crate::model::Licensing>,
    /// <p>Launch configuration boot mode.</p>
    #[doc(hidden)]
    pub boot_mode: std::option::Option<crate::model::BootMode>,
    /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
    #[doc(hidden)]
    pub post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
    /// <p>Enable map auto tagging.</p>
    #[doc(hidden)]
    pub enable_map_auto_tagging: std::option::Option<bool>,
    /// <p>Map auto tagging MPE ID.</p>
    #[doc(hidden)]
    pub map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
}
impl UpdateLaunchConfigurationOutput {
    /// <p>Launch configuration Source Server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Launch configuration name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Launch configuration EC2 Launch template ID.</p>
    pub fn ec2_launch_template_id(&self) -> std::option::Option<& str> {
        self.ec2_launch_template_id.as_deref()
    }
    /// <p>Launch disposition for launch configuration.</p>
    pub fn launch_disposition(&self) -> std::option::Option<& crate::model::LaunchDisposition> {
        self.launch_disposition.as_ref()
    }
    /// <p>Launch configuration Target instance type right sizing method.</p>
    pub fn target_instance_type_right_sizing_method(&self) -> std::option::Option<& crate::model::TargetInstanceTypeRightSizingMethod> {
        self.target_instance_type_right_sizing_method.as_ref()
    }
    /// <p>Copy Private IP during Launch Configuration.</p>
    pub fn copy_private_ip(&self) -> std::option::Option<bool> {
        self.copy_private_ip
    }
    /// <p>Copy Tags during Launch Configuration.</p>
    pub fn copy_tags(&self) -> std::option::Option<bool> {
        self.copy_tags
    }
    /// <p>Launch configuration OS licensing.</p>
    pub fn licensing(&self) -> std::option::Option<& crate::model::Licensing> {
        self.licensing.as_ref()
    }
    /// <p>Launch configuration boot mode.</p>
    pub fn boot_mode(&self) -> std::option::Option<& crate::model::BootMode> {
        self.boot_mode.as_ref()
    }
    /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
    pub fn post_launch_actions(&self) -> std::option::Option<& crate::model::PostLaunchActions> {
        self.post_launch_actions.as_ref()
    }
    /// <p>Enable map auto tagging.</p>
    pub fn enable_map_auto_tagging(&self) -> std::option::Option<bool> {
        self.enable_map_auto_tagging
    }
    /// <p>Map auto tagging MPE ID.</p>
    pub fn map_auto_tagging_mpe_id(&self) -> std::option::Option<& str> {
        self.map_auto_tagging_mpe_id.as_deref()
    }
}
/// See [`UpdateLaunchConfigurationOutput`](crate::output::UpdateLaunchConfigurationOutput).
pub mod update_launch_configuration_output {
    
    /// A builder for [`UpdateLaunchConfigurationOutput`](crate::output::UpdateLaunchConfigurationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) ec2_launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
        pub(crate) target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
        pub(crate) copy_private_ip: std::option::Option<bool>,
        pub(crate) copy_tags: std::option::Option<bool>,
        pub(crate) licensing: std::option::Option<crate::model::Licensing>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootMode>,
        pub(crate) post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
        pub(crate) enable_map_auto_tagging: std::option::Option<bool>,
        pub(crate) map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Launch configuration Source Server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Launch configuration Source Server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Launch configuration name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Launch configuration name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Launch configuration EC2 Launch template ID.</p>
        pub fn ec2_launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_launch_template_id = Some(input.into());
            self
        }
        /// <p>Launch configuration EC2 Launch template ID.</p>
        pub fn set_ec2_launch_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_launch_template_id = input; self
        }
        /// <p>Launch disposition for launch configuration.</p>
        pub fn launch_disposition(mut self, input: crate::model::LaunchDisposition) -> Self {
            self.launch_disposition = Some(input);
            self
        }
        /// <p>Launch disposition for launch configuration.</p>
        pub fn set_launch_disposition(mut self, input: std::option::Option<crate::model::LaunchDisposition>) -> Self {
            self.launch_disposition = input; self
        }
        /// <p>Launch configuration Target instance type right sizing method.</p>
        pub fn target_instance_type_right_sizing_method(mut self, input: crate::model::TargetInstanceTypeRightSizingMethod) -> Self {
            self.target_instance_type_right_sizing_method = Some(input);
            self
        }
        /// <p>Launch configuration Target instance type right sizing method.</p>
        pub fn set_target_instance_type_right_sizing_method(mut self, input: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>) -> Self {
            self.target_instance_type_right_sizing_method = input; self
        }
        /// <p>Copy Private IP during Launch Configuration.</p>
        pub fn copy_private_ip(mut self, input: bool) -> Self {
            self.copy_private_ip = Some(input);
            self
        }
        /// <p>Copy Private IP during Launch Configuration.</p>
        pub fn set_copy_private_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_private_ip = input; self
        }
        /// <p>Copy Tags during Launch Configuration.</p>
        pub fn copy_tags(mut self, input: bool) -> Self {
            self.copy_tags = Some(input);
            self
        }
        /// <p>Copy Tags during Launch Configuration.</p>
        pub fn set_copy_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags = input; self
        }
        /// <p>Launch configuration OS licensing.</p>
        pub fn licensing(mut self, input: crate::model::Licensing) -> Self {
            self.licensing = Some(input);
            self
        }
        /// <p>Launch configuration OS licensing.</p>
        pub fn set_licensing(mut self, input: std::option::Option<crate::model::Licensing>) -> Self {
            self.licensing = input; self
        }
        /// <p>Launch configuration boot mode.</p>
        pub fn boot_mode(mut self, input: crate::model::BootMode) -> Self {
            self.boot_mode = Some(input);
            self
        }
        /// <p>Launch configuration boot mode.</p>
        pub fn set_boot_mode(mut self, input: std::option::Option<crate::model::BootMode>) -> Self {
            self.boot_mode = input; self
        }
        /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
        pub fn post_launch_actions(mut self, input: crate::model::PostLaunchActions) -> Self {
            self.post_launch_actions = Some(input);
            self
        }
        /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
        pub fn set_post_launch_actions(mut self, input: std::option::Option<crate::model::PostLaunchActions>) -> Self {
            self.post_launch_actions = input; self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn enable_map_auto_tagging(mut self, input: bool) -> Self {
            self.enable_map_auto_tagging = Some(input);
            self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn set_enable_map_auto_tagging(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_map_auto_tagging = input; self
        }
        /// <p>Map auto tagging MPE ID.</p>
        pub fn map_auto_tagging_mpe_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = Some(input.into());
            self
        }
        /// <p>Map auto tagging MPE ID.</p>
        pub fn set_map_auto_tagging_mpe_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = input; self
        }
        /// Consumes the builder and constructs a [`UpdateLaunchConfigurationOutput`](crate::output::UpdateLaunchConfigurationOutput).
        pub fn build(self) -> crate::output::UpdateLaunchConfigurationOutput {
            crate::output::UpdateLaunchConfigurationOutput {
                source_server_id: self.source_server_id
                ,
                name: self.name
                ,
                ec2_launch_template_id: self.ec2_launch_template_id
                ,
                launch_disposition: self.launch_disposition
                ,
                target_instance_type_right_sizing_method: self.target_instance_type_right_sizing_method
                ,
                copy_private_ip: self.copy_private_ip
                ,
                copy_tags: self.copy_tags
                ,
                licensing: self.licensing
                ,
                boot_mode: self.boot_mode
                ,
                post_launch_actions: self.post_launch_actions
                ,
                enable_map_auto_tagging: self.enable_map_auto_tagging
                ,
                map_auto_tagging_mpe_id: self.map_auto_tagging_mpe_id
                ,
            }
        }
    }
    
    
}
impl UpdateLaunchConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateLaunchConfigurationOutput`](crate::output::UpdateLaunchConfigurationOutput).
    pub fn builder() -> crate::output::update_launch_configuration_output::Builder {
        crate::output::update_launch_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartReplicationOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl StartReplicationOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for StartReplicationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartReplicationOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`StartReplicationOutput`](crate::output::StartReplicationOutput).
pub mod start_replication_output {
    
    /// A builder for [`StartReplicationOutput`](crate::output::StartReplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`StartReplicationOutput`](crate::output::StartReplicationOutput).
        pub fn build(self) -> crate::output::StartReplicationOutput {
            crate::output::StartReplicationOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl StartReplicationOutput {
    /// Creates a new builder-style object to manufacture [`StartReplicationOutput`](crate::output::StartReplicationOutput).
    pub fn builder() -> crate::output::start_replication_output::Builder {
        crate::output::start_replication_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RetryDataReplicationOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl RetryDataReplicationOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for RetryDataReplicationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RetryDataReplicationOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`RetryDataReplicationOutput`](crate::output::RetryDataReplicationOutput).
pub mod retry_data_replication_output {
    
    /// A builder for [`RetryDataReplicationOutput`](crate::output::RetryDataReplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`RetryDataReplicationOutput`](crate::output::RetryDataReplicationOutput).
        pub fn build(self) -> crate::output::RetryDataReplicationOutput {
            crate::output::RetryDataReplicationOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl RetryDataReplicationOutput {
    /// Creates a new builder-style object to manufacture [`RetryDataReplicationOutput`](crate::output::RetryDataReplicationOutput).
    pub fn builder() -> crate::output::retry_data_replication_output::Builder {
        crate::output::retry_data_replication_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemoveSourceServerActionOutput  {
}
/// See [`RemoveSourceServerActionOutput`](crate::output::RemoveSourceServerActionOutput).
pub mod remove_source_server_action_output {
    
    /// A builder for [`RemoveSourceServerActionOutput`](crate::output::RemoveSourceServerActionOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`RemoveSourceServerActionOutput`](crate::output::RemoveSourceServerActionOutput).
        pub fn build(self) -> crate::output::RemoveSourceServerActionOutput {
            crate::output::RemoveSourceServerActionOutput {
            }
        }
    }
    
    
}
impl RemoveSourceServerActionOutput {
    /// Creates a new builder-style object to manufacture [`RemoveSourceServerActionOutput`](crate::output::RemoveSourceServerActionOutput).
    pub fn builder() -> crate::output::remove_source_server_action_output::Builder {
        crate::output::remove_source_server_action_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutSourceServerActionOutput  {
    /// <p>Source server post migration custom action ID.</p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
    /// <p>Source server post migration custom action name.</p>
    #[doc(hidden)]
    pub action_name: std::option::Option<std::string::String>,
    /// <p>Source server post migration custom action document identifier.</p>
    #[doc(hidden)]
    pub document_identifier: std::option::Option<std::string::String>,
    /// <p>Source server post migration custom action order.</p>
    #[doc(hidden)]
    pub order: i32,
    /// <p>Source server post migration custom action document version.</p>
    #[doc(hidden)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>Source server post migration custom action active status.</p>
    #[doc(hidden)]
    pub active: std::option::Option<bool>,
    /// <p>Source server post migration custom action timeout in seconds.</p>
    #[doc(hidden)]
    pub timeout_seconds: i32,
    /// <p>Source server post migration custom action must succeed for cutover.</p>
    #[doc(hidden)]
    pub must_succeed_for_cutover: std::option::Option<bool>,
    /// <p>Source server post migration custom action parameters.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>>,
}
impl PutSourceServerActionOutput {
    /// <p>Source server post migration custom action ID.</p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
    /// <p>Source server post migration custom action name.</p>
    pub fn action_name(&self) -> std::option::Option<& str> {
        self.action_name.as_deref()
    }
    /// <p>Source server post migration custom action document identifier.</p>
    pub fn document_identifier(&self) -> std::option::Option<& str> {
        self.document_identifier.as_deref()
    }
    /// <p>Source server post migration custom action order.</p>
    pub fn order(&self) -> i32 {
        self.order
    }
    /// <p>Source server post migration custom action document version.</p>
    pub fn document_version(&self) -> std::option::Option<& str> {
        self.document_version.as_deref()
    }
    /// <p>Source server post migration custom action active status.</p>
    pub fn active(&self) -> std::option::Option<bool> {
        self.active
    }
    /// <p>Source server post migration custom action timeout in seconds.</p>
    pub fn timeout_seconds(&self) -> i32 {
        self.timeout_seconds
    }
    /// <p>Source server post migration custom action must succeed for cutover.</p>
    pub fn must_succeed_for_cutover(&self) -> std::option::Option<bool> {
        self.must_succeed_for_cutover
    }
    /// <p>Source server post migration custom action parameters.</p>
    pub fn parameters(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>> {
        self.parameters.as_ref()
    }
}
/// See [`PutSourceServerActionOutput`](crate::output::PutSourceServerActionOutput).
pub mod put_source_server_action_output {
    
    /// A builder for [`PutSourceServerActionOutput`](crate::output::PutSourceServerActionOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) document_identifier: std::option::Option<std::string::String>,
        pub(crate) order: std::option::Option<i32>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) active: std::option::Option<bool>,
        pub(crate) timeout_seconds: std::option::Option<i32>,
        pub(crate) must_succeed_for_cutover: std::option::Option<bool>,
        pub(crate) parameters: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>>,
    }
    impl Builder {
        /// <p>Source server post migration custom action ID.</p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p>Source server post migration custom action ID.</p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// <p>Source server post migration custom action name.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>Source server post migration custom action name.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input; self
        }
        /// <p>Source server post migration custom action document identifier.</p>
        pub fn document_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_identifier = Some(input.into());
            self
        }
        /// <p>Source server post migration custom action document identifier.</p>
        pub fn set_document_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_identifier = input; self
        }
        /// <p>Source server post migration custom action order.</p>
        pub fn order(mut self, input: i32) -> Self {
            self.order = Some(input);
            self
        }
        /// <p>Source server post migration custom action order.</p>
        pub fn set_order(mut self, input: std::option::Option<i32>) -> Self {
            self.order = input; self
        }
        /// <p>Source server post migration custom action document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        /// <p>Source server post migration custom action document version.</p>
        pub fn set_document_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_version = input; self
        }
        /// <p>Source server post migration custom action active status.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>Source server post migration custom action active status.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input; self
        }
        /// <p>Source server post migration custom action timeout in seconds.</p>
        pub fn timeout_seconds(mut self, input: i32) -> Self {
            self.timeout_seconds = Some(input);
            self
        }
        /// <p>Source server post migration custom action timeout in seconds.</p>
        pub fn set_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout_seconds = input; self
        }
        /// <p>Source server post migration custom action must succeed for cutover.</p>
        pub fn must_succeed_for_cutover(mut self, input: bool) -> Self {
            self.must_succeed_for_cutover = Some(input);
            self
        }
        /// <p>Source server post migration custom action must succeed for cutover.</p>
        pub fn set_must_succeed_for_cutover(mut self, input: std::option::Option<bool>) -> Self {
            self.must_succeed_for_cutover = input; self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>Source server post migration custom action parameters.</p>
        pub fn parameters(mut self, k: impl Into<std::string::String>, v: std::vec::Vec<crate::model::SsmParameterStoreParameter>) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.parameters = Some(hash_map);
                            self
        }
        /// <p>Source server post migration custom action parameters.</p>
        pub fn set_parameters(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>>) -> Self {
            self.parameters = input; self
        }
        /// Consumes the builder and constructs a [`PutSourceServerActionOutput`](crate::output::PutSourceServerActionOutput).
        pub fn build(self) -> crate::output::PutSourceServerActionOutput {
            crate::output::PutSourceServerActionOutput {
                action_id: self.action_id
                ,
                action_name: self.action_name
                ,
                document_identifier: self.document_identifier
                ,
                order: self.order
                    .unwrap_or_default()
                ,
                document_version: self.document_version
                ,
                active: self.active
                ,
                timeout_seconds: self.timeout_seconds
                    .unwrap_or_default()
                ,
                must_succeed_for_cutover: self.must_succeed_for_cutover
                ,
                parameters: self.parameters
                ,
            }
        }
    }
    
    
}
impl PutSourceServerActionOutput {
    /// Creates a new builder-style object to manufacture [`PutSourceServerActionOutput`](crate::output::PutSourceServerActionOutput).
    pub fn builder() -> crate::output::put_source_server_action_output::Builder {
        crate::output::put_source_server_action_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MarkAsArchivedOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl MarkAsArchivedOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for MarkAsArchivedOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MarkAsArchivedOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`MarkAsArchivedOutput`](crate::output::MarkAsArchivedOutput).
pub mod mark_as_archived_output {
    
    /// A builder for [`MarkAsArchivedOutput`](crate::output::MarkAsArchivedOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`MarkAsArchivedOutput`](crate::output::MarkAsArchivedOutput).
        pub fn build(self) -> crate::output::MarkAsArchivedOutput {
            crate::output::MarkAsArchivedOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl MarkAsArchivedOutput {
    /// Creates a new builder-style object to manufacture [`MarkAsArchivedOutput`](crate::output::MarkAsArchivedOutput).
    pub fn builder() -> crate::output::mark_as_archived_output::Builder {
        crate::output::mark_as_archived_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSourceServerActionsOutput  {
    /// <p>List of source server post migration custom actions.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::SourceServerActionDocument>>,
    /// <p>Next token returned when listing source server post migration custom actions.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSourceServerActionsOutput {
    /// <p>List of source server post migration custom actions.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::SourceServerActionDocument]> {
        self.items.as_deref()
    }
    /// <p>Next token returned when listing source server post migration custom actions.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`ListSourceServerActionsOutput`](crate::output::ListSourceServerActionsOutput).
pub mod list_source_server_actions_output {
    
    /// A builder for [`ListSourceServerActionsOutput`](crate::output::ListSourceServerActionsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::SourceServerActionDocument>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>List of source server post migration custom actions.</p>
        pub fn items(mut self, input: crate::model::SourceServerActionDocument) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>List of source server post migration custom actions.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::SourceServerActionDocument>>) -> Self {
            self.items = input; self
        }
        /// <p>Next token returned when listing source server post migration custom actions.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Next token returned when listing source server post migration custom actions.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListSourceServerActionsOutput`](crate::output::ListSourceServerActionsOutput).
        pub fn build(self) -> crate::output::ListSourceServerActionsOutput {
            crate::output::ListSourceServerActionsOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl ListSourceServerActionsOutput {
    /// Creates a new builder-style object to manufacture [`ListSourceServerActionsOutput`](crate::output::ListSourceServerActionsOutput).
    pub fn builder() -> crate::output::list_source_server_actions_output::Builder {
        crate::output::list_source_server_actions_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetReplicationConfigurationOutput  {
    /// <p>Replication Configuration Source Server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Replication Configuration Staging Area subnet ID.</p>
    #[doc(hidden)]
    pub staging_area_subnet_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
    #[doc(hidden)]
    pub associate_default_security_group: std::option::Option<bool>,
    /// <p>Replication Configuration Replication Server Security Group IDs.</p>
    #[doc(hidden)]
    pub replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Replication Configuration Replication Server instance type.</p>
    #[doc(hidden)]
    pub replication_server_instance_type: std::option::Option<std::string::String>,
    /// <p>Replication Configuration use Dedicated Replication Server.</p>
    #[doc(hidden)]
    pub use_dedicated_replication_server: std::option::Option<bool>,
    /// <p>Replication Configuration use default large Staging Disks.</p>
    #[doc(hidden)]
    pub default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
    /// <p>Replication Configuration replicated disks.</p>
    #[doc(hidden)]
    pub replicated_disks: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationReplicatedDisk>>,
    /// <p>Replication Configuration EBS encryption.</p>
    #[doc(hidden)]
    pub ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
    /// <p>Replication Configuration EBS encryption key ARN.</p>
    #[doc(hidden)]
    pub ebs_encryption_key_arn: std::option::Option<std::string::String>,
    /// <p>Replication Configuration set bandwidth throttling.</p>
    #[doc(hidden)]
    pub bandwidth_throttling: i64,
    /// <p>Replication Configuration data plane routing.</p>
    #[doc(hidden)]
    pub data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
    /// <p>Replication Configuration create Public IP.</p>
    #[doc(hidden)]
    pub create_public_ip: std::option::Option<bool>,
    /// <p>Replication Configuration Staging Area tags.</p>
    #[doc(hidden)]
    pub staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl GetReplicationConfigurationOutput {
    /// <p>Replication Configuration Source Server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Replication Configuration name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Replication Configuration Staging Area subnet ID.</p>
    pub fn staging_area_subnet_id(&self) -> std::option::Option<& str> {
        self.staging_area_subnet_id.as_deref()
    }
    /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
    pub fn associate_default_security_group(&self) -> std::option::Option<bool> {
        self.associate_default_security_group
    }
    /// <p>Replication Configuration Replication Server Security Group IDs.</p>
    pub fn replication_servers_security_groups_i_ds(&self) -> std::option::Option<& [std::string::String]> {
        self.replication_servers_security_groups_i_ds.as_deref()
    }
    /// <p>Replication Configuration Replication Server instance type.</p>
    pub fn replication_server_instance_type(&self) -> std::option::Option<& str> {
        self.replication_server_instance_type.as_deref()
    }
    /// <p>Replication Configuration use Dedicated Replication Server.</p>
    pub fn use_dedicated_replication_server(&self) -> std::option::Option<bool> {
        self.use_dedicated_replication_server
    }
    /// <p>Replication Configuration use default large Staging Disks.</p>
    pub fn default_large_staging_disk_type(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDefaultLargeStagingDiskType> {
        self.default_large_staging_disk_type.as_ref()
    }
    /// <p>Replication Configuration replicated disks.</p>
    pub fn replicated_disks(&self) -> std::option::Option<& [crate::model::ReplicationConfigurationReplicatedDisk]> {
        self.replicated_disks.as_deref()
    }
    /// <p>Replication Configuration EBS encryption.</p>
    pub fn ebs_encryption(&self) -> std::option::Option<& crate::model::ReplicationConfigurationEbsEncryption> {
        self.ebs_encryption.as_ref()
    }
    /// <p>Replication Configuration EBS encryption key ARN.</p>
    pub fn ebs_encryption_key_arn(&self) -> std::option::Option<& str> {
        self.ebs_encryption_key_arn.as_deref()
    }
    /// <p>Replication Configuration set bandwidth throttling.</p>
    pub fn bandwidth_throttling(&self) -> i64 {
        self.bandwidth_throttling
    }
    /// <p>Replication Configuration data plane routing.</p>
    pub fn data_plane_routing(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDataPlaneRouting> {
        self.data_plane_routing.as_ref()
    }
    /// <p>Replication Configuration create Public IP.</p>
    pub fn create_public_ip(&self) -> std::option::Option<bool> {
        self.create_public_ip
    }
    /// <p>Replication Configuration Staging Area tags.</p>
    pub fn staging_area_tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.staging_area_tags.as_ref()
    }
}
impl  std::fmt::Debug for GetReplicationConfigurationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetReplicationConfigurationOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("name", &self.name);
        formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
        formatter.field("associate_default_security_group", &self.associate_default_security_group);
        formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
        formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
        formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
        formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
        formatter.field("replicated_disks", &self.replicated_disks);
        formatter.field("ebs_encryption", &self.ebs_encryption);
        formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
        formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
        formatter.field("data_plane_routing", &self.data_plane_routing);
        formatter.field("create_public_ip", &self.create_public_ip);
        formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`GetReplicationConfigurationOutput`](crate::output::GetReplicationConfigurationOutput).
pub mod get_replication_configuration_output {
    
    /// A builder for [`GetReplicationConfigurationOutput`](crate::output::GetReplicationConfigurationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) staging_area_subnet_id: std::option::Option<std::string::String>,
        pub(crate) associate_default_security_group: std::option::Option<bool>,
        pub(crate) replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) replication_server_instance_type: std::option::Option<std::string::String>,
        pub(crate) use_dedicated_replication_server: std::option::Option<bool>,
        pub(crate) default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
        pub(crate) replicated_disks: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationReplicatedDisk>>,
        pub(crate) ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
        pub(crate) ebs_encryption_key_arn: std::option::Option<std::string::String>,
        pub(crate) bandwidth_throttling: std::option::Option<i64>,
        pub(crate) data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
        pub(crate) create_public_ip: std::option::Option<bool>,
        pub(crate) staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Replication Configuration Source Server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration Source Server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Replication Configuration name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Replication Configuration name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Replication Configuration Staging Area subnet ID.</p>
        pub fn staging_area_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_area_subnet_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration Staging Area subnet ID.</p>
        pub fn set_staging_area_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.staging_area_subnet_id = input; self
        }
        /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
        pub fn associate_default_security_group(mut self, input: bool) -> Self {
            self.associate_default_security_group = Some(input);
            self
        }
        /// <p>Replication Configuration associate default Application Migration Service Security Group.</p>
        pub fn set_associate_default_security_group(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_default_security_group = input; self
        }
        /// Appends an item to `replication_servers_security_groups_i_ds`.
        ///
        /// To override the contents of this collection use [`set_replication_servers_security_groups_i_ds`](Self::set_replication_servers_security_groups_i_ds).
        ///
        /// <p>Replication Configuration Replication Server Security Group IDs.</p>
        pub fn replication_servers_security_groups_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.replication_servers_security_groups_i_ds.unwrap_or_default();
                            v.push(input.into());
                            self.replication_servers_security_groups_i_ds = Some(v);
                            self
        }
        /// <p>Replication Configuration Replication Server Security Group IDs.</p>
        pub fn set_replication_servers_security_groups_i_ds(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.replication_servers_security_groups_i_ds = input; self
        }
        /// <p>Replication Configuration Replication Server instance type.</p>
        pub fn replication_server_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_server_instance_type = Some(input.into());
            self
        }
        /// <p>Replication Configuration Replication Server instance type.</p>
        pub fn set_replication_server_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.replication_server_instance_type = input; self
        }
        /// <p>Replication Configuration use Dedicated Replication Server.</p>
        pub fn use_dedicated_replication_server(mut self, input: bool) -> Self {
            self.use_dedicated_replication_server = Some(input);
            self
        }
        /// <p>Replication Configuration use Dedicated Replication Server.</p>
        pub fn set_use_dedicated_replication_server(mut self, input: std::option::Option<bool>) -> Self {
            self.use_dedicated_replication_server = input; self
        }
        /// <p>Replication Configuration use default large Staging Disks.</p>
        pub fn default_large_staging_disk_type(mut self, input: crate::model::ReplicationConfigurationDefaultLargeStagingDiskType) -> Self {
            self.default_large_staging_disk_type = Some(input);
            self
        }
        /// <p>Replication Configuration use default large Staging Disks.</p>
        pub fn set_default_large_staging_disk_type(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>) -> Self {
            self.default_large_staging_disk_type = input; self
        }
        /// Appends an item to `replicated_disks`.
        ///
        /// To override the contents of this collection use [`set_replicated_disks`](Self::set_replicated_disks).
        ///
        /// <p>Replication Configuration replicated disks.</p>
        pub fn replicated_disks(mut self, input: crate::model::ReplicationConfigurationReplicatedDisk) -> Self {
            let mut v = self.replicated_disks.unwrap_or_default();
                            v.push(input);
                            self.replicated_disks = Some(v);
                            self
        }
        /// <p>Replication Configuration replicated disks.</p>
        pub fn set_replicated_disks(mut self, input: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationReplicatedDisk>>) -> Self {
            self.replicated_disks = input; self
        }
        /// <p>Replication Configuration EBS encryption.</p>
        pub fn ebs_encryption(mut self, input: crate::model::ReplicationConfigurationEbsEncryption) -> Self {
            self.ebs_encryption = Some(input);
            self
        }
        /// <p>Replication Configuration EBS encryption.</p>
        pub fn set_ebs_encryption(mut self, input: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>) -> Self {
            self.ebs_encryption = input; self
        }
        /// <p>Replication Configuration EBS encryption key ARN.</p>
        pub fn ebs_encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = Some(input.into());
            self
        }
        /// <p>Replication Configuration EBS encryption key ARN.</p>
        pub fn set_ebs_encryption_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = input; self
        }
        /// <p>Replication Configuration set bandwidth throttling.</p>
        pub fn bandwidth_throttling(mut self, input: i64) -> Self {
            self.bandwidth_throttling = Some(input);
            self
        }
        /// <p>Replication Configuration set bandwidth throttling.</p>
        pub fn set_bandwidth_throttling(mut self, input: std::option::Option<i64>) -> Self {
            self.bandwidth_throttling = input; self
        }
        /// <p>Replication Configuration data plane routing.</p>
        pub fn data_plane_routing(mut self, input: crate::model::ReplicationConfigurationDataPlaneRouting) -> Self {
            self.data_plane_routing = Some(input);
            self
        }
        /// <p>Replication Configuration data plane routing.</p>
        pub fn set_data_plane_routing(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>) -> Self {
            self.data_plane_routing = input; self
        }
        /// <p>Replication Configuration create Public IP.</p>
        pub fn create_public_ip(mut self, input: bool) -> Self {
            self.create_public_ip = Some(input);
            self
        }
        /// <p>Replication Configuration create Public IP.</p>
        pub fn set_create_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.create_public_ip = input; self
        }
        /// Adds a key-value pair to `staging_area_tags`.
        ///
        /// To override the contents of this collection use [`set_staging_area_tags`](Self::set_staging_area_tags).
        ///
        /// <p>Replication Configuration Staging Area tags.</p>
        pub fn staging_area_tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.staging_area_tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.staging_area_tags = Some(hash_map);
                            self
        }
        /// <p>Replication Configuration Staging Area tags.</p>
        pub fn set_staging_area_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.staging_area_tags = input; self
        }
        /// Consumes the builder and constructs a [`GetReplicationConfigurationOutput`](crate::output::GetReplicationConfigurationOutput).
        pub fn build(self) -> crate::output::GetReplicationConfigurationOutput {
            crate::output::GetReplicationConfigurationOutput {
                source_server_id: self.source_server_id
                ,
                name: self.name
                ,
                staging_area_subnet_id: self.staging_area_subnet_id
                ,
                associate_default_security_group: self.associate_default_security_group
                ,
                replication_servers_security_groups_i_ds: self.replication_servers_security_groups_i_ds
                ,
                replication_server_instance_type: self.replication_server_instance_type
                ,
                use_dedicated_replication_server: self.use_dedicated_replication_server
                ,
                default_large_staging_disk_type: self.default_large_staging_disk_type
                ,
                replicated_disks: self.replicated_disks
                ,
                ebs_encryption: self.ebs_encryption
                ,
                ebs_encryption_key_arn: self.ebs_encryption_key_arn
                ,
                bandwidth_throttling: self.bandwidth_throttling
                    .unwrap_or_default()
                ,
                data_plane_routing: self.data_plane_routing
                ,
                create_public_ip: self.create_public_ip
                ,
                staging_area_tags: self.staging_area_tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("name", &self.name);
            formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
            formatter.field("associate_default_security_group", &self.associate_default_security_group);
            formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
            formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
            formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
            formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
            formatter.field("replicated_disks", &self.replicated_disks);
            formatter.field("ebs_encryption", &self.ebs_encryption);
            formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
            formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
            formatter.field("data_plane_routing", &self.data_plane_routing);
            formatter.field("create_public_ip", &self.create_public_ip);
            formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl GetReplicationConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`GetReplicationConfigurationOutput`](crate::output::GetReplicationConfigurationOutput).
    pub fn builder() -> crate::output::get_replication_configuration_output::Builder {
        crate::output::get_replication_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLaunchConfigurationOutput  {
    /// <p>Launch configuration Source Server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Launch configuration name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Launch configuration EC2 Launch template ID.</p>
    #[doc(hidden)]
    pub ec2_launch_template_id: std::option::Option<std::string::String>,
    /// <p>Launch disposition for launch configuration.</p>
    #[doc(hidden)]
    pub launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
    /// <p>Launch configuration Target instance type right sizing method.</p>
    #[doc(hidden)]
    pub target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
    /// <p>Copy Private IP during Launch Configuration.</p>
    #[doc(hidden)]
    pub copy_private_ip: std::option::Option<bool>,
    /// <p>Copy Tags during Launch Configuration.</p>
    #[doc(hidden)]
    pub copy_tags: std::option::Option<bool>,
    /// <p>Launch configuration OS licensing.</p>
    #[doc(hidden)]
    pub licensing: std::option::Option<crate::model::Licensing>,
    /// <p>Launch configuration boot mode.</p>
    #[doc(hidden)]
    pub boot_mode: std::option::Option<crate::model::BootMode>,
    /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
    #[doc(hidden)]
    pub post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
    /// <p>Enable map auto tagging.</p>
    #[doc(hidden)]
    pub enable_map_auto_tagging: std::option::Option<bool>,
    /// <p>Map auto tagging MPE ID.</p>
    #[doc(hidden)]
    pub map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
}
impl GetLaunchConfigurationOutput {
    /// <p>Launch configuration Source Server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Launch configuration name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Launch configuration EC2 Launch template ID.</p>
    pub fn ec2_launch_template_id(&self) -> std::option::Option<& str> {
        self.ec2_launch_template_id.as_deref()
    }
    /// <p>Launch disposition for launch configuration.</p>
    pub fn launch_disposition(&self) -> std::option::Option<& crate::model::LaunchDisposition> {
        self.launch_disposition.as_ref()
    }
    /// <p>Launch configuration Target instance type right sizing method.</p>
    pub fn target_instance_type_right_sizing_method(&self) -> std::option::Option<& crate::model::TargetInstanceTypeRightSizingMethod> {
        self.target_instance_type_right_sizing_method.as_ref()
    }
    /// <p>Copy Private IP during Launch Configuration.</p>
    pub fn copy_private_ip(&self) -> std::option::Option<bool> {
        self.copy_private_ip
    }
    /// <p>Copy Tags during Launch Configuration.</p>
    pub fn copy_tags(&self) -> std::option::Option<bool> {
        self.copy_tags
    }
    /// <p>Launch configuration OS licensing.</p>
    pub fn licensing(&self) -> std::option::Option<& crate::model::Licensing> {
        self.licensing.as_ref()
    }
    /// <p>Launch configuration boot mode.</p>
    pub fn boot_mode(&self) -> std::option::Option<& crate::model::BootMode> {
        self.boot_mode.as_ref()
    }
    /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
    pub fn post_launch_actions(&self) -> std::option::Option<& crate::model::PostLaunchActions> {
        self.post_launch_actions.as_ref()
    }
    /// <p>Enable map auto tagging.</p>
    pub fn enable_map_auto_tagging(&self) -> std::option::Option<bool> {
        self.enable_map_auto_tagging
    }
    /// <p>Map auto tagging MPE ID.</p>
    pub fn map_auto_tagging_mpe_id(&self) -> std::option::Option<& str> {
        self.map_auto_tagging_mpe_id.as_deref()
    }
}
/// See [`GetLaunchConfigurationOutput`](crate::output::GetLaunchConfigurationOutput).
pub mod get_launch_configuration_output {
    
    /// A builder for [`GetLaunchConfigurationOutput`](crate::output::GetLaunchConfigurationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) ec2_launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
        pub(crate) target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
        pub(crate) copy_private_ip: std::option::Option<bool>,
        pub(crate) copy_tags: std::option::Option<bool>,
        pub(crate) licensing: std::option::Option<crate::model::Licensing>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootMode>,
        pub(crate) post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
        pub(crate) enable_map_auto_tagging: std::option::Option<bool>,
        pub(crate) map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Launch configuration Source Server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Launch configuration Source Server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Launch configuration name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Launch configuration name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Launch configuration EC2 Launch template ID.</p>
        pub fn ec2_launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_launch_template_id = Some(input.into());
            self
        }
        /// <p>Launch configuration EC2 Launch template ID.</p>
        pub fn set_ec2_launch_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_launch_template_id = input; self
        }
        /// <p>Launch disposition for launch configuration.</p>
        pub fn launch_disposition(mut self, input: crate::model::LaunchDisposition) -> Self {
            self.launch_disposition = Some(input);
            self
        }
        /// <p>Launch disposition for launch configuration.</p>
        pub fn set_launch_disposition(mut self, input: std::option::Option<crate::model::LaunchDisposition>) -> Self {
            self.launch_disposition = input; self
        }
        /// <p>Launch configuration Target instance type right sizing method.</p>
        pub fn target_instance_type_right_sizing_method(mut self, input: crate::model::TargetInstanceTypeRightSizingMethod) -> Self {
            self.target_instance_type_right_sizing_method = Some(input);
            self
        }
        /// <p>Launch configuration Target instance type right sizing method.</p>
        pub fn set_target_instance_type_right_sizing_method(mut self, input: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>) -> Self {
            self.target_instance_type_right_sizing_method = input; self
        }
        /// <p>Copy Private IP during Launch Configuration.</p>
        pub fn copy_private_ip(mut self, input: bool) -> Self {
            self.copy_private_ip = Some(input);
            self
        }
        /// <p>Copy Private IP during Launch Configuration.</p>
        pub fn set_copy_private_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_private_ip = input; self
        }
        /// <p>Copy Tags during Launch Configuration.</p>
        pub fn copy_tags(mut self, input: bool) -> Self {
            self.copy_tags = Some(input);
            self
        }
        /// <p>Copy Tags during Launch Configuration.</p>
        pub fn set_copy_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags = input; self
        }
        /// <p>Launch configuration OS licensing.</p>
        pub fn licensing(mut self, input: crate::model::Licensing) -> Self {
            self.licensing = Some(input);
            self
        }
        /// <p>Launch configuration OS licensing.</p>
        pub fn set_licensing(mut self, input: std::option::Option<crate::model::Licensing>) -> Self {
            self.licensing = input; self
        }
        /// <p>Launch configuration boot mode.</p>
        pub fn boot_mode(mut self, input: crate::model::BootMode) -> Self {
            self.boot_mode = Some(input);
            self
        }
        /// <p>Launch configuration boot mode.</p>
        pub fn set_boot_mode(mut self, input: std::option::Option<crate::model::BootMode>) -> Self {
            self.boot_mode = input; self
        }
        /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
        pub fn post_launch_actions(mut self, input: crate::model::PostLaunchActions) -> Self {
            self.post_launch_actions = Some(input);
            self
        }
        /// <p>Post Launch Actions to executed on the Test or Cutover instance.</p>
        pub fn set_post_launch_actions(mut self, input: std::option::Option<crate::model::PostLaunchActions>) -> Self {
            self.post_launch_actions = input; self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn enable_map_auto_tagging(mut self, input: bool) -> Self {
            self.enable_map_auto_tagging = Some(input);
            self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn set_enable_map_auto_tagging(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_map_auto_tagging = input; self
        }
        /// <p>Map auto tagging MPE ID.</p>
        pub fn map_auto_tagging_mpe_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = Some(input.into());
            self
        }
        /// <p>Map auto tagging MPE ID.</p>
        pub fn set_map_auto_tagging_mpe_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = input; self
        }
        /// Consumes the builder and constructs a [`GetLaunchConfigurationOutput`](crate::output::GetLaunchConfigurationOutput).
        pub fn build(self) -> crate::output::GetLaunchConfigurationOutput {
            crate::output::GetLaunchConfigurationOutput {
                source_server_id: self.source_server_id
                ,
                name: self.name
                ,
                ec2_launch_template_id: self.ec2_launch_template_id
                ,
                launch_disposition: self.launch_disposition
                ,
                target_instance_type_right_sizing_method: self.target_instance_type_right_sizing_method
                ,
                copy_private_ip: self.copy_private_ip
                ,
                copy_tags: self.copy_tags
                ,
                licensing: self.licensing
                ,
                boot_mode: self.boot_mode
                ,
                post_launch_actions: self.post_launch_actions
                ,
                enable_map_auto_tagging: self.enable_map_auto_tagging
                ,
                map_auto_tagging_mpe_id: self.map_auto_tagging_mpe_id
                ,
            }
        }
    }
    
    
}
impl GetLaunchConfigurationOutput {
    /// Creates a new builder-style object to manufacture [`GetLaunchConfigurationOutput`](crate::output::GetLaunchConfigurationOutput).
    pub fn builder() -> crate::output::get_launch_configuration_output::Builder {
        crate::output::get_launch_configuration_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FinalizeCutoverOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl FinalizeCutoverOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for FinalizeCutoverOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FinalizeCutoverOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`FinalizeCutoverOutput`](crate::output::FinalizeCutoverOutput).
pub mod finalize_cutover_output {
    
    /// A builder for [`FinalizeCutoverOutput`](crate::output::FinalizeCutoverOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`FinalizeCutoverOutput`](crate::output::FinalizeCutoverOutput).
        pub fn build(self) -> crate::output::FinalizeCutoverOutput {
            crate::output::FinalizeCutoverOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl FinalizeCutoverOutput {
    /// Creates a new builder-style object to manufacture [`FinalizeCutoverOutput`](crate::output::FinalizeCutoverOutput).
    pub fn builder() -> crate::output::finalize_cutover_output::Builder {
        crate::output::finalize_cutover_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisconnectFromServiceOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl DisconnectFromServiceOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for DisconnectFromServiceOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisconnectFromServiceOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`DisconnectFromServiceOutput`](crate::output::DisconnectFromServiceOutput).
pub mod disconnect_from_service_output {
    
    /// A builder for [`DisconnectFromServiceOutput`](crate::output::DisconnectFromServiceOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`DisconnectFromServiceOutput`](crate::output::DisconnectFromServiceOutput).
        pub fn build(self) -> crate::output::DisconnectFromServiceOutput {
            crate::output::DisconnectFromServiceOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl DisconnectFromServiceOutput {
    /// Creates a new builder-style object to manufacture [`DisconnectFromServiceOutput`](crate::output::DisconnectFromServiceOutput).
    pub fn builder() -> crate::output::disconnect_from_service_output::Builder {
        crate::output::disconnect_from_service_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeServerLifeCycleStateOutput  {
    /// <p>Source server ID.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>Source server ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Source server archived status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Source server Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Source server launched instance.</p>
    #[doc(hidden)]
    pub launched_instance: std::option::Option<crate::model::LaunchedInstance>,
    /// <p>Source server data replication info.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>Source server lifecycle state.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>Source server properties.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>Source server replication type.</p>
    #[doc(hidden)]
    pub replication_type: std::option::Option<crate::model::ReplicationType>,
    /// <p>Source server vCenter client id.</p>
    #[doc(hidden)]
    pub vcenter_client_id: std::option::Option<std::string::String>,
    /// <p>Source server application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
}
impl ChangeServerLifeCycleStateOutput {
    /// <p>Source server ID.</p>
    pub fn source_server_id(&self) -> std::option::Option<& str> {
        self.source_server_id.as_deref()
    }
    /// <p>Source server ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Source server archived status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Source server Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Source server launched instance.</p>
    pub fn launched_instance(&self) -> std::option::Option<& crate::model::LaunchedInstance> {
        self.launched_instance.as_ref()
    }
    /// <p>Source server data replication info.</p>
    pub fn data_replication_info(&self) -> std::option::Option<& crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Source server lifecycle state.</p>
    pub fn life_cycle(&self) -> std::option::Option<& crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>Source server properties.</p>
    pub fn source_properties(&self) -> std::option::Option<& crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>Source server replication type.</p>
    pub fn replication_type(&self) -> std::option::Option<& crate::model::ReplicationType> {
        self.replication_type.as_ref()
    }
    /// <p>Source server vCenter client id.</p>
    pub fn vcenter_client_id(&self) -> std::option::Option<& str> {
        self.vcenter_client_id.as_deref()
    }
    /// <p>Source server application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
}
impl  std::fmt::Debug for ChangeServerLifeCycleStateOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeServerLifeCycleStateOutput");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("launched_instance", &self.launched_instance);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("replication_type", &self.replication_type);
        formatter.field("vcenter_client_id", &self.vcenter_client_id);
        formatter.field("application_id", &self.application_id);
        formatter.finish()
    }
}
/// See [`ChangeServerLifeCycleStateOutput`](crate::output::ChangeServerLifeCycleStateOutput).
pub mod change_server_life_cycle_state_output {
    
    /// A builder for [`ChangeServerLifeCycleStateOutput`](crate::output::ChangeServerLifeCycleStateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) launched_instance: std::option::Option<crate::model::LaunchedInstance>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) replication_type: std::option::Option<crate::model::ReplicationType>,
        pub(crate) vcenter_client_id: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Source server ID.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>Source server ID.</p>
        pub fn set_source_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_server_id = input; self
        }
        /// <p>Source server ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Source server ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Source server archived status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Source server archived status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Source server Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Source server Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Source server launched instance.</p>
        pub fn launched_instance(mut self, input: crate::model::LaunchedInstance) -> Self {
            self.launched_instance = Some(input);
            self
        }
        /// <p>Source server launched instance.</p>
        pub fn set_launched_instance(mut self, input: std::option::Option<crate::model::LaunchedInstance>) -> Self {
            self.launched_instance = input; self
        }
        /// <p>Source server data replication info.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>Source server data replication info.</p>
        pub fn set_data_replication_info(mut self, input: std::option::Option<crate::model::DataReplicationInfo>) -> Self {
            self.data_replication_info = input; self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>Source server lifecycle state.</p>
        pub fn set_life_cycle(mut self, input: std::option::Option<crate::model::LifeCycle>) -> Self {
            self.life_cycle = input; self
        }
        /// <p>Source server properties.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>Source server properties.</p>
        pub fn set_source_properties(mut self, input: std::option::Option<crate::model::SourceProperties>) -> Self {
            self.source_properties = input; self
        }
        /// <p>Source server replication type.</p>
        pub fn replication_type(mut self, input: crate::model::ReplicationType) -> Self {
            self.replication_type = Some(input);
            self
        }
        /// <p>Source server replication type.</p>
        pub fn set_replication_type(mut self, input: std::option::Option<crate::model::ReplicationType>) -> Self {
            self.replication_type = input; self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn vcenter_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcenter_client_id = Some(input.into());
            self
        }
        /// <p>Source server vCenter client id.</p>
        pub fn set_vcenter_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcenter_client_id = input; self
        }
        /// <p>Source server application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Source server application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// Consumes the builder and constructs a [`ChangeServerLifeCycleStateOutput`](crate::output::ChangeServerLifeCycleStateOutput).
        pub fn build(self) -> crate::output::ChangeServerLifeCycleStateOutput {
            crate::output::ChangeServerLifeCycleStateOutput {
                source_server_id: self.source_server_id
                ,
                arn: self.arn
                ,
                is_archived: self.is_archived
                ,
                tags: self.tags
                ,
                launched_instance: self.launched_instance
                ,
                data_replication_info: self.data_replication_info
                ,
                life_cycle: self.life_cycle
                ,
                source_properties: self.source_properties
                ,
                replication_type: self.replication_type
                ,
                vcenter_client_id: self.vcenter_client_id
                ,
                application_id: self.application_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("launched_instance", &self.launched_instance);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("replication_type", &self.replication_type);
            formatter.field("vcenter_client_id", &self.vcenter_client_id);
            formatter.field("application_id", &self.application_id);
            formatter.finish()
        }
    }
    
    
}
impl ChangeServerLifeCycleStateOutput {
    /// Creates a new builder-style object to manufacture [`ChangeServerLifeCycleStateOutput`](crate::output::ChangeServerLifeCycleStateOutput).
    pub fn builder() -> crate::output::change_server_life_cycle_state_output::Builder {
        crate::output::change_server_life_cycle_state_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TerminateTargetInstancesOutput  {
    /// <p>Terminate Target instance Job response.</p>
    #[doc(hidden)]
    pub job: std::option::Option<crate::model::Job>,
}
impl TerminateTargetInstancesOutput {
    /// <p>Terminate Target instance Job response.</p>
    pub fn job(&self) -> std::option::Option<& crate::model::Job> {
        self.job.as_ref()
    }
}
/// See [`TerminateTargetInstancesOutput`](crate::output::TerminateTargetInstancesOutput).
pub mod terminate_target_instances_output {
    
    /// A builder for [`TerminateTargetInstancesOutput`](crate::output::TerminateTargetInstancesOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job: std::option::Option<crate::model::Job>,
    }
    impl Builder {
        /// <p>Terminate Target instance Job response.</p>
        pub fn job(mut self, input: crate::model::Job) -> Self {
            self.job = Some(input);
            self
        }
        /// <p>Terminate Target instance Job response.</p>
        pub fn set_job(mut self, input: std::option::Option<crate::model::Job>) -> Self {
            self.job = input; self
        }
        /// Consumes the builder and constructs a [`TerminateTargetInstancesOutput`](crate::output::TerminateTargetInstancesOutput).
        pub fn build(self) -> crate::output::TerminateTargetInstancesOutput {
            crate::output::TerminateTargetInstancesOutput {
                job: self.job
                ,
            }
        }
    }
    
    
}
impl TerminateTargetInstancesOutput {
    /// Creates a new builder-style object to manufacture [`TerminateTargetInstancesOutput`](crate::output::TerminateTargetInstancesOutput).
    pub fn builder() -> crate::output::terminate_target_instances_output::Builder {
        crate::output::terminate_target_instances_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartTestOutput  {
    /// <p>Start Test Job response.</p>
    #[doc(hidden)]
    pub job: std::option::Option<crate::model::Job>,
}
impl StartTestOutput {
    /// <p>Start Test Job response.</p>
    pub fn job(&self) -> std::option::Option<& crate::model::Job> {
        self.job.as_ref()
    }
}
/// See [`StartTestOutput`](crate::output::StartTestOutput).
pub mod start_test_output {
    
    /// A builder for [`StartTestOutput`](crate::output::StartTestOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job: std::option::Option<crate::model::Job>,
    }
    impl Builder {
        /// <p>Start Test Job response.</p>
        pub fn job(mut self, input: crate::model::Job) -> Self {
            self.job = Some(input);
            self
        }
        /// <p>Start Test Job response.</p>
        pub fn set_job(mut self, input: std::option::Option<crate::model::Job>) -> Self {
            self.job = input; self
        }
        /// Consumes the builder and constructs a [`StartTestOutput`](crate::output::StartTestOutput).
        pub fn build(self) -> crate::output::StartTestOutput {
            crate::output::StartTestOutput {
                job: self.job
                ,
            }
        }
    }
    
    
}
impl StartTestOutput {
    /// Creates a new builder-style object to manufacture [`StartTestOutput`](crate::output::StartTestOutput).
    pub fn builder() -> crate::output::start_test_output::Builder {
        crate::output::start_test_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartCutoverOutput  {
    /// <p>Start Cutover Job response.</p>
    #[doc(hidden)]
    pub job: std::option::Option<crate::model::Job>,
}
impl StartCutoverOutput {
    /// <p>Start Cutover Job response.</p>
    pub fn job(&self) -> std::option::Option<& crate::model::Job> {
        self.job.as_ref()
    }
}
/// See [`StartCutoverOutput`](crate::output::StartCutoverOutput).
pub mod start_cutover_output {
    
    /// A builder for [`StartCutoverOutput`](crate::output::StartCutoverOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job: std::option::Option<crate::model::Job>,
    }
    impl Builder {
        /// <p>Start Cutover Job response.</p>
        pub fn job(mut self, input: crate::model::Job) -> Self {
            self.job = Some(input);
            self
        }
        /// <p>Start Cutover Job response.</p>
        pub fn set_job(mut self, input: std::option::Option<crate::model::Job>) -> Self {
            self.job = input; self
        }
        /// Consumes the builder and constructs a [`StartCutoverOutput`](crate::output::StartCutoverOutput).
        pub fn build(self) -> crate::output::StartCutoverOutput {
            crate::output::StartCutoverOutput {
                job: self.job
                ,
            }
        }
    }
    
    
}
impl StartCutoverOutput {
    /// Creates a new builder-style object to manufacture [`StartCutoverOutput`](crate::output::StartCutoverOutput).
    pub fn builder() -> crate::output::start_cutover_output::Builder {
        crate::output::start_cutover_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeSourceServersOutput  {
    /// <p>Request to filter Source Servers list by item.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::SourceServer>>,
    /// <p>Request to filter Source Servers next token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeSourceServersOutput {
    /// <p>Request to filter Source Servers list by item.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::SourceServer]> {
        self.items.as_deref()
    }
    /// <p>Request to filter Source Servers next token.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`DescribeSourceServersOutput`](crate::output::DescribeSourceServersOutput).
pub mod describe_source_servers_output {
    
    /// A builder for [`DescribeSourceServersOutput`](crate::output::DescribeSourceServersOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::SourceServer>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Request to filter Source Servers list by item.</p>
        pub fn items(mut self, input: crate::model::SourceServer) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Request to filter Source Servers list by item.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::SourceServer>>) -> Self {
            self.items = input; self
        }
        /// <p>Request to filter Source Servers next token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Request to filter Source Servers next token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeSourceServersOutput`](crate::output::DescribeSourceServersOutput).
        pub fn build(self) -> crate::output::DescribeSourceServersOutput {
            crate::output::DescribeSourceServersOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl DescribeSourceServersOutput {
    /// Creates a new builder-style object to manufacture [`DescribeSourceServersOutput`](crate::output::DescribeSourceServersOutput).
    pub fn builder() -> crate::output::describe_source_servers_output::Builder {
        crate::output::describe_source_servers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSourceServerOutput  {
}
/// See [`DeleteSourceServerOutput`](crate::output::DeleteSourceServerOutput).
pub mod delete_source_server_output {
    
    /// A builder for [`DeleteSourceServerOutput`](crate::output::DeleteSourceServerOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteSourceServerOutput`](crate::output::DeleteSourceServerOutput).
        pub fn build(self) -> crate::output::DeleteSourceServerOutput {
            crate::output::DeleteSourceServerOutput {
            }
        }
    }
    
    
}
impl DeleteSourceServerOutput {
    /// Creates a new builder-style object to manufacture [`DeleteSourceServerOutput`](crate::output::DeleteSourceServerOutput).
    pub fn builder() -> crate::output::delete_source_server_output::Builder {
        crate::output::delete_source_server_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeReplicationConfigurationTemplatesOutput  {
    /// <p>Request to describe Replication Configuration template by items.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationTemplate>>,
    /// <p>Request to describe Replication Configuration template by next token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeReplicationConfigurationTemplatesOutput {
    /// <p>Request to describe Replication Configuration template by items.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::ReplicationConfigurationTemplate]> {
        self.items.as_deref()
    }
    /// <p>Request to describe Replication Configuration template by next token.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`DescribeReplicationConfigurationTemplatesOutput`](crate::output::DescribeReplicationConfigurationTemplatesOutput).
pub mod describe_replication_configuration_templates_output {
    
    /// A builder for [`DescribeReplicationConfigurationTemplatesOutput`](crate::output::DescribeReplicationConfigurationTemplatesOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationTemplate>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Request to describe Replication Configuration template by items.</p>
        pub fn items(mut self, input: crate::model::ReplicationConfigurationTemplate) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Request to describe Replication Configuration template by items.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::ReplicationConfigurationTemplate>>) -> Self {
            self.items = input; self
        }
        /// <p>Request to describe Replication Configuration template by next token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Request to describe Replication Configuration template by next token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeReplicationConfigurationTemplatesOutput`](crate::output::DescribeReplicationConfigurationTemplatesOutput).
        pub fn build(self) -> crate::output::DescribeReplicationConfigurationTemplatesOutput {
            crate::output::DescribeReplicationConfigurationTemplatesOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl DescribeReplicationConfigurationTemplatesOutput {
    /// Creates a new builder-style object to manufacture [`DescribeReplicationConfigurationTemplatesOutput`](crate::output::DescribeReplicationConfigurationTemplatesOutput).
    pub fn builder() -> crate::output::describe_replication_configuration_templates_output::Builder {
        crate::output::describe_replication_configuration_templates_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateReplicationConfigurationTemplateOutput  {
    /// <p>Replication Configuration template ID.</p>
    #[doc(hidden)]
    pub replication_configuration_template_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    #[doc(hidden)]
    pub staging_area_subnet_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    #[doc(hidden)]
    pub associate_default_security_group: std::option::Option<bool>,
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    #[doc(hidden)]
    pub replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Replication Configuration template server instance type.</p>
    #[doc(hidden)]
    pub replication_server_instance_type: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    #[doc(hidden)]
    pub use_dedicated_replication_server: std::option::Option<bool>,
    /// <p>Replication Configuration template use default large Staging Disk type.</p>
    #[doc(hidden)]
    pub default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
    /// <p>Replication Configuration template EBS encryption.</p>
    #[doc(hidden)]
    pub ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    #[doc(hidden)]
    pub ebs_encryption_key_arn: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template bandwidth throttling.</p>
    #[doc(hidden)]
    pub bandwidth_throttling: i64,
    /// <p>Replication Configuration template data plane routing.</p>
    #[doc(hidden)]
    pub data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
    /// <p>Replication Configuration template create Public IP.</p>
    #[doc(hidden)]
    pub create_public_ip: std::option::Option<bool>,
    /// <p>Replication Configuration template Staging Area Tags.</p>
    #[doc(hidden)]
    pub staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Replication Configuration template Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CreateReplicationConfigurationTemplateOutput {
    /// <p>Replication Configuration template ID.</p>
    pub fn replication_configuration_template_id(&self) -> std::option::Option<& str> {
        self.replication_configuration_template_id.as_deref()
    }
    /// <p>Replication Configuration template ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    pub fn staging_area_subnet_id(&self) -> std::option::Option<& str> {
        self.staging_area_subnet_id.as_deref()
    }
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    pub fn associate_default_security_group(&self) -> std::option::Option<bool> {
        self.associate_default_security_group
    }
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    pub fn replication_servers_security_groups_i_ds(&self) -> std::option::Option<& [std::string::String]> {
        self.replication_servers_security_groups_i_ds.as_deref()
    }
    /// <p>Replication Configuration template server instance type.</p>
    pub fn replication_server_instance_type(&self) -> std::option::Option<& str> {
        self.replication_server_instance_type.as_deref()
    }
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    pub fn use_dedicated_replication_server(&self) -> std::option::Option<bool> {
        self.use_dedicated_replication_server
    }
    /// <p>Replication Configuration template use default large Staging Disk type.</p>
    pub fn default_large_staging_disk_type(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDefaultLargeStagingDiskType> {
        self.default_large_staging_disk_type.as_ref()
    }
    /// <p>Replication Configuration template EBS encryption.</p>
    pub fn ebs_encryption(&self) -> std::option::Option<& crate::model::ReplicationConfigurationEbsEncryption> {
        self.ebs_encryption.as_ref()
    }
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    pub fn ebs_encryption_key_arn(&self) -> std::option::Option<& str> {
        self.ebs_encryption_key_arn.as_deref()
    }
    /// <p>Replication Configuration template bandwidth throttling.</p>
    pub fn bandwidth_throttling(&self) -> i64 {
        self.bandwidth_throttling
    }
    /// <p>Replication Configuration template data plane routing.</p>
    pub fn data_plane_routing(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDataPlaneRouting> {
        self.data_plane_routing.as_ref()
    }
    /// <p>Replication Configuration template create Public IP.</p>
    pub fn create_public_ip(&self) -> std::option::Option<bool> {
        self.create_public_ip
    }
    /// <p>Replication Configuration template Staging Area Tags.</p>
    pub fn staging_area_tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.staging_area_tags.as_ref()
    }
    /// <p>Replication Configuration template Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for CreateReplicationConfigurationTemplateOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateReplicationConfigurationTemplateOutput");
        formatter.field("replication_configuration_template_id", &self.replication_configuration_template_id);
        formatter.field("arn", &self.arn);
        formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
        formatter.field("associate_default_security_group", &self.associate_default_security_group);
        formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
        formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
        formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
        formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
        formatter.field("ebs_encryption", &self.ebs_encryption);
        formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
        formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
        formatter.field("data_plane_routing", &self.data_plane_routing);
        formatter.field("create_public_ip", &self.create_public_ip);
        formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`CreateReplicationConfigurationTemplateOutput`](crate::output::CreateReplicationConfigurationTemplateOutput).
pub mod create_replication_configuration_template_output {
    
    /// A builder for [`CreateReplicationConfigurationTemplateOutput`](crate::output::CreateReplicationConfigurationTemplateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) replication_configuration_template_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) staging_area_subnet_id: std::option::Option<std::string::String>,
        pub(crate) associate_default_security_group: std::option::Option<bool>,
        pub(crate) replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) replication_server_instance_type: std::option::Option<std::string::String>,
        pub(crate) use_dedicated_replication_server: std::option::Option<bool>,
        pub(crate) default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
        pub(crate) ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
        pub(crate) ebs_encryption_key_arn: std::option::Option<std::string::String>,
        pub(crate) bandwidth_throttling: std::option::Option<i64>,
        pub(crate) data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
        pub(crate) create_public_ip: std::option::Option<bool>,
        pub(crate) staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Replication Configuration template ID.</p>
        pub fn replication_configuration_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_configuration_template_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration template ID.</p>
        pub fn set_replication_configuration_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.replication_configuration_template_id = input; self
        }
        /// <p>Replication Configuration template ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Replication Configuration template ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Replication Configuration template Staging Area subnet ID.</p>
        pub fn staging_area_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_area_subnet_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration template Staging Area subnet ID.</p>
        pub fn set_staging_area_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.staging_area_subnet_id = input; self
        }
        /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
        pub fn associate_default_security_group(mut self, input: bool) -> Self {
            self.associate_default_security_group = Some(input);
            self
        }
        /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
        pub fn set_associate_default_security_group(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_default_security_group = input; self
        }
        /// Appends an item to `replication_servers_security_groups_i_ds`.
        ///
        /// To override the contents of this collection use [`set_replication_servers_security_groups_i_ds`](Self::set_replication_servers_security_groups_i_ds).
        ///
        /// <p>Replication Configuration template server Security Groups IDs.</p>
        pub fn replication_servers_security_groups_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.replication_servers_security_groups_i_ds.unwrap_or_default();
                            v.push(input.into());
                            self.replication_servers_security_groups_i_ds = Some(v);
                            self
        }
        /// <p>Replication Configuration template server Security Groups IDs.</p>
        pub fn set_replication_servers_security_groups_i_ds(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.replication_servers_security_groups_i_ds = input; self
        }
        /// <p>Replication Configuration template server instance type.</p>
        pub fn replication_server_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_server_instance_type = Some(input.into());
            self
        }
        /// <p>Replication Configuration template server instance type.</p>
        pub fn set_replication_server_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.replication_server_instance_type = input; self
        }
        /// <p>Replication Configuration template use Dedicated Replication Server.</p>
        pub fn use_dedicated_replication_server(mut self, input: bool) -> Self {
            self.use_dedicated_replication_server = Some(input);
            self
        }
        /// <p>Replication Configuration template use Dedicated Replication Server.</p>
        pub fn set_use_dedicated_replication_server(mut self, input: std::option::Option<bool>) -> Self {
            self.use_dedicated_replication_server = input; self
        }
        /// <p>Replication Configuration template use default large Staging Disk type.</p>
        pub fn default_large_staging_disk_type(mut self, input: crate::model::ReplicationConfigurationDefaultLargeStagingDiskType) -> Self {
            self.default_large_staging_disk_type = Some(input);
            self
        }
        /// <p>Replication Configuration template use default large Staging Disk type.</p>
        pub fn set_default_large_staging_disk_type(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>) -> Self {
            self.default_large_staging_disk_type = input; self
        }
        /// <p>Replication Configuration template EBS encryption.</p>
        pub fn ebs_encryption(mut self, input: crate::model::ReplicationConfigurationEbsEncryption) -> Self {
            self.ebs_encryption = Some(input);
            self
        }
        /// <p>Replication Configuration template EBS encryption.</p>
        pub fn set_ebs_encryption(mut self, input: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>) -> Self {
            self.ebs_encryption = input; self
        }
        /// <p>Replication Configuration template EBS encryption key ARN.</p>
        pub fn ebs_encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = Some(input.into());
            self
        }
        /// <p>Replication Configuration template EBS encryption key ARN.</p>
        pub fn set_ebs_encryption_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = input; self
        }
        /// <p>Replication Configuration template bandwidth throttling.</p>
        pub fn bandwidth_throttling(mut self, input: i64) -> Self {
            self.bandwidth_throttling = Some(input);
            self
        }
        /// <p>Replication Configuration template bandwidth throttling.</p>
        pub fn set_bandwidth_throttling(mut self, input: std::option::Option<i64>) -> Self {
            self.bandwidth_throttling = input; self
        }
        /// <p>Replication Configuration template data plane routing.</p>
        pub fn data_plane_routing(mut self, input: crate::model::ReplicationConfigurationDataPlaneRouting) -> Self {
            self.data_plane_routing = Some(input);
            self
        }
        /// <p>Replication Configuration template data plane routing.</p>
        pub fn set_data_plane_routing(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>) -> Self {
            self.data_plane_routing = input; self
        }
        /// <p>Replication Configuration template create Public IP.</p>
        pub fn create_public_ip(mut self, input: bool) -> Self {
            self.create_public_ip = Some(input);
            self
        }
        /// <p>Replication Configuration template create Public IP.</p>
        pub fn set_create_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.create_public_ip = input; self
        }
        /// Adds a key-value pair to `staging_area_tags`.
        ///
        /// To override the contents of this collection use [`set_staging_area_tags`](Self::set_staging_area_tags).
        ///
        /// <p>Replication Configuration template Staging Area Tags.</p>
        pub fn staging_area_tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.staging_area_tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.staging_area_tags = Some(hash_map);
                            self
        }
        /// <p>Replication Configuration template Staging Area Tags.</p>
        pub fn set_staging_area_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.staging_area_tags = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Replication Configuration template Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Replication Configuration template Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateReplicationConfigurationTemplateOutput`](crate::output::CreateReplicationConfigurationTemplateOutput).
        pub fn build(self) -> crate::output::CreateReplicationConfigurationTemplateOutput {
            crate::output::CreateReplicationConfigurationTemplateOutput {
                replication_configuration_template_id: self.replication_configuration_template_id
                ,
                arn: self.arn
                ,
                staging_area_subnet_id: self.staging_area_subnet_id
                ,
                associate_default_security_group: self.associate_default_security_group
                ,
                replication_servers_security_groups_i_ds: self.replication_servers_security_groups_i_ds
                ,
                replication_server_instance_type: self.replication_server_instance_type
                ,
                use_dedicated_replication_server: self.use_dedicated_replication_server
                ,
                default_large_staging_disk_type: self.default_large_staging_disk_type
                ,
                ebs_encryption: self.ebs_encryption
                ,
                ebs_encryption_key_arn: self.ebs_encryption_key_arn
                ,
                bandwidth_throttling: self.bandwidth_throttling
                    .unwrap_or_default()
                ,
                data_plane_routing: self.data_plane_routing
                ,
                create_public_ip: self.create_public_ip
                ,
                staging_area_tags: self.staging_area_tags
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("replication_configuration_template_id", &self.replication_configuration_template_id);
            formatter.field("arn", &self.arn);
            formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
            formatter.field("associate_default_security_group", &self.associate_default_security_group);
            formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
            formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
            formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
            formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
            formatter.field("ebs_encryption", &self.ebs_encryption);
            formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
            formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
            formatter.field("data_plane_routing", &self.data_plane_routing);
            formatter.field("create_public_ip", &self.create_public_ip);
            formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl CreateReplicationConfigurationTemplateOutput {
    /// Creates a new builder-style object to manufacture [`CreateReplicationConfigurationTemplateOutput`](crate::output::CreateReplicationConfigurationTemplateOutput).
    pub fn builder() -> crate::output::create_replication_configuration_template_output::Builder {
        crate::output::create_replication_configuration_template_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteReplicationConfigurationTemplateOutput  {
}
/// See [`DeleteReplicationConfigurationTemplateOutput`](crate::output::DeleteReplicationConfigurationTemplateOutput).
pub mod delete_replication_configuration_template_output {
    
    /// A builder for [`DeleteReplicationConfigurationTemplateOutput`](crate::output::DeleteReplicationConfigurationTemplateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteReplicationConfigurationTemplateOutput`](crate::output::DeleteReplicationConfigurationTemplateOutput).
        pub fn build(self) -> crate::output::DeleteReplicationConfigurationTemplateOutput {
            crate::output::DeleteReplicationConfigurationTemplateOutput {
            }
        }
    }
    
    
}
impl DeleteReplicationConfigurationTemplateOutput {
    /// Creates a new builder-style object to manufacture [`DeleteReplicationConfigurationTemplateOutput`](crate::output::DeleteReplicationConfigurationTemplateOutput).
    pub fn builder() -> crate::output::delete_replication_configuration_template_output::Builder {
        crate::output::delete_replication_configuration_template_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateReplicationConfigurationTemplateOutput  {
    /// <p>Replication Configuration template ID.</p>
    #[doc(hidden)]
    pub replication_configuration_template_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    #[doc(hidden)]
    pub staging_area_subnet_id: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    #[doc(hidden)]
    pub associate_default_security_group: std::option::Option<bool>,
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    #[doc(hidden)]
    pub replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Replication Configuration template server instance type.</p>
    #[doc(hidden)]
    pub replication_server_instance_type: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    #[doc(hidden)]
    pub use_dedicated_replication_server: std::option::Option<bool>,
    /// <p>Replication Configuration template use default large Staging Disk type.</p>
    #[doc(hidden)]
    pub default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
    /// <p>Replication Configuration template EBS encryption.</p>
    #[doc(hidden)]
    pub ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    #[doc(hidden)]
    pub ebs_encryption_key_arn: std::option::Option<std::string::String>,
    /// <p>Replication Configuration template bandwidth throttling.</p>
    #[doc(hidden)]
    pub bandwidth_throttling: i64,
    /// <p>Replication Configuration template data plane routing.</p>
    #[doc(hidden)]
    pub data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
    /// <p>Replication Configuration template create Public IP.</p>
    #[doc(hidden)]
    pub create_public_ip: std::option::Option<bool>,
    /// <p>Replication Configuration template Staging Area Tags.</p>
    #[doc(hidden)]
    pub staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Replication Configuration template Tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateReplicationConfigurationTemplateOutput {
    /// <p>Replication Configuration template ID.</p>
    pub fn replication_configuration_template_id(&self) -> std::option::Option<& str> {
        self.replication_configuration_template_id.as_deref()
    }
    /// <p>Replication Configuration template ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Replication Configuration template Staging Area subnet ID.</p>
    pub fn staging_area_subnet_id(&self) -> std::option::Option<& str> {
        self.staging_area_subnet_id.as_deref()
    }
    /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
    pub fn associate_default_security_group(&self) -> std::option::Option<bool> {
        self.associate_default_security_group
    }
    /// <p>Replication Configuration template server Security Groups IDs.</p>
    pub fn replication_servers_security_groups_i_ds(&self) -> std::option::Option<& [std::string::String]> {
        self.replication_servers_security_groups_i_ds.as_deref()
    }
    /// <p>Replication Configuration template server instance type.</p>
    pub fn replication_server_instance_type(&self) -> std::option::Option<& str> {
        self.replication_server_instance_type.as_deref()
    }
    /// <p>Replication Configuration template use Dedicated Replication Server.</p>
    pub fn use_dedicated_replication_server(&self) -> std::option::Option<bool> {
        self.use_dedicated_replication_server
    }
    /// <p>Replication Configuration template use default large Staging Disk type.</p>
    pub fn default_large_staging_disk_type(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDefaultLargeStagingDiskType> {
        self.default_large_staging_disk_type.as_ref()
    }
    /// <p>Replication Configuration template EBS encryption.</p>
    pub fn ebs_encryption(&self) -> std::option::Option<& crate::model::ReplicationConfigurationEbsEncryption> {
        self.ebs_encryption.as_ref()
    }
    /// <p>Replication Configuration template EBS encryption key ARN.</p>
    pub fn ebs_encryption_key_arn(&self) -> std::option::Option<& str> {
        self.ebs_encryption_key_arn.as_deref()
    }
    /// <p>Replication Configuration template bandwidth throttling.</p>
    pub fn bandwidth_throttling(&self) -> i64 {
        self.bandwidth_throttling
    }
    /// <p>Replication Configuration template data plane routing.</p>
    pub fn data_plane_routing(&self) -> std::option::Option<& crate::model::ReplicationConfigurationDataPlaneRouting> {
        self.data_plane_routing.as_ref()
    }
    /// <p>Replication Configuration template create Public IP.</p>
    pub fn create_public_ip(&self) -> std::option::Option<bool> {
        self.create_public_ip
    }
    /// <p>Replication Configuration template Staging Area Tags.</p>
    pub fn staging_area_tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.staging_area_tags.as_ref()
    }
    /// <p>Replication Configuration template Tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for UpdateReplicationConfigurationTemplateOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateReplicationConfigurationTemplateOutput");
        formatter.field("replication_configuration_template_id", &self.replication_configuration_template_id);
        formatter.field("arn", &self.arn);
        formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
        formatter.field("associate_default_security_group", &self.associate_default_security_group);
        formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
        formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
        formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
        formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
        formatter.field("ebs_encryption", &self.ebs_encryption);
        formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
        formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
        formatter.field("data_plane_routing", &self.data_plane_routing);
        formatter.field("create_public_ip", &self.create_public_ip);
        formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`UpdateReplicationConfigurationTemplateOutput`](crate::output::UpdateReplicationConfigurationTemplateOutput).
pub mod update_replication_configuration_template_output {
    
    /// A builder for [`UpdateReplicationConfigurationTemplateOutput`](crate::output::UpdateReplicationConfigurationTemplateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) replication_configuration_template_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) staging_area_subnet_id: std::option::Option<std::string::String>,
        pub(crate) associate_default_security_group: std::option::Option<bool>,
        pub(crate) replication_servers_security_groups_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) replication_server_instance_type: std::option::Option<std::string::String>,
        pub(crate) use_dedicated_replication_server: std::option::Option<bool>,
        pub(crate) default_large_staging_disk_type: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
        pub(crate) ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
        pub(crate) ebs_encryption_key_arn: std::option::Option<std::string::String>,
        pub(crate) bandwidth_throttling: std::option::Option<i64>,
        pub(crate) data_plane_routing: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
        pub(crate) create_public_ip: std::option::Option<bool>,
        pub(crate) staging_area_tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>Replication Configuration template ID.</p>
        pub fn replication_configuration_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_configuration_template_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration template ID.</p>
        pub fn set_replication_configuration_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.replication_configuration_template_id = input; self
        }
        /// <p>Replication Configuration template ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Replication Configuration template ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Replication Configuration template Staging Area subnet ID.</p>
        pub fn staging_area_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_area_subnet_id = Some(input.into());
            self
        }
        /// <p>Replication Configuration template Staging Area subnet ID.</p>
        pub fn set_staging_area_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.staging_area_subnet_id = input; self
        }
        /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
        pub fn associate_default_security_group(mut self, input: bool) -> Self {
            self.associate_default_security_group = Some(input);
            self
        }
        /// <p>Replication Configuration template associate default Application Migration Service Security group.</p>
        pub fn set_associate_default_security_group(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_default_security_group = input; self
        }
        /// Appends an item to `replication_servers_security_groups_i_ds`.
        ///
        /// To override the contents of this collection use [`set_replication_servers_security_groups_i_ds`](Self::set_replication_servers_security_groups_i_ds).
        ///
        /// <p>Replication Configuration template server Security Groups IDs.</p>
        pub fn replication_servers_security_groups_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.replication_servers_security_groups_i_ds.unwrap_or_default();
                            v.push(input.into());
                            self.replication_servers_security_groups_i_ds = Some(v);
                            self
        }
        /// <p>Replication Configuration template server Security Groups IDs.</p>
        pub fn set_replication_servers_security_groups_i_ds(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.replication_servers_security_groups_i_ds = input; self
        }
        /// <p>Replication Configuration template server instance type.</p>
        pub fn replication_server_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.replication_server_instance_type = Some(input.into());
            self
        }
        /// <p>Replication Configuration template server instance type.</p>
        pub fn set_replication_server_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.replication_server_instance_type = input; self
        }
        /// <p>Replication Configuration template use Dedicated Replication Server.</p>
        pub fn use_dedicated_replication_server(mut self, input: bool) -> Self {
            self.use_dedicated_replication_server = Some(input);
            self
        }
        /// <p>Replication Configuration template use Dedicated Replication Server.</p>
        pub fn set_use_dedicated_replication_server(mut self, input: std::option::Option<bool>) -> Self {
            self.use_dedicated_replication_server = input; self
        }
        /// <p>Replication Configuration template use default large Staging Disk type.</p>
        pub fn default_large_staging_disk_type(mut self, input: crate::model::ReplicationConfigurationDefaultLargeStagingDiskType) -> Self {
            self.default_large_staging_disk_type = Some(input);
            self
        }
        /// <p>Replication Configuration template use default large Staging Disk type.</p>
        pub fn set_default_large_staging_disk_type(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>) -> Self {
            self.default_large_staging_disk_type = input; self
        }
        /// <p>Replication Configuration template EBS encryption.</p>
        pub fn ebs_encryption(mut self, input: crate::model::ReplicationConfigurationEbsEncryption) -> Self {
            self.ebs_encryption = Some(input);
            self
        }
        /// <p>Replication Configuration template EBS encryption.</p>
        pub fn set_ebs_encryption(mut self, input: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>) -> Self {
            self.ebs_encryption = input; self
        }
        /// <p>Replication Configuration template EBS encryption key ARN.</p>
        pub fn ebs_encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = Some(input.into());
            self
        }
        /// <p>Replication Configuration template EBS encryption key ARN.</p>
        pub fn set_ebs_encryption_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = input; self
        }
        /// <p>Replication Configuration template bandwidth throttling.</p>
        pub fn bandwidth_throttling(mut self, input: i64) -> Self {
            self.bandwidth_throttling = Some(input);
            self
        }
        /// <p>Replication Configuration template bandwidth throttling.</p>
        pub fn set_bandwidth_throttling(mut self, input: std::option::Option<i64>) -> Self {
            self.bandwidth_throttling = input; self
        }
        /// <p>Replication Configuration template data plane routing.</p>
        pub fn data_plane_routing(mut self, input: crate::model::ReplicationConfigurationDataPlaneRouting) -> Self {
            self.data_plane_routing = Some(input);
            self
        }
        /// <p>Replication Configuration template data plane routing.</p>
        pub fn set_data_plane_routing(mut self, input: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>) -> Self {
            self.data_plane_routing = input; self
        }
        /// <p>Replication Configuration template create Public IP.</p>
        pub fn create_public_ip(mut self, input: bool) -> Self {
            self.create_public_ip = Some(input);
            self
        }
        /// <p>Replication Configuration template create Public IP.</p>
        pub fn set_create_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.create_public_ip = input; self
        }
        /// Adds a key-value pair to `staging_area_tags`.
        ///
        /// To override the contents of this collection use [`set_staging_area_tags`](Self::set_staging_area_tags).
        ///
        /// <p>Replication Configuration template Staging Area Tags.</p>
        pub fn staging_area_tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.staging_area_tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.staging_area_tags = Some(hash_map);
                            self
        }
        /// <p>Replication Configuration template Staging Area Tags.</p>
        pub fn set_staging_area_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.staging_area_tags = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Replication Configuration template Tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Replication Configuration template Tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`UpdateReplicationConfigurationTemplateOutput`](crate::output::UpdateReplicationConfigurationTemplateOutput).
        pub fn build(self) -> crate::output::UpdateReplicationConfigurationTemplateOutput {
            crate::output::UpdateReplicationConfigurationTemplateOutput {
                replication_configuration_template_id: self.replication_configuration_template_id
                ,
                arn: self.arn
                ,
                staging_area_subnet_id: self.staging_area_subnet_id
                ,
                associate_default_security_group: self.associate_default_security_group
                ,
                replication_servers_security_groups_i_ds: self.replication_servers_security_groups_i_ds
                ,
                replication_server_instance_type: self.replication_server_instance_type
                ,
                use_dedicated_replication_server: self.use_dedicated_replication_server
                ,
                default_large_staging_disk_type: self.default_large_staging_disk_type
                ,
                ebs_encryption: self.ebs_encryption
                ,
                ebs_encryption_key_arn: self.ebs_encryption_key_arn
                ,
                bandwidth_throttling: self.bandwidth_throttling
                    .unwrap_or_default()
                ,
                data_plane_routing: self.data_plane_routing
                ,
                create_public_ip: self.create_public_ip
                ,
                staging_area_tags: self.staging_area_tags
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("replication_configuration_template_id", &self.replication_configuration_template_id);
            formatter.field("arn", &self.arn);
            formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
            formatter.field("associate_default_security_group", &self.associate_default_security_group);
            formatter.field("replication_servers_security_groups_i_ds", &self.replication_servers_security_groups_i_ds);
            formatter.field("replication_server_instance_type", &self.replication_server_instance_type);
            formatter.field("use_dedicated_replication_server", &self.use_dedicated_replication_server);
            formatter.field("default_large_staging_disk_type", &self.default_large_staging_disk_type);
            formatter.field("ebs_encryption", &self.ebs_encryption);
            formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
            formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
            formatter.field("data_plane_routing", &self.data_plane_routing);
            formatter.field("create_public_ip", &self.create_public_ip);
            formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl UpdateReplicationConfigurationTemplateOutput {
    /// Creates a new builder-style object to manufacture [`UpdateReplicationConfigurationTemplateOutput`](crate::output::UpdateReplicationConfigurationTemplateOutput).
    pub fn builder() -> crate::output::update_replication_configuration_template_output::Builder {
        crate::output::update_replication_configuration_template_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RemoveTemplateActionOutput  {
}
/// See [`RemoveTemplateActionOutput`](crate::output::RemoveTemplateActionOutput).
pub mod remove_template_action_output {
    
    /// A builder for [`RemoveTemplateActionOutput`](crate::output::RemoveTemplateActionOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`RemoveTemplateActionOutput`](crate::output::RemoveTemplateActionOutput).
        pub fn build(self) -> crate::output::RemoveTemplateActionOutput {
            crate::output::RemoveTemplateActionOutput {
            }
        }
    }
    
    
}
impl RemoveTemplateActionOutput {
    /// Creates a new builder-style object to manufacture [`RemoveTemplateActionOutput`](crate::output::RemoveTemplateActionOutput).
    pub fn builder() -> crate::output::remove_template_action_output::Builder {
        crate::output::remove_template_action_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutTemplateActionOutput  {
    /// <p>Template post migration custom action ID.</p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
    /// <p>Template post migration custom action name.</p>
    #[doc(hidden)]
    pub action_name: std::option::Option<std::string::String>,
    /// <p>Template post migration custom action document identifier.</p>
    #[doc(hidden)]
    pub document_identifier: std::option::Option<std::string::String>,
    /// <p>Template post migration custom action order.</p>
    #[doc(hidden)]
    pub order: i32,
    /// <p>Template post migration custom action document version.</p>
    #[doc(hidden)]
    pub document_version: std::option::Option<std::string::String>,
    /// <p>Template post migration custom action active status.</p>
    #[doc(hidden)]
    pub active: std::option::Option<bool>,
    /// <p>Template post migration custom action timeout in seconds.</p>
    #[doc(hidden)]
    pub timeout_seconds: i32,
    /// <p>Template post migration custom action must succeed for cutover.</p>
    #[doc(hidden)]
    pub must_succeed_for_cutover: std::option::Option<bool>,
    /// <p>Template post migration custom action parameters.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>>,
    /// <p>Operating system eligible for this template post migration custom action.</p>
    #[doc(hidden)]
    pub operating_system: std::option::Option<std::string::String>,
}
impl PutTemplateActionOutput {
    /// <p>Template post migration custom action ID.</p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
    /// <p>Template post migration custom action name.</p>
    pub fn action_name(&self) -> std::option::Option<& str> {
        self.action_name.as_deref()
    }
    /// <p>Template post migration custom action document identifier.</p>
    pub fn document_identifier(&self) -> std::option::Option<& str> {
        self.document_identifier.as_deref()
    }
    /// <p>Template post migration custom action order.</p>
    pub fn order(&self) -> i32 {
        self.order
    }
    /// <p>Template post migration custom action document version.</p>
    pub fn document_version(&self) -> std::option::Option<& str> {
        self.document_version.as_deref()
    }
    /// <p>Template post migration custom action active status.</p>
    pub fn active(&self) -> std::option::Option<bool> {
        self.active
    }
    /// <p>Template post migration custom action timeout in seconds.</p>
    pub fn timeout_seconds(&self) -> i32 {
        self.timeout_seconds
    }
    /// <p>Template post migration custom action must succeed for cutover.</p>
    pub fn must_succeed_for_cutover(&self) -> std::option::Option<bool> {
        self.must_succeed_for_cutover
    }
    /// <p>Template post migration custom action parameters.</p>
    pub fn parameters(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>> {
        self.parameters.as_ref()
    }
    /// <p>Operating system eligible for this template post migration custom action.</p>
    pub fn operating_system(&self) -> std::option::Option<& str> {
        self.operating_system.as_deref()
    }
}
/// See [`PutTemplateActionOutput`](crate::output::PutTemplateActionOutput).
pub mod put_template_action_output {
    
    /// A builder for [`PutTemplateActionOutput`](crate::output::PutTemplateActionOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) action_name: std::option::Option<std::string::String>,
        pub(crate) document_identifier: std::option::Option<std::string::String>,
        pub(crate) order: std::option::Option<i32>,
        pub(crate) document_version: std::option::Option<std::string::String>,
        pub(crate) active: std::option::Option<bool>,
        pub(crate) timeout_seconds: std::option::Option<i32>,
        pub(crate) must_succeed_for_cutover: std::option::Option<bool>,
        pub(crate) parameters: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>>,
        pub(crate) operating_system: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Template post migration custom action ID.</p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p>Template post migration custom action ID.</p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// <p>Template post migration custom action name.</p>
        pub fn action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_name = Some(input.into());
            self
        }
        /// <p>Template post migration custom action name.</p>
        pub fn set_action_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_name = input; self
        }
        /// <p>Template post migration custom action document identifier.</p>
        pub fn document_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_identifier = Some(input.into());
            self
        }
        /// <p>Template post migration custom action document identifier.</p>
        pub fn set_document_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_identifier = input; self
        }
        /// <p>Template post migration custom action order.</p>
        pub fn order(mut self, input: i32) -> Self {
            self.order = Some(input);
            self
        }
        /// <p>Template post migration custom action order.</p>
        pub fn set_order(mut self, input: std::option::Option<i32>) -> Self {
            self.order = input; self
        }
        /// <p>Template post migration custom action document version.</p>
        pub fn document_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.document_version = Some(input.into());
            self
        }
        /// <p>Template post migration custom action document version.</p>
        pub fn set_document_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.document_version = input; self
        }
        /// <p>Template post migration custom action active status.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>Template post migration custom action active status.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input; self
        }
        /// <p>Template post migration custom action timeout in seconds.</p>
        pub fn timeout_seconds(mut self, input: i32) -> Self {
            self.timeout_seconds = Some(input);
            self
        }
        /// <p>Template post migration custom action timeout in seconds.</p>
        pub fn set_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.timeout_seconds = input; self
        }
        /// <p>Template post migration custom action must succeed for cutover.</p>
        pub fn must_succeed_for_cutover(mut self, input: bool) -> Self {
            self.must_succeed_for_cutover = Some(input);
            self
        }
        /// <p>Template post migration custom action must succeed for cutover.</p>
        pub fn set_must_succeed_for_cutover(mut self, input: std::option::Option<bool>) -> Self {
            self.must_succeed_for_cutover = input; self
        }
        /// Adds a key-value pair to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>Template post migration custom action parameters.</p>
        pub fn parameters(mut self, k: impl Into<std::string::String>, v: std::vec::Vec<crate::model::SsmParameterStoreParameter>) -> Self {
            let mut hash_map = self.parameters.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.parameters = Some(hash_map);
                            self
        }
        /// <p>Template post migration custom action parameters.</p>
        pub fn set_parameters(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::SsmParameterStoreParameter>>>) -> Self {
            self.parameters = input; self
        }
        /// <p>Operating system eligible for this template post migration custom action.</p>
        pub fn operating_system(mut self, input: impl Into<std::string::String>) -> Self {
            self.operating_system = Some(input.into());
            self
        }
        /// <p>Operating system eligible for this template post migration custom action.</p>
        pub fn set_operating_system(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operating_system = input; self
        }
        /// Consumes the builder and constructs a [`PutTemplateActionOutput`](crate::output::PutTemplateActionOutput).
        pub fn build(self) -> crate::output::PutTemplateActionOutput {
            crate::output::PutTemplateActionOutput {
                action_id: self.action_id
                ,
                action_name: self.action_name
                ,
                document_identifier: self.document_identifier
                ,
                order: self.order
                    .unwrap_or_default()
                ,
                document_version: self.document_version
                ,
                active: self.active
                ,
                timeout_seconds: self.timeout_seconds
                    .unwrap_or_default()
                ,
                must_succeed_for_cutover: self.must_succeed_for_cutover
                ,
                parameters: self.parameters
                ,
                operating_system: self.operating_system
                ,
            }
        }
    }
    
    
}
impl PutTemplateActionOutput {
    /// Creates a new builder-style object to manufacture [`PutTemplateActionOutput`](crate::output::PutTemplateActionOutput).
    pub fn builder() -> crate::output::put_template_action_output::Builder {
        crate::output::put_template_action_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTemplateActionsOutput  {
    /// <p>List of template post migration custom actions.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::TemplateActionDocument>>,
    /// <p>Next token returned when listing template post migration custom actions.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListTemplateActionsOutput {
    /// <p>List of template post migration custom actions.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::TemplateActionDocument]> {
        self.items.as_deref()
    }
    /// <p>Next token returned when listing template post migration custom actions.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`ListTemplateActionsOutput`](crate::output::ListTemplateActionsOutput).
pub mod list_template_actions_output {
    
    /// A builder for [`ListTemplateActionsOutput`](crate::output::ListTemplateActionsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::TemplateActionDocument>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>List of template post migration custom actions.</p>
        pub fn items(mut self, input: crate::model::TemplateActionDocument) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>List of template post migration custom actions.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::TemplateActionDocument>>) -> Self {
            self.items = input; self
        }
        /// <p>Next token returned when listing template post migration custom actions.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Next token returned when listing template post migration custom actions.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListTemplateActionsOutput`](crate::output::ListTemplateActionsOutput).
        pub fn build(self) -> crate::output::ListTemplateActionsOutput {
            crate::output::ListTemplateActionsOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl ListTemplateActionsOutput {
    /// Creates a new builder-style object to manufacture [`ListTemplateActionsOutput`](crate::output::ListTemplateActionsOutput).
    pub fn builder() -> crate::output::list_template_actions_output::Builder {
        crate::output::list_template_actions_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeLaunchConfigurationTemplatesOutput  {
    /// <p>List of items returned by DescribeLaunchConfigurationTemplates.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::LaunchConfigurationTemplate>>,
    /// <p>Next pagination token returned from DescribeLaunchConfigurationTemplates.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeLaunchConfigurationTemplatesOutput {
    /// <p>List of items returned by DescribeLaunchConfigurationTemplates.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::LaunchConfigurationTemplate]> {
        self.items.as_deref()
    }
    /// <p>Next pagination token returned from DescribeLaunchConfigurationTemplates.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`DescribeLaunchConfigurationTemplatesOutput`](crate::output::DescribeLaunchConfigurationTemplatesOutput).
pub mod describe_launch_configuration_templates_output {
    
    /// A builder for [`DescribeLaunchConfigurationTemplatesOutput`](crate::output::DescribeLaunchConfigurationTemplatesOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::LaunchConfigurationTemplate>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>List of items returned by DescribeLaunchConfigurationTemplates.</p>
        pub fn items(mut self, input: crate::model::LaunchConfigurationTemplate) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>List of items returned by DescribeLaunchConfigurationTemplates.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::LaunchConfigurationTemplate>>) -> Self {
            self.items = input; self
        }
        /// <p>Next pagination token returned from DescribeLaunchConfigurationTemplates.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Next pagination token returned from DescribeLaunchConfigurationTemplates.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeLaunchConfigurationTemplatesOutput`](crate::output::DescribeLaunchConfigurationTemplatesOutput).
        pub fn build(self) -> crate::output::DescribeLaunchConfigurationTemplatesOutput {
            crate::output::DescribeLaunchConfigurationTemplatesOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl DescribeLaunchConfigurationTemplatesOutput {
    /// Creates a new builder-style object to manufacture [`DescribeLaunchConfigurationTemplatesOutput`](crate::output::DescribeLaunchConfigurationTemplatesOutput).
    pub fn builder() -> crate::output::describe_launch_configuration_templates_output::Builder {
        crate::output::describe_launch_configuration_templates_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLaunchConfigurationTemplateOutput  {
    /// <p>ID of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub launch_configuration_template_id: std::option::Option<std::string::String>,
    /// <p>ARN of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Post Launch Actions of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
    /// <p>Enable map auto tagging.</p>
    #[doc(hidden)]
    pub enable_map_auto_tagging: std::option::Option<bool>,
    /// <p>Launch configuration template map auto tagging MPE ID.</p>
    #[doc(hidden)]
    pub map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
    /// <p>Tags of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>EC2 launch template ID.</p>
    #[doc(hidden)]
    pub ec2_launch_template_id: std::option::Option<std::string::String>,
    /// <p>Launch disposition.</p>
    #[doc(hidden)]
    pub launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
    /// <p>Target instance type right-sizing method.</p>
    #[doc(hidden)]
    pub target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
    /// <p>Copy private Ip.</p>
    #[doc(hidden)]
    pub copy_private_ip: std::option::Option<bool>,
    /// <p>Associate public Ip address.</p>
    #[doc(hidden)]
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>Copy tags.</p>
    #[doc(hidden)]
    pub copy_tags: std::option::Option<bool>,
    /// <p>Configure Licensing.</p>
    #[doc(hidden)]
    pub licensing: std::option::Option<crate::model::Licensing>,
    /// <p>Launch configuration template boot mode.</p>
    #[doc(hidden)]
    pub boot_mode: std::option::Option<crate::model::BootMode>,
    /// <p>Small volume maximum size.</p>
    #[doc(hidden)]
    pub small_volume_max_size: i64,
    /// <p>Small volume config.</p>
    #[doc(hidden)]
    pub small_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
    /// <p>Large volume config.</p>
    #[doc(hidden)]
    pub large_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
}
impl CreateLaunchConfigurationTemplateOutput {
    /// <p>ID of the Launch Configuration Template.</p>
    pub fn launch_configuration_template_id(&self) -> std::option::Option<& str> {
        self.launch_configuration_template_id.as_deref()
    }
    /// <p>ARN of the Launch Configuration Template.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Post Launch Actions of the Launch Configuration Template.</p>
    pub fn post_launch_actions(&self) -> std::option::Option<& crate::model::PostLaunchActions> {
        self.post_launch_actions.as_ref()
    }
    /// <p>Enable map auto tagging.</p>
    pub fn enable_map_auto_tagging(&self) -> std::option::Option<bool> {
        self.enable_map_auto_tagging
    }
    /// <p>Launch configuration template map auto tagging MPE ID.</p>
    pub fn map_auto_tagging_mpe_id(&self) -> std::option::Option<& str> {
        self.map_auto_tagging_mpe_id.as_deref()
    }
    /// <p>Tags of the Launch Configuration Template.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>EC2 launch template ID.</p>
    pub fn ec2_launch_template_id(&self) -> std::option::Option<& str> {
        self.ec2_launch_template_id.as_deref()
    }
    /// <p>Launch disposition.</p>
    pub fn launch_disposition(&self) -> std::option::Option<& crate::model::LaunchDisposition> {
        self.launch_disposition.as_ref()
    }
    /// <p>Target instance type right-sizing method.</p>
    pub fn target_instance_type_right_sizing_method(&self) -> std::option::Option<& crate::model::TargetInstanceTypeRightSizingMethod> {
        self.target_instance_type_right_sizing_method.as_ref()
    }
    /// <p>Copy private Ip.</p>
    pub fn copy_private_ip(&self) -> std::option::Option<bool> {
        self.copy_private_ip
    }
    /// <p>Associate public Ip address.</p>
    pub fn associate_public_ip_address(&self) -> std::option::Option<bool> {
        self.associate_public_ip_address
    }
    /// <p>Copy tags.</p>
    pub fn copy_tags(&self) -> std::option::Option<bool> {
        self.copy_tags
    }
    /// <p>Configure Licensing.</p>
    pub fn licensing(&self) -> std::option::Option<& crate::model::Licensing> {
        self.licensing.as_ref()
    }
    /// <p>Launch configuration template boot mode.</p>
    pub fn boot_mode(&self) -> std::option::Option<& crate::model::BootMode> {
        self.boot_mode.as_ref()
    }
    /// <p>Small volume maximum size.</p>
    pub fn small_volume_max_size(&self) -> i64 {
        self.small_volume_max_size
    }
    /// <p>Small volume config.</p>
    pub fn small_volume_conf(&self) -> std::option::Option<& crate::model::LaunchTemplateDiskConf> {
        self.small_volume_conf.as_ref()
    }
    /// <p>Large volume config.</p>
    pub fn large_volume_conf(&self) -> std::option::Option<& crate::model::LaunchTemplateDiskConf> {
        self.large_volume_conf.as_ref()
    }
}
impl  std::fmt::Debug for CreateLaunchConfigurationTemplateOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLaunchConfigurationTemplateOutput");
        formatter.field("launch_configuration_template_id", &self.launch_configuration_template_id);
        formatter.field("arn", &self.arn);
        formatter.field("post_launch_actions", &self.post_launch_actions);
        formatter.field("enable_map_auto_tagging", &self.enable_map_auto_tagging);
        formatter.field("map_auto_tagging_mpe_id", &self.map_auto_tagging_mpe_id);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_launch_template_id", &self.ec2_launch_template_id);
        formatter.field("launch_disposition", &self.launch_disposition);
        formatter.field("target_instance_type_right_sizing_method", &self.target_instance_type_right_sizing_method);
        formatter.field("copy_private_ip", &self.copy_private_ip);
        formatter.field("associate_public_ip_address", &self.associate_public_ip_address);
        formatter.field("copy_tags", &self.copy_tags);
        formatter.field("licensing", &self.licensing);
        formatter.field("boot_mode", &self.boot_mode);
        formatter.field("small_volume_max_size", &self.small_volume_max_size);
        formatter.field("small_volume_conf", &self.small_volume_conf);
        formatter.field("large_volume_conf", &self.large_volume_conf);
        formatter.finish()
    }
}
/// See [`CreateLaunchConfigurationTemplateOutput`](crate::output::CreateLaunchConfigurationTemplateOutput).
pub mod create_launch_configuration_template_output {
    
    /// A builder for [`CreateLaunchConfigurationTemplateOutput`](crate::output::CreateLaunchConfigurationTemplateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) launch_configuration_template_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
        pub(crate) enable_map_auto_tagging: std::option::Option<bool>,
        pub(crate) map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) ec2_launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
        pub(crate) target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
        pub(crate) copy_private_ip: std::option::Option<bool>,
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) copy_tags: std::option::Option<bool>,
        pub(crate) licensing: std::option::Option<crate::model::Licensing>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootMode>,
        pub(crate) small_volume_max_size: std::option::Option<i64>,
        pub(crate) small_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
        pub(crate) large_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
    }
    impl Builder {
        /// <p>ID of the Launch Configuration Template.</p>
        pub fn launch_configuration_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_template_id = Some(input.into());
            self
        }
        /// <p>ID of the Launch Configuration Template.</p>
        pub fn set_launch_configuration_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launch_configuration_template_id = input; self
        }
        /// <p>ARN of the Launch Configuration Template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>ARN of the Launch Configuration Template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Post Launch Actions of the Launch Configuration Template.</p>
        pub fn post_launch_actions(mut self, input: crate::model::PostLaunchActions) -> Self {
            self.post_launch_actions = Some(input);
            self
        }
        /// <p>Post Launch Actions of the Launch Configuration Template.</p>
        pub fn set_post_launch_actions(mut self, input: std::option::Option<crate::model::PostLaunchActions>) -> Self {
            self.post_launch_actions = input; self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn enable_map_auto_tagging(mut self, input: bool) -> Self {
            self.enable_map_auto_tagging = Some(input);
            self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn set_enable_map_auto_tagging(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_map_auto_tagging = input; self
        }
        /// <p>Launch configuration template map auto tagging MPE ID.</p>
        pub fn map_auto_tagging_mpe_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = Some(input.into());
            self
        }
        /// <p>Launch configuration template map auto tagging MPE ID.</p>
        pub fn set_map_auto_tagging_mpe_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags of the Launch Configuration Template.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags of the Launch Configuration Template.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>EC2 launch template ID.</p>
        pub fn ec2_launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_launch_template_id = Some(input.into());
            self
        }
        /// <p>EC2 launch template ID.</p>
        pub fn set_ec2_launch_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_launch_template_id = input; self
        }
        /// <p>Launch disposition.</p>
        pub fn launch_disposition(mut self, input: crate::model::LaunchDisposition) -> Self {
            self.launch_disposition = Some(input);
            self
        }
        /// <p>Launch disposition.</p>
        pub fn set_launch_disposition(mut self, input: std::option::Option<crate::model::LaunchDisposition>) -> Self {
            self.launch_disposition = input; self
        }
        /// <p>Target instance type right-sizing method.</p>
        pub fn target_instance_type_right_sizing_method(mut self, input: crate::model::TargetInstanceTypeRightSizingMethod) -> Self {
            self.target_instance_type_right_sizing_method = Some(input);
            self
        }
        /// <p>Target instance type right-sizing method.</p>
        pub fn set_target_instance_type_right_sizing_method(mut self, input: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>) -> Self {
            self.target_instance_type_right_sizing_method = input; self
        }
        /// <p>Copy private Ip.</p>
        pub fn copy_private_ip(mut self, input: bool) -> Self {
            self.copy_private_ip = Some(input);
            self
        }
        /// <p>Copy private Ip.</p>
        pub fn set_copy_private_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_private_ip = input; self
        }
        /// <p>Associate public Ip address.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        /// <p>Associate public Ip address.</p>
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input; self
        }
        /// <p>Copy tags.</p>
        pub fn copy_tags(mut self, input: bool) -> Self {
            self.copy_tags = Some(input);
            self
        }
        /// <p>Copy tags.</p>
        pub fn set_copy_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags = input; self
        }
        /// <p>Configure Licensing.</p>
        pub fn licensing(mut self, input: crate::model::Licensing) -> Self {
            self.licensing = Some(input);
            self
        }
        /// <p>Configure Licensing.</p>
        pub fn set_licensing(mut self, input: std::option::Option<crate::model::Licensing>) -> Self {
            self.licensing = input; self
        }
        /// <p>Launch configuration template boot mode.</p>
        pub fn boot_mode(mut self, input: crate::model::BootMode) -> Self {
            self.boot_mode = Some(input);
            self
        }
        /// <p>Launch configuration template boot mode.</p>
        pub fn set_boot_mode(mut self, input: std::option::Option<crate::model::BootMode>) -> Self {
            self.boot_mode = input; self
        }
        /// <p>Small volume maximum size.</p>
        pub fn small_volume_max_size(mut self, input: i64) -> Self {
            self.small_volume_max_size = Some(input);
            self
        }
        /// <p>Small volume maximum size.</p>
        pub fn set_small_volume_max_size(mut self, input: std::option::Option<i64>) -> Self {
            self.small_volume_max_size = input; self
        }
        /// <p>Small volume config.</p>
        pub fn small_volume_conf(mut self, input: crate::model::LaunchTemplateDiskConf) -> Self {
            self.small_volume_conf = Some(input);
            self
        }
        /// <p>Small volume config.</p>
        pub fn set_small_volume_conf(mut self, input: std::option::Option<crate::model::LaunchTemplateDiskConf>) -> Self {
            self.small_volume_conf = input; self
        }
        /// <p>Large volume config.</p>
        pub fn large_volume_conf(mut self, input: crate::model::LaunchTemplateDiskConf) -> Self {
            self.large_volume_conf = Some(input);
            self
        }
        /// <p>Large volume config.</p>
        pub fn set_large_volume_conf(mut self, input: std::option::Option<crate::model::LaunchTemplateDiskConf>) -> Self {
            self.large_volume_conf = input; self
        }
        /// Consumes the builder and constructs a [`CreateLaunchConfigurationTemplateOutput`](crate::output::CreateLaunchConfigurationTemplateOutput).
        pub fn build(self) -> crate::output::CreateLaunchConfigurationTemplateOutput {
            crate::output::CreateLaunchConfigurationTemplateOutput {
                launch_configuration_template_id: self.launch_configuration_template_id
                ,
                arn: self.arn
                ,
                post_launch_actions: self.post_launch_actions
                ,
                enable_map_auto_tagging: self.enable_map_auto_tagging
                ,
                map_auto_tagging_mpe_id: self.map_auto_tagging_mpe_id
                ,
                tags: self.tags
                ,
                ec2_launch_template_id: self.ec2_launch_template_id
                ,
                launch_disposition: self.launch_disposition
                ,
                target_instance_type_right_sizing_method: self.target_instance_type_right_sizing_method
                ,
                copy_private_ip: self.copy_private_ip
                ,
                associate_public_ip_address: self.associate_public_ip_address
                ,
                copy_tags: self.copy_tags
                ,
                licensing: self.licensing
                ,
                boot_mode: self.boot_mode
                ,
                small_volume_max_size: self.small_volume_max_size
                    .unwrap_or_default()
                ,
                small_volume_conf: self.small_volume_conf
                ,
                large_volume_conf: self.large_volume_conf
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("launch_configuration_template_id", &self.launch_configuration_template_id);
            formatter.field("arn", &self.arn);
            formatter.field("post_launch_actions", &self.post_launch_actions);
            formatter.field("enable_map_auto_tagging", &self.enable_map_auto_tagging);
            formatter.field("map_auto_tagging_mpe_id", &self.map_auto_tagging_mpe_id);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("ec2_launch_template_id", &self.ec2_launch_template_id);
            formatter.field("launch_disposition", &self.launch_disposition);
            formatter.field("target_instance_type_right_sizing_method", &self.target_instance_type_right_sizing_method);
            formatter.field("copy_private_ip", &self.copy_private_ip);
            formatter.field("associate_public_ip_address", &self.associate_public_ip_address);
            formatter.field("copy_tags", &self.copy_tags);
            formatter.field("licensing", &self.licensing);
            formatter.field("boot_mode", &self.boot_mode);
            formatter.field("small_volume_max_size", &self.small_volume_max_size);
            formatter.field("small_volume_conf", &self.small_volume_conf);
            formatter.field("large_volume_conf", &self.large_volume_conf);
            formatter.finish()
        }
    }
    
    
}
impl CreateLaunchConfigurationTemplateOutput {
    /// Creates a new builder-style object to manufacture [`CreateLaunchConfigurationTemplateOutput`](crate::output::CreateLaunchConfigurationTemplateOutput).
    pub fn builder() -> crate::output::create_launch_configuration_template_output::Builder {
        crate::output::create_launch_configuration_template_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteLaunchConfigurationTemplateOutput  {
}
/// See [`DeleteLaunchConfigurationTemplateOutput`](crate::output::DeleteLaunchConfigurationTemplateOutput).
pub mod delete_launch_configuration_template_output {
    
    /// A builder for [`DeleteLaunchConfigurationTemplateOutput`](crate::output::DeleteLaunchConfigurationTemplateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteLaunchConfigurationTemplateOutput`](crate::output::DeleteLaunchConfigurationTemplateOutput).
        pub fn build(self) -> crate::output::DeleteLaunchConfigurationTemplateOutput {
            crate::output::DeleteLaunchConfigurationTemplateOutput {
            }
        }
    }
    
    
}
impl DeleteLaunchConfigurationTemplateOutput {
    /// Creates a new builder-style object to manufacture [`DeleteLaunchConfigurationTemplateOutput`](crate::output::DeleteLaunchConfigurationTemplateOutput).
    pub fn builder() -> crate::output::delete_launch_configuration_template_output::Builder {
        crate::output::delete_launch_configuration_template_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLaunchConfigurationTemplateOutput  {
    /// <p>ID of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub launch_configuration_template_id: std::option::Option<std::string::String>,
    /// <p>ARN of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Post Launch Actions of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
    /// <p>Enable map auto tagging.</p>
    #[doc(hidden)]
    pub enable_map_auto_tagging: std::option::Option<bool>,
    /// <p>Launch configuration template map auto tagging MPE ID.</p>
    #[doc(hidden)]
    pub map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
    /// <p>Tags of the Launch Configuration Template.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>EC2 launch template ID.</p>
    #[doc(hidden)]
    pub ec2_launch_template_id: std::option::Option<std::string::String>,
    /// <p>Launch disposition.</p>
    #[doc(hidden)]
    pub launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
    /// <p>Target instance type right-sizing method.</p>
    #[doc(hidden)]
    pub target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
    /// <p>Copy private Ip.</p>
    #[doc(hidden)]
    pub copy_private_ip: std::option::Option<bool>,
    /// <p>Associate public Ip address.</p>
    #[doc(hidden)]
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>Copy tags.</p>
    #[doc(hidden)]
    pub copy_tags: std::option::Option<bool>,
    /// <p>Configure Licensing.</p>
    #[doc(hidden)]
    pub licensing: std::option::Option<crate::model::Licensing>,
    /// <p>Launch configuration template boot mode.</p>
    #[doc(hidden)]
    pub boot_mode: std::option::Option<crate::model::BootMode>,
    /// <p>Small volume maximum size.</p>
    #[doc(hidden)]
    pub small_volume_max_size: i64,
    /// <p>Small volume config.</p>
    #[doc(hidden)]
    pub small_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
    /// <p>Large volume config.</p>
    #[doc(hidden)]
    pub large_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
}
impl UpdateLaunchConfigurationTemplateOutput {
    /// <p>ID of the Launch Configuration Template.</p>
    pub fn launch_configuration_template_id(&self) -> std::option::Option<& str> {
        self.launch_configuration_template_id.as_deref()
    }
    /// <p>ARN of the Launch Configuration Template.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Post Launch Actions of the Launch Configuration Template.</p>
    pub fn post_launch_actions(&self) -> std::option::Option<& crate::model::PostLaunchActions> {
        self.post_launch_actions.as_ref()
    }
    /// <p>Enable map auto tagging.</p>
    pub fn enable_map_auto_tagging(&self) -> std::option::Option<bool> {
        self.enable_map_auto_tagging
    }
    /// <p>Launch configuration template map auto tagging MPE ID.</p>
    pub fn map_auto_tagging_mpe_id(&self) -> std::option::Option<& str> {
        self.map_auto_tagging_mpe_id.as_deref()
    }
    /// <p>Tags of the Launch Configuration Template.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>EC2 launch template ID.</p>
    pub fn ec2_launch_template_id(&self) -> std::option::Option<& str> {
        self.ec2_launch_template_id.as_deref()
    }
    /// <p>Launch disposition.</p>
    pub fn launch_disposition(&self) -> std::option::Option<& crate::model::LaunchDisposition> {
        self.launch_disposition.as_ref()
    }
    /// <p>Target instance type right-sizing method.</p>
    pub fn target_instance_type_right_sizing_method(&self) -> std::option::Option<& crate::model::TargetInstanceTypeRightSizingMethod> {
        self.target_instance_type_right_sizing_method.as_ref()
    }
    /// <p>Copy private Ip.</p>
    pub fn copy_private_ip(&self) -> std::option::Option<bool> {
        self.copy_private_ip
    }
    /// <p>Associate public Ip address.</p>
    pub fn associate_public_ip_address(&self) -> std::option::Option<bool> {
        self.associate_public_ip_address
    }
    /// <p>Copy tags.</p>
    pub fn copy_tags(&self) -> std::option::Option<bool> {
        self.copy_tags
    }
    /// <p>Configure Licensing.</p>
    pub fn licensing(&self) -> std::option::Option<& crate::model::Licensing> {
        self.licensing.as_ref()
    }
    /// <p>Launch configuration template boot mode.</p>
    pub fn boot_mode(&self) -> std::option::Option<& crate::model::BootMode> {
        self.boot_mode.as_ref()
    }
    /// <p>Small volume maximum size.</p>
    pub fn small_volume_max_size(&self) -> i64 {
        self.small_volume_max_size
    }
    /// <p>Small volume config.</p>
    pub fn small_volume_conf(&self) -> std::option::Option<& crate::model::LaunchTemplateDiskConf> {
        self.small_volume_conf.as_ref()
    }
    /// <p>Large volume config.</p>
    pub fn large_volume_conf(&self) -> std::option::Option<& crate::model::LaunchTemplateDiskConf> {
        self.large_volume_conf.as_ref()
    }
}
impl  std::fmt::Debug for UpdateLaunchConfigurationTemplateOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLaunchConfigurationTemplateOutput");
        formatter.field("launch_configuration_template_id", &self.launch_configuration_template_id);
        formatter.field("arn", &self.arn);
        formatter.field("post_launch_actions", &self.post_launch_actions);
        formatter.field("enable_map_auto_tagging", &self.enable_map_auto_tagging);
        formatter.field("map_auto_tagging_mpe_id", &self.map_auto_tagging_mpe_id);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_launch_template_id", &self.ec2_launch_template_id);
        formatter.field("launch_disposition", &self.launch_disposition);
        formatter.field("target_instance_type_right_sizing_method", &self.target_instance_type_right_sizing_method);
        formatter.field("copy_private_ip", &self.copy_private_ip);
        formatter.field("associate_public_ip_address", &self.associate_public_ip_address);
        formatter.field("copy_tags", &self.copy_tags);
        formatter.field("licensing", &self.licensing);
        formatter.field("boot_mode", &self.boot_mode);
        formatter.field("small_volume_max_size", &self.small_volume_max_size);
        formatter.field("small_volume_conf", &self.small_volume_conf);
        formatter.field("large_volume_conf", &self.large_volume_conf);
        formatter.finish()
    }
}
/// See [`UpdateLaunchConfigurationTemplateOutput`](crate::output::UpdateLaunchConfigurationTemplateOutput).
pub mod update_launch_configuration_template_output {
    
    /// A builder for [`UpdateLaunchConfigurationTemplateOutput`](crate::output::UpdateLaunchConfigurationTemplateOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) launch_configuration_template_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) post_launch_actions: std::option::Option<crate::model::PostLaunchActions>,
        pub(crate) enable_map_auto_tagging: std::option::Option<bool>,
        pub(crate) map_auto_tagging_mpe_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) ec2_launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_disposition: std::option::Option<crate::model::LaunchDisposition>,
        pub(crate) target_instance_type_right_sizing_method: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>,
        pub(crate) copy_private_ip: std::option::Option<bool>,
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) copy_tags: std::option::Option<bool>,
        pub(crate) licensing: std::option::Option<crate::model::Licensing>,
        pub(crate) boot_mode: std::option::Option<crate::model::BootMode>,
        pub(crate) small_volume_max_size: std::option::Option<i64>,
        pub(crate) small_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
        pub(crate) large_volume_conf: std::option::Option<crate::model::LaunchTemplateDiskConf>,
    }
    impl Builder {
        /// <p>ID of the Launch Configuration Template.</p>
        pub fn launch_configuration_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_template_id = Some(input.into());
            self
        }
        /// <p>ID of the Launch Configuration Template.</p>
        pub fn set_launch_configuration_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.launch_configuration_template_id = input; self
        }
        /// <p>ARN of the Launch Configuration Template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>ARN of the Launch Configuration Template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Post Launch Actions of the Launch Configuration Template.</p>
        pub fn post_launch_actions(mut self, input: crate::model::PostLaunchActions) -> Self {
            self.post_launch_actions = Some(input);
            self
        }
        /// <p>Post Launch Actions of the Launch Configuration Template.</p>
        pub fn set_post_launch_actions(mut self, input: std::option::Option<crate::model::PostLaunchActions>) -> Self {
            self.post_launch_actions = input; self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn enable_map_auto_tagging(mut self, input: bool) -> Self {
            self.enable_map_auto_tagging = Some(input);
            self
        }
        /// <p>Enable map auto tagging.</p>
        pub fn set_enable_map_auto_tagging(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_map_auto_tagging = input; self
        }
        /// <p>Launch configuration template map auto tagging MPE ID.</p>
        pub fn map_auto_tagging_mpe_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = Some(input.into());
            self
        }
        /// <p>Launch configuration template map auto tagging MPE ID.</p>
        pub fn set_map_auto_tagging_mpe_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.map_auto_tagging_mpe_id = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags of the Launch Configuration Template.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Tags of the Launch Configuration Template.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>EC2 launch template ID.</p>
        pub fn ec2_launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_launch_template_id = Some(input.into());
            self
        }
        /// <p>EC2 launch template ID.</p>
        pub fn set_ec2_launch_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_launch_template_id = input; self
        }
        /// <p>Launch disposition.</p>
        pub fn launch_disposition(mut self, input: crate::model::LaunchDisposition) -> Self {
            self.launch_disposition = Some(input);
            self
        }
        /// <p>Launch disposition.</p>
        pub fn set_launch_disposition(mut self, input: std::option::Option<crate::model::LaunchDisposition>) -> Self {
            self.launch_disposition = input; self
        }
        /// <p>Target instance type right-sizing method.</p>
        pub fn target_instance_type_right_sizing_method(mut self, input: crate::model::TargetInstanceTypeRightSizingMethod) -> Self {
            self.target_instance_type_right_sizing_method = Some(input);
            self
        }
        /// <p>Target instance type right-sizing method.</p>
        pub fn set_target_instance_type_right_sizing_method(mut self, input: std::option::Option<crate::model::TargetInstanceTypeRightSizingMethod>) -> Self {
            self.target_instance_type_right_sizing_method = input; self
        }
        /// <p>Copy private Ip.</p>
        pub fn copy_private_ip(mut self, input: bool) -> Self {
            self.copy_private_ip = Some(input);
            self
        }
        /// <p>Copy private Ip.</p>
        pub fn set_copy_private_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_private_ip = input; self
        }
        /// <p>Associate public Ip address.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        /// <p>Associate public Ip address.</p>
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input; self
        }
        /// <p>Copy tags.</p>
        pub fn copy_tags(mut self, input: bool) -> Self {
            self.copy_tags = Some(input);
            self
        }
        /// <p>Copy tags.</p>
        pub fn set_copy_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags = input; self
        }
        /// <p>Configure Licensing.</p>
        pub fn licensing(mut self, input: crate::model::Licensing) -> Self {
            self.licensing = Some(input);
            self
        }
        /// <p>Configure Licensing.</p>
        pub fn set_licensing(mut self, input: std::option::Option<crate::model::Licensing>) -> Self {
            self.licensing = input; self
        }
        /// <p>Launch configuration template boot mode.</p>
        pub fn boot_mode(mut self, input: crate::model::BootMode) -> Self {
            self.boot_mode = Some(input);
            self
        }
        /// <p>Launch configuration template boot mode.</p>
        pub fn set_boot_mode(mut self, input: std::option::Option<crate::model::BootMode>) -> Self {
            self.boot_mode = input; self
        }
        /// <p>Small volume maximum size.</p>
        pub fn small_volume_max_size(mut self, input: i64) -> Self {
            self.small_volume_max_size = Some(input);
            self
        }
        /// <p>Small volume maximum size.</p>
        pub fn set_small_volume_max_size(mut self, input: std::option::Option<i64>) -> Self {
            self.small_volume_max_size = input; self
        }
        /// <p>Small volume config.</p>
        pub fn small_volume_conf(mut self, input: crate::model::LaunchTemplateDiskConf) -> Self {
            self.small_volume_conf = Some(input);
            self
        }
        /// <p>Small volume config.</p>
        pub fn set_small_volume_conf(mut self, input: std::option::Option<crate::model::LaunchTemplateDiskConf>) -> Self {
            self.small_volume_conf = input; self
        }
        /// <p>Large volume config.</p>
        pub fn large_volume_conf(mut self, input: crate::model::LaunchTemplateDiskConf) -> Self {
            self.large_volume_conf = Some(input);
            self
        }
        /// <p>Large volume config.</p>
        pub fn set_large_volume_conf(mut self, input: std::option::Option<crate::model::LaunchTemplateDiskConf>) -> Self {
            self.large_volume_conf = input; self
        }
        /// Consumes the builder and constructs a [`UpdateLaunchConfigurationTemplateOutput`](crate::output::UpdateLaunchConfigurationTemplateOutput).
        pub fn build(self) -> crate::output::UpdateLaunchConfigurationTemplateOutput {
            crate::output::UpdateLaunchConfigurationTemplateOutput {
                launch_configuration_template_id: self.launch_configuration_template_id
                ,
                arn: self.arn
                ,
                post_launch_actions: self.post_launch_actions
                ,
                enable_map_auto_tagging: self.enable_map_auto_tagging
                ,
                map_auto_tagging_mpe_id: self.map_auto_tagging_mpe_id
                ,
                tags: self.tags
                ,
                ec2_launch_template_id: self.ec2_launch_template_id
                ,
                launch_disposition: self.launch_disposition
                ,
                target_instance_type_right_sizing_method: self.target_instance_type_right_sizing_method
                ,
                copy_private_ip: self.copy_private_ip
                ,
                associate_public_ip_address: self.associate_public_ip_address
                ,
                copy_tags: self.copy_tags
                ,
                licensing: self.licensing
                ,
                boot_mode: self.boot_mode
                ,
                small_volume_max_size: self.small_volume_max_size
                    .unwrap_or_default()
                ,
                small_volume_conf: self.small_volume_conf
                ,
                large_volume_conf: self.large_volume_conf
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("launch_configuration_template_id", &self.launch_configuration_template_id);
            formatter.field("arn", &self.arn);
            formatter.field("post_launch_actions", &self.post_launch_actions);
            formatter.field("enable_map_auto_tagging", &self.enable_map_auto_tagging);
            formatter.field("map_auto_tagging_mpe_id", &self.map_auto_tagging_mpe_id);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("ec2_launch_template_id", &self.ec2_launch_template_id);
            formatter.field("launch_disposition", &self.launch_disposition);
            formatter.field("target_instance_type_right_sizing_method", &self.target_instance_type_right_sizing_method);
            formatter.field("copy_private_ip", &self.copy_private_ip);
            formatter.field("associate_public_ip_address", &self.associate_public_ip_address);
            formatter.field("copy_tags", &self.copy_tags);
            formatter.field("licensing", &self.licensing);
            formatter.field("boot_mode", &self.boot_mode);
            formatter.field("small_volume_max_size", &self.small_volume_max_size);
            formatter.field("small_volume_conf", &self.small_volume_conf);
            formatter.field("large_volume_conf", &self.large_volume_conf);
            formatter.finish()
        }
    }
    
    
}
impl UpdateLaunchConfigurationTemplateOutput {
    /// Creates a new builder-style object to manufacture [`UpdateLaunchConfigurationTemplateOutput`](crate::output::UpdateLaunchConfigurationTemplateOutput).
    pub fn builder() -> crate::output::update_launch_configuration_template_output::Builder {
        crate::output::update_launch_configuration_template_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeJobLogItemsOutput  {
    /// <p>Request to describe Job log response items.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::JobLog>>,
    /// <p>Request to describe Job log response next token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeJobLogItemsOutput {
    /// <p>Request to describe Job log response items.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::JobLog]> {
        self.items.as_deref()
    }
    /// <p>Request to describe Job log response next token.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`DescribeJobLogItemsOutput`](crate::output::DescribeJobLogItemsOutput).
pub mod describe_job_log_items_output {
    
    /// A builder for [`DescribeJobLogItemsOutput`](crate::output::DescribeJobLogItemsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::JobLog>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Request to describe Job log response items.</p>
        pub fn items(mut self, input: crate::model::JobLog) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Request to describe Job log response items.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::JobLog>>) -> Self {
            self.items = input; self
        }
        /// <p>Request to describe Job log response next token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Request to describe Job log response next token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeJobLogItemsOutput`](crate::output::DescribeJobLogItemsOutput).
        pub fn build(self) -> crate::output::DescribeJobLogItemsOutput {
            crate::output::DescribeJobLogItemsOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl DescribeJobLogItemsOutput {
    /// Creates a new builder-style object to manufacture [`DescribeJobLogItemsOutput`](crate::output::DescribeJobLogItemsOutput).
    pub fn builder() -> crate::output::describe_job_log_items_output::Builder {
        crate::output::describe_job_log_items_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeJobsOutput  {
    /// <p>Request to describe Job log items.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::Job>>,
    /// <p>Request to describe Job response by next token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeJobsOutput {
    /// <p>Request to describe Job log items.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::Job]> {
        self.items.as_deref()
    }
    /// <p>Request to describe Job response by next token.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`DescribeJobsOutput`](crate::output::DescribeJobsOutput).
pub mod describe_jobs_output {
    
    /// A builder for [`DescribeJobsOutput`](crate::output::DescribeJobsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::Job>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Request to describe Job log items.</p>
        pub fn items(mut self, input: crate::model::Job) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Request to describe Job log items.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::Job>>) -> Self {
            self.items = input; self
        }
        /// <p>Request to describe Job response by next token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Request to describe Job response by next token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeJobsOutput`](crate::output::DescribeJobsOutput).
        pub fn build(self) -> crate::output::DescribeJobsOutput {
            crate::output::DescribeJobsOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl DescribeJobsOutput {
    /// Creates a new builder-style object to manufacture [`DescribeJobsOutput`](crate::output::DescribeJobsOutput).
    pub fn builder() -> crate::output::describe_jobs_output::Builder {
        crate::output::describe_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteJobOutput  {
}
/// See [`DeleteJobOutput`](crate::output::DeleteJobOutput).
pub mod delete_job_output {
    
    /// A builder for [`DeleteJobOutput`](crate::output::DeleteJobOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteJobOutput`](crate::output::DeleteJobOutput).
        pub fn build(self) -> crate::output::DeleteJobOutput {
            crate::output::DeleteJobOutput {
            }
        }
    }
    
    
}
impl DeleteJobOutput {
    /// Creates a new builder-style object to manufacture [`DeleteJobOutput`](crate::output::DeleteJobOutput).
    pub fn builder() -> crate::output::delete_job_output::Builder {
        crate::output::delete_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateApplicationOutput  {
    /// <p>Application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>Application ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Application name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Application description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Application archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Application aggregated status.</p>
    #[doc(hidden)]
    pub application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
    /// <p>Application creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Application last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Application tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Application wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
}
impl UpdateApplicationOutput {
    /// <p>Application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
    /// <p>Application ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Application name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Application description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Application archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Application aggregated status.</p>
    pub fn application_aggregated_status(&self) -> std::option::Option<& crate::model::ApplicationAggregatedStatus> {
        self.application_aggregated_status.as_ref()
    }
    /// <p>Application creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Application last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Application tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Application wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
}
impl  std::fmt::Debug for UpdateApplicationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateApplicationOutput");
        formatter.field("application_id", &self.application_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("application_aggregated_status", &self.application_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("wave_id", &self.wave_id);
        formatter.finish()
    }
}
/// See [`UpdateApplicationOutput`](crate::output::UpdateApplicationOutput).
pub mod update_application_output {
    
    /// A builder for [`UpdateApplicationOutput`](crate::output::UpdateApplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) wave_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// <p>Application ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Application ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Application name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Application name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Application description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Application description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Application archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Application archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Application aggregated status.</p>
        pub fn application_aggregated_status(mut self, input: crate::model::ApplicationAggregatedStatus) -> Self {
            self.application_aggregated_status = Some(input);
            self
        }
        /// <p>Application aggregated status.</p>
        pub fn set_application_aggregated_status(mut self, input: std::option::Option<crate::model::ApplicationAggregatedStatus>) -> Self {
            self.application_aggregated_status = input; self
        }
        /// <p>Application creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Application creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Application tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Application tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Application wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Application wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// Consumes the builder and constructs a [`UpdateApplicationOutput`](crate::output::UpdateApplicationOutput).
        pub fn build(self) -> crate::output::UpdateApplicationOutput {
            crate::output::UpdateApplicationOutput {
                application_id: self.application_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                application_aggregated_status: self.application_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
                wave_id: self.wave_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("application_id", &self.application_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("application_aggregated_status", &self.application_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("wave_id", &self.wave_id);
            formatter.finish()
        }
    }
    
    
}
impl UpdateApplicationOutput {
    /// Creates a new builder-style object to manufacture [`UpdateApplicationOutput`](crate::output::UpdateApplicationOutput).
    pub fn builder() -> crate::output::update_application_output::Builder {
        crate::output::update_application_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnarchiveApplicationOutput  {
    /// <p>Application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>Application ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Application name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Application description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Application archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Application aggregated status.</p>
    #[doc(hidden)]
    pub application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
    /// <p>Application creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Application last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Application tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Application wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
}
impl UnarchiveApplicationOutput {
    /// <p>Application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
    /// <p>Application ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Application name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Application description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Application archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Application aggregated status.</p>
    pub fn application_aggregated_status(&self) -> std::option::Option<& crate::model::ApplicationAggregatedStatus> {
        self.application_aggregated_status.as_ref()
    }
    /// <p>Application creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Application last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Application tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Application wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
}
impl  std::fmt::Debug for UnarchiveApplicationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnarchiveApplicationOutput");
        formatter.field("application_id", &self.application_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("application_aggregated_status", &self.application_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("wave_id", &self.wave_id);
        formatter.finish()
    }
}
/// See [`UnarchiveApplicationOutput`](crate::output::UnarchiveApplicationOutput).
pub mod unarchive_application_output {
    
    /// A builder for [`UnarchiveApplicationOutput`](crate::output::UnarchiveApplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) wave_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// <p>Application ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Application ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Application name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Application name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Application description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Application description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Application archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Application archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Application aggregated status.</p>
        pub fn application_aggregated_status(mut self, input: crate::model::ApplicationAggregatedStatus) -> Self {
            self.application_aggregated_status = Some(input);
            self
        }
        /// <p>Application aggregated status.</p>
        pub fn set_application_aggregated_status(mut self, input: std::option::Option<crate::model::ApplicationAggregatedStatus>) -> Self {
            self.application_aggregated_status = input; self
        }
        /// <p>Application creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Application creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Application tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Application tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Application wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Application wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// Consumes the builder and constructs a [`UnarchiveApplicationOutput`](crate::output::UnarchiveApplicationOutput).
        pub fn build(self) -> crate::output::UnarchiveApplicationOutput {
            crate::output::UnarchiveApplicationOutput {
                application_id: self.application_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                application_aggregated_status: self.application_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
                wave_id: self.wave_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("application_id", &self.application_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("application_aggregated_status", &self.application_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("wave_id", &self.wave_id);
            formatter.finish()
        }
    }
    
    
}
impl UnarchiveApplicationOutput {
    /// Creates a new builder-style object to manufacture [`UnarchiveApplicationOutput`](crate::output::UnarchiveApplicationOutput).
    pub fn builder() -> crate::output::unarchive_application_output::Builder {
        crate::output::unarchive_application_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateSourceServersOutput  {
}
/// See [`DisassociateSourceServersOutput`](crate::output::DisassociateSourceServersOutput).
pub mod disassociate_source_servers_output {
    
    /// A builder for [`DisassociateSourceServersOutput`](crate::output::DisassociateSourceServersOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DisassociateSourceServersOutput`](crate::output::DisassociateSourceServersOutput).
        pub fn build(self) -> crate::output::DisassociateSourceServersOutput {
            crate::output::DisassociateSourceServersOutput {
            }
        }
    }
    
    
}
impl DisassociateSourceServersOutput {
    /// Creates a new builder-style object to manufacture [`DisassociateSourceServersOutput`](crate::output::DisassociateSourceServersOutput).
    pub fn builder() -> crate::output::disassociate_source_servers_output::Builder {
        crate::output::disassociate_source_servers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateSourceServersOutput  {
}
/// See [`AssociateSourceServersOutput`](crate::output::AssociateSourceServersOutput).
pub mod associate_source_servers_output {
    
    /// A builder for [`AssociateSourceServersOutput`](crate::output::AssociateSourceServersOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`AssociateSourceServersOutput`](crate::output::AssociateSourceServersOutput).
        pub fn build(self) -> crate::output::AssociateSourceServersOutput {
            crate::output::AssociateSourceServersOutput {
            }
        }
    }
    
    
}
impl AssociateSourceServersOutput {
    /// Creates a new builder-style object to manufacture [`AssociateSourceServersOutput`](crate::output::AssociateSourceServersOutput).
    pub fn builder() -> crate::output::associate_source_servers_output::Builder {
        crate::output::associate_source_servers_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArchiveApplicationOutput  {
    /// <p>Application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>Application ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Application name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Application description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Application archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Application aggregated status.</p>
    #[doc(hidden)]
    pub application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
    /// <p>Application creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Application last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Application tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Application wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
}
impl ArchiveApplicationOutput {
    /// <p>Application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
    /// <p>Application ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Application name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Application description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Application archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Application aggregated status.</p>
    pub fn application_aggregated_status(&self) -> std::option::Option<& crate::model::ApplicationAggregatedStatus> {
        self.application_aggregated_status.as_ref()
    }
    /// <p>Application creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Application last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Application tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Application wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
}
impl  std::fmt::Debug for ArchiveApplicationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArchiveApplicationOutput");
        formatter.field("application_id", &self.application_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("application_aggregated_status", &self.application_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("wave_id", &self.wave_id);
        formatter.finish()
    }
}
/// See [`ArchiveApplicationOutput`](crate::output::ArchiveApplicationOutput).
pub mod archive_application_output {
    
    /// A builder for [`ArchiveApplicationOutput`](crate::output::ArchiveApplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) wave_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// <p>Application ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Application ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Application name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Application name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Application description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Application description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Application archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Application archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Application aggregated status.</p>
        pub fn application_aggregated_status(mut self, input: crate::model::ApplicationAggregatedStatus) -> Self {
            self.application_aggregated_status = Some(input);
            self
        }
        /// <p>Application aggregated status.</p>
        pub fn set_application_aggregated_status(mut self, input: std::option::Option<crate::model::ApplicationAggregatedStatus>) -> Self {
            self.application_aggregated_status = input; self
        }
        /// <p>Application creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Application creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Application tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Application tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Application wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Application wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// Consumes the builder and constructs a [`ArchiveApplicationOutput`](crate::output::ArchiveApplicationOutput).
        pub fn build(self) -> crate::output::ArchiveApplicationOutput {
            crate::output::ArchiveApplicationOutput {
                application_id: self.application_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                application_aggregated_status: self.application_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
                wave_id: self.wave_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("application_id", &self.application_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("application_aggregated_status", &self.application_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("wave_id", &self.wave_id);
            formatter.finish()
        }
    }
    
    
}
impl ArchiveApplicationOutput {
    /// Creates a new builder-style object to manufacture [`ArchiveApplicationOutput`](crate::output::ArchiveApplicationOutput).
    pub fn builder() -> crate::output::archive_application_output::Builder {
        crate::output::archive_application_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListApplicationsOutput  {
    /// <p>Applications list.</p>
    #[doc(hidden)]
    pub items: std::option::Option<std::vec::Vec<crate::model::Application>>,
    /// <p>Response next token.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListApplicationsOutput {
    /// <p>Applications list.</p>
    pub fn items(&self) -> std::option::Option<& [crate::model::Application]> {
        self.items.as_deref()
    }
    /// <p>Response next token.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}
/// See [`ListApplicationsOutput`](crate::output::ListApplicationsOutput).
pub mod list_applications_output {
    
    /// A builder for [`ListApplicationsOutput`](crate::output::ListApplicationsOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) items: std::option::Option<std::vec::Vec<crate::model::Application>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `items`.
        ///
        /// To override the contents of this collection use [`set_items`](Self::set_items).
        ///
        /// <p>Applications list.</p>
        pub fn items(mut self, input: crate::model::Application) -> Self {
            let mut v = self.items.unwrap_or_default();
                            v.push(input);
                            self.items = Some(v);
                            self
        }
        /// <p>Applications list.</p>
        pub fn set_items(mut self, input: std::option::Option<std::vec::Vec<crate::model::Application>>) -> Self {
            self.items = input; self
        }
        /// <p>Response next token.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Response next token.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListApplicationsOutput`](crate::output::ListApplicationsOutput).
        pub fn build(self) -> crate::output::ListApplicationsOutput {
            crate::output::ListApplicationsOutput {
                items: self.items
                ,
                next_token: self.next_token
                ,
            }
        }
    }
    
    
}
impl ListApplicationsOutput {
    /// Creates a new builder-style object to manufacture [`ListApplicationsOutput`](crate::output::ListApplicationsOutput).
    pub fn builder() -> crate::output::list_applications_output::Builder {
        crate::output::list_applications_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateApplicationOutput  {
    /// <p>Application ID.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>Application ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Application name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Application description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Application archival status.</p>
    #[doc(hidden)]
    pub is_archived: std::option::Option<bool>,
    /// <p>Application aggregated status.</p>
    #[doc(hidden)]
    pub application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
    /// <p>Application creation dateTime.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>Application last modified dateTime.</p>
    #[doc(hidden)]
    pub last_modified_date_time: std::option::Option<std::string::String>,
    /// <p>Application tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Application wave ID.</p>
    #[doc(hidden)]
    pub wave_id: std::option::Option<std::string::String>,
}
impl CreateApplicationOutput {
    /// <p>Application ID.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
    /// <p>Application ARN.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>Application name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Application description.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Application archival status.</p>
    pub fn is_archived(&self) -> std::option::Option<bool> {
        self.is_archived
    }
    /// <p>Application aggregated status.</p>
    pub fn application_aggregated_status(&self) -> std::option::Option<& crate::model::ApplicationAggregatedStatus> {
        self.application_aggregated_status.as_ref()
    }
    /// <p>Application creation dateTime.</p>
    pub fn creation_date_time(&self) -> std::option::Option<& str> {
        self.creation_date_time.as_deref()
    }
    /// <p>Application last modified dateTime.</p>
    pub fn last_modified_date_time(&self) -> std::option::Option<& str> {
        self.last_modified_date_time.as_deref()
    }
    /// <p>Application tags.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>Application wave ID.</p>
    pub fn wave_id(&self) -> std::option::Option<& str> {
        self.wave_id.as_deref()
    }
}
impl  std::fmt::Debug for CreateApplicationOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateApplicationOutput");
        formatter.field("application_id", &self.application_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("application_aggregated_status", &self.application_aggregated_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("last_modified_date_time", &self.last_modified_date_time);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("wave_id", &self.wave_id);
        formatter.finish()
    }
}
/// See [`CreateApplicationOutput`](crate::output::CreateApplicationOutput).
pub mod create_application_output {
    
    /// A builder for [`CreateApplicationOutput`](crate::output::CreateApplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) application_aggregated_status: std::option::Option<crate::model::ApplicationAggregatedStatus>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) last_modified_date_time: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) wave_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Application ID.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>Application ID.</p>
        pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.application_id = input; self
        }
        /// <p>Application ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>Application ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// <p>Application name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Application name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Application description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Application description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Application archival status.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Application archival status.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input; self
        }
        /// <p>Application aggregated status.</p>
        pub fn application_aggregated_status(mut self, input: crate::model::ApplicationAggregatedStatus) -> Self {
            self.application_aggregated_status = Some(input);
            self
        }
        /// <p>Application aggregated status.</p>
        pub fn set_application_aggregated_status(mut self, input: std::option::Option<crate::model::ApplicationAggregatedStatus>) -> Self {
            self.application_aggregated_status = input; self
        }
        /// <p>Application creation dateTime.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>Application creation dateTime.</p>
        pub fn set_creation_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.creation_date_time = input; self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn last_modified_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date_time = Some(input.into());
            self
        }
        /// <p>Application last modified dateTime.</p>
        pub fn set_last_modified_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_modified_date_time = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Application tags.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>Application tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// <p>Application wave ID.</p>
        pub fn wave_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.wave_id = Some(input.into());
            self
        }
        /// <p>Application wave ID.</p>
        pub fn set_wave_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wave_id = input; self
        }
        /// Consumes the builder and constructs a [`CreateApplicationOutput`](crate::output::CreateApplicationOutput).
        pub fn build(self) -> crate::output::CreateApplicationOutput {
            crate::output::CreateApplicationOutput {
                application_id: self.application_id
                ,
                arn: self.arn
                ,
                name: self.name
                ,
                description: self.description
                ,
                is_archived: self.is_archived
                ,
                application_aggregated_status: self.application_aggregated_status
                ,
                creation_date_time: self.creation_date_time
                ,
                last_modified_date_time: self.last_modified_date_time
                ,
                tags: self.tags
                ,
                wave_id: self.wave_id
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("application_id", &self.application_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &self.name);
            formatter.field("description", &self.description);
            formatter.field("is_archived", &self.is_archived);
            formatter.field("application_aggregated_status", &self.application_aggregated_status);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("last_modified_date_time", &self.last_modified_date_time);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("wave_id", &self.wave_id);
            formatter.finish()
        }
    }
    
    
}
impl CreateApplicationOutput {
    /// Creates a new builder-style object to manufacture [`CreateApplicationOutput`](crate::output::CreateApplicationOutput).
    pub fn builder() -> crate::output::create_application_output::Builder {
        crate::output::create_application_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteApplicationOutput  {
}
/// See [`DeleteApplicationOutput`](crate::output::DeleteApplicationOutput).
pub mod delete_application_output {
    
    /// A builder for [`DeleteApplicationOutput`](crate::output::DeleteApplicationOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteApplicationOutput`](crate::output::DeleteApplicationOutput).
        pub fn build(self) -> crate::output::DeleteApplicationOutput {
            crate::output::DeleteApplicationOutput {
            }
        }
    }
    
    
}
impl DeleteApplicationOutput {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationOutput`](crate::output::DeleteApplicationOutput).
    pub fn builder() -> crate::output::delete_application_output::Builder {
        crate::output::delete_application_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceOutput  {
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput).
pub mod untag_resource_output {
    
    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput).
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {
            }
        }
    }
    
    
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceOutput  {
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput).
pub mod tag_resource_output {
    
    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput).
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {
            }
        }
    }
    
    
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput).
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput  {
    /// <p>List tags for resource response.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ListTagsForResourceOutput {
    /// <p>List tags for resource response.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
}
impl  std::fmt::Debug for ListTagsForResourceOutput  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
pub mod list_tags_for_resource_output {
    
    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>List tags for resource response.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>List tags for resource response.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InitializeServiceOutput  {
}
/// See [`InitializeServiceOutput`](crate::output::InitializeServiceOutput).
pub mod initialize_service_output {
    
    /// A builder for [`InitializeServiceOutput`](crate::output::InitializeServiceOutput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
    }
    impl Builder {
        /// Consumes the builder and constructs a [`InitializeServiceOutput`](crate::output::InitializeServiceOutput).
        pub fn build(self) -> crate::output::InitializeServiceOutput {
            crate::output::InitializeServiceOutput {
            }
        }
    }
    
    
}
impl InitializeServiceOutput {
    /// Creates a new builder-style object to manufacture [`InitializeServiceOutput`](crate::output::InitializeServiceOutput).
    pub fn builder() -> crate::output::initialize_service_output::Builder {
        crate::output::initialize_service_output::Builder::default()
    }
}

