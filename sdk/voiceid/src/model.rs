// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains a summary of information about a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainSummary {
    /// <p>The service-generated identifier for the domain.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the domain.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The client-provided name for the domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The client-provided description of the domain.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The current status of the domain.</p>
    #[doc(hidden)]
    pub domain_status: std::option::Option<crate::model::DomainStatus>,
    /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
    #[doc(hidden)]
    pub server_side_encryption_configuration:
        std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
    /// <p>The timestamp showing when the domain is created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp showing the domain's last update.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
    #[doc(hidden)]
    pub server_side_encryption_update_details:
        std::option::Option<crate::model::ServerSideEncryptionUpdateDetails>,
}
impl DomainSummary {
    /// <p>The service-generated identifier for the domain.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the domain.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The client-provided name for the domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The client-provided description of the domain.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The current status of the domain.</p>
    pub fn domain_status(&self) -> std::option::Option<&crate::model::DomainStatus> {
        self.domain_status.as_ref()
    }
    /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
    pub fn server_side_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ServerSideEncryptionConfiguration> {
        self.server_side_encryption_configuration.as_ref()
    }
    /// <p>The timestamp showing when the domain is created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The timestamp showing the domain's last update.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
    pub fn server_side_encryption_update_details(
        &self,
    ) -> std::option::Option<&crate::model::ServerSideEncryptionUpdateDetails> {
        self.server_side_encryption_update_details.as_ref()
    }
}
impl std::fmt::Debug for DomainSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainSummary");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("domain_status", &self.domain_status);
        formatter.field(
            "server_side_encryption_configuration",
            &self.server_side_encryption_configuration,
        );
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field(
            "server_side_encryption_update_details",
            &self.server_side_encryption_update_details,
        );
        formatter.finish()
    }
}
impl DomainSummary {
    /// Creates a new builder-style object to manufacture [`DomainSummary`](crate::model::DomainSummary).
    pub fn builder() -> crate::model::domain_summary::Builder {
        crate::model::domain_summary::Builder::default()
    }
}

/// See [`DomainSummary`](crate::model::DomainSummary).
pub mod domain_summary {

    /// A builder for [`DomainSummary`](crate::model::DomainSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) domain_status: std::option::Option<crate::model::DomainStatus>,
        pub(crate) server_side_encryption_configuration:
            std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) server_side_encryption_update_details:
            std::option::Option<crate::model::ServerSideEncryptionUpdateDetails>,
    }
    impl Builder {
        /// <p>The service-generated identifier for the domain.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the domain.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the domain.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the domain.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The client-provided name for the domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The client-provided name for the domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The client-provided description of the domain.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The client-provided description of the domain.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The current status of the domain.</p>
        pub fn domain_status(mut self, input: crate::model::DomainStatus) -> Self {
            self.domain_status = Some(input);
            self
        }
        /// <p>The current status of the domain.</p>
        pub fn set_domain_status(
            mut self,
            input: std::option::Option<crate::model::DomainStatus>,
        ) -> Self {
            self.domain_status = input;
            self
        }
        /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            input: crate::model::ServerSideEncryptionConfiguration,
        ) -> Self {
            self.server_side_encryption_configuration = Some(input);
            self
        }
        /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
        pub fn set_server_side_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        ) -> Self {
            self.server_side_encryption_configuration = input;
            self
        }
        /// <p>The timestamp showing when the domain is created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp showing when the domain is created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The timestamp showing the domain's last update.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The timestamp showing the domain's last update.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
        pub fn server_side_encryption_update_details(
            mut self,
            input: crate::model::ServerSideEncryptionUpdateDetails,
        ) -> Self {
            self.server_side_encryption_update_details = Some(input);
            self
        }
        /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
        pub fn set_server_side_encryption_update_details(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionUpdateDetails>,
        ) -> Self {
            self.server_side_encryption_update_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainSummary`](crate::model::DomainSummary).
        pub fn build(self) -> crate::model::DomainSummary {
            crate::model::DomainSummary {
                domain_id: self.domain_id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                domain_status: self.domain_status,
                server_side_encryption_configuration: self.server_side_encryption_configuration,
                created_at: self.created_at,
                updated_at: self.updated_at,
                server_side_encryption_update_details: self.server_side_encryption_update_details,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("domain_id", &self.domain_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("domain_status", &self.domain_status);
            formatter.field(
                "server_side_encryption_configuration",
                &self.server_side_encryption_configuration,
            );
            formatter.field("created_at", &self.created_at);
            formatter.field("updated_at", &self.updated_at);
            formatter.field(
                "server_side_encryption_update_details",
                &self.server_side_encryption_update_details,
            );
            formatter.finish()
        }
    }
}

/// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain’s data can only be accessed using the new KMS key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerSideEncryptionUpdateDetails {
    /// <p>The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.</p>
    #[doc(hidden)]
    pub old_kms_key_id: std::option::Option<std::string::String>,
    /// <p>Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.</p>
    #[doc(hidden)]
    pub update_status: std::option::Option<crate::model::ServerSideEncryptionUpdateStatus>,
    /// <p>Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServerSideEncryptionUpdateDetails {
    /// <p>The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.</p>
    pub fn old_kms_key_id(&self) -> std::option::Option<&str> {
        self.old_kms_key_id.as_deref()
    }
    /// <p>Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.</p>
    pub fn update_status(
        &self,
    ) -> std::option::Option<&crate::model::ServerSideEncryptionUpdateStatus> {
        self.update_status.as_ref()
    }
    /// <p>Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl ServerSideEncryptionUpdateDetails {
    /// Creates a new builder-style object to manufacture [`ServerSideEncryptionUpdateDetails`](crate::model::ServerSideEncryptionUpdateDetails).
    pub fn builder() -> crate::model::server_side_encryption_update_details::Builder {
        crate::model::server_side_encryption_update_details::Builder::default()
    }
}

/// See [`ServerSideEncryptionUpdateDetails`](crate::model::ServerSideEncryptionUpdateDetails).
pub mod server_side_encryption_update_details {

    /// A builder for [`ServerSideEncryptionUpdateDetails`](crate::model::ServerSideEncryptionUpdateDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) old_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) update_status:
            std::option::Option<crate::model::ServerSideEncryptionUpdateStatus>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.</p>
        pub fn old_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.old_kms_key_id = Some(input.into());
            self
        }
        /// <p>The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.</p>
        pub fn set_old_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.old_kms_key_id = input;
            self
        }
        /// <p>Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.</p>
        pub fn update_status(
            mut self,
            input: crate::model::ServerSideEncryptionUpdateStatus,
        ) -> Self {
            self.update_status = Some(input);
            self
        }
        /// <p>Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.</p>
        pub fn set_update_status(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionUpdateStatus>,
        ) -> Self {
            self.update_status = input;
            self
        }
        /// <p>Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerSideEncryptionUpdateDetails`](crate::model::ServerSideEncryptionUpdateDetails).
        pub fn build(self) -> crate::model::ServerSideEncryptionUpdateDetails {
            crate::model::ServerSideEncryptionUpdateDetails {
                old_kms_key_id: self.old_kms_key_id,
                update_status: self.update_status,
                message: self.message,
            }
        }
    }
}

/// When writing a match expression against `ServerSideEncryptionUpdateStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let serversideencryptionupdatestatus = unimplemented!();
/// match serversideencryptionupdatestatus {
///     ServerSideEncryptionUpdateStatus::Completed => { /* ... */ },
///     ServerSideEncryptionUpdateStatus::Failed => { /* ... */ },
///     ServerSideEncryptionUpdateStatus::InProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `serversideencryptionupdatestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServerSideEncryptionUpdateStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServerSideEncryptionUpdateStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServerSideEncryptionUpdateStatus::NewFeature` is defined.
/// Specifically, when `serversideencryptionupdatestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServerSideEncryptionUpdateStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServerSideEncryptionUpdateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServerSideEncryptionUpdateStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => ServerSideEncryptionUpdateStatus::Completed,
            "FAILED" => ServerSideEncryptionUpdateStatus::Failed,
            "IN_PROGRESS" => ServerSideEncryptionUpdateStatus::InProgress,
            other => ServerSideEncryptionUpdateStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ServerSideEncryptionUpdateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServerSideEncryptionUpdateStatus::from(s))
    }
}
impl ServerSideEncryptionUpdateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServerSideEncryptionUpdateStatus::Completed => "COMPLETED",
            ServerSideEncryptionUpdateStatus::Failed => "FAILED",
            ServerSideEncryptionUpdateStatus::InProgress => "IN_PROGRESS",
            ServerSideEncryptionUpdateStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "IN_PROGRESS"]
    }
}
impl AsRef<str> for ServerSideEncryptionUpdateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration containing information about the customer managed key used for encrypting customer data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerSideEncryptionConfiguration {
    /// <p>The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys. </p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl ServerSideEncryptionConfiguration {
    /// <p>The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys. </p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl ServerSideEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
    pub fn builder() -> crate::model::server_side_encryption_configuration::Builder {
        crate::model::server_side_encryption_configuration::Builder::default()
    }
}

/// See [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
pub mod server_side_encryption_configuration {

    /// A builder for [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys. </p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys. </p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerSideEncryptionConfiguration`](crate::model::ServerSideEncryptionConfiguration).
        pub fn build(self) -> crate::model::ServerSideEncryptionConfiguration {
            crate::model::ServerSideEncryptionConfiguration {
                kms_key_id: self.kms_key_id,
            }
        }
    }
}

/// When writing a match expression against `DomainStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let domainstatus = unimplemented!();
/// match domainstatus {
///     DomainStatus::Active => { /* ... */ },
///     DomainStatus::Pending => { /* ... */ },
///     DomainStatus::Suspended => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `domainstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DomainStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DomainStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DomainStatus::NewFeature` is defined.
/// Specifically, when `domainstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DomainStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Suspended,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DomainStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DomainStatus::Active,
            "PENDING" => DomainStatus::Pending,
            "SUSPENDED" => DomainStatus::Suspended,
            other => DomainStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DomainStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainStatus::from(s))
    }
}
impl DomainStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DomainStatus::Active => "ACTIVE",
            DomainStatus::Pending => "PENDING",
            DomainStatus::Suspended => "SUSPENDED",
            DomainStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "PENDING", "SUSPENDED"]
    }
}
impl AsRef<str> for DomainStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::BatchJob => { /* ... */ },
///     ResourceType::ComplianceConsent => { /* ... */ },
///     ResourceType::Domain => { /* ... */ },
///     ResourceType::Fraudster => { /* ... */ },
///     ResourceType::Session => { /* ... */ },
///     ResourceType::Speaker => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    BatchJob,
    #[allow(missing_docs)] // documentation missing in model
    ComplianceConsent,
    #[allow(missing_docs)] // documentation missing in model
    Domain,
    #[allow(missing_docs)] // documentation missing in model
    Fraudster,
    #[allow(missing_docs)] // documentation missing in model
    Session,
    #[allow(missing_docs)] // documentation missing in model
    Speaker,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "BATCH_JOB" => ResourceType::BatchJob,
            "COMPLIANCE_CONSENT" => ResourceType::ComplianceConsent,
            "DOMAIN" => ResourceType::Domain,
            "FRAUDSTER" => ResourceType::Fraudster,
            "SESSION" => ResourceType::Session,
            "SPEAKER" => ResourceType::Speaker,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::BatchJob => "BATCH_JOB",
            ResourceType::ComplianceConsent => "COMPLIANCE_CONSENT",
            ResourceType::Domain => "DOMAIN",
            ResourceType::Fraudster => "FRAUDSTER",
            ResourceType::Session => "SESSION",
            ResourceType::Speaker => "SPEAKER",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BATCH_JOB",
            "COMPLIANCE_CONSENT",
            "DOMAIN",
            "FRAUDSTER",
            "SESSION",
            "SPEAKER",
        ]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConflictType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let conflicttype = unimplemented!();
/// match conflicttype {
///     ConflictType::AnotherActiveStream => { /* ... */ },
///     ConflictType::CannotChangeSpeakerAfterEnrollment => { /* ... */ },
///     ConflictType::ConcurrentChanges => { /* ... */ },
///     ConflictType::DomainLockedFromEncryptionUpdates => { /* ... */ },
///     ConflictType::DomainNotActive => { /* ... */ },
///     ConflictType::EnrollmentAlreadyExists => { /* ... */ },
///     ConflictType::SpeakerNotSet => { /* ... */ },
///     ConflictType::SpeakerOptedOut => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `conflicttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConflictType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConflictType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConflictType::NewFeature` is defined.
/// Specifically, when `conflicttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConflictType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConflictType {
    #[allow(missing_docs)] // documentation missing in model
    AnotherActiveStream,
    #[allow(missing_docs)] // documentation missing in model
    CannotChangeSpeakerAfterEnrollment,
    #[allow(missing_docs)] // documentation missing in model
    ConcurrentChanges,
    #[allow(missing_docs)] // documentation missing in model
    DomainLockedFromEncryptionUpdates,
    #[allow(missing_docs)] // documentation missing in model
    DomainNotActive,
    #[allow(missing_docs)] // documentation missing in model
    EnrollmentAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    SpeakerNotSet,
    #[allow(missing_docs)] // documentation missing in model
    SpeakerOptedOut,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConflictType {
    fn from(s: &str) -> Self {
        match s {
            "ANOTHER_ACTIVE_STREAM" => ConflictType::AnotherActiveStream,
            "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT" => {
                ConflictType::CannotChangeSpeakerAfterEnrollment
            }
            "CONCURRENT_CHANGES" => ConflictType::ConcurrentChanges,
            "DOMAIN_LOCKED_FROM_ENCRYPTION_UPDATES" => {
                ConflictType::DomainLockedFromEncryptionUpdates
            }
            "DOMAIN_NOT_ACTIVE" => ConflictType::DomainNotActive,
            "ENROLLMENT_ALREADY_EXISTS" => ConflictType::EnrollmentAlreadyExists,
            "SPEAKER_NOT_SET" => ConflictType::SpeakerNotSet,
            "SPEAKER_OPTED_OUT" => ConflictType::SpeakerOptedOut,
            other => ConflictType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ConflictType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConflictType::from(s))
    }
}
impl ConflictType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConflictType::AnotherActiveStream => "ANOTHER_ACTIVE_STREAM",
            ConflictType::CannotChangeSpeakerAfterEnrollment => {
                "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT"
            }
            ConflictType::ConcurrentChanges => "CONCURRENT_CHANGES",
            ConflictType::DomainLockedFromEncryptionUpdates => {
                "DOMAIN_LOCKED_FROM_ENCRYPTION_UPDATES"
            }
            ConflictType::DomainNotActive => "DOMAIN_NOT_ACTIVE",
            ConflictType::EnrollmentAlreadyExists => "ENROLLMENT_ALREADY_EXISTS",
            ConflictType::SpeakerNotSet => "SPEAKER_NOT_SET",
            ConflictType::SpeakerOptedOut => "SPEAKER_OPTED_OUT",
            ConflictType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ANOTHER_ACTIVE_STREAM",
            "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT",
            "CONCURRENT_CHANGES",
            "DOMAIN_LOCKED_FROM_ENCRYPTION_UPDATES",
            "DOMAIN_NOT_ACTIVE",
            "ENROLLMENT_ALREADY_EXISTS",
            "SPEAKER_NOT_SET",
            "SPEAKER_OPTED_OUT",
        ]
    }
}
impl AsRef<str> for ConflictType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains all the information about a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Domain {
    /// <p>The service-generated identifier for the domain.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the domain.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The client-provided name for the domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The client-provided description of the domain.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The current status of the domain.</p>
    #[doc(hidden)]
    pub domain_status: std::option::Option<crate::model::DomainStatus>,
    /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
    #[doc(hidden)]
    pub server_side_encryption_configuration:
        std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
    /// <p>The timestamp at which the domain is created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp showing the domain's last update.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
    #[doc(hidden)]
    pub server_side_encryption_update_details:
        std::option::Option<crate::model::ServerSideEncryptionUpdateDetails>,
}
impl Domain {
    /// <p>The service-generated identifier for the domain.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) for the domain.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The client-provided name for the domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The client-provided description of the domain.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The current status of the domain.</p>
    pub fn domain_status(&self) -> std::option::Option<&crate::model::DomainStatus> {
        self.domain_status.as_ref()
    }
    /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
    pub fn server_side_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ServerSideEncryptionConfiguration> {
        self.server_side_encryption_configuration.as_ref()
    }
    /// <p>The timestamp at which the domain is created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The timestamp showing the domain's last update.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
    pub fn server_side_encryption_update_details(
        &self,
    ) -> std::option::Option<&crate::model::ServerSideEncryptionUpdateDetails> {
        self.server_side_encryption_update_details.as_ref()
    }
}
impl std::fmt::Debug for Domain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Domain");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("domain_status", &self.domain_status);
        formatter.field(
            "server_side_encryption_configuration",
            &self.server_side_encryption_configuration,
        );
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field(
            "server_side_encryption_update_details",
            &self.server_side_encryption_update_details,
        );
        formatter.finish()
    }
}
impl Domain {
    /// Creates a new builder-style object to manufacture [`Domain`](crate::model::Domain).
    pub fn builder() -> crate::model::domain::Builder {
        crate::model::domain::Builder::default()
    }
}

/// See [`Domain`](crate::model::Domain).
pub mod domain {

    /// A builder for [`Domain`](crate::model::Domain).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) domain_status: std::option::Option<crate::model::DomainStatus>,
        pub(crate) server_side_encryption_configuration:
            std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) server_side_encryption_update_details:
            std::option::Option<crate::model::ServerSideEncryptionUpdateDetails>,
    }
    impl Builder {
        /// <p>The service-generated identifier for the domain.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the domain.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the domain.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the domain.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The client-provided name for the domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The client-provided name for the domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The client-provided description of the domain.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The client-provided description of the domain.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The current status of the domain.</p>
        pub fn domain_status(mut self, input: crate::model::DomainStatus) -> Self {
            self.domain_status = Some(input);
            self
        }
        /// <p>The current status of the domain.</p>
        pub fn set_domain_status(
            mut self,
            input: std::option::Option<crate::model::DomainStatus>,
        ) -> Self {
            self.domain_status = input;
            self
        }
        /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
        pub fn server_side_encryption_configuration(
            mut self,
            input: crate::model::ServerSideEncryptionConfiguration,
        ) -> Self {
            self.server_side_encryption_configuration = Some(input);
            self
        }
        /// <p>The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.</p>
        pub fn set_server_side_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionConfiguration>,
        ) -> Self {
            self.server_side_encryption_configuration = input;
            self
        }
        /// <p>The timestamp at which the domain is created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp at which the domain is created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The timestamp showing the domain's last update.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The timestamp showing the domain's last update.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
        pub fn server_side_encryption_update_details(
            mut self,
            input: crate::model::ServerSideEncryptionUpdateDetails,
        ) -> Self {
            self.server_side_encryption_update_details = Some(input);
            self
        }
        /// <p>Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.</p>
        pub fn set_server_side_encryption_update_details(
            mut self,
            input: std::option::Option<crate::model::ServerSideEncryptionUpdateDetails>,
        ) -> Self {
            self.server_side_encryption_update_details = input;
            self
        }
        /// Consumes the builder and constructs a [`Domain`](crate::model::Domain).
        pub fn build(self) -> crate::model::Domain {
            crate::model::Domain {
                domain_id: self.domain_id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                domain_status: self.domain_status,
                server_side_encryption_configuration: self.server_side_encryption_configuration,
                created_at: self.created_at,
                updated_at: self.updated_at,
                server_side_encryption_update_details: self.server_side_encryption_update_details,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("domain_id", &self.domain_id);
            formatter.field("arn", &self.arn);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("domain_status", &self.domain_status);
            formatter.field(
                "server_side_encryption_configuration",
                &self.server_side_encryption_configuration,
            );
            formatter.field("created_at", &self.created_at);
            formatter.field("updated_at", &self.updated_at);
            formatter.field(
                "server_side_encryption_update_details",
                &self.server_side_encryption_update_details,
            );
            formatter.finish()
        }
    }
}

/// <p>The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'. </p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'. </p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &"*** Sensitive Data Redacted ***");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'. </p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'. </p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("key", &"*** Sensitive Data Redacted ***");
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>Contains all the information about a speaker enrollment job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpeakerEnrollmentJob {
    /// <p>The client-provided name for the speaker enrollment job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the speaker enrollment job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The current status of the speaker enrollment job.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::SpeakerEnrollmentJobStatus>,
    /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the <code>FraudDetectionConfig</code> to use.</p>
    #[doc(hidden)]
    pub enrollment_config: std::option::Option<crate::model::EnrollmentConfig>,
    /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>A timestamp showing the creation of the speaker enrollment job.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp showing when the speaker enrollment job ended. </p>
    #[doc(hidden)]
    pub ended_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    #[doc(hidden)]
    pub failure_details: std::option::Option<crate::model::FailureDetails>,
    /// <p>Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.</p>
    #[doc(hidden)]
    pub job_progress: std::option::Option<crate::model::JobProgress>,
}
impl SpeakerEnrollmentJob {
    /// <p>The client-provided name for the speaker enrollment job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The service-generated identifier for the speaker enrollment job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The current status of the speaker enrollment job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::SpeakerEnrollmentJobStatus> {
        self.job_status.as_ref()
    }
    /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the <code>FraudDetectionConfig</code> to use.</p>
    pub fn enrollment_config(&self) -> std::option::Option<&crate::model::EnrollmentConfig> {
        self.enrollment_config.as_ref()
    }
    /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>A timestamp showing the creation of the speaker enrollment job.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A timestamp showing when the speaker enrollment job ended. </p>
    pub fn ended_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ended_at.as_ref()
    }
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    pub fn failure_details(&self) -> std::option::Option<&crate::model::FailureDetails> {
        self.failure_details.as_ref()
    }
    /// <p>Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.</p>
    pub fn job_progress(&self) -> std::option::Option<&crate::model::JobProgress> {
        self.job_progress.as_ref()
    }
}
impl std::fmt::Debug for SpeakerEnrollmentJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpeakerEnrollmentJob");
        formatter.field("job_name", &"*** Sensitive Data Redacted ***");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.field("enrollment_config", &self.enrollment_config);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("created_at", &self.created_at);
        formatter.field("ended_at", &self.ended_at);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("job_progress", &self.job_progress);
        formatter.finish()
    }
}
impl SpeakerEnrollmentJob {
    /// Creates a new builder-style object to manufacture [`SpeakerEnrollmentJob`](crate::model::SpeakerEnrollmentJob).
    pub fn builder() -> crate::model::speaker_enrollment_job::Builder {
        crate::model::speaker_enrollment_job::Builder::default()
    }
}

/// See [`SpeakerEnrollmentJob`](crate::model::SpeakerEnrollmentJob).
pub mod speaker_enrollment_job {

    /// A builder for [`SpeakerEnrollmentJob`](crate::model::SpeakerEnrollmentJob).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::SpeakerEnrollmentJobStatus>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) enrollment_config: std::option::Option<crate::model::EnrollmentConfig>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ended_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_details: std::option::Option<crate::model::FailureDetails>,
        pub(crate) job_progress: std::option::Option<crate::model::JobProgress>,
    }
    impl Builder {
        /// <p>The client-provided name for the speaker enrollment job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The client-provided name for the speaker enrollment job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The service-generated identifier for the speaker enrollment job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the speaker enrollment job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The current status of the speaker enrollment job.</p>
        pub fn job_status(mut self, input: crate::model::SpeakerEnrollmentJobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the speaker enrollment job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::SpeakerEnrollmentJobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the <code>FraudDetectionConfig</code> to use.</p>
        pub fn enrollment_config(mut self, input: crate::model::EnrollmentConfig) -> Self {
            self.enrollment_config = Some(input);
            self
        }
        /// <p>The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the <code>FraudDetectionConfig</code> to use.</p>
        pub fn set_enrollment_config(
            mut self,
            input: std::option::Option<crate::model::EnrollmentConfig>,
        ) -> Self {
            self.enrollment_config = input;
            self
        }
        /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>A timestamp showing the creation of the speaker enrollment job.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>A timestamp showing the creation of the speaker enrollment job.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A timestamp showing when the speaker enrollment job ended. </p>
        pub fn ended_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ended_at = Some(input);
            self
        }
        /// <p>A timestamp showing when the speaker enrollment job ended. </p>
        pub fn set_ended_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ended_at = input;
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.</p>
        pub fn job_progress(mut self, input: crate::model::JobProgress) -> Self {
            self.job_progress = Some(input);
            self
        }
        /// <p>Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.</p>
        pub fn set_job_progress(
            mut self,
            input: std::option::Option<crate::model::JobProgress>,
        ) -> Self {
            self.job_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`SpeakerEnrollmentJob`](crate::model::SpeakerEnrollmentJob).
        pub fn build(self) -> crate::model::SpeakerEnrollmentJob {
            crate::model::SpeakerEnrollmentJob {
                job_name: self.job_name,
                job_id: self.job_id,
                job_status: self.job_status,
                domain_id: self.domain_id,
                data_access_role_arn: self.data_access_role_arn,
                enrollment_config: self.enrollment_config,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                created_at: self.created_at,
                ended_at: self.ended_at,
                failure_details: self.failure_details,
                job_progress: self.job_progress,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("job_name", &"*** Sensitive Data Redacted ***");
            formatter.field("job_id", &self.job_id);
            formatter.field("job_status", &self.job_status);
            formatter.field("domain_id", &self.domain_id);
            formatter.field("data_access_role_arn", &self.data_access_role_arn);
            formatter.field("enrollment_config", &self.enrollment_config);
            formatter.field("input_data_config", &self.input_data_config);
            formatter.field("output_data_config", &self.output_data_config);
            formatter.field("created_at", &self.created_at);
            formatter.field("ended_at", &self.ended_at);
            formatter.field("failure_details", &self.failure_details);
            formatter.field("job_progress", &self.job_progress);
            formatter.finish()
        }
    }
}

/// <p>Indicates the completion progress for a batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobProgress {
    /// <p>Shows the completed percentage of enrollment or registration requests listed in the input file.</p>
    #[doc(hidden)]
    pub percent_complete: std::option::Option<i32>,
}
impl JobProgress {
    /// <p>Shows the completed percentage of enrollment or registration requests listed in the input file.</p>
    pub fn percent_complete(&self) -> std::option::Option<i32> {
        self.percent_complete
    }
}
impl JobProgress {
    /// Creates a new builder-style object to manufacture [`JobProgress`](crate::model::JobProgress).
    pub fn builder() -> crate::model::job_progress::Builder {
        crate::model::job_progress::Builder::default()
    }
}

/// See [`JobProgress`](crate::model::JobProgress).
pub mod job_progress {

    /// A builder for [`JobProgress`](crate::model::JobProgress).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percent_complete: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Shows the completed percentage of enrollment or registration requests listed in the input file.</p>
        pub fn percent_complete(mut self, input: i32) -> Self {
            self.percent_complete = Some(input);
            self
        }
        /// <p>Shows the completed percentage of enrollment or registration requests listed in the input file.</p>
        pub fn set_percent_complete(mut self, input: std::option::Option<i32>) -> Self {
            self.percent_complete = input;
            self
        }
        /// Consumes the builder and constructs a [`JobProgress`](crate::model::JobProgress).
        pub fn build(self) -> crate::model::JobProgress {
            crate::model::JobProgress {
                percent_complete: self.percent_complete,
            }
        }
    }
}

/// <p>Contains error details for a failed batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailureDetails {
    /// <p>An HTTP status code representing the nature of the error.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<i32>,
    /// <p>A description of the error that caused the batch job failure.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl FailureDetails {
    /// <p>An HTTP status code representing the nature of the error.</p>
    pub fn status_code(&self) -> std::option::Option<i32> {
        self.status_code
    }
    /// <p>A description of the error that caused the batch job failure.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl FailureDetails {
    /// Creates a new builder-style object to manufacture [`FailureDetails`](crate::model::FailureDetails).
    pub fn builder() -> crate::model::failure_details::Builder {
        crate::model::failure_details::Builder::default()
    }
}

/// See [`FailureDetails`](crate::model::FailureDetails).
pub mod failure_details {

    /// A builder for [`FailureDetails`](crate::model::FailureDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status_code: std::option::Option<i32>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An HTTP status code representing the nature of the error.</p>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>An HTTP status code representing the nature of the error.</p>
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// <p>A description of the error that caused the batch job failure.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error that caused the batch job failure.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailureDetails`](crate::model::FailureDetails).
        pub fn build(self) -> crate::model::FailureDetails {
            crate::model::FailureDetails {
                status_code: self.status_code,
                message: self.message,
            }
        }
    }
}

/// <p>The configuration containing output file information for a batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OutputDataConfig {
    /// <p>The S3 path of the folder where Voice ID writes the job output file. It has a <code>*.out</code> extension. For example, if the input file name is <code>input-file.json</code> and the output folder path is <code>s3://output-bucket/output-folder</code>, the full output file path is <code>s3://output-bucket/output-folder/job-Id/input-file.json.out</code>.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
    /// <p>The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job. </p>
    #[doc(hidden)]
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl OutputDataConfig {
    /// <p>The S3 path of the folder where Voice ID writes the job output file. It has a <code>*.out</code> extension. For example, if the input file name is <code>input-file.json</code> and the output folder path is <code>s3://output-bucket/output-folder</code>, the full output file path is <code>s3://output-bucket/output-folder/job-Id/input-file.json.out</code>.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
    /// <p>The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job. </p>
    pub fn kms_key_id(&self) -> std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
}
impl OutputDataConfig {
    /// Creates a new builder-style object to manufacture [`OutputDataConfig`](crate::model::OutputDataConfig).
    pub fn builder() -> crate::model::output_data_config::Builder {
        crate::model::output_data_config::Builder::default()
    }
}

/// See [`OutputDataConfig`](crate::model::OutputDataConfig).
pub mod output_data_config {

    /// A builder for [`OutputDataConfig`](crate::model::OutputDataConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 path of the folder where Voice ID writes the job output file. It has a <code>*.out</code> extension. For example, if the input file name is <code>input-file.json</code> and the output folder path is <code>s3://output-bucket/output-folder</code>, the full output file path is <code>s3://output-bucket/output-folder/job-Id/input-file.json.out</code>.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 path of the folder where Voice ID writes the job output file. It has a <code>*.out</code> extension. For example, if the input file name is <code>input-file.json</code> and the output folder path is <code>s3://output-bucket/output-folder</code>, the full output file path is <code>s3://output-bucket/output-folder/job-Id/input-file.json.out</code>.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// <p>The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job. </p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job. </p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputDataConfig`](crate::model::OutputDataConfig).
        pub fn build(self) -> crate::model::OutputDataConfig {
            crate::model::OutputDataConfig {
                s3_uri: self.s3_uri,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}

/// <p>The configuration containing input file information for a batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InputDataConfig {
    /// <p>The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.</p>
    #[doc(hidden)]
    pub s3_uri: std::option::Option<std::string::String>,
}
impl InputDataConfig {
    /// <p>The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.</p>
    pub fn s3_uri(&self) -> std::option::Option<&str> {
        self.s3_uri.as_deref()
    }
}
impl InputDataConfig {
    /// Creates a new builder-style object to manufacture [`InputDataConfig`](crate::model::InputDataConfig).
    pub fn builder() -> crate::model::input_data_config::Builder {
        crate::model::input_data_config::Builder::default()
    }
}

/// See [`InputDataConfig`](crate::model::InputDataConfig).
pub mod input_data_config {

    /// A builder for [`InputDataConfig`](crate::model::InputDataConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.</p>
        pub fn s3_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_uri = Some(input.into());
            self
        }
        /// <p>The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.</p>
        pub fn set_s3_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`InputDataConfig`](crate::model::InputDataConfig).
        pub fn build(self) -> crate::model::InputDataConfig {
            crate::model::InputDataConfig {
                s3_uri: self.s3_uri,
            }
        }
    }
}

/// <p>Contains configurations defining enrollment behavior for the batch job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnrollmentConfig {
    /// <p> The action to take when the specified speaker is already enrolled in the specified domain. The default value is <code>SKIP</code>, which skips the enrollment for the existing speaker. Setting the value to <code>OVERWRITE</code> replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.</p>
    #[doc(hidden)]
    pub existing_enrollment_action: std::option::Option<crate::model::ExistingEnrollmentAction>,
    /// <p>The fraud detection configuration to use for the speaker enrollment job.</p>
    #[doc(hidden)]
    pub fraud_detection_config:
        std::option::Option<crate::model::EnrollmentJobFraudDetectionConfig>,
}
impl EnrollmentConfig {
    /// <p> The action to take when the specified speaker is already enrolled in the specified domain. The default value is <code>SKIP</code>, which skips the enrollment for the existing speaker. Setting the value to <code>OVERWRITE</code> replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.</p>
    pub fn existing_enrollment_action(
        &self,
    ) -> std::option::Option<&crate::model::ExistingEnrollmentAction> {
        self.existing_enrollment_action.as_ref()
    }
    /// <p>The fraud detection configuration to use for the speaker enrollment job.</p>
    pub fn fraud_detection_config(
        &self,
    ) -> std::option::Option<&crate::model::EnrollmentJobFraudDetectionConfig> {
        self.fraud_detection_config.as_ref()
    }
}
impl EnrollmentConfig {
    /// Creates a new builder-style object to manufacture [`EnrollmentConfig`](crate::model::EnrollmentConfig).
    pub fn builder() -> crate::model::enrollment_config::Builder {
        crate::model::enrollment_config::Builder::default()
    }
}

/// See [`EnrollmentConfig`](crate::model::EnrollmentConfig).
pub mod enrollment_config {

    /// A builder for [`EnrollmentConfig`](crate::model::EnrollmentConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) existing_enrollment_action:
            std::option::Option<crate::model::ExistingEnrollmentAction>,
        pub(crate) fraud_detection_config:
            std::option::Option<crate::model::EnrollmentJobFraudDetectionConfig>,
    }
    impl Builder {
        /// <p> The action to take when the specified speaker is already enrolled in the specified domain. The default value is <code>SKIP</code>, which skips the enrollment for the existing speaker. Setting the value to <code>OVERWRITE</code> replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.</p>
        pub fn existing_enrollment_action(
            mut self,
            input: crate::model::ExistingEnrollmentAction,
        ) -> Self {
            self.existing_enrollment_action = Some(input);
            self
        }
        /// <p> The action to take when the specified speaker is already enrolled in the specified domain. The default value is <code>SKIP</code>, which skips the enrollment for the existing speaker. Setting the value to <code>OVERWRITE</code> replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.</p>
        pub fn set_existing_enrollment_action(
            mut self,
            input: std::option::Option<crate::model::ExistingEnrollmentAction>,
        ) -> Self {
            self.existing_enrollment_action = input;
            self
        }
        /// <p>The fraud detection configuration to use for the speaker enrollment job.</p>
        pub fn fraud_detection_config(
            mut self,
            input: crate::model::EnrollmentJobFraudDetectionConfig,
        ) -> Self {
            self.fraud_detection_config = Some(input);
            self
        }
        /// <p>The fraud detection configuration to use for the speaker enrollment job.</p>
        pub fn set_fraud_detection_config(
            mut self,
            input: std::option::Option<crate::model::EnrollmentJobFraudDetectionConfig>,
        ) -> Self {
            self.fraud_detection_config = input;
            self
        }
        /// Consumes the builder and constructs a [`EnrollmentConfig`](crate::model::EnrollmentConfig).
        pub fn build(self) -> crate::model::EnrollmentConfig {
            crate::model::EnrollmentConfig {
                existing_enrollment_action: self.existing_enrollment_action,
                fraud_detection_config: self.fraud_detection_config,
            }
        }
    }
}

/// <p>The configuration defining the action to take when a speaker is flagged by the fraud detection system during a batch speaker enrollment job, and the risk threshold to use for identification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnrollmentJobFraudDetectionConfig {
    /// <p>The action to take when the given speaker is flagged by the fraud detection system. The default value is <code>FAIL</code>, which fails the speaker enrollment. Changing this value to <code>IGNORE</code> results in the speaker being enrolled even if they are flagged by the fraud detection system.</p>
    #[doc(hidden)]
    pub fraud_detection_action: std::option::Option<crate::model::FraudDetectionAction>,
    /// <p>Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.</p>
    #[doc(hidden)]
    pub risk_threshold: std::option::Option<i32>,
}
impl EnrollmentJobFraudDetectionConfig {
    /// <p>The action to take when the given speaker is flagged by the fraud detection system. The default value is <code>FAIL</code>, which fails the speaker enrollment. Changing this value to <code>IGNORE</code> results in the speaker being enrolled even if they are flagged by the fraud detection system.</p>
    pub fn fraud_detection_action(
        &self,
    ) -> std::option::Option<&crate::model::FraudDetectionAction> {
        self.fraud_detection_action.as_ref()
    }
    /// <p>Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.</p>
    pub fn risk_threshold(&self) -> std::option::Option<i32> {
        self.risk_threshold
    }
}
impl EnrollmentJobFraudDetectionConfig {
    /// Creates a new builder-style object to manufacture [`EnrollmentJobFraudDetectionConfig`](crate::model::EnrollmentJobFraudDetectionConfig).
    pub fn builder() -> crate::model::enrollment_job_fraud_detection_config::Builder {
        crate::model::enrollment_job_fraud_detection_config::Builder::default()
    }
}

/// See [`EnrollmentJobFraudDetectionConfig`](crate::model::EnrollmentJobFraudDetectionConfig).
pub mod enrollment_job_fraud_detection_config {

    /// A builder for [`EnrollmentJobFraudDetectionConfig`](crate::model::EnrollmentJobFraudDetectionConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fraud_detection_action: std::option::Option<crate::model::FraudDetectionAction>,
        pub(crate) risk_threshold: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The action to take when the given speaker is flagged by the fraud detection system. The default value is <code>FAIL</code>, which fails the speaker enrollment. Changing this value to <code>IGNORE</code> results in the speaker being enrolled even if they are flagged by the fraud detection system.</p>
        pub fn fraud_detection_action(mut self, input: crate::model::FraudDetectionAction) -> Self {
            self.fraud_detection_action = Some(input);
            self
        }
        /// <p>The action to take when the given speaker is flagged by the fraud detection system. The default value is <code>FAIL</code>, which fails the speaker enrollment. Changing this value to <code>IGNORE</code> results in the speaker being enrolled even if they are flagged by the fraud detection system.</p>
        pub fn set_fraud_detection_action(
            mut self,
            input: std::option::Option<crate::model::FraudDetectionAction>,
        ) -> Self {
            self.fraud_detection_action = input;
            self
        }
        /// <p>Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.</p>
        pub fn risk_threshold(mut self, input: i32) -> Self {
            self.risk_threshold = Some(input);
            self
        }
        /// <p>Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.</p>
        pub fn set_risk_threshold(mut self, input: std::option::Option<i32>) -> Self {
            self.risk_threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`EnrollmentJobFraudDetectionConfig`](crate::model::EnrollmentJobFraudDetectionConfig).
        pub fn build(self) -> crate::model::EnrollmentJobFraudDetectionConfig {
            crate::model::EnrollmentJobFraudDetectionConfig {
                fraud_detection_action: self.fraud_detection_action,
                risk_threshold: self.risk_threshold,
            }
        }
    }
}

/// When writing a match expression against `FraudDetectionAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let frauddetectionaction = unimplemented!();
/// match frauddetectionaction {
///     FraudDetectionAction::Fail => { /* ... */ },
///     FraudDetectionAction::Ignore => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `frauddetectionaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FraudDetectionAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FraudDetectionAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FraudDetectionAction::NewFeature` is defined.
/// Specifically, when `frauddetectionaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FraudDetectionAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FraudDetectionAction {
    #[allow(missing_docs)] // documentation missing in model
    Fail,
    #[allow(missing_docs)] // documentation missing in model
    Ignore,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FraudDetectionAction {
    fn from(s: &str) -> Self {
        match s {
            "FAIL" => FraudDetectionAction::Fail,
            "IGNORE" => FraudDetectionAction::Ignore,
            other => {
                FraudDetectionAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FraudDetectionAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FraudDetectionAction::from(s))
    }
}
impl FraudDetectionAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FraudDetectionAction::Fail => "FAIL",
            FraudDetectionAction::Ignore => "IGNORE",
            FraudDetectionAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAIL", "IGNORE"]
    }
}
impl AsRef<str> for FraudDetectionAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ExistingEnrollmentAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let existingenrollmentaction = unimplemented!();
/// match existingenrollmentaction {
///     ExistingEnrollmentAction::Overwrite => { /* ... */ },
///     ExistingEnrollmentAction::Skip => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `existingenrollmentaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExistingEnrollmentAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExistingEnrollmentAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExistingEnrollmentAction::NewFeature` is defined.
/// Specifically, when `existingenrollmentaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExistingEnrollmentAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExistingEnrollmentAction {
    #[allow(missing_docs)] // documentation missing in model
    Overwrite,
    #[allow(missing_docs)] // documentation missing in model
    Skip,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExistingEnrollmentAction {
    fn from(s: &str) -> Self {
        match s {
            "OVERWRITE" => ExistingEnrollmentAction::Overwrite,
            "SKIP" => ExistingEnrollmentAction::Skip,
            other => ExistingEnrollmentAction::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ExistingEnrollmentAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExistingEnrollmentAction::from(s))
    }
}
impl ExistingEnrollmentAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExistingEnrollmentAction::Overwrite => "OVERWRITE",
            ExistingEnrollmentAction::Skip => "SKIP",
            ExistingEnrollmentAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OVERWRITE", "SKIP"]
    }
}
impl AsRef<str> for ExistingEnrollmentAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SpeakerEnrollmentJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let speakerenrollmentjobstatus = unimplemented!();
/// match speakerenrollmentjobstatus {
///     SpeakerEnrollmentJobStatus::Completed => { /* ... */ },
///     SpeakerEnrollmentJobStatus::CompletedWithErrors => { /* ... */ },
///     SpeakerEnrollmentJobStatus::Failed => { /* ... */ },
///     SpeakerEnrollmentJobStatus::InProgress => { /* ... */ },
///     SpeakerEnrollmentJobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `speakerenrollmentjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SpeakerEnrollmentJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SpeakerEnrollmentJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SpeakerEnrollmentJobStatus::NewFeature` is defined.
/// Specifically, when `speakerenrollmentjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SpeakerEnrollmentJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpeakerEnrollmentJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithErrors,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SpeakerEnrollmentJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => SpeakerEnrollmentJobStatus::Completed,
            "COMPLETED_WITH_ERRORS" => SpeakerEnrollmentJobStatus::CompletedWithErrors,
            "FAILED" => SpeakerEnrollmentJobStatus::Failed,
            "IN_PROGRESS" => SpeakerEnrollmentJobStatus::InProgress,
            "SUBMITTED" => SpeakerEnrollmentJobStatus::Submitted,
            other => SpeakerEnrollmentJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SpeakerEnrollmentJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpeakerEnrollmentJobStatus::from(s))
    }
}
impl SpeakerEnrollmentJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SpeakerEnrollmentJobStatus::Completed => "COMPLETED",
            SpeakerEnrollmentJobStatus::CompletedWithErrors => "COMPLETED_WITH_ERRORS",
            SpeakerEnrollmentJobStatus::Failed => "FAILED",
            SpeakerEnrollmentJobStatus::InProgress => "IN_PROGRESS",
            SpeakerEnrollmentJobStatus::Submitted => "SUBMITTED",
            SpeakerEnrollmentJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "COMPLETED_WITH_ERRORS",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for SpeakerEnrollmentJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains all the information about a fraudster registration job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FraudsterRegistrationJob {
    /// <p>The client-provided name for the fraudster registration job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the fraudster registration job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The current status of the fraudster registration job.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::FraudsterRegistrationJobStatus>,
    /// <p>The identifier of the domain containing the fraudster registration job.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
    /// <p>The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.</p>
    #[doc(hidden)]
    pub registration_config: std::option::Option<crate::model::RegistrationConfig>,
    /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.</p>
    #[doc(hidden)]
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.</p>
    #[doc(hidden)]
    pub output_data_config: std::option::Option<crate::model::OutputDataConfig>,
    /// <p>A timestamp showing the creation time of the fraudster registration job.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp showing when the fraudster registration job ended.</p>
    #[doc(hidden)]
    pub ended_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    #[doc(hidden)]
    pub failure_details: std::option::Option<crate::model::FailureDetails>,
    /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
    #[doc(hidden)]
    pub job_progress: std::option::Option<crate::model::JobProgress>,
}
impl FraudsterRegistrationJob {
    /// <p>The client-provided name for the fraudster registration job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The service-generated identifier for the fraudster registration job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The current status of the fraudster registration job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::FraudsterRegistrationJobStatus> {
        self.job_status.as_ref()
    }
    /// <p>The identifier of the domain containing the fraudster registration job.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
    /// <p>The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.</p>
    pub fn registration_config(&self) -> std::option::Option<&crate::model::RegistrationConfig> {
        self.registration_config.as_ref()
    }
    /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.</p>
    pub fn input_data_config(&self) -> std::option::Option<&crate::model::InputDataConfig> {
        self.input_data_config.as_ref()
    }
    /// <p>The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.</p>
    pub fn output_data_config(&self) -> std::option::Option<&crate::model::OutputDataConfig> {
        self.output_data_config.as_ref()
    }
    /// <p>A timestamp showing the creation time of the fraudster registration job.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A timestamp showing when the fraudster registration job ended.</p>
    pub fn ended_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ended_at.as_ref()
    }
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    pub fn failure_details(&self) -> std::option::Option<&crate::model::FailureDetails> {
        self.failure_details.as_ref()
    }
    /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
    pub fn job_progress(&self) -> std::option::Option<&crate::model::JobProgress> {
        self.job_progress.as_ref()
    }
}
impl std::fmt::Debug for FraudsterRegistrationJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FraudsterRegistrationJob");
        formatter.field("job_name", &"*** Sensitive Data Redacted ***");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("data_access_role_arn", &self.data_access_role_arn);
        formatter.field("registration_config", &self.registration_config);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("output_data_config", &self.output_data_config);
        formatter.field("created_at", &self.created_at);
        formatter.field("ended_at", &self.ended_at);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("job_progress", &self.job_progress);
        formatter.finish()
    }
}
impl FraudsterRegistrationJob {
    /// Creates a new builder-style object to manufacture [`FraudsterRegistrationJob`](crate::model::FraudsterRegistrationJob).
    pub fn builder() -> crate::model::fraudster_registration_job::Builder {
        crate::model::fraudster_registration_job::Builder::default()
    }
}

/// See [`FraudsterRegistrationJob`](crate::model::FraudsterRegistrationJob).
pub mod fraudster_registration_job {

    /// A builder for [`FraudsterRegistrationJob`](crate::model::FraudsterRegistrationJob).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::FraudsterRegistrationJobStatus>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
        pub(crate) registration_config: std::option::Option<crate::model::RegistrationConfig>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) output_data_config: std::option::Option<crate::model::OutputDataConfig>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ended_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_details: std::option::Option<crate::model::FailureDetails>,
        pub(crate) job_progress: std::option::Option<crate::model::JobProgress>,
    }
    impl Builder {
        /// <p>The client-provided name for the fraudster registration job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The client-provided name for the fraudster registration job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The service-generated identifier for the fraudster registration job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the fraudster registration job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The current status of the fraudster registration job.</p>
        pub fn job_status(mut self, input: crate::model::FraudsterRegistrationJobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the fraudster registration job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::FraudsterRegistrationJobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>The identifier of the domain containing the fraudster registration job.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain containing the fraudster registration job.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// <p>The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.</p>
        pub fn registration_config(mut self, input: crate::model::RegistrationConfig) -> Self {
            self.registration_config = Some(input);
            self
        }
        /// <p>The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.</p>
        pub fn set_registration_config(
            mut self,
            input: std::option::Option<crate::model::RegistrationConfig>,
        ) -> Self {
            self.registration_config = input;
            self
        }
        /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.</p>
        pub fn output_data_config(mut self, input: crate::model::OutputDataConfig) -> Self {
            self.output_data_config = Some(input);
            self
        }
        /// <p>The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.</p>
        pub fn set_output_data_config(
            mut self,
            input: std::option::Option<crate::model::OutputDataConfig>,
        ) -> Self {
            self.output_data_config = input;
            self
        }
        /// <p>A timestamp showing the creation time of the fraudster registration job.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>A timestamp showing the creation time of the fraudster registration job.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A timestamp showing when the fraudster registration job ended.</p>
        pub fn ended_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ended_at = Some(input);
            self
        }
        /// <p>A timestamp showing when the fraudster registration job ended.</p>
        pub fn set_ended_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ended_at = input;
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
        pub fn job_progress(mut self, input: crate::model::JobProgress) -> Self {
            self.job_progress = Some(input);
            self
        }
        /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
        pub fn set_job_progress(
            mut self,
            input: std::option::Option<crate::model::JobProgress>,
        ) -> Self {
            self.job_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`FraudsterRegistrationJob`](crate::model::FraudsterRegistrationJob).
        pub fn build(self) -> crate::model::FraudsterRegistrationJob {
            crate::model::FraudsterRegistrationJob {
                job_name: self.job_name,
                job_id: self.job_id,
                job_status: self.job_status,
                domain_id: self.domain_id,
                data_access_role_arn: self.data_access_role_arn,
                registration_config: self.registration_config,
                input_data_config: self.input_data_config,
                output_data_config: self.output_data_config,
                created_at: self.created_at,
                ended_at: self.ended_at,
                failure_details: self.failure_details,
                job_progress: self.job_progress,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("job_name", &"*** Sensitive Data Redacted ***");
            formatter.field("job_id", &self.job_id);
            formatter.field("job_status", &self.job_status);
            formatter.field("domain_id", &self.domain_id);
            formatter.field("data_access_role_arn", &self.data_access_role_arn);
            formatter.field("registration_config", &self.registration_config);
            formatter.field("input_data_config", &self.input_data_config);
            formatter.field("output_data_config", &self.output_data_config);
            formatter.field("created_at", &self.created_at);
            formatter.field("ended_at", &self.ended_at);
            formatter.field("failure_details", &self.failure_details);
            formatter.field("job_progress", &self.job_progress);
            formatter.finish()
        }
    }
}

/// <p>The configuration defining the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster during a batch fraudster registration job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegistrationConfig {
    /// <p>The action to take when a fraudster is identified as a duplicate. The default action is <code>SKIP</code>, which skips registering the duplicate fraudster. Setting the value to <code>REGISTER_AS_NEW</code> always registers a new fraudster into the specified domain.</p>
    #[doc(hidden)]
    pub duplicate_registration_action:
        std::option::Option<crate::model::DuplicateRegistrationAction>,
    /// <p>The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.</p>
    #[doc(hidden)]
    pub fraudster_similarity_threshold: std::option::Option<i32>,
}
impl RegistrationConfig {
    /// <p>The action to take when a fraudster is identified as a duplicate. The default action is <code>SKIP</code>, which skips registering the duplicate fraudster. Setting the value to <code>REGISTER_AS_NEW</code> always registers a new fraudster into the specified domain.</p>
    pub fn duplicate_registration_action(
        &self,
    ) -> std::option::Option<&crate::model::DuplicateRegistrationAction> {
        self.duplicate_registration_action.as_ref()
    }
    /// <p>The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.</p>
    pub fn fraudster_similarity_threshold(&self) -> std::option::Option<i32> {
        self.fraudster_similarity_threshold
    }
}
impl RegistrationConfig {
    /// Creates a new builder-style object to manufacture [`RegistrationConfig`](crate::model::RegistrationConfig).
    pub fn builder() -> crate::model::registration_config::Builder {
        crate::model::registration_config::Builder::default()
    }
}

/// See [`RegistrationConfig`](crate::model::RegistrationConfig).
pub mod registration_config {

    /// A builder for [`RegistrationConfig`](crate::model::RegistrationConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) duplicate_registration_action:
            std::option::Option<crate::model::DuplicateRegistrationAction>,
        pub(crate) fraudster_similarity_threshold: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The action to take when a fraudster is identified as a duplicate. The default action is <code>SKIP</code>, which skips registering the duplicate fraudster. Setting the value to <code>REGISTER_AS_NEW</code> always registers a new fraudster into the specified domain.</p>
        pub fn duplicate_registration_action(
            mut self,
            input: crate::model::DuplicateRegistrationAction,
        ) -> Self {
            self.duplicate_registration_action = Some(input);
            self
        }
        /// <p>The action to take when a fraudster is identified as a duplicate. The default action is <code>SKIP</code>, which skips registering the duplicate fraudster. Setting the value to <code>REGISTER_AS_NEW</code> always registers a new fraudster into the specified domain.</p>
        pub fn set_duplicate_registration_action(
            mut self,
            input: std::option::Option<crate::model::DuplicateRegistrationAction>,
        ) -> Self {
            self.duplicate_registration_action = input;
            self
        }
        /// <p>The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.</p>
        pub fn fraudster_similarity_threshold(mut self, input: i32) -> Self {
            self.fraudster_similarity_threshold = Some(input);
            self
        }
        /// <p>The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.</p>
        pub fn set_fraudster_similarity_threshold(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.fraudster_similarity_threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`RegistrationConfig`](crate::model::RegistrationConfig).
        pub fn build(self) -> crate::model::RegistrationConfig {
            crate::model::RegistrationConfig {
                duplicate_registration_action: self.duplicate_registration_action,
                fraudster_similarity_threshold: self.fraudster_similarity_threshold,
            }
        }
    }
}

/// When writing a match expression against `DuplicateRegistrationAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let duplicateregistrationaction = unimplemented!();
/// match duplicateregistrationaction {
///     DuplicateRegistrationAction::RegisterAsNew => { /* ... */ },
///     DuplicateRegistrationAction::Skip => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `duplicateregistrationaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DuplicateRegistrationAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DuplicateRegistrationAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DuplicateRegistrationAction::NewFeature` is defined.
/// Specifically, when `duplicateregistrationaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DuplicateRegistrationAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DuplicateRegistrationAction {
    #[allow(missing_docs)] // documentation missing in model
    RegisterAsNew,
    #[allow(missing_docs)] // documentation missing in model
    Skip,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DuplicateRegistrationAction {
    fn from(s: &str) -> Self {
        match s {
            "REGISTER_AS_NEW" => DuplicateRegistrationAction::RegisterAsNew,
            "SKIP" => DuplicateRegistrationAction::Skip,
            other => DuplicateRegistrationAction::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DuplicateRegistrationAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DuplicateRegistrationAction::from(s))
    }
}
impl DuplicateRegistrationAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DuplicateRegistrationAction::RegisterAsNew => "REGISTER_AS_NEW",
            DuplicateRegistrationAction::Skip => "SKIP",
            DuplicateRegistrationAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["REGISTER_AS_NEW", "SKIP"]
    }
}
impl AsRef<str> for DuplicateRegistrationAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FraudsterRegistrationJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fraudsterregistrationjobstatus = unimplemented!();
/// match fraudsterregistrationjobstatus {
///     FraudsterRegistrationJobStatus::Completed => { /* ... */ },
///     FraudsterRegistrationJobStatus::CompletedWithErrors => { /* ... */ },
///     FraudsterRegistrationJobStatus::Failed => { /* ... */ },
///     FraudsterRegistrationJobStatus::InProgress => { /* ... */ },
///     FraudsterRegistrationJobStatus::Submitted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fraudsterregistrationjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FraudsterRegistrationJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FraudsterRegistrationJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FraudsterRegistrationJobStatus::NewFeature` is defined.
/// Specifically, when `fraudsterregistrationjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FraudsterRegistrationJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FraudsterRegistrationJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithErrors,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FraudsterRegistrationJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => FraudsterRegistrationJobStatus::Completed,
            "COMPLETED_WITH_ERRORS" => FraudsterRegistrationJobStatus::CompletedWithErrors,
            "FAILED" => FraudsterRegistrationJobStatus::Failed,
            "IN_PROGRESS" => FraudsterRegistrationJobStatus::InProgress,
            "SUBMITTED" => FraudsterRegistrationJobStatus::Submitted,
            other => FraudsterRegistrationJobStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for FraudsterRegistrationJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FraudsterRegistrationJobStatus::from(s))
    }
}
impl FraudsterRegistrationJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FraudsterRegistrationJobStatus::Completed => "COMPLETED",
            FraudsterRegistrationJobStatus::CompletedWithErrors => "COMPLETED_WITH_ERRORS",
            FraudsterRegistrationJobStatus::Failed => "FAILED",
            FraudsterRegistrationJobStatus::InProgress => "IN_PROGRESS",
            FraudsterRegistrationJobStatus::Submitted => "SUBMITTED",
            FraudsterRegistrationJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "COMPLETED_WITH_ERRORS",
            "FAILED",
            "IN_PROGRESS",
            "SUBMITTED",
        ]
    }
}
impl AsRef<str> for FraudsterRegistrationJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains all the information about a speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Speaker {
    /// <p>The identifier of the domain that contains the speaker.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The client-provided identifier for the speaker.</p>
    #[doc(hidden)]
    pub customer_speaker_id: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the speaker.</p>
    #[doc(hidden)]
    pub generated_speaker_id: std::option::Option<std::string::String>,
    /// <p>The current status of the speaker.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SpeakerStatus>,
    /// <p>A timestamp showing when the speaker is created. </p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp showing the speaker's last update.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
    #[doc(hidden)]
    pub last_accessed_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Speaker {
    /// <p>The identifier of the domain that contains the speaker.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The client-provided identifier for the speaker.</p>
    pub fn customer_speaker_id(&self) -> std::option::Option<&str> {
        self.customer_speaker_id.as_deref()
    }
    /// <p>The service-generated identifier for the speaker.</p>
    pub fn generated_speaker_id(&self) -> std::option::Option<&str> {
        self.generated_speaker_id.as_deref()
    }
    /// <p>The current status of the speaker.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SpeakerStatus> {
        self.status.as_ref()
    }
    /// <p>A timestamp showing when the speaker is created. </p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A timestamp showing the speaker's last update.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
    pub fn last_accessed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_accessed_at.as_ref()
    }
}
impl std::fmt::Debug for Speaker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Speaker");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("customer_speaker_id", &"*** Sensitive Data Redacted ***");
        formatter.field("generated_speaker_id", &self.generated_speaker_id);
        formatter.field("status", &self.status);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("last_accessed_at", &self.last_accessed_at);
        formatter.finish()
    }
}
impl Speaker {
    /// Creates a new builder-style object to manufacture [`Speaker`](crate::model::Speaker).
    pub fn builder() -> crate::model::speaker::Builder {
        crate::model::speaker::Builder::default()
    }
}

/// See [`Speaker`](crate::model::Speaker).
pub mod speaker {

    /// A builder for [`Speaker`](crate::model::Speaker).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) customer_speaker_id: std::option::Option<std::string::String>,
        pub(crate) generated_speaker_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SpeakerStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_accessed_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the domain that contains the speaker.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain that contains the speaker.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The client-provided identifier for the speaker.</p>
        pub fn customer_speaker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_speaker_id = Some(input.into());
            self
        }
        /// <p>The client-provided identifier for the speaker.</p>
        pub fn set_customer_speaker_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_speaker_id = input;
            self
        }
        /// <p>The service-generated identifier for the speaker.</p>
        pub fn generated_speaker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_speaker_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the speaker.</p>
        pub fn set_generated_speaker_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_speaker_id = input;
            self
        }
        /// <p>The current status of the speaker.</p>
        pub fn status(mut self, input: crate::model::SpeakerStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the speaker.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SpeakerStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A timestamp showing when the speaker is created. </p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>A timestamp showing when the speaker is created. </p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A timestamp showing the speaker's last update.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>A timestamp showing the speaker's last update.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
        pub fn last_accessed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_accessed_at = Some(input);
            self
        }
        /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
        pub fn set_last_accessed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_accessed_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Speaker`](crate::model::Speaker).
        pub fn build(self) -> crate::model::Speaker {
            crate::model::Speaker {
                domain_id: self.domain_id,
                customer_speaker_id: self.customer_speaker_id,
                generated_speaker_id: self.generated_speaker_id,
                status: self.status,
                created_at: self.created_at,
                updated_at: self.updated_at,
                last_accessed_at: self.last_accessed_at,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("domain_id", &self.domain_id);
            formatter.field("customer_speaker_id", &"*** Sensitive Data Redacted ***");
            formatter.field("generated_speaker_id", &self.generated_speaker_id);
            formatter.field("status", &self.status);
            formatter.field("created_at", &self.created_at);
            formatter.field("updated_at", &self.updated_at);
            formatter.field("last_accessed_at", &self.last_accessed_at);
            formatter.finish()
        }
    }
}

/// When writing a match expression against `SpeakerStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let speakerstatus = unimplemented!();
/// match speakerstatus {
///     SpeakerStatus::Enrolled => { /* ... */ },
///     SpeakerStatus::Expired => { /* ... */ },
///     SpeakerStatus::OptedOut => { /* ... */ },
///     SpeakerStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `speakerstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SpeakerStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SpeakerStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SpeakerStatus::NewFeature` is defined.
/// Specifically, when `speakerstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SpeakerStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpeakerStatus {
    #[allow(missing_docs)] // documentation missing in model
    Enrolled,
    #[allow(missing_docs)] // documentation missing in model
    Expired,
    #[allow(missing_docs)] // documentation missing in model
    OptedOut,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SpeakerStatus {
    fn from(s: &str) -> Self {
        match s {
            "ENROLLED" => SpeakerStatus::Enrolled,
            "EXPIRED" => SpeakerStatus::Expired,
            "OPTED_OUT" => SpeakerStatus::OptedOut,
            "PENDING" => SpeakerStatus::Pending,
            other => SpeakerStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SpeakerStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpeakerStatus::from(s))
    }
}
impl SpeakerStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SpeakerStatus::Enrolled => "ENROLLED",
            SpeakerStatus::Expired => "EXPIRED",
            SpeakerStatus::OptedOut => "OPTED_OUT",
            SpeakerStatus::Pending => "PENDING",
            SpeakerStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENROLLED", "EXPIRED", "OPTED_OUT", "PENDING"]
    }
}
impl AsRef<str> for SpeakerStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains a summary of information about a speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpeakerSummary {
    /// <p>The identifier of the domain that contains the speaker.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The client-provided identifier for the speaker.</p>
    #[doc(hidden)]
    pub customer_speaker_id: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the speaker. </p>
    #[doc(hidden)]
    pub generated_speaker_id: std::option::Option<std::string::String>,
    /// <p>The current status of the speaker.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SpeakerStatus>,
    /// <p>A timestamp showing the speaker's creation time. </p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp showing the speaker's last update.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
    #[doc(hidden)]
    pub last_accessed_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl SpeakerSummary {
    /// <p>The identifier of the domain that contains the speaker.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The client-provided identifier for the speaker.</p>
    pub fn customer_speaker_id(&self) -> std::option::Option<&str> {
        self.customer_speaker_id.as_deref()
    }
    /// <p>The service-generated identifier for the speaker. </p>
    pub fn generated_speaker_id(&self) -> std::option::Option<&str> {
        self.generated_speaker_id.as_deref()
    }
    /// <p>The current status of the speaker.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::SpeakerStatus> {
        self.status.as_ref()
    }
    /// <p>A timestamp showing the speaker's creation time. </p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A timestamp showing the speaker's last update.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
    pub fn last_accessed_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_accessed_at.as_ref()
    }
}
impl std::fmt::Debug for SpeakerSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpeakerSummary");
        formatter.field("domain_id", &self.domain_id);
        formatter.field("customer_speaker_id", &"*** Sensitive Data Redacted ***");
        formatter.field("generated_speaker_id", &self.generated_speaker_id);
        formatter.field("status", &self.status);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("last_accessed_at", &self.last_accessed_at);
        formatter.finish()
    }
}
impl SpeakerSummary {
    /// Creates a new builder-style object to manufacture [`SpeakerSummary`](crate::model::SpeakerSummary).
    pub fn builder() -> crate::model::speaker_summary::Builder {
        crate::model::speaker_summary::Builder::default()
    }
}

/// See [`SpeakerSummary`](crate::model::SpeakerSummary).
pub mod speaker_summary {

    /// A builder for [`SpeakerSummary`](crate::model::SpeakerSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) customer_speaker_id: std::option::Option<std::string::String>,
        pub(crate) generated_speaker_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::SpeakerStatus>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_accessed_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the domain that contains the speaker.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain that contains the speaker.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The client-provided identifier for the speaker.</p>
        pub fn customer_speaker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_speaker_id = Some(input.into());
            self
        }
        /// <p>The client-provided identifier for the speaker.</p>
        pub fn set_customer_speaker_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_speaker_id = input;
            self
        }
        /// <p>The service-generated identifier for the speaker. </p>
        pub fn generated_speaker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_speaker_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the speaker. </p>
        pub fn set_generated_speaker_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_speaker_id = input;
            self
        }
        /// <p>The current status of the speaker.</p>
        pub fn status(mut self, input: crate::model::SpeakerStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the speaker.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SpeakerStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A timestamp showing the speaker's creation time. </p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>A timestamp showing the speaker's creation time. </p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A timestamp showing the speaker's last update.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>A timestamp showing the speaker's last update.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
        pub fn last_accessed_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_accessed_at = Some(input);
            self
        }
        /// <p>The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.</p>
        pub fn set_last_accessed_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_accessed_at = input;
            self
        }
        /// Consumes the builder and constructs a [`SpeakerSummary`](crate::model::SpeakerSummary).
        pub fn build(self) -> crate::model::SpeakerSummary {
            crate::model::SpeakerSummary {
                domain_id: self.domain_id,
                customer_speaker_id: self.customer_speaker_id,
                generated_speaker_id: self.generated_speaker_id,
                status: self.status,
                created_at: self.created_at,
                updated_at: self.updated_at,
                last_accessed_at: self.last_accessed_at,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("domain_id", &self.domain_id);
            formatter.field("customer_speaker_id", &"*** Sensitive Data Redacted ***");
            formatter.field("generated_speaker_id", &self.generated_speaker_id);
            formatter.field("status", &self.status);
            formatter.field("created_at", &self.created_at);
            formatter.field("updated_at", &self.updated_at);
            formatter.field("last_accessed_at", &self.last_accessed_at);
            formatter.finish()
        }
    }
}

/// <p>Contains a summary of information about a speaker enrollment job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SpeakerEnrollmentJobSummary {
    /// <p>The client-provided name for the speaker enrollment job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the speaker enrollment job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The current status of the speaker enrollment job.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::SpeakerEnrollmentJobStatus>,
    /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A timestamp showing the creation time of the speaker enrollment job.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp showing when the speaker enrollment job ended.</p>
    #[doc(hidden)]
    pub ended_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    #[doc(hidden)]
    pub failure_details: std::option::Option<crate::model::FailureDetails>,
    /// <p>Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.</p>
    #[doc(hidden)]
    pub job_progress: std::option::Option<crate::model::JobProgress>,
}
impl SpeakerEnrollmentJobSummary {
    /// <p>The client-provided name for the speaker enrollment job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The service-generated identifier for the speaker enrollment job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The current status of the speaker enrollment job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::SpeakerEnrollmentJobStatus> {
        self.job_status.as_ref()
    }
    /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A timestamp showing the creation time of the speaker enrollment job.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A timestamp showing when the speaker enrollment job ended.</p>
    pub fn ended_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ended_at.as_ref()
    }
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    pub fn failure_details(&self) -> std::option::Option<&crate::model::FailureDetails> {
        self.failure_details.as_ref()
    }
    /// <p>Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.</p>
    pub fn job_progress(&self) -> std::option::Option<&crate::model::JobProgress> {
        self.job_progress.as_ref()
    }
}
impl std::fmt::Debug for SpeakerEnrollmentJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SpeakerEnrollmentJobSummary");
        formatter.field("job_name", &"*** Sensitive Data Redacted ***");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("created_at", &self.created_at);
        formatter.field("ended_at", &self.ended_at);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("job_progress", &self.job_progress);
        formatter.finish()
    }
}
impl SpeakerEnrollmentJobSummary {
    /// Creates a new builder-style object to manufacture [`SpeakerEnrollmentJobSummary`](crate::model::SpeakerEnrollmentJobSummary).
    pub fn builder() -> crate::model::speaker_enrollment_job_summary::Builder {
        crate::model::speaker_enrollment_job_summary::Builder::default()
    }
}

/// See [`SpeakerEnrollmentJobSummary`](crate::model::SpeakerEnrollmentJobSummary).
pub mod speaker_enrollment_job_summary {

    /// A builder for [`SpeakerEnrollmentJobSummary`](crate::model::SpeakerEnrollmentJobSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::SpeakerEnrollmentJobStatus>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ended_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_details: std::option::Option<crate::model::FailureDetails>,
        pub(crate) job_progress: std::option::Option<crate::model::JobProgress>,
    }
    impl Builder {
        /// <p>The client-provided name for the speaker enrollment job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The client-provided name for the speaker enrollment job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The service-generated identifier for the speaker enrollment job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the speaker enrollment job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The current status of the speaker enrollment job.</p>
        pub fn job_status(mut self, input: crate::model::SpeakerEnrollmentJobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the speaker enrollment job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::SpeakerEnrollmentJobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain that contains the speaker enrollment job.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A timestamp showing the creation time of the speaker enrollment job.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>A timestamp showing the creation time of the speaker enrollment job.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A timestamp showing when the speaker enrollment job ended.</p>
        pub fn ended_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ended_at = Some(input);
            self
        }
        /// <p>A timestamp showing when the speaker enrollment job ended.</p>
        pub fn set_ended_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ended_at = input;
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.</p>
        pub fn job_progress(mut self, input: crate::model::JobProgress) -> Self {
            self.job_progress = Some(input);
            self
        }
        /// <p>Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.</p>
        pub fn set_job_progress(
            mut self,
            input: std::option::Option<crate::model::JobProgress>,
        ) -> Self {
            self.job_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`SpeakerEnrollmentJobSummary`](crate::model::SpeakerEnrollmentJobSummary).
        pub fn build(self) -> crate::model::SpeakerEnrollmentJobSummary {
            crate::model::SpeakerEnrollmentJobSummary {
                job_name: self.job_name,
                job_id: self.job_id,
                job_status: self.job_status,
                domain_id: self.domain_id,
                created_at: self.created_at,
                ended_at: self.ended_at,
                failure_details: self.failure_details,
                job_progress: self.job_progress,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("job_name", &"*** Sensitive Data Redacted ***");
            formatter.field("job_id", &self.job_id);
            formatter.field("job_status", &self.job_status);
            formatter.field("domain_id", &self.domain_id);
            formatter.field("created_at", &self.created_at);
            formatter.field("ended_at", &self.ended_at);
            formatter.field("failure_details", &self.failure_details);
            formatter.field("job_progress", &self.job_progress);
            formatter.finish()
        }
    }
}

/// <p>Contains a summary of information about a fraudster registration job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FraudsterRegistrationJobSummary {
    /// <p>The client-provided name for the fraudster registration job.</p>
    #[doc(hidden)]
    pub job_name: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the fraudster registration job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The current status of the fraudster registration job.</p>
    #[doc(hidden)]
    pub job_status: std::option::Option<crate::model::FraudsterRegistrationJobStatus>,
    /// <p>The identifier of the domain containing the fraudster registration job.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A timestamp showing when the fraudster registration job is created. </p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp showing when the fraudster registration job ended.</p>
    #[doc(hidden)]
    pub ended_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    #[doc(hidden)]
    pub failure_details: std::option::Option<crate::model::FailureDetails>,
    /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
    #[doc(hidden)]
    pub job_progress: std::option::Option<crate::model::JobProgress>,
}
impl FraudsterRegistrationJobSummary {
    /// <p>The client-provided name for the fraudster registration job.</p>
    pub fn job_name(&self) -> std::option::Option<&str> {
        self.job_name.as_deref()
    }
    /// <p>The service-generated identifier for the fraudster registration job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The current status of the fraudster registration job.</p>
    pub fn job_status(&self) -> std::option::Option<&crate::model::FraudsterRegistrationJobStatus> {
        self.job_status.as_ref()
    }
    /// <p>The identifier of the domain containing the fraudster registration job.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A timestamp showing when the fraudster registration job is created. </p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A timestamp showing when the fraudster registration job ended.</p>
    pub fn ended_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.ended_at.as_ref()
    }
    /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
    pub fn failure_details(&self) -> std::option::Option<&crate::model::FailureDetails> {
        self.failure_details.as_ref()
    }
    /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
    pub fn job_progress(&self) -> std::option::Option<&crate::model::JobProgress> {
        self.job_progress.as_ref()
    }
}
impl std::fmt::Debug for FraudsterRegistrationJobSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FraudsterRegistrationJobSummary");
        formatter.field("job_name", &"*** Sensitive Data Redacted ***");
        formatter.field("job_id", &self.job_id);
        formatter.field("job_status", &self.job_status);
        formatter.field("domain_id", &self.domain_id);
        formatter.field("created_at", &self.created_at);
        formatter.field("ended_at", &self.ended_at);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("job_progress", &self.job_progress);
        formatter.finish()
    }
}
impl FraudsterRegistrationJobSummary {
    /// Creates a new builder-style object to manufacture [`FraudsterRegistrationJobSummary`](crate::model::FraudsterRegistrationJobSummary).
    pub fn builder() -> crate::model::fraudster_registration_job_summary::Builder {
        crate::model::fraudster_registration_job_summary::Builder::default()
    }
}

/// See [`FraudsterRegistrationJobSummary`](crate::model::FraudsterRegistrationJobSummary).
pub mod fraudster_registration_job_summary {

    /// A builder for [`FraudsterRegistrationJobSummary`](crate::model::FraudsterRegistrationJobSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) job_name: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::FraudsterRegistrationJobStatus>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) ended_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) failure_details: std::option::Option<crate::model::FailureDetails>,
        pub(crate) job_progress: std::option::Option<crate::model::JobProgress>,
    }
    impl Builder {
        /// <p>The client-provided name for the fraudster registration job.</p>
        pub fn job_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_name = Some(input.into());
            self
        }
        /// <p>The client-provided name for the fraudster registration job.</p>
        pub fn set_job_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_name = input;
            self
        }
        /// <p>The service-generated identifier for the fraudster registration job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the fraudster registration job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The current status of the fraudster registration job.</p>
        pub fn job_status(mut self, input: crate::model::FraudsterRegistrationJobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The current status of the fraudster registration job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::FraudsterRegistrationJobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>The identifier of the domain containing the fraudster registration job.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier of the domain containing the fraudster registration job.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A timestamp showing when the fraudster registration job is created. </p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>A timestamp showing when the fraudster registration job is created. </p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A timestamp showing when the fraudster registration job ended.</p>
        pub fn ended_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.ended_at = Some(input);
            self
        }
        /// <p>A timestamp showing when the fraudster registration job ended.</p>
        pub fn set_ended_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.ended_at = input;
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn failure_details(mut self, input: crate::model::FailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        /// <p>Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a <code>JobStatus</code> of <code>COMPLETED_WITH_ERRORS</code>. You can use the job output file to identify the individual registration requests that failed.</p>
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
        pub fn job_progress(mut self, input: crate::model::JobProgress) -> Self {
            self.job_progress = Some(input);
            self
        }
        /// <p>Shows the completed percentage of registration requests listed in the input file.</p>
        pub fn set_job_progress(
            mut self,
            input: std::option::Option<crate::model::JobProgress>,
        ) -> Self {
            self.job_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`FraudsterRegistrationJobSummary`](crate::model::FraudsterRegistrationJobSummary).
        pub fn build(self) -> crate::model::FraudsterRegistrationJobSummary {
            crate::model::FraudsterRegistrationJobSummary {
                job_name: self.job_name,
                job_id: self.job_id,
                job_status: self.job_status,
                domain_id: self.domain_id,
                created_at: self.created_at,
                ended_at: self.ended_at,
                failure_details: self.failure_details,
                job_progress: self.job_progress,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("job_name", &"*** Sensitive Data Redacted ***");
            formatter.field("job_id", &self.job_id);
            formatter.field("job_status", &self.job_status);
            formatter.field("domain_id", &self.domain_id);
            formatter.field("created_at", &self.created_at);
            formatter.field("ended_at", &self.ended_at);
            formatter.field("failure_details", &self.failure_details);
            formatter.field("job_progress", &self.job_progress);
            formatter.finish()
        }
    }
}

/// <p>The fraud detection result produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FraudDetectionResult {
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    #[doc(hidden)]
    pub fraud_detection_result_id: std::option::Option<std::string::String>,
    /// <p>A timestamp indicating when audio aggregation started for this fraud detection result.</p>
    #[doc(hidden)]
    pub audio_aggregation_started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp indicating when audio aggregation ended for this fraud detection result.</p>
    #[doc(hidden)]
    pub audio_aggregation_ended_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::FraudDetectionConfiguration>,
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    #[doc(hidden)]
    pub decision: std::option::Option<crate::model::FraudDetectionDecision>,
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    #[doc(hidden)]
    pub reasons: std::option::Option<std::vec::Vec<crate::model::FraudDetectionReason>>,
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    #[doc(hidden)]
    pub risk_details: std::option::Option<crate::model::FraudRiskDetails>,
}
impl FraudDetectionResult {
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    pub fn fraud_detection_result_id(&self) -> std::option::Option<&str> {
        self.fraud_detection_result_id.as_deref()
    }
    /// <p>A timestamp indicating when audio aggregation started for this fraud detection result.</p>
    pub fn audio_aggregation_started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.audio_aggregation_started_at.as_ref()
    }
    /// <p>A timestamp indicating when audio aggregation ended for this fraud detection result.</p>
    pub fn audio_aggregation_ended_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.audio_aggregation_ended_at.as_ref()
    }
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::FraudDetectionConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub fn decision(&self) -> std::option::Option<&crate::model::FraudDetectionDecision> {
        self.decision.as_ref()
    }
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    pub fn reasons(&self) -> std::option::Option<&[crate::model::FraudDetectionReason]> {
        self.reasons.as_deref()
    }
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    pub fn risk_details(&self) -> std::option::Option<&crate::model::FraudRiskDetails> {
        self.risk_details.as_ref()
    }
}
impl FraudDetectionResult {
    /// Creates a new builder-style object to manufacture [`FraudDetectionResult`](crate::model::FraudDetectionResult).
    pub fn builder() -> crate::model::fraud_detection_result::Builder {
        crate::model::fraud_detection_result::Builder::default()
    }
}

/// See [`FraudDetectionResult`](crate::model::FraudDetectionResult).
pub mod fraud_detection_result {

    /// A builder for [`FraudDetectionResult`](crate::model::FraudDetectionResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fraud_detection_result_id: std::option::Option<std::string::String>,
        pub(crate) audio_aggregation_started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) audio_aggregation_ended_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) configuration: std::option::Option<crate::model::FraudDetectionConfiguration>,
        pub(crate) decision: std::option::Option<crate::model::FraudDetectionDecision>,
        pub(crate) reasons: std::option::Option<std::vec::Vec<crate::model::FraudDetectionReason>>,
        pub(crate) risk_details: std::option::Option<crate::model::FraudRiskDetails>,
    }
    impl Builder {
        /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
        pub fn fraud_detection_result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fraud_detection_result_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
        pub fn set_fraud_detection_result_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fraud_detection_result_id = input;
            self
        }
        /// <p>A timestamp indicating when audio aggregation started for this fraud detection result.</p>
        pub fn audio_aggregation_started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.audio_aggregation_started_at = Some(input);
            self
        }
        /// <p>A timestamp indicating when audio aggregation started for this fraud detection result.</p>
        pub fn set_audio_aggregation_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.audio_aggregation_started_at = input;
            self
        }
        /// <p>A timestamp indicating when audio aggregation ended for this fraud detection result.</p>
        pub fn audio_aggregation_ended_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.audio_aggregation_ended_at = Some(input);
            self
        }
        /// <p>A timestamp indicating when audio aggregation ended for this fraud detection result.</p>
        pub fn set_audio_aggregation_ended_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.audio_aggregation_ended_at = input;
            self
        }
        /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
        pub fn configuration(mut self, input: crate::model::FraudDetectionConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::FraudDetectionConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
        pub fn decision(mut self, input: crate::model::FraudDetectionDecision) -> Self {
            self.decision = Some(input);
            self
        }
        /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
        pub fn set_decision(
            mut self,
            input: std::option::Option<crate::model::FraudDetectionDecision>,
        ) -> Self {
            self.decision = input;
            self
        }
        /// Appends an item to `reasons`.
        ///
        /// To override the contents of this collection use [`set_reasons`](Self::set_reasons).
        ///
        /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
        pub fn reasons(mut self, input: crate::model::FraudDetectionReason) -> Self {
            let mut v = self.reasons.unwrap_or_default();
            v.push(input);
            self.reasons = Some(v);
            self
        }
        /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
        pub fn set_reasons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FraudDetectionReason>>,
        ) -> Self {
            self.reasons = input;
            self
        }
        /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
        pub fn risk_details(mut self, input: crate::model::FraudRiskDetails) -> Self {
            self.risk_details = Some(input);
            self
        }
        /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
        pub fn set_risk_details(
            mut self,
            input: std::option::Option<crate::model::FraudRiskDetails>,
        ) -> Self {
            self.risk_details = input;
            self
        }
        /// Consumes the builder and constructs a [`FraudDetectionResult`](crate::model::FraudDetectionResult).
        pub fn build(self) -> crate::model::FraudDetectionResult {
            crate::model::FraudDetectionResult {
                fraud_detection_result_id: self.fraud_detection_result_id,
                audio_aggregation_started_at: self.audio_aggregation_started_at,
                audio_aggregation_ended_at: self.audio_aggregation_ended_at,
                configuration: self.configuration,
                decision: self.decision,
                reasons: self.reasons,
                risk_details: self.risk_details,
            }
        }
    }
}

/// <p>Details regarding various fraud risk analyses performed against the current session state and streamed audio of the speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FraudRiskDetails {
    /// <p>The details resulting from 'Known Fraudster Risk' analysis of the speaker.</p>
    #[doc(hidden)]
    pub known_fraudster_risk: std::option::Option<crate::model::KnownFraudsterRisk>,
    /// <p>The details resulting from 'Voice Spoofing Risk' analysis of the speaker.</p>
    #[doc(hidden)]
    pub voice_spoofing_risk: std::option::Option<crate::model::VoiceSpoofingRisk>,
}
impl FraudRiskDetails {
    /// <p>The details resulting from 'Known Fraudster Risk' analysis of the speaker.</p>
    pub fn known_fraudster_risk(&self) -> std::option::Option<&crate::model::KnownFraudsterRisk> {
        self.known_fraudster_risk.as_ref()
    }
    /// <p>The details resulting from 'Voice Spoofing Risk' analysis of the speaker.</p>
    pub fn voice_spoofing_risk(&self) -> std::option::Option<&crate::model::VoiceSpoofingRisk> {
        self.voice_spoofing_risk.as_ref()
    }
}
impl FraudRiskDetails {
    /// Creates a new builder-style object to manufacture [`FraudRiskDetails`](crate::model::FraudRiskDetails).
    pub fn builder() -> crate::model::fraud_risk_details::Builder {
        crate::model::fraud_risk_details::Builder::default()
    }
}

/// See [`FraudRiskDetails`](crate::model::FraudRiskDetails).
pub mod fraud_risk_details {

    /// A builder for [`FraudRiskDetails`](crate::model::FraudRiskDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) known_fraudster_risk: std::option::Option<crate::model::KnownFraudsterRisk>,
        pub(crate) voice_spoofing_risk: std::option::Option<crate::model::VoiceSpoofingRisk>,
    }
    impl Builder {
        /// <p>The details resulting from 'Known Fraudster Risk' analysis of the speaker.</p>
        pub fn known_fraudster_risk(mut self, input: crate::model::KnownFraudsterRisk) -> Self {
            self.known_fraudster_risk = Some(input);
            self
        }
        /// <p>The details resulting from 'Known Fraudster Risk' analysis of the speaker.</p>
        pub fn set_known_fraudster_risk(
            mut self,
            input: std::option::Option<crate::model::KnownFraudsterRisk>,
        ) -> Self {
            self.known_fraudster_risk = input;
            self
        }
        /// <p>The details resulting from 'Voice Spoofing Risk' analysis of the speaker.</p>
        pub fn voice_spoofing_risk(mut self, input: crate::model::VoiceSpoofingRisk) -> Self {
            self.voice_spoofing_risk = Some(input);
            self
        }
        /// <p>The details resulting from 'Voice Spoofing Risk' analysis of the speaker.</p>
        pub fn set_voice_spoofing_risk(
            mut self,
            input: std::option::Option<crate::model::VoiceSpoofingRisk>,
        ) -> Self {
            self.voice_spoofing_risk = input;
            self
        }
        /// Consumes the builder and constructs a [`FraudRiskDetails`](crate::model::FraudRiskDetails).
        pub fn build(self) -> crate::model::FraudRiskDetails {
            crate::model::FraudRiskDetails {
                known_fraudster_risk: self.known_fraudster_risk,
                voice_spoofing_risk: self.voice_spoofing_risk,
            }
        }
    }
}

/// <p>The details resulting from 'Voice Spoofing Risk' analysis of the speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VoiceSpoofingRisk {
    /// <p>The score indicating the likelihood of speaker’s voice being spoofed.</p>
    #[doc(hidden)]
    pub risk_score: std::option::Option<i32>,
}
impl VoiceSpoofingRisk {
    /// <p>The score indicating the likelihood of speaker’s voice being spoofed.</p>
    pub fn risk_score(&self) -> std::option::Option<i32> {
        self.risk_score
    }
}
impl VoiceSpoofingRisk {
    /// Creates a new builder-style object to manufacture [`VoiceSpoofingRisk`](crate::model::VoiceSpoofingRisk).
    pub fn builder() -> crate::model::voice_spoofing_risk::Builder {
        crate::model::voice_spoofing_risk::Builder::default()
    }
}

/// See [`VoiceSpoofingRisk`](crate::model::VoiceSpoofingRisk).
pub mod voice_spoofing_risk {

    /// A builder for [`VoiceSpoofingRisk`](crate::model::VoiceSpoofingRisk).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) risk_score: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The score indicating the likelihood of speaker’s voice being spoofed.</p>
        pub fn risk_score(mut self, input: i32) -> Self {
            self.risk_score = Some(input);
            self
        }
        /// <p>The score indicating the likelihood of speaker’s voice being spoofed.</p>
        pub fn set_risk_score(mut self, input: std::option::Option<i32>) -> Self {
            self.risk_score = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceSpoofingRisk`](crate::model::VoiceSpoofingRisk).
        pub fn build(self) -> crate::model::VoiceSpoofingRisk {
            crate::model::VoiceSpoofingRisk {
                risk_score: self.risk_score,
            }
        }
    }
}

/// <p>Contains details produced as a result of performing known fraudster risk analysis on a speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KnownFraudsterRisk {
    /// <p>The score indicating the likelihood the speaker is a known fraudster.</p>
    #[doc(hidden)]
    pub risk_score: std::option::Option<i32>,
    /// <p>The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is <code>null</code>.</p>
    #[doc(hidden)]
    pub generated_fraudster_id: std::option::Option<std::string::String>,
}
impl KnownFraudsterRisk {
    /// <p>The score indicating the likelihood the speaker is a known fraudster.</p>
    pub fn risk_score(&self) -> std::option::Option<i32> {
        self.risk_score
    }
    /// <p>The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is <code>null</code>.</p>
    pub fn generated_fraudster_id(&self) -> std::option::Option<&str> {
        self.generated_fraudster_id.as_deref()
    }
}
impl KnownFraudsterRisk {
    /// Creates a new builder-style object to manufacture [`KnownFraudsterRisk`](crate::model::KnownFraudsterRisk).
    pub fn builder() -> crate::model::known_fraudster_risk::Builder {
        crate::model::known_fraudster_risk::Builder::default()
    }
}

/// See [`KnownFraudsterRisk`](crate::model::KnownFraudsterRisk).
pub mod known_fraudster_risk {

    /// A builder for [`KnownFraudsterRisk`](crate::model::KnownFraudsterRisk).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) risk_score: std::option::Option<i32>,
        pub(crate) generated_fraudster_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The score indicating the likelihood the speaker is a known fraudster.</p>
        pub fn risk_score(mut self, input: i32) -> Self {
            self.risk_score = Some(input);
            self
        }
        /// <p>The score indicating the likelihood the speaker is a known fraudster.</p>
        pub fn set_risk_score(mut self, input: std::option::Option<i32>) -> Self {
            self.risk_score = input;
            self
        }
        /// <p>The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is <code>null</code>.</p>
        pub fn generated_fraudster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_fraudster_id = Some(input.into());
            self
        }
        /// <p>The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is <code>null</code>.</p>
        pub fn set_generated_fraudster_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_fraudster_id = input;
            self
        }
        /// Consumes the builder and constructs a [`KnownFraudsterRisk`](crate::model::KnownFraudsterRisk).
        pub fn build(self) -> crate::model::KnownFraudsterRisk {
            crate::model::KnownFraudsterRisk {
                risk_score: self.risk_score,
                generated_fraudster_id: self.generated_fraudster_id,
            }
        }
    }
}

/// When writing a match expression against `FraudDetectionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let frauddetectionreason = unimplemented!();
/// match frauddetectionreason {
///     FraudDetectionReason::KnownFraudster => { /* ... */ },
///     FraudDetectionReason::VoiceSpoofing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `frauddetectionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FraudDetectionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FraudDetectionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FraudDetectionReason::NewFeature` is defined.
/// Specifically, when `frauddetectionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FraudDetectionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FraudDetectionReason {
    #[allow(missing_docs)] // documentation missing in model
    KnownFraudster,
    #[allow(missing_docs)] // documentation missing in model
    VoiceSpoofing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FraudDetectionReason {
    fn from(s: &str) -> Self {
        match s {
            "KNOWN_FRAUDSTER" => FraudDetectionReason::KnownFraudster,
            "VOICE_SPOOFING" => FraudDetectionReason::VoiceSpoofing,
            other => {
                FraudDetectionReason::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FraudDetectionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FraudDetectionReason::from(s))
    }
}
impl FraudDetectionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FraudDetectionReason::KnownFraudster => "KNOWN_FRAUDSTER",
            FraudDetectionReason::VoiceSpoofing => "VOICE_SPOOFING",
            FraudDetectionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["KNOWN_FRAUDSTER", "VOICE_SPOOFING"]
    }
}
impl AsRef<str> for FraudDetectionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FraudDetectionDecision`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let frauddetectiondecision = unimplemented!();
/// match frauddetectiondecision {
///     FraudDetectionDecision::HighRisk => { /* ... */ },
///     FraudDetectionDecision::LowRisk => { /* ... */ },
///     FraudDetectionDecision::NotEnoughSpeech => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `frauddetectiondecision` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FraudDetectionDecision::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FraudDetectionDecision::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FraudDetectionDecision::NewFeature` is defined.
/// Specifically, when `frauddetectiondecision` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FraudDetectionDecision::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FraudDetectionDecision {
    #[allow(missing_docs)] // documentation missing in model
    HighRisk,
    #[allow(missing_docs)] // documentation missing in model
    LowRisk,
    #[allow(missing_docs)] // documentation missing in model
    NotEnoughSpeech,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FraudDetectionDecision {
    fn from(s: &str) -> Self {
        match s {
            "HIGH_RISK" => FraudDetectionDecision::HighRisk,
            "LOW_RISK" => FraudDetectionDecision::LowRisk,
            "NOT_ENOUGH_SPEECH" => FraudDetectionDecision::NotEnoughSpeech,
            other => {
                FraudDetectionDecision::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FraudDetectionDecision {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FraudDetectionDecision::from(s))
    }
}
impl FraudDetectionDecision {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FraudDetectionDecision::HighRisk => "HIGH_RISK",
            FraudDetectionDecision::LowRisk => "LOW_RISK",
            FraudDetectionDecision::NotEnoughSpeech => "NOT_ENOUGH_SPEECH",
            FraudDetectionDecision::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["HIGH_RISK", "LOW_RISK", "NOT_ENOUGH_SPEECH"]
    }
}
impl AsRef<str> for FraudDetectionDecision {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration used for performing fraud detection over a speaker during a session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FraudDetectionConfiguration {
    /// <p>Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.</p>
    #[doc(hidden)]
    pub risk_threshold: std::option::Option<i32>,
}
impl FraudDetectionConfiguration {
    /// <p>Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.</p>
    pub fn risk_threshold(&self) -> std::option::Option<i32> {
        self.risk_threshold
    }
}
impl FraudDetectionConfiguration {
    /// Creates a new builder-style object to manufacture [`FraudDetectionConfiguration`](crate::model::FraudDetectionConfiguration).
    pub fn builder() -> crate::model::fraud_detection_configuration::Builder {
        crate::model::fraud_detection_configuration::Builder::default()
    }
}

/// See [`FraudDetectionConfiguration`](crate::model::FraudDetectionConfiguration).
pub mod fraud_detection_configuration {

    /// A builder for [`FraudDetectionConfiguration`](crate::model::FraudDetectionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) risk_threshold: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.</p>
        pub fn risk_threshold(mut self, input: i32) -> Self {
            self.risk_threshold = Some(input);
            self
        }
        /// <p>Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.</p>
        pub fn set_risk_threshold(mut self, input: std::option::Option<i32>) -> Self {
            self.risk_threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`FraudDetectionConfiguration`](crate::model::FraudDetectionConfiguration).
        pub fn build(self) -> crate::model::FraudDetectionConfiguration {
            crate::model::FraudDetectionConfiguration {
                risk_threshold: self.risk_threshold,
            }
        }
    }
}

/// <p>The authentication result produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthenticationResult {
    /// <p>The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, <code>AcceptanceThreshold</code> changes, or <code>SpeakerId</code> changes, Voice ID always returns cached Authentication Result for this API.</p>
    #[doc(hidden)]
    pub authentication_result_id: std::option::Option<std::string::String>,
    /// <p>A timestamp indicating when audio aggregation started for this authentication result.</p>
    #[doc(hidden)]
    pub audio_aggregation_started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp indicating when audio aggregation ended for this authentication result.</p>
    #[doc(hidden)]
    pub audio_aggregation_ended_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The client-provided identifier for the speaker whose authentication result is produced. Only present if a <code>SpeakerId</code> is provided for the session.</p>
    #[doc(hidden)]
    pub customer_speaker_id: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the speaker whose authentication result is produced.</p>
    #[doc(hidden)]
    pub generated_speaker_id: std::option::Option<std::string::String>,
    /// <p>The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    #[doc(hidden)]
    pub decision: std::option::Option<crate::model::AuthenticationDecision>,
    /// <p>The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either <code>ACCEPT</code> or <code>REJECT</code>.</p>
    #[doc(hidden)]
    pub score: std::option::Option<i32>,
    /// <p>The <code>AuthenticationConfiguration</code> used to generate this authentication result.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::AuthenticationConfiguration>,
}
impl AuthenticationResult {
    /// <p>The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, <code>AcceptanceThreshold</code> changes, or <code>SpeakerId</code> changes, Voice ID always returns cached Authentication Result for this API.</p>
    pub fn authentication_result_id(&self) -> std::option::Option<&str> {
        self.authentication_result_id.as_deref()
    }
    /// <p>A timestamp indicating when audio aggregation started for this authentication result.</p>
    pub fn audio_aggregation_started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.audio_aggregation_started_at.as_ref()
    }
    /// <p>A timestamp indicating when audio aggregation ended for this authentication result.</p>
    pub fn audio_aggregation_ended_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.audio_aggregation_ended_at.as_ref()
    }
    /// <p>The client-provided identifier for the speaker whose authentication result is produced. Only present if a <code>SpeakerId</code> is provided for the session.</p>
    pub fn customer_speaker_id(&self) -> std::option::Option<&str> {
        self.customer_speaker_id.as_deref()
    }
    /// <p>The service-generated identifier for the speaker whose authentication result is produced.</p>
    pub fn generated_speaker_id(&self) -> std::option::Option<&str> {
        self.generated_speaker_id.as_deref()
    }
    /// <p>The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub fn decision(&self) -> std::option::Option<&crate::model::AuthenticationDecision> {
        self.decision.as_ref()
    }
    /// <p>The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either <code>ACCEPT</code> or <code>REJECT</code>.</p>
    pub fn score(&self) -> std::option::Option<i32> {
        self.score
    }
    /// <p>The <code>AuthenticationConfiguration</code> used to generate this authentication result.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::AuthenticationConfiguration> {
        self.configuration.as_ref()
    }
}
impl std::fmt::Debug for AuthenticationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthenticationResult");
        formatter.field("authentication_result_id", &self.authentication_result_id);
        formatter.field(
            "audio_aggregation_started_at",
            &self.audio_aggregation_started_at,
        );
        formatter.field(
            "audio_aggregation_ended_at",
            &self.audio_aggregation_ended_at,
        );
        formatter.field("customer_speaker_id", &"*** Sensitive Data Redacted ***");
        formatter.field("generated_speaker_id", &self.generated_speaker_id);
        formatter.field("decision", &self.decision);
        formatter.field("score", &self.score);
        formatter.field("configuration", &self.configuration);
        formatter.finish()
    }
}
impl AuthenticationResult {
    /// Creates a new builder-style object to manufacture [`AuthenticationResult`](crate::model::AuthenticationResult).
    pub fn builder() -> crate::model::authentication_result::Builder {
        crate::model::authentication_result::Builder::default()
    }
}

/// See [`AuthenticationResult`](crate::model::AuthenticationResult).
pub mod authentication_result {

    /// A builder for [`AuthenticationResult`](crate::model::AuthenticationResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) authentication_result_id: std::option::Option<std::string::String>,
        pub(crate) audio_aggregation_started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) audio_aggregation_ended_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) customer_speaker_id: std::option::Option<std::string::String>,
        pub(crate) generated_speaker_id: std::option::Option<std::string::String>,
        pub(crate) decision: std::option::Option<crate::model::AuthenticationDecision>,
        pub(crate) score: std::option::Option<i32>,
        pub(crate) configuration: std::option::Option<crate::model::AuthenticationConfiguration>,
    }
    impl Builder {
        /// <p>The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, <code>AcceptanceThreshold</code> changes, or <code>SpeakerId</code> changes, Voice ID always returns cached Authentication Result for this API.</p>
        pub fn authentication_result_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.authentication_result_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, <code>AcceptanceThreshold</code> changes, or <code>SpeakerId</code> changes, Voice ID always returns cached Authentication Result for this API.</p>
        pub fn set_authentication_result_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_result_id = input;
            self
        }
        /// <p>A timestamp indicating when audio aggregation started for this authentication result.</p>
        pub fn audio_aggregation_started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.audio_aggregation_started_at = Some(input);
            self
        }
        /// <p>A timestamp indicating when audio aggregation started for this authentication result.</p>
        pub fn set_audio_aggregation_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.audio_aggregation_started_at = input;
            self
        }
        /// <p>A timestamp indicating when audio aggregation ended for this authentication result.</p>
        pub fn audio_aggregation_ended_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.audio_aggregation_ended_at = Some(input);
            self
        }
        /// <p>A timestamp indicating when audio aggregation ended for this authentication result.</p>
        pub fn set_audio_aggregation_ended_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.audio_aggregation_ended_at = input;
            self
        }
        /// <p>The client-provided identifier for the speaker whose authentication result is produced. Only present if a <code>SpeakerId</code> is provided for the session.</p>
        pub fn customer_speaker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_speaker_id = Some(input.into());
            self
        }
        /// <p>The client-provided identifier for the speaker whose authentication result is produced. Only present if a <code>SpeakerId</code> is provided for the session.</p>
        pub fn set_customer_speaker_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_speaker_id = input;
            self
        }
        /// <p>The service-generated identifier for the speaker whose authentication result is produced.</p>
        pub fn generated_speaker_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_speaker_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the speaker whose authentication result is produced.</p>
        pub fn set_generated_speaker_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_speaker_id = input;
            self
        }
        /// <p>The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
        pub fn decision(mut self, input: crate::model::AuthenticationDecision) -> Self {
            self.decision = Some(input);
            self
        }
        /// <p>The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
        pub fn set_decision(
            mut self,
            input: std::option::Option<crate::model::AuthenticationDecision>,
        ) -> Self {
            self.decision = input;
            self
        }
        /// <p>The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either <code>ACCEPT</code> or <code>REJECT</code>.</p>
        pub fn score(mut self, input: i32) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either <code>ACCEPT</code> or <code>REJECT</code>.</p>
        pub fn set_score(mut self, input: std::option::Option<i32>) -> Self {
            self.score = input;
            self
        }
        /// <p>The <code>AuthenticationConfiguration</code> used to generate this authentication result.</p>
        pub fn configuration(mut self, input: crate::model::AuthenticationConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The <code>AuthenticationConfiguration</code> used to generate this authentication result.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::AuthenticationConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationResult`](crate::model::AuthenticationResult).
        pub fn build(self) -> crate::model::AuthenticationResult {
            crate::model::AuthenticationResult {
                authentication_result_id: self.authentication_result_id,
                audio_aggregation_started_at: self.audio_aggregation_started_at,
                audio_aggregation_ended_at: self.audio_aggregation_ended_at,
                customer_speaker_id: self.customer_speaker_id,
                generated_speaker_id: self.generated_speaker_id,
                decision: self.decision,
                score: self.score,
                configuration: self.configuration,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("authentication_result_id", &self.authentication_result_id);
            formatter.field(
                "audio_aggregation_started_at",
                &self.audio_aggregation_started_at,
            );
            formatter.field(
                "audio_aggregation_ended_at",
                &self.audio_aggregation_ended_at,
            );
            formatter.field("customer_speaker_id", &"*** Sensitive Data Redacted ***");
            formatter.field("generated_speaker_id", &self.generated_speaker_id);
            formatter.field("decision", &self.decision);
            formatter.field("score", &self.score);
            formatter.field("configuration", &self.configuration);
            formatter.finish()
        }
    }
}

/// <p>The configuration used to authenticate a speaker during a session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthenticationConfiguration {
    /// <p>The minimum threshold needed to successfully authenticate a speaker.</p>
    #[doc(hidden)]
    pub acceptance_threshold: std::option::Option<i32>,
}
impl AuthenticationConfiguration {
    /// <p>The minimum threshold needed to successfully authenticate a speaker.</p>
    pub fn acceptance_threshold(&self) -> std::option::Option<i32> {
        self.acceptance_threshold
    }
}
impl AuthenticationConfiguration {
    /// Creates a new builder-style object to manufacture [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
    pub fn builder() -> crate::model::authentication_configuration::Builder {
        crate::model::authentication_configuration::Builder::default()
    }
}

/// See [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
pub mod authentication_configuration {

    /// A builder for [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) acceptance_threshold: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The minimum threshold needed to successfully authenticate a speaker.</p>
        pub fn acceptance_threshold(mut self, input: i32) -> Self {
            self.acceptance_threshold = Some(input);
            self
        }
        /// <p>The minimum threshold needed to successfully authenticate a speaker.</p>
        pub fn set_acceptance_threshold(mut self, input: std::option::Option<i32>) -> Self {
            self.acceptance_threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationConfiguration`](crate::model::AuthenticationConfiguration).
        pub fn build(self) -> crate::model::AuthenticationConfiguration {
            crate::model::AuthenticationConfiguration {
                acceptance_threshold: self.acceptance_threshold,
            }
        }
    }
}

/// When writing a match expression against `AuthenticationDecision`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let authenticationdecision = unimplemented!();
/// match authenticationdecision {
///     AuthenticationDecision::Accept => { /* ... */ },
///     AuthenticationDecision::NotEnoughSpeech => { /* ... */ },
///     AuthenticationDecision::Reject => { /* ... */ },
///     AuthenticationDecision::SpeakerExpired => { /* ... */ },
///     AuthenticationDecision::SpeakerIdNotProvided => { /* ... */ },
///     AuthenticationDecision::SpeakerNotEnrolled => { /* ... */ },
///     AuthenticationDecision::SpeakerOptedOut => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `authenticationdecision` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AuthenticationDecision::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AuthenticationDecision::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AuthenticationDecision::NewFeature` is defined.
/// Specifically, when `authenticationdecision` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AuthenticationDecision::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthenticationDecision {
    #[allow(missing_docs)] // documentation missing in model
    Accept,
    #[allow(missing_docs)] // documentation missing in model
    NotEnoughSpeech,
    #[allow(missing_docs)] // documentation missing in model
    Reject,
    #[allow(missing_docs)] // documentation missing in model
    SpeakerExpired,
    #[allow(missing_docs)] // documentation missing in model
    SpeakerIdNotProvided,
    #[allow(missing_docs)] // documentation missing in model
    SpeakerNotEnrolled,
    #[allow(missing_docs)] // documentation missing in model
    SpeakerOptedOut,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AuthenticationDecision {
    fn from(s: &str) -> Self {
        match s {
            "ACCEPT" => AuthenticationDecision::Accept,
            "NOT_ENOUGH_SPEECH" => AuthenticationDecision::NotEnoughSpeech,
            "REJECT" => AuthenticationDecision::Reject,
            "SPEAKER_EXPIRED" => AuthenticationDecision::SpeakerExpired,
            "SPEAKER_ID_NOT_PROVIDED" => AuthenticationDecision::SpeakerIdNotProvided,
            "SPEAKER_NOT_ENROLLED" => AuthenticationDecision::SpeakerNotEnrolled,
            "SPEAKER_OPTED_OUT" => AuthenticationDecision::SpeakerOptedOut,
            other => {
                AuthenticationDecision::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AuthenticationDecision {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthenticationDecision::from(s))
    }
}
impl AuthenticationDecision {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthenticationDecision::Accept => "ACCEPT",
            AuthenticationDecision::NotEnoughSpeech => "NOT_ENOUGH_SPEECH",
            AuthenticationDecision::Reject => "REJECT",
            AuthenticationDecision::SpeakerExpired => "SPEAKER_EXPIRED",
            AuthenticationDecision::SpeakerIdNotProvided => "SPEAKER_ID_NOT_PROVIDED",
            AuthenticationDecision::SpeakerNotEnrolled => "SPEAKER_NOT_ENROLLED",
            AuthenticationDecision::SpeakerOptedOut => "SPEAKER_OPTED_OUT",
            AuthenticationDecision::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCEPT",
            "NOT_ENOUGH_SPEECH",
            "REJECT",
            "SPEAKER_EXPIRED",
            "SPEAKER_ID_NOT_PROVIDED",
            "SPEAKER_NOT_ENROLLED",
            "SPEAKER_OPTED_OUT",
        ]
    }
}
impl AsRef<str> for AuthenticationDecision {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StreamingStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingstatus = unimplemented!();
/// match streamingstatus {
///     StreamingStatus::Ended => { /* ... */ },
///     StreamingStatus::Ongoing => { /* ... */ },
///     StreamingStatus::PendingConfiguration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingStatus::NewFeature` is defined.
/// Specifically, when `streamingstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingStatus {
    #[allow(missing_docs)] // documentation missing in model
    Ended,
    #[allow(missing_docs)] // documentation missing in model
    Ongoing,
    #[allow(missing_docs)] // documentation missing in model
    PendingConfiguration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingStatus {
    fn from(s: &str) -> Self {
        match s {
            "ENDED" => StreamingStatus::Ended,
            "ONGOING" => StreamingStatus::Ongoing,
            "PENDING_CONFIGURATION" => StreamingStatus::PendingConfiguration,
            other => StreamingStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StreamingStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingStatus::from(s))
    }
}
impl StreamingStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingStatus::Ended => "ENDED",
            StreamingStatus::Ongoing => "ONGOING",
            StreamingStatus::PendingConfiguration => "PENDING_CONFIGURATION",
            StreamingStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENDED", "ONGOING", "PENDING_CONFIGURATION"]
    }
}
impl AsRef<str> for StreamingStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains all the information about a fraudster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Fraudster {
    /// <p>The identifier for the domain containing the fraudster.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier for the fraudster.</p>
    #[doc(hidden)]
    pub generated_fraudster_id: std::option::Option<std::string::String>,
    /// <p>The timestamp when Voice ID identified the fraudster.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Fraudster {
    /// <p>The identifier for the domain containing the fraudster.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The service-generated identifier for the fraudster.</p>
    pub fn generated_fraudster_id(&self) -> std::option::Option<&str> {
        self.generated_fraudster_id.as_deref()
    }
    /// <p>The timestamp when Voice ID identified the fraudster.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
impl Fraudster {
    /// Creates a new builder-style object to manufacture [`Fraudster`](crate::model::Fraudster).
    pub fn builder() -> crate::model::fraudster::Builder {
        crate::model::fraudster::Builder::default()
    }
}

/// See [`Fraudster`](crate::model::Fraudster).
pub mod fraudster {

    /// A builder for [`Fraudster`](crate::model::Fraudster).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) generated_fraudster_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier for the domain containing the fraudster.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The identifier for the domain containing the fraudster.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The service-generated identifier for the fraudster.</p>
        pub fn generated_fraudster_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.generated_fraudster_id = Some(input.into());
            self
        }
        /// <p>The service-generated identifier for the fraudster.</p>
        pub fn set_generated_fraudster_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generated_fraudster_id = input;
            self
        }
        /// <p>The timestamp when Voice ID identified the fraudster.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when Voice ID identified the fraudster.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Fraudster`](crate::model::Fraudster).
        pub fn build(self) -> crate::model::Fraudster {
            crate::model::Fraudster {
                domain_id: self.domain_id,
                generated_fraudster_id: self.generated_fraudster_id,
                created_at: self.created_at,
            }
        }
    }
}
