// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluateSessionOutput {
    /// <p>The identifier of the domain containing the session.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The service-generated identifier of the session.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The client-provided name of the session.</p>
    #[doc(hidden)]
    pub session_name: std::option::Option<std::string::String>,
    /// <p>The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is <code>NOT_ENOUGH_SPEECH</code>. In this situation, if the <code>StreamingStatus</code> is <code>ONGOING/PENDING_CONFIGURATION</code>, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains <code>NOT_ENOUGH_SPEECH</code> even after <code>StreamingStatus</code> is <code>ENDED</code>, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.</p>
    #[doc(hidden)]
    pub streaming_status: std::option::Option<crate::types::StreamingStatus>,
    /// <p>Details resulting from the authentication process, such as authentication decision and authentication score.</p>
    #[doc(hidden)]
    pub authentication_result: std::option::Option<crate::types::AuthenticationResult>,
    /// <p>Details resulting from the fraud detection process, such as fraud detection decision and risk score.</p>
    #[doc(hidden)]
    pub fraud_detection_result: std::option::Option<crate::types::FraudDetectionResult>,
    _request_id: Option<String>,
}
impl EvaluateSessionOutput {
    /// <p>The identifier of the domain containing the session.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The service-generated identifier of the session.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The client-provided name of the session.</p>
    pub fn session_name(&self) -> std::option::Option<&str> {
        self.session_name.as_deref()
    }
    /// <p>The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is <code>NOT_ENOUGH_SPEECH</code>. In this situation, if the <code>StreamingStatus</code> is <code>ONGOING/PENDING_CONFIGURATION</code>, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains <code>NOT_ENOUGH_SPEECH</code> even after <code>StreamingStatus</code> is <code>ENDED</code>, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.</p>
    pub fn streaming_status(&self) -> std::option::Option<&crate::types::StreamingStatus> {
        self.streaming_status.as_ref()
    }
    /// <p>Details resulting from the authentication process, such as authentication decision and authentication score.</p>
    pub fn authentication_result(
        &self,
    ) -> std::option::Option<&crate::types::AuthenticationResult> {
        self.authentication_result.as_ref()
    }
    /// <p>Details resulting from the fraud detection process, such as fraud detection decision and risk score.</p>
    pub fn fraud_detection_result(
        &self,
    ) -> std::option::Option<&crate::types::FraudDetectionResult> {
        self.fraud_detection_result.as_ref()
    }
}
impl aws_http::request_id::RequestId for EvaluateSessionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl EvaluateSessionOutput {
    /// Creates a new builder-style object to manufacture [`EvaluateSessionOutput`](crate::operation::evaluate_session::EvaluateSessionOutput).
    pub fn builder() -> crate::operation::evaluate_session::builders::EvaluateSessionOutputBuilder {
        crate::operation::evaluate_session::builders::EvaluateSessionOutputBuilder::default()
    }
}

/// A builder for [`EvaluateSessionOutput`](crate::operation::evaluate_session::EvaluateSessionOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct EvaluateSessionOutputBuilder {
    pub(crate) domain_id: std::option::Option<std::string::String>,
    pub(crate) session_id: std::option::Option<std::string::String>,
    pub(crate) session_name: std::option::Option<std::string::String>,
    pub(crate) streaming_status: std::option::Option<crate::types::StreamingStatus>,
    pub(crate) authentication_result: std::option::Option<crate::types::AuthenticationResult>,
    pub(crate) fraud_detection_result: std::option::Option<crate::types::FraudDetectionResult>,
    _request_id: Option<String>,
}
impl EvaluateSessionOutputBuilder {
    /// <p>The identifier of the domain containing the session.</p>
    pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.domain_id = Some(input.into());
        self
    }
    /// <p>The identifier of the domain containing the session.</p>
    pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.domain_id = input;
        self
    }
    /// <p>The service-generated identifier of the session.</p>
    pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.session_id = Some(input.into());
        self
    }
    /// <p>The service-generated identifier of the session.</p>
    pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.session_id = input;
        self
    }
    /// <p>The client-provided name of the session.</p>
    pub fn session_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.session_name = Some(input.into());
        self
    }
    /// <p>The client-provided name of the session.</p>
    pub fn set_session_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.session_name = input;
        self
    }
    /// <p>The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is <code>NOT_ENOUGH_SPEECH</code>. In this situation, if the <code>StreamingStatus</code> is <code>ONGOING/PENDING_CONFIGURATION</code>, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains <code>NOT_ENOUGH_SPEECH</code> even after <code>StreamingStatus</code> is <code>ENDED</code>, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.</p>
    pub fn streaming_status(mut self, input: crate::types::StreamingStatus) -> Self {
        self.streaming_status = Some(input);
        self
    }
    /// <p>The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is <code>NOT_ENOUGH_SPEECH</code>. In this situation, if the <code>StreamingStatus</code> is <code>ONGOING/PENDING_CONFIGURATION</code>, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains <code>NOT_ENOUGH_SPEECH</code> even after <code>StreamingStatus</code> is <code>ENDED</code>, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.</p>
    pub fn set_streaming_status(
        mut self,
        input: std::option::Option<crate::types::StreamingStatus>,
    ) -> Self {
        self.streaming_status = input;
        self
    }
    /// <p>Details resulting from the authentication process, such as authentication decision and authentication score.</p>
    pub fn authentication_result(mut self, input: crate::types::AuthenticationResult) -> Self {
        self.authentication_result = Some(input);
        self
    }
    /// <p>Details resulting from the authentication process, such as authentication decision and authentication score.</p>
    pub fn set_authentication_result(
        mut self,
        input: std::option::Option<crate::types::AuthenticationResult>,
    ) -> Self {
        self.authentication_result = input;
        self
    }
    /// <p>Details resulting from the fraud detection process, such as fraud detection decision and risk score.</p>
    pub fn fraud_detection_result(mut self, input: crate::types::FraudDetectionResult) -> Self {
        self.fraud_detection_result = Some(input);
        self
    }
    /// <p>Details resulting from the fraud detection process, such as fraud detection decision and risk score.</p>
    pub fn set_fraud_detection_result(
        mut self,
        input: std::option::Option<crate::types::FraudDetectionResult>,
    ) -> Self {
        self.fraud_detection_result = input;
        self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`EvaluateSessionOutput`](crate::operation::evaluate_session::EvaluateSessionOutput).
    pub fn build(self) -> crate::operation::evaluate_session::EvaluateSessionOutput {
        crate::operation::evaluate_session::EvaluateSessionOutput {
            domain_id: self.domain_id,
            session_id: self.session_id,
            session_name: self.session_name,
            streaming_status: self.streaming_status,
            authentication_result: self.authentication_result,
            fraud_detection_result: self.fraud_detection_result,
            _request_id: self._request_id,
        }
    }
}
