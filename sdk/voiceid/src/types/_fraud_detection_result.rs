// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The fraud detection result produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct FraudDetectionResult  {
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    pub fraud_detection_result_id: ::std::option::Option<::std::string::String>,
    /// <p>A timestamp of when audio aggregation started for this fraud detection result.</p>
    pub audio_aggregation_started_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>A timestamp of when audio aggregation ended for this fraud detection result.</p>
    pub audio_aggregation_ended_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    pub configuration: ::std::option::Option<crate::types::FraudDetectionConfiguration>,
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub decision: ::std::option::Option<crate::types::FraudDetectionDecision>,
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    pub reasons: ::std::option::Option<::std::vec::Vec::<crate::types::FraudDetectionReason>>,
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    pub risk_details: ::std::option::Option<crate::types::FraudRiskDetails>,
}
impl  FraudDetectionResult  {
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    pub fn fraud_detection_result_id(&self) -> ::std::option::Option<& str> {
        self.fraud_detection_result_id.as_deref()
    }
    /// <p>A timestamp of when audio aggregation started for this fraud detection result.</p>
    pub fn audio_aggregation_started_at(&self) -> ::std::option::Option<& ::aws_smithy_types::DateTime> {
        self.audio_aggregation_started_at.as_ref()
    }
    /// <p>A timestamp of when audio aggregation ended for this fraud detection result.</p>
    pub fn audio_aggregation_ended_at(&self) -> ::std::option::Option<& ::aws_smithy_types::DateTime> {
        self.audio_aggregation_ended_at.as_ref()
    }
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    pub fn configuration(&self) -> ::std::option::Option<& crate::types::FraudDetectionConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub fn decision(&self) -> ::std::option::Option<& crate::types::FraudDetectionDecision> {
        self.decision.as_ref()
    }
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    /// 
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.reasons.is_none()`.
    pub fn reasons(&self) -> & [crate::types::FraudDetectionReason] {
        self.reasons.as_deref()
        .unwrap_or_default()
    }
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    pub fn risk_details(&self) -> ::std::option::Option<& crate::types::FraudRiskDetails> {
        self.risk_details.as_ref()
    }
}
impl FraudDetectionResult {
    /// Creates a new builder-style object to manufacture [`FraudDetectionResult`](crate::types::FraudDetectionResult).
    pub fn builder() -> crate::types::builders::FraudDetectionResultBuilder {
        crate::types::builders::FraudDetectionResultBuilder::default()
    }
}

/// A builder for [`FraudDetectionResult`](crate::types::FraudDetectionResult).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct FraudDetectionResultBuilder {
    pub(crate) fraud_detection_result_id: ::std::option::Option<::std::string::String>,
    pub(crate) audio_aggregation_started_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) audio_aggregation_ended_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) configuration: ::std::option::Option<crate::types::FraudDetectionConfiguration>,
    pub(crate) decision: ::std::option::Option<crate::types::FraudDetectionDecision>,
    pub(crate) reasons: ::std::option::Option<::std::vec::Vec::<crate::types::FraudDetectionReason>>,
    pub(crate) risk_details: ::std::option::Option<crate::types::FraudRiskDetails>,
}
impl FraudDetectionResultBuilder {
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    pub fn fraud_detection_result_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.fraud_detection_result_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    pub fn set_fraud_detection_result_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.fraud_detection_result_id = input; self
    }
    /// <p>The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.</p>
    pub fn get_fraud_detection_result_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.fraud_detection_result_id
    }
    /// <p>A timestamp of when audio aggregation started for this fraud detection result.</p>
    pub fn audio_aggregation_started_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.audio_aggregation_started_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>A timestamp of when audio aggregation started for this fraud detection result.</p>
    pub fn set_audio_aggregation_started_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.audio_aggregation_started_at = input; self
    }
    /// <p>A timestamp of when audio aggregation started for this fraud detection result.</p>
    pub fn get_audio_aggregation_started_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.audio_aggregation_started_at
    }
    /// <p>A timestamp of when audio aggregation ended for this fraud detection result.</p>
    pub fn audio_aggregation_ended_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.audio_aggregation_ended_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>A timestamp of when audio aggregation ended for this fraud detection result.</p>
    pub fn set_audio_aggregation_ended_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.audio_aggregation_ended_at = input; self
    }
    /// <p>A timestamp of when audio aggregation ended for this fraud detection result.</p>
    pub fn get_audio_aggregation_ended_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.audio_aggregation_ended_at
    }
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    pub fn configuration(mut self, input: crate::types::FraudDetectionConfiguration) -> Self {
        self.configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    pub fn set_configuration(mut self, input: ::std::option::Option<crate::types::FraudDetectionConfiguration>) -> Self {
        self.configuration = input; self
    }
    /// <p>The <code>FraudDetectionConfiguration</code> used to generate this fraud detection result.</p>
    pub fn get_configuration(&self) -> &::std::option::Option<crate::types::FraudDetectionConfiguration> {
        &self.configuration
    }
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub fn decision(mut self, input: crate::types::FraudDetectionDecision) -> Self {
        self.decision = ::std::option::Option::Some(input);
        self
    }
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub fn set_decision(mut self, input: ::std::option::Option<crate::types::FraudDetectionDecision>) -> Self {
        self.decision = input; self
    }
    /// <p>The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.</p>
    pub fn get_decision(&self) -> &::std::option::Option<crate::types::FraudDetectionDecision> {
        &self.decision
    }
    /// Appends an item to `reasons`.
    ///
    /// To override the contents of this collection use [`set_reasons`](Self::set_reasons).
    ///
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    pub fn reasons(mut self, input: crate::types::FraudDetectionReason) -> Self {
        let mut v = self.reasons.unwrap_or_default();
                        v.push(input);
                        self.reasons = ::std::option::Option::Some(v);
                        self
    }
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    pub fn set_reasons(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::types::FraudDetectionReason>>) -> Self {
        self.reasons = input; self
    }
    /// <p>The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is <code>HIGH_RISK</code>, and the following possible values: <code>KNOWN_FRAUDSTER</code> and <code>VOICE_SPOOFING</code>.</p>
    pub fn get_reasons(&self) -> &::std::option::Option<::std::vec::Vec::<crate::types::FraudDetectionReason>> {
        &self.reasons
    }
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    pub fn risk_details(mut self, input: crate::types::FraudRiskDetails) -> Self {
        self.risk_details = ::std::option::Option::Some(input);
        self
    }
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    pub fn set_risk_details(mut self, input: ::std::option::Option<crate::types::FraudRiskDetails>) -> Self {
        self.risk_details = input; self
    }
    /// <p>Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.</p>
    pub fn get_risk_details(&self) -> &::std::option::Option<crate::types::FraudRiskDetails> {
        &self.risk_details
    }
    /// Consumes the builder and constructs a [`FraudDetectionResult`](crate::types::FraudDetectionResult).
    pub fn build(self) -> crate::types::FraudDetectionResult {
        crate::types::FraudDetectionResult {
            fraud_detection_result_id: self.fraud_detection_result_id
            ,
            audio_aggregation_started_at: self.audio_aggregation_started_at
            ,
            audio_aggregation_ended_at: self.audio_aggregation_ended_at
            ,
            configuration: self.configuration
            ,
            decision: self.decision
            ,
            reasons: self.reasons
            ,
            risk_details: self.risk_details
            ,
        }
    }
}

