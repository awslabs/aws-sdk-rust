// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutAlarmInput {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub alarm_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li>
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li>
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub metric_name: ::std::option::Option<crate::types::MetricName>,
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub monitored_resource_name: ::std::option::Option<::std::string::String>,
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub comparison_operator: ::std::option::Option<crate::types::ComparisonOperator>,
    /// <p>The value against which the specified statistic is compared.</p>
    pub threshold: ::std::option::Option<f64>,
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub evaluation_periods: ::std::option::Option<i32>,
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub datapoints_to_alarm: ::std::option::Option<i32>,
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li>
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub treat_missing_data: ::std::option::Option<crate::types::TreatMissingData>,
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub contact_protocols: ::std::option::Option<::std::vec::Vec<crate::types::ContactProtocol>>,
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li>
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li>
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub notification_triggers: ::std::option::Option<::std::vec::Vec<crate::types::AlarmState>>,
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub notification_enabled: ::std::option::Option<bool>,
}
impl PutAlarmInput {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub fn alarm_name(&self) -> ::std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li>
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li>
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn metric_name(&self) -> ::std::option::Option<&crate::types::MetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub fn monitored_resource_name(&self) -> ::std::option::Option<&str> {
        self.monitored_resource_name.as_deref()
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub fn comparison_operator(&self) -> ::std::option::Option<&crate::types::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn threshold(&self) -> ::std::option::Option<f64> {
        self.threshold
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub fn evaluation_periods(&self) -> ::std::option::Option<i32> {
        self.evaluation_periods
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn datapoints_to_alarm(&self) -> ::std::option::Option<i32> {
        self.datapoints_to_alarm
    }
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li>
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn treat_missing_data(&self) -> ::std::option::Option<&crate::types::TreatMissingData> {
        self.treat_missing_data.as_ref()
    }
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.contact_protocols.is_none()`.
    pub fn contact_protocols(&self) -> &[crate::types::ContactProtocol] {
        self.contact_protocols.as_deref().unwrap_or_default()
    }
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li>
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li>
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.notification_triggers.is_none()`.
    pub fn notification_triggers(&self) -> &[crate::types::AlarmState] {
        self.notification_triggers.as_deref().unwrap_or_default()
    }
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn notification_enabled(&self) -> ::std::option::Option<bool> {
        self.notification_enabled
    }
}
impl PutAlarmInput {
    /// Creates a new builder-style object to manufacture [`PutAlarmInput`](crate::operation::put_alarm::PutAlarmInput).
    pub fn builder() -> crate::operation::put_alarm::builders::PutAlarmInputBuilder {
        crate::operation::put_alarm::builders::PutAlarmInputBuilder::default()
    }
}

/// A builder for [`PutAlarmInput`](crate::operation::put_alarm::PutAlarmInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct PutAlarmInputBuilder {
    pub(crate) alarm_name: ::std::option::Option<::std::string::String>,
    pub(crate) metric_name: ::std::option::Option<crate::types::MetricName>,
    pub(crate) monitored_resource_name: ::std::option::Option<::std::string::String>,
    pub(crate) comparison_operator: ::std::option::Option<crate::types::ComparisonOperator>,
    pub(crate) threshold: ::std::option::Option<f64>,
    pub(crate) evaluation_periods: ::std::option::Option<i32>,
    pub(crate) datapoints_to_alarm: ::std::option::Option<i32>,
    pub(crate) treat_missing_data: ::std::option::Option<crate::types::TreatMissingData>,
    pub(crate) contact_protocols: ::std::option::Option<::std::vec::Vec<crate::types::ContactProtocol>>,
    pub(crate) notification_triggers: ::std::option::Option<::std::vec::Vec<crate::types::AlarmState>>,
    pub(crate) notification_enabled: ::std::option::Option<bool>,
}
impl PutAlarmInputBuilder {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    /// This field is required.
    pub fn alarm_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.alarm_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub fn set_alarm_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.alarm_name = input;
        self
    }
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub fn get_alarm_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.alarm_name
    }
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li>
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li>
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    /// This field is required.
    pub fn metric_name(mut self, input: crate::types::MetricName) -> Self {
        self.metric_name = ::std::option::Option::Some(input);
        self
    }
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li>
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li>
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn set_metric_name(mut self, input: ::std::option::Option<crate::types::MetricName>) -> Self {
        self.metric_name = input;
        self
    }
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li>
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li>
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn get_metric_name(&self) -> &::std::option::Option<crate::types::MetricName> {
        &self.metric_name
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    /// This field is required.
    pub fn monitored_resource_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.monitored_resource_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub fn set_monitored_resource_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.monitored_resource_name = input;
        self
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub fn get_monitored_resource_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.monitored_resource_name
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    /// This field is required.
    pub fn comparison_operator(mut self, input: crate::types::ComparisonOperator) -> Self {
        self.comparison_operator = ::std::option::Option::Some(input);
        self
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub fn set_comparison_operator(mut self, input: ::std::option::Option<crate::types::ComparisonOperator>) -> Self {
        self.comparison_operator = input;
        self
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub fn get_comparison_operator(&self) -> &::std::option::Option<crate::types::ComparisonOperator> {
        &self.comparison_operator
    }
    /// <p>The value against which the specified statistic is compared.</p>
    /// This field is required.
    pub fn threshold(mut self, input: f64) -> Self {
        self.threshold = ::std::option::Option::Some(input);
        self
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn set_threshold(mut self, input: ::std::option::Option<f64>) -> Self {
        self.threshold = input;
        self
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn get_threshold(&self) -> &::std::option::Option<f64> {
        &self.threshold
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    /// This field is required.
    pub fn evaluation_periods(mut self, input: i32) -> Self {
        self.evaluation_periods = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub fn set_evaluation_periods(mut self, input: ::std::option::Option<i32>) -> Self {
        self.evaluation_periods = input;
        self
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub fn get_evaluation_periods(&self) -> &::std::option::Option<i32> {
        &self.evaluation_periods
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
        self.datapoints_to_alarm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn set_datapoints_to_alarm(mut self, input: ::std::option::Option<i32>) -> Self {
        self.datapoints_to_alarm = input;
        self
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn get_datapoints_to_alarm(&self) -> &::std::option::Option<i32> {
        &self.datapoints_to_alarm
    }
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li>
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn treat_missing_data(mut self, input: crate::types::TreatMissingData) -> Self {
        self.treat_missing_data = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li>
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn set_treat_missing_data(mut self, input: ::std::option::Option<crate::types::TreatMissingData>) -> Self {
        self.treat_missing_data = input;
        self
    }
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li>
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li>
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn get_treat_missing_data(&self) -> &::std::option::Option<crate::types::TreatMissingData> {
        &self.treat_missing_data
    }
    /// Appends an item to `contact_protocols`.
    ///
    /// To override the contents of this collection use [`set_contact_protocols`](Self::set_contact_protocols).
    ///
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub fn contact_protocols(mut self, input: crate::types::ContactProtocol) -> Self {
        let mut v = self.contact_protocols.unwrap_or_default();
        v.push(input);
        self.contact_protocols = ::std::option::Option::Some(v);
        self
    }
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub fn set_contact_protocols(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ContactProtocol>>) -> Self {
        self.contact_protocols = input;
        self
    }
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub fn get_contact_protocols(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ContactProtocol>> {
        &self.contact_protocols
    }
    /// Appends an item to `notification_triggers`.
    ///
    /// To override the contents of this collection use [`set_notification_triggers`](Self::set_notification_triggers).
    ///
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li>
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li>
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub fn notification_triggers(mut self, input: crate::types::AlarmState) -> Self {
        let mut v = self.notification_triggers.unwrap_or_default();
        v.push(input);
        self.notification_triggers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li>
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li>
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub fn set_notification_triggers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AlarmState>>) -> Self {
        self.notification_triggers = input;
        self
    }
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li>
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li>
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub fn get_notification_triggers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AlarmState>> {
        &self.notification_triggers
    }
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn notification_enabled(mut self, input: bool) -> Self {
        self.notification_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn set_notification_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.notification_enabled = input;
        self
    }
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn get_notification_enabled(&self) -> &::std::option::Option<bool> {
        &self.notification_enabled
    }
    /// Consumes the builder and constructs a [`PutAlarmInput`](crate::operation::put_alarm::PutAlarmInput).
    pub fn build(self) -> ::std::result::Result<crate::operation::put_alarm::PutAlarmInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::put_alarm::PutAlarmInput {
            alarm_name: self.alarm_name,
            metric_name: self.metric_name,
            monitored_resource_name: self.monitored_resource_name,
            comparison_operator: self.comparison_operator,
            threshold: self.threshold,
            evaluation_periods: self.evaluation_periods,
            datapoints_to_alarm: self.datapoints_to_alarm,
            treat_missing_data: self.treat_missing_data,
            contact_protocols: self.contact_protocols,
            notification_triggers: self.notification_triggers,
            notification_enabled: self.notification_enabled,
        })
    }
}
