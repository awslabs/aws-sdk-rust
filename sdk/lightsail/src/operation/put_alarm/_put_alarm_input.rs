// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutAlarmInput  {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    #[doc(hidden)]
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The name of the metric to associate with the alarm.</p> 
    /// <p>You can configure up to two alarms per metric.</p> 
    /// <p>The following metrics are available for each resource type:</p> 
    /// <ul> 
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li> 
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li> 
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li> 
    /// </ul> 
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    #[doc(hidden)]
    pub metric_name: std::option::Option<crate::types::MetricName>,
    /// <p>The name of the Lightsail resource that will be monitored.</p> 
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    #[doc(hidden)]
    pub monitored_resource_name: std::option::Option<std::string::String>,
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    #[doc(hidden)]
    pub comparison_operator: std::option::Option<crate::types::ComparisonOperator>,
    /// <p>The value against which the specified statistic is compared.</p>
    #[doc(hidden)]
    pub threshold: std::option::Option<f64>,
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p> 
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p> 
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p> 
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    #[doc(hidden)]
    pub evaluation_periods: std::option::Option<i32>,
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    #[doc(hidden)]
    pub datapoints_to_alarm: std::option::Option<i32>,
    /// <p>Sets how this alarm will handle missing data points.</p> 
    /// <p>An alarm can treat missing data in the following ways:</p> 
    /// <ul> 
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li> 
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li> 
    /// </ul> 
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    #[doc(hidden)]
    pub treat_missing_data: std::option::Option<crate::types::TreatMissingData>,
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p> 
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p> 
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p> 
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub contact_protocols: std::option::Option<std::vec::Vec<crate::types::ContactProtocol>>,
    /// <p>The alarm states that trigger a notification.</p> 
    /// <p>An alarm has the following possible states:</p> 
    /// <ul> 
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li> 
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li> 
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li> 
    /// </ul> 
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p> 
    /// <ul> 
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li> 
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li> 
    /// </ul> 
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    #[doc(hidden)]
    pub notification_triggers: std::option::Option<std::vec::Vec<crate::types::AlarmState>>,
    /// <p>Indicates whether the alarm is enabled.</p> 
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    #[doc(hidden)]
    pub notification_enabled: std::option::Option<bool>,
}
impl PutAlarmInput {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub fn alarm_name(&self) -> std::option::Option<& str> {
        self.alarm_name.as_deref()
    }
    /// <p>The name of the metric to associate with the alarm.</p> 
    /// <p>You can configure up to two alarms per metric.</p> 
    /// <p>The following metrics are available for each resource type:</p> 
    /// <ul> 
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li> 
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li> 
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li> 
    /// </ul> 
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn metric_name(&self) -> std::option::Option<& crate::types::MetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p> 
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub fn monitored_resource_name(&self) -> std::option::Option<& str> {
        self.monitored_resource_name.as_deref()
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub fn comparison_operator(&self) -> std::option::Option<& crate::types::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn threshold(&self) -> std::option::Option<f64> {
        self.threshold
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p> 
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p> 
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p> 
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub fn evaluation_periods(&self) -> std::option::Option<i32> {
        self.evaluation_periods
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn datapoints_to_alarm(&self) -> std::option::Option<i32> {
        self.datapoints_to_alarm
    }
    /// <p>Sets how this alarm will handle missing data points.</p> 
    /// <p>An alarm can treat missing data in the following ways:</p> 
    /// <ul> 
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li> 
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li> 
    /// </ul> 
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn treat_missing_data(&self) -> std::option::Option<& crate::types::TreatMissingData> {
        self.treat_missing_data.as_ref()
    }
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p> 
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p> 
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p> 
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub fn contact_protocols(&self) -> std::option::Option<& [crate::types::ContactProtocol]> {
        self.contact_protocols.as_deref()
    }
    /// <p>The alarm states that trigger a notification.</p> 
    /// <p>An alarm has the following possible states:</p> 
    /// <ul> 
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li> 
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li> 
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li> 
    /// </ul> 
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p> 
    /// <ul> 
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li> 
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li> 
    /// </ul> 
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub fn notification_triggers(&self) -> std::option::Option<& [crate::types::AlarmState]> {
        self.notification_triggers.as_deref()
    }
    /// <p>Indicates whether the alarm is enabled.</p> 
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn notification_enabled(&self) -> std::option::Option<bool> {
        self.notification_enabled
    }
}
impl PutAlarmInput {
    /// Creates a new builder-style object to manufacture [`PutAlarmInput`](crate::operation::put_alarm::PutAlarmInput).
    pub fn builder() -> crate::operation::put_alarm::builders::PutAlarmInputBuilder {
        crate::operation::put_alarm::builders::PutAlarmInputBuilder::default()
    }
}

/// A builder for [`PutAlarmInput`](crate::operation::put_alarm::PutAlarmInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct PutAlarmInputBuilder {
    pub(crate) alarm_name: std::option::Option<std::string::String>,
    pub(crate) metric_name: std::option::Option<crate::types::MetricName>,
    pub(crate) monitored_resource_name: std::option::Option<std::string::String>,
    pub(crate) comparison_operator: std::option::Option<crate::types::ComparisonOperator>,
    pub(crate) threshold: std::option::Option<f64>,
    pub(crate) evaluation_periods: std::option::Option<i32>,
    pub(crate) datapoints_to_alarm: std::option::Option<i32>,
    pub(crate) treat_missing_data: std::option::Option<crate::types::TreatMissingData>,
    pub(crate) contact_protocols: std::option::Option<std::vec::Vec<crate::types::ContactProtocol>>,
    pub(crate) notification_triggers: std::option::Option<std::vec::Vec<crate::types::AlarmState>>,
    pub(crate) notification_enabled: std::option::Option<bool>,
}
impl PutAlarmInputBuilder {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_name = Some(input.into());
        self
    }
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the previous configuration of the alarm.</p>
    pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_name = input; self
    }
    /// <p>The name of the metric to associate with the alarm.</p> 
    /// <p>You can configure up to two alarms per metric.</p> 
    /// <p>The following metrics are available for each resource type:</p> 
    /// <ul> 
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li> 
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li> 
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li> 
    /// </ul> 
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn metric_name(mut self, input: crate::types::MetricName) -> Self {
        self.metric_name = Some(input);
        self
    }
    /// <p>The name of the metric to associate with the alarm.</p> 
    /// <p>You can configure up to two alarms per metric.</p> 
    /// <p>The following metrics are available for each resource type:</p> 
    /// <ul> 
    /// <li> <p> <b>Instances</b>: <code>BurstCapacityPercentage</code>, <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>, <code>NetworkOut</code>, <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and <code>StatusCheckFailed_System</code>.</p> </li> 
    /// <li> <p> <b>Load balancers</b>: <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>, <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>, <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>, <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>, <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>, <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p> </li> 
    /// <li> <p> <b>Relational databases</b>: <code>CPUUtilization</code>, <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>, <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and <code>NetworkTransmitThroughput</code>.</p> </li> 
    /// </ul> 
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn set_metric_name(mut self, input: std::option::Option<crate::types::MetricName>) -> Self {
        self.metric_name = input; self
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p> 
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub fn monitored_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.monitored_resource_name = Some(input.into());
        self
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p> 
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources that can currently be monitored by alarms.</p>
    pub fn set_monitored_resource_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.monitored_resource_name = input; self
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub fn comparison_operator(mut self, input: crate::types::ComparisonOperator) -> Self {
        self.comparison_operator = Some(input);
        self
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold. The specified statistic value is used as the first operand.</p>
    pub fn set_comparison_operator(mut self, input: std::option::Option<crate::types::ComparisonOperator>) -> Self {
        self.comparison_operator = input; self
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn threshold(mut self, input: f64) -> Self {
        self.threshold = Some(input);
        self
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
        self.threshold = input; self
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p> 
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p> 
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p> 
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub fn evaluation_periods(mut self, input: i32) -> Self {
        self.evaluation_periods = Some(input);
        self
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold. If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the N.</p> 
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies the rolling period of time in which data points are evaluated.</p> 
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of 24 to evaluate a metric over a rolling period of two hours.</p> 
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation period of 288 (24 hours).</p>
    pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
        self.evaluation_periods = input; self
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
        self.datapoints_to_alarm = Some(input);
        self
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>) is the M.</p>
    pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
        self.datapoints_to_alarm = input; self
    }
    /// <p>Sets how this alarm will handle missing data points.</p> 
    /// <p>An alarm can treat missing data in the following ways:</p> 
    /// <ul> 
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li> 
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li> 
    /// </ul> 
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn treat_missing_data(mut self, input: crate::types::TreatMissingData) -> Self {
        self.treat_missing_data = Some(input);
        self
    }
    /// <p>Sets how this alarm will handle missing data points.</p> 
    /// <p>An alarm can treat missing data in the following ways:</p> 
    /// <ul> 
    /// <li> <p> <code>breaching</code> - Assume the missing data is not within the threshold. Missing data counts towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>notBreaching</code> - Assume the missing data is within the threshold. Missing data does not count towards the number of times the metric is not within the threshold.</p> </li> 
    /// <li> <p> <code>ignore</code> - Ignore the missing data. Maintains the current alarm state.</p> </li> 
    /// <li> <p> <code>missing</code> - Missing data is treated as missing.</p> </li> 
    /// </ul> 
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of <code>missing</code> is used.</p>
    pub fn set_treat_missing_data(mut self, input: std::option::Option<crate::types::TreatMissingData>) -> Self {
        self.treat_missing_data = input; self
    }
    /// Appends an item to `contact_protocols`.
    ///
    /// To override the contents of this collection use [`set_contact_protocols`](Self::set_contact_protocols).
    ///
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p> 
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p> 
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p> 
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub fn contact_protocols(mut self, input: crate::types::ContactProtocol) -> Self {
        let mut v = self.contact_protocols.unwrap_or_default();
                        v.push(input);
                        self.contact_protocols = Some(v);
                        self
    }
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code> (text messaging), or both.</p> 
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for the alarm, and when the alarm is triggered.</p> 
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified contact protocol is not configured in the Amazon Web Services Region, or if notifications are not enabled for the alarm using the <code>notificationEnabled</code> paramater.</p> 
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an Amazon Web Services Region.</p>
    pub fn set_contact_protocols(mut self, input: std::option::Option<std::vec::Vec<crate::types::ContactProtocol>>) -> Self {
        self.contact_protocols = input; self
    }
    /// Appends an item to `notification_triggers`.
    ///
    /// To override the contents of this collection use [`set_notification_triggers`](Self::set_notification_triggers).
    ///
    /// <p>The alarm states that trigger a notification.</p> 
    /// <p>An alarm has the following possible states:</p> 
    /// <ul> 
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li> 
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li> 
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li> 
    /// </ul> 
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p> 
    /// <ul> 
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li> 
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li> 
    /// </ul> 
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub fn notification_triggers(mut self, input: crate::types::AlarmState) -> Self {
        let mut v = self.notification_triggers.unwrap_or_default();
                        v.push(input);
                        self.notification_triggers = Some(v);
                        self
    }
    /// <p>The alarm states that trigger a notification.</p> 
    /// <p>An alarm has the following possible states:</p> 
    /// <ul> 
    /// <li> <p> <code>ALARM</code> - The metric is outside of the defined threshold.</p> </li> 
    /// <li> <p> <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not available, or not enough data is available for the metric to determine the alarm state.</p> </li> 
    /// <li> <p> <code>OK</code> - The metric is within the defined threshold.</p> </li> 
    /// </ul> 
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified. The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to the <code>ALARM</code> state.</p> 
    /// <ul> 
    /// <li> <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to an <code>OK</code> state. This can be thought of as an <i>all clear</i> alarm notification.</p> </li> 
    /// <li> <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to an <code>INSUFFICIENT_DATA</code> state.</p> </li> 
    /// </ul> 
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this parameter.</p>
    pub fn set_notification_triggers(mut self, input: std::option::Option<std::vec::Vec<crate::types::AlarmState>>) -> Self {
        self.notification_triggers = input; self
    }
    /// <p>Indicates whether the alarm is enabled.</p> 
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn notification_enabled(mut self, input: bool) -> Self {
        self.notification_enabled = Some(input);
        self
    }
    /// <p>Indicates whether the alarm is enabled.</p> 
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn set_notification_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.notification_enabled = input; self
    }
    /// Consumes the builder and constructs a [`PutAlarmInput`](crate::operation::put_alarm::PutAlarmInput).
    pub fn build(self) -> Result<crate::operation::put_alarm::PutAlarmInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::put_alarm::PutAlarmInput {
                alarm_name: self.alarm_name
                ,
                metric_name: self.metric_name
                ,
                monitored_resource_name: self.monitored_resource_name
                ,
                comparison_operator: self.comparison_operator
                ,
                threshold: self.threshold
                ,
                evaluation_periods: self.evaluation_periods
                ,
                datapoints_to_alarm: self.datapoints_to_alarm
                ,
                treat_missing_data: self.treat_missing_data
                ,
                contact_protocols: self.contact_protocols
                ,
                notification_triggers: self.notification_triggers
                ,
                notification_enabled: self.notification_enabled
                ,
            }
        )
    }
}

