// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AllocateStaticIpError {
    pub kind: AllocateStaticIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AllocateStaticIpErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AllocateStaticIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AllocateStaticIpErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            AllocateStaticIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AllocateStaticIpError {
    fn code(&self) -> Option<&str> {
        AllocateStaticIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AllocateStaticIpError {
    pub fn new(kind: AllocateStaticIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AllocateStaticIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AllocateStaticIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateStaticIpErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateStaticIpErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateStaticIpErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, AllocateStaticIpErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateStaticIpErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, AllocateStaticIpErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateStaticIpErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for AllocateStaticIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AllocateStaticIpErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::InvalidInputException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::NotFoundException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::OperationFailureException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::ServiceException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            AllocateStaticIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachCertificateToDistributionError {
    pub kind: AttachCertificateToDistributionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachCertificateToDistributionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachCertificateToDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachCertificateToDistributionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AttachCertificateToDistributionErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            AttachCertificateToDistributionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AttachCertificateToDistributionErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            AttachCertificateToDistributionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AttachCertificateToDistributionErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            AttachCertificateToDistributionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachCertificateToDistributionError {
    fn code(&self) -> Option<&str> {
        AttachCertificateToDistributionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachCertificateToDistributionError {
    pub fn new(kind: AttachCertificateToDistributionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachCertificateToDistributionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachCertificateToDistributionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachCertificateToDistributionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachCertificateToDistributionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachCertificateToDistributionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachCertificateToDistributionErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachCertificateToDistributionErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachCertificateToDistributionErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for AttachCertificateToDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachCertificateToDistributionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AttachCertificateToDistributionErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachCertificateToDistributionErrorKind::NotFoundException(_inner) => Some(_inner),
            AttachCertificateToDistributionErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            AttachCertificateToDistributionErrorKind::ServiceException(_inner) => Some(_inner),
            AttachCertificateToDistributionErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            AttachCertificateToDistributionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachDiskError {
    pub kind: AttachDiskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachDiskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachDiskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachDiskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            AttachDiskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachDiskError {
    fn code(&self) -> Option<&str> {
        AttachDiskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachDiskError {
    pub fn new(kind: AttachDiskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachDiskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachDiskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AttachDiskErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachDiskErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, AttachDiskErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, AttachDiskErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachDiskErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, AttachDiskErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, AttachDiskErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for AttachDiskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachDiskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AttachDiskErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            AttachDiskErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachDiskErrorKind::NotFoundException(_inner) => Some(_inner),
            AttachDiskErrorKind::OperationFailureException(_inner) => Some(_inner),
            AttachDiskErrorKind::ServiceException(_inner) => Some(_inner),
            AttachDiskErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            AttachDiskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachInstancesToLoadBalancerError {
    pub kind: AttachInstancesToLoadBalancerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachInstancesToLoadBalancerErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachInstancesToLoadBalancerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachInstancesToLoadBalancerErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AttachInstancesToLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            AttachInstancesToLoadBalancerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AttachInstancesToLoadBalancerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AttachInstancesToLoadBalancerErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            AttachInstancesToLoadBalancerErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AttachInstancesToLoadBalancerErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            AttachInstancesToLoadBalancerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachInstancesToLoadBalancerError {
    fn code(&self) -> Option<&str> {
        AttachInstancesToLoadBalancerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachInstancesToLoadBalancerError {
    pub fn new(kind: AttachInstancesToLoadBalancerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachInstancesToLoadBalancerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachInstancesToLoadBalancerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachInstancesToLoadBalancerErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for AttachInstancesToLoadBalancerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachInstancesToLoadBalancerErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AttachInstancesToLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            AttachInstancesToLoadBalancerErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachInstancesToLoadBalancerErrorKind::NotFoundException(_inner) => Some(_inner),
            AttachInstancesToLoadBalancerErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            AttachInstancesToLoadBalancerErrorKind::ServiceException(_inner) => Some(_inner),
            AttachInstancesToLoadBalancerErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            AttachInstancesToLoadBalancerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachLoadBalancerTlsCertificateError {
    pub kind: AttachLoadBalancerTlsCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachLoadBalancerTlsCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachLoadBalancerTlsCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AttachLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            AttachLoadBalancerTlsCertificateErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            AttachLoadBalancerTlsCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AttachLoadBalancerTlsCertificateErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            AttachLoadBalancerTlsCertificateErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AttachLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            AttachLoadBalancerTlsCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachLoadBalancerTlsCertificateError {
    fn code(&self) -> Option<&str> {
        AttachLoadBalancerTlsCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachLoadBalancerTlsCertificateError {
    pub fn new(kind: AttachLoadBalancerTlsCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachLoadBalancerTlsCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachLoadBalancerTlsCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for AttachLoadBalancerTlsCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AttachLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            AttachLoadBalancerTlsCertificateErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            AttachLoadBalancerTlsCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            AttachLoadBalancerTlsCertificateErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            AttachLoadBalancerTlsCertificateErrorKind::ServiceException(_inner) => Some(_inner),
            AttachLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            AttachLoadBalancerTlsCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachStaticIpError {
    pub kind: AttachStaticIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachStaticIpErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachStaticIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachStaticIpErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::ServiceException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            AttachStaticIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachStaticIpError {
    fn code(&self) -> Option<&str> {
        AttachStaticIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachStaticIpError {
    pub fn new(kind: AttachStaticIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachStaticIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachStaticIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachStaticIpErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachStaticIpErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachStaticIpErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, AttachStaticIpErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachStaticIpErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, AttachStaticIpErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachStaticIpErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for AttachStaticIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachStaticIpErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::InvalidInputException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::NotFoundException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::OperationFailureException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::ServiceException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            AttachStaticIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CloseInstancePublicPortsError {
    pub kind: CloseInstancePublicPortsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CloseInstancePublicPortsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CloseInstancePublicPortsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CloseInstancePublicPortsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CloseInstancePublicPortsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CloseInstancePublicPortsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CloseInstancePublicPortsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CloseInstancePublicPortsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CloseInstancePublicPortsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CloseInstancePublicPortsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CloseInstancePublicPortsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CloseInstancePublicPortsError {
    fn code(&self) -> Option<&str> {
        CloseInstancePublicPortsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CloseInstancePublicPortsError {
    pub fn new(kind: CloseInstancePublicPortsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CloseInstancePublicPortsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CloseInstancePublicPortsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CloseInstancePublicPortsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CloseInstancePublicPortsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CloseInstancePublicPortsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CloseInstancePublicPortsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CloseInstancePublicPortsErrorKind::InvalidInputException(_inner) => Some(_inner),
            CloseInstancePublicPortsErrorKind::NotFoundException(_inner) => Some(_inner),
            CloseInstancePublicPortsErrorKind::OperationFailureException(_inner) => Some(_inner),
            CloseInstancePublicPortsErrorKind::ServiceException(_inner) => Some(_inner),
            CloseInstancePublicPortsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CloseInstancePublicPortsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopySnapshotError {
    pub kind: CopySnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopySnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopySnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopySnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopySnapshotError {
    fn code(&self) -> Option<&str> {
        CopySnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopySnapshotError {
    pub fn new(kind: CopySnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopySnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopySnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CopySnapshotErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CopySnapshotErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CopySnapshotErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CopySnapshotErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CopySnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopySnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CopySnapshotErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CopySnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            CopySnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            CopySnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            CopySnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CopySnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CopySnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCertificateError {
    pub kind: CreateCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCertificateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateCertificateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateCertificateErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateCertificateErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCertificateError {
    fn code(&self) -> Option<&str> {
        CreateCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCertificateError {
    pub fn new(kind: CreateCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateCertificateErrorKind::NotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateCertificateErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCertificateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateCertificateErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateCertificateErrorKind::ServiceException(_inner) => Some(_inner),
            CreateCertificateErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCloudFormationStackError {
    pub kind: CreateCloudFormationStackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCloudFormationStackErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCloudFormationStackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCloudFormationStackErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateCloudFormationStackErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateCloudFormationStackErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateCloudFormationStackErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateCloudFormationStackErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateCloudFormationStackErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateCloudFormationStackErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateCloudFormationStackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCloudFormationStackError {
    fn code(&self) -> Option<&str> {
        CreateCloudFormationStackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCloudFormationStackError {
    pub fn new(kind: CreateCloudFormationStackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCloudFormationStackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCloudFormationStackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCloudFormationStackErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateCloudFormationStackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCloudFormationStackErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateCloudFormationStackErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateCloudFormationStackErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateCloudFormationStackErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateCloudFormationStackErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateCloudFormationStackErrorKind::ServiceException(_inner) => Some(_inner),
            CreateCloudFormationStackErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateCloudFormationStackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContactMethodError {
    pub kind: CreateContactMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContactMethodErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContactMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContactMethodErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateContactMethodErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateContactMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateContactMethodErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateContactMethodErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateContactMethodErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateContactMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContactMethodError {
    fn code(&self) -> Option<&str> {
        CreateContactMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContactMethodError {
    pub fn new(kind: CreateContactMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContactMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContactMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactMethodErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactMethodErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactMethodErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactMethodErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactMethodErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactMethodErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateContactMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContactMethodErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateContactMethodErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateContactMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateContactMethodErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateContactMethodErrorKind::ServiceException(_inner) => Some(_inner),
            CreateContactMethodErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateContactMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContainerServiceError {
    pub kind: CreateContainerServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContainerServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContainerServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContainerServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateContainerServiceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateContainerServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateContainerServiceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateContainerServiceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateContainerServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContainerServiceError {
    fn code(&self) -> Option<&str> {
        CreateContainerServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContainerServiceError {
    pub fn new(kind: CreateContainerServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContainerServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContainerServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateContainerServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContainerServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateContainerServiceErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateContainerServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateContainerServiceErrorKind::ServiceException(_inner) => Some(_inner),
            CreateContainerServiceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateContainerServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContainerServiceDeploymentError {
    pub kind: CreateContainerServiceDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContainerServiceDeploymentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContainerServiceDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContainerServiceDeploymentErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceDeploymentErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceDeploymentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateContainerServiceDeploymentErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateContainerServiceDeploymentErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContainerServiceDeploymentError {
    fn code(&self) -> Option<&str> {
        CreateContainerServiceDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContainerServiceDeploymentError {
    pub fn new(kind: CreateContainerServiceDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContainerServiceDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContainerServiceDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceDeploymentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceDeploymentErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceDeploymentErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceDeploymentErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceDeploymentErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateContainerServiceDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContainerServiceDeploymentErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateContainerServiceDeploymentErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            CreateContainerServiceDeploymentErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateContainerServiceDeploymentErrorKind::ServiceException(_inner) => Some(_inner),
            CreateContainerServiceDeploymentErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            CreateContainerServiceDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContainerServiceRegistryLoginError {
    pub kind: CreateContainerServiceRegistryLoginErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContainerServiceRegistryLoginErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContainerServiceRegistryLoginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContainerServiceRegistryLoginErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceRegistryLoginErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceRegistryLoginErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceRegistryLoginErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateContainerServiceRegistryLoginErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            CreateContainerServiceRegistryLoginErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContainerServiceRegistryLoginError {
    fn code(&self) -> Option<&str> {
        CreateContainerServiceRegistryLoginError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContainerServiceRegistryLoginError {
    pub fn new(
        kind: CreateContainerServiceRegistryLoginErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContainerServiceRegistryLoginErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContainerServiceRegistryLoginErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceRegistryLoginErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceRegistryLoginErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceRegistryLoginErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceRegistryLoginErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContainerServiceRegistryLoginErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateContainerServiceRegistryLoginError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContainerServiceRegistryLoginErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateContainerServiceRegistryLoginErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            CreateContainerServiceRegistryLoginErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateContainerServiceRegistryLoginErrorKind::ServiceException(_inner) => Some(_inner),
            CreateContainerServiceRegistryLoginErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            CreateContainerServiceRegistryLoginErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDiskError {
    pub kind: CreateDiskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDiskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDiskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDiskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateDiskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDiskError {
    fn code(&self) -> Option<&str> {
        CreateDiskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDiskError {
    pub fn new(kind: CreateDiskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDiskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDiskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateDiskErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateDiskErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateDiskErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateDiskErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, CreateDiskErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for CreateDiskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDiskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDiskErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateDiskErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDiskErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDiskErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateDiskErrorKind::ServiceException(_inner) => Some(_inner),
            CreateDiskErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateDiskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDiskFromSnapshotError {
    pub kind: CreateDiskFromSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDiskFromSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDiskFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDiskFromSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDiskFromSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateDiskFromSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDiskFromSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDiskFromSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateDiskFromSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateDiskFromSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateDiskFromSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDiskFromSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateDiskFromSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDiskFromSnapshotError {
    pub fn new(kind: CreateDiskFromSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDiskFromSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDiskFromSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskFromSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateDiskFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDiskFromSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDiskFromSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateDiskFromSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDiskFromSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDiskFromSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateDiskFromSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CreateDiskFromSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateDiskFromSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDiskSnapshotError {
    pub kind: CreateDiskSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDiskSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDiskSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDiskSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateDiskSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDiskSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateDiskSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDiskSnapshotError {
    pub fn new(kind: CreateDiskSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDiskSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDiskSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateDiskSnapshotErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDiskSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateDiskSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDiskSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateDiskSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDistributionError {
    pub kind: CreateDistributionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDistributionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDistributionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDistributionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDistributionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDistributionErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateDistributionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateDistributionErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateDistributionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDistributionError {
    fn code(&self) -> Option<&str> {
        CreateDistributionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDistributionError {
    pub fn new(kind: CreateDistributionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDistributionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDistributionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDistributionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDistributionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDistributionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDistributionErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateDistributionErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDistributionErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDistributionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDistributionErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDistributionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDistributionErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateDistributionErrorKind::ServiceException(_inner) => Some(_inner),
            CreateDistributionErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateDistributionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainError {
    pub kind: CreateDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDomainError {
    fn code(&self) -> Option<&str> {
        CreateDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDomainError {
    pub fn new(kind: CreateDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDomainErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateDomainErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDomainErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDomainErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateDomainErrorKind::ServiceException(_inner) => Some(_inner),
            CreateDomainErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainEntryError {
    pub kind: CreateDomainEntryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainEntryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDomainEntryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainEntryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateDomainEntryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDomainEntryError {
    fn code(&self) -> Option<&str> {
        CreateDomainEntryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDomainEntryError {
    pub fn new(kind: CreateDomainEntryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDomainEntryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDomainEntryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainEntryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainEntryErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainEntryErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainEntryErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainEntryErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainEntryErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainEntryErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateDomainEntryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainEntryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::ServiceException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateDomainEntryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstancesError {
    pub kind: CreateInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstancesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstancesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstancesError {
    fn code(&self) -> Option<&str> {
        CreateInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstancesError {
    pub fn new(kind: CreateInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateInstancesErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateInstancesErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstancesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateInstancesErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateInstancesErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateInstancesErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateInstancesErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateInstancesErrorKind::ServiceException(_inner) => Some(_inner),
            CreateInstancesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstancesFromSnapshotError {
    pub kind: CreateInstancesFromSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstancesFromSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstancesFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstancesFromSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateInstancesFromSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateInstancesFromSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateInstancesFromSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateInstancesFromSnapshotErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateInstancesFromSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateInstancesFromSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateInstancesFromSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstancesFromSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateInstancesFromSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstancesFromSnapshotError {
    pub fn new(kind: CreateInstancesFromSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstancesFromSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstancesFromSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstancesFromSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateInstancesFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstancesFromSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateInstancesFromSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateInstancesFromSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateInstancesFromSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateInstancesFromSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateInstancesFromSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CreateInstancesFromSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateInstancesFromSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstanceSnapshotError {
    pub kind: CreateInstanceSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstanceSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstanceSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstanceSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateInstanceSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateInstanceSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateInstanceSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateInstanceSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateInstanceSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateInstanceSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateInstanceSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstanceSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateInstanceSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstanceSnapshotError {
    pub fn new(kind: CreateInstanceSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstanceSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstanceSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateInstanceSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstanceSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateInstanceSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateInstanceSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateInstanceSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateInstanceSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateInstanceSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CreateInstanceSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateInstanceSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateKeyPairError {
    pub kind: CreateKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateKeyPairErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateKeyPairErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateKeyPairError {
    fn code(&self) -> Option<&str> {
        CreateKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateKeyPairError {
    pub fn new(kind: CreateKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyPairErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyPairErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyPairErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyPairErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyPairErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyPairErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyPairErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateKeyPairErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::ServiceException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLoadBalancerError {
    pub kind: CreateLoadBalancerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLoadBalancerErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLoadBalancerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLoadBalancerErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateLoadBalancerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLoadBalancerError {
    fn code(&self) -> Option<&str> {
        CreateLoadBalancerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLoadBalancerError {
    pub fn new(kind: CreateLoadBalancerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLoadBalancerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLoadBalancerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, CreateLoadBalancerErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateLoadBalancerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLoadBalancerErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::ServiceException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateLoadBalancerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLoadBalancerTlsCertificateError {
    pub kind: CreateLoadBalancerTlsCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLoadBalancerTlsCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLoadBalancerTlsCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateLoadBalancerTlsCertificateErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            CreateLoadBalancerTlsCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateLoadBalancerTlsCertificateErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateLoadBalancerTlsCertificateErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            CreateLoadBalancerTlsCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLoadBalancerTlsCertificateError {
    fn code(&self) -> Option<&str> {
        CreateLoadBalancerTlsCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLoadBalancerTlsCertificateError {
    pub fn new(kind: CreateLoadBalancerTlsCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLoadBalancerTlsCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLoadBalancerTlsCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateLoadBalancerTlsCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateLoadBalancerTlsCertificateErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            CreateLoadBalancerTlsCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateLoadBalancerTlsCertificateErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            CreateLoadBalancerTlsCertificateErrorKind::ServiceException(_inner) => Some(_inner),
            CreateLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            CreateLoadBalancerTlsCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRelationalDatabaseError {
    pub kind: CreateRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        CreateRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRelationalDatabaseError {
    pub fn new(kind: CreateRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            CreateRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            CreateRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            CreateRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            CreateRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRelationalDatabaseFromSnapshotError {
    pub kind: CreateRelationalDatabaseFromSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRelationalDatabaseFromSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRelationalDatabaseFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRelationalDatabaseFromSnapshotErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::AccountSetupInProgressException(
                _inner,
            ) => _inner.fmt(f),
            CreateRelationalDatabaseFromSnapshotErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::ServiceException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRelationalDatabaseFromSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateRelationalDatabaseFromSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRelationalDatabaseFromSnapshotError {
    pub fn new(
        kind: CreateRelationalDatabaseFromSnapshotErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRelationalDatabaseFromSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRelationalDatabaseFromSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseFromSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateRelationalDatabaseFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRelationalDatabaseFromSnapshotErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::AccountSetupInProgressException(
                _inner,
            ) => Some(_inner),
            CreateRelationalDatabaseFromSnapshotErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CreateRelationalDatabaseFromSnapshotErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseFromSnapshotErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRelationalDatabaseSnapshotError {
    pub kind: CreateRelationalDatabaseSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRelationalDatabaseSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRelationalDatabaseSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseSnapshotErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseSnapshotErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            CreateRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRelationalDatabaseSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRelationalDatabaseSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateRelationalDatabaseSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRelationalDatabaseSnapshotError {
    pub fn new(kind: CreateRelationalDatabaseSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRelationalDatabaseSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRelationalDatabaseSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for CreateRelationalDatabaseSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseSnapshotErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRelationalDatabaseSnapshotErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            CreateRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            CreateRelationalDatabaseSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAlarmError {
    pub kind: DeleteAlarmErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAlarmErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAlarmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAlarmErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAlarmErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteAlarmErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAlarmErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteAlarmErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteAlarmErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteAlarmErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAlarmError {
    fn code(&self) -> Option<&str> {
        DeleteAlarmError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAlarmError {
    pub fn new(kind: DeleteAlarmErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAlarmErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAlarmErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteAlarmErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteAlarmErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAlarmErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAlarmErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteAlarmErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAlarmErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteAlarmError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAlarmErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAlarmErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteAlarmErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAlarmErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteAlarmErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteAlarmErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteAlarmErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAutoSnapshotError {
    pub kind: DeleteAutoSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAutoSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAutoSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAutoSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteAutoSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteAutoSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAutoSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteAutoSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteAutoSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteAutoSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAutoSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteAutoSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAutoSnapshotError {
    pub fn new(kind: DeleteAutoSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAutoSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAutoSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutoSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutoSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutoSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutoSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteAutoSnapshotErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutoSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteAutoSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAutoSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteAutoSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteAutoSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAutoSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteAutoSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteAutoSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteAutoSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCertificateError {
    pub kind: DeleteCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCertificateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCertificateError {
    pub fn new(kind: DeleteCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteCertificateErrorKind::NotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteCertificateErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCertificateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContactMethodError {
    pub kind: DeleteContactMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContactMethodErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContactMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContactMethodErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteContactMethodErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteContactMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteContactMethodErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteContactMethodErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteContactMethodErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteContactMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContactMethodError {
    fn code(&self) -> Option<&str> {
        DeleteContactMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContactMethodError {
    pub fn new(kind: DeleteContactMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContactMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContactMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactMethodErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactMethodErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactMethodErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactMethodErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactMethodErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactMethodErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteContactMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContactMethodErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteContactMethodErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteContactMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteContactMethodErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteContactMethodErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteContactMethodErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteContactMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContainerImageError {
    pub kind: DeleteContainerImageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContainerImageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContainerImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContainerImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteContainerImageErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteContainerImageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteContainerImageErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteContainerImageErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteContainerImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContainerImageError {
    fn code(&self) -> Option<&str> {
        DeleteContainerImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContainerImageError {
    pub fn new(kind: DeleteContainerImageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContainerImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContainerImageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerImageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerImageErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerImageErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerImageErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerImageErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteContainerImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContainerImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteContainerImageErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteContainerImageErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteContainerImageErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteContainerImageErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteContainerImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContainerServiceError {
    pub kind: DeleteContainerServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContainerServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContainerServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContainerServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteContainerServiceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteContainerServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteContainerServiceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteContainerServiceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteContainerServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContainerServiceError {
    fn code(&self) -> Option<&str> {
        DeleteContainerServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContainerServiceError {
    pub fn new(kind: DeleteContainerServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContainerServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContainerServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerServiceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerServiceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerServiceErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContainerServiceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteContainerServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContainerServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteContainerServiceErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteContainerServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteContainerServiceErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteContainerServiceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteContainerServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDiskError {
    pub kind: DeleteDiskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDiskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDiskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDiskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteDiskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDiskError {
    fn code(&self) -> Option<&str> {
        DeleteDiskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDiskError {
    pub fn new(kind: DeleteDiskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDiskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDiskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteDiskErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteDiskErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDiskErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteDiskErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, DeleteDiskErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for DeleteDiskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDiskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDiskErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteDiskErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDiskErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDiskErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteDiskErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteDiskErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteDiskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDiskSnapshotError {
    pub kind: DeleteDiskSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDiskSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDiskSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDiskSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteDiskSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDiskSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteDiskSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDiskSnapshotError {
    pub fn new(kind: DeleteDiskSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDiskSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDiskSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteDiskSnapshotErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDiskSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteDiskSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDiskSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteDiskSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDistributionError {
    pub kind: DeleteDistributionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDistributionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDistributionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDistributionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDistributionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDistributionErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteDistributionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteDistributionErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteDistributionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDistributionError {
    fn code(&self) -> Option<&str> {
        DeleteDistributionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDistributionError {
    pub fn new(kind: DeleteDistributionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDistributionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDistributionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDistributionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDistributionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDistributionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDistributionErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteDistributionErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDistributionErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDistributionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDistributionErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDistributionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDistributionErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteDistributionErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteDistributionErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteDistributionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDomainError {
    pub kind: DeleteDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDomainErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDomainErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDomainError {
    fn code(&self) -> Option<&str> {
        DeleteDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDomainError {
    pub fn new(kind: DeleteDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDomainErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDomainErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteDomainErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDomainErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDomainErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteDomainErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteDomainErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDomainEntryError {
    pub kind: DeleteDomainEntryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDomainEntryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDomainEntryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDomainEntryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteDomainEntryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDomainEntryError {
    fn code(&self) -> Option<&str> {
        DeleteDomainEntryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDomainEntryError {
    pub fn new(kind: DeleteDomainEntryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDomainEntryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDomainEntryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainEntryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainEntryErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainEntryErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainEntryErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainEntryErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainEntryErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainEntryErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteDomainEntryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDomainEntryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteDomainEntryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceError {
    pub kind: DeleteInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstanceError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceError {
    pub fn new(kind: DeleteInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteInstanceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceSnapshotError {
    pub kind: DeleteInstanceSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstanceSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteInstanceSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteInstanceSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteInstanceSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteInstanceSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteInstanceSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteInstanceSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteInstanceSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstanceSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceSnapshotError {
    pub fn new(kind: DeleteInstanceSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstanceSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstanceSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteInstanceSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteInstanceSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteInstanceSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteInstanceSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteInstanceSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteInstanceSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteInstanceSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteInstanceSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteKeyPairError {
    pub kind: DeleteKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteKeyPairErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteKeyPairErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteKeyPairError {
    fn code(&self) -> Option<&str> {
        DeleteKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteKeyPairError {
    pub fn new(kind: DeleteKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteKeyPairErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKeyPairErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DeleteKeyPairErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteKeyPairErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKeyPairErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteKeyPairErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKeyPairErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteKeyPairErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteKnownHostKeysError {
    pub kind: DeleteKnownHostKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteKnownHostKeysErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteKnownHostKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteKnownHostKeysErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteKnownHostKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteKnownHostKeysError {
    fn code(&self) -> Option<&str> {
        DeleteKnownHostKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteKnownHostKeysError {
    pub fn new(kind: DeleteKnownHostKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteKnownHostKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteKnownHostKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteKnownHostKeysErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteKnownHostKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteKnownHostKeysErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteKnownHostKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLoadBalancerError {
    pub kind: DeleteLoadBalancerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLoadBalancerErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLoadBalancerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLoadBalancerErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLoadBalancerError {
    fn code(&self) -> Option<&str> {
        DeleteLoadBalancerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLoadBalancerError {
    pub fn new(kind: DeleteLoadBalancerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLoadBalancerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLoadBalancerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DeleteLoadBalancerErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteLoadBalancerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLoadBalancerErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteLoadBalancerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLoadBalancerTlsCertificateError {
    pub kind: DeleteLoadBalancerTlsCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLoadBalancerTlsCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLoadBalancerTlsCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerTlsCertificateErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLoadBalancerTlsCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteLoadBalancerTlsCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLoadBalancerTlsCertificateError {
    pub fn new(kind: DeleteLoadBalancerTlsCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLoadBalancerTlsCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLoadBalancerTlsCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteLoadBalancerTlsCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLoadBalancerTlsCertificateErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteLoadBalancerTlsCertificateErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteLoadBalancerTlsCertificateErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            DeleteLoadBalancerTlsCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRelationalDatabaseError {
    pub kind: DeleteRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        DeleteRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRelationalDatabaseError {
    pub fn new(kind: DeleteRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            DeleteRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            DeleteRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DeleteRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRelationalDatabaseSnapshotError {
    pub kind: DeleteRelationalDatabaseSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRelationalDatabaseSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRelationalDatabaseSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseSnapshotErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DeleteRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRelationalDatabaseSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteRelationalDatabaseSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRelationalDatabaseSnapshotError {
    pub fn new(kind: DeleteRelationalDatabaseSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRelationalDatabaseSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRelationalDatabaseSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DeleteRelationalDatabaseSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRelationalDatabaseSnapshotErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            DeleteRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            DeleteRelationalDatabaseSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachCertificateFromDistributionError {
    pub kind: DetachCertificateFromDistributionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachCertificateFromDistributionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachCertificateFromDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachCertificateFromDistributionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DetachCertificateFromDistributionErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DetachCertificateFromDistributionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DetachCertificateFromDistributionErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            DetachCertificateFromDistributionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DetachCertificateFromDistributionErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            DetachCertificateFromDistributionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachCertificateFromDistributionError {
    fn code(&self) -> Option<&str> {
        DetachCertificateFromDistributionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachCertificateFromDistributionError {
    pub fn new(
        kind: DetachCertificateFromDistributionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachCertificateFromDistributionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachCertificateFromDistributionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachCertificateFromDistributionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachCertificateFromDistributionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachCertificateFromDistributionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachCertificateFromDistributionErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachCertificateFromDistributionErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachCertificateFromDistributionErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DetachCertificateFromDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachCertificateFromDistributionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DetachCertificateFromDistributionErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            DetachCertificateFromDistributionErrorKind::NotFoundException(_inner) => Some(_inner),
            DetachCertificateFromDistributionErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            DetachCertificateFromDistributionErrorKind::ServiceException(_inner) => Some(_inner),
            DetachCertificateFromDistributionErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            DetachCertificateFromDistributionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachDiskError {
    pub kind: DetachDiskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachDiskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachDiskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachDiskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DetachDiskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachDiskError {
    fn code(&self) -> Option<&str> {
        DetachDiskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachDiskError {
    pub fn new(kind: DetachDiskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachDiskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachDiskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DetachDiskErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachDiskErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DetachDiskErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DetachDiskErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachDiskErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DetachDiskErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, DetachDiskErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for DetachDiskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachDiskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetachDiskErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DetachDiskErrorKind::InvalidInputException(_inner) => Some(_inner),
            DetachDiskErrorKind::NotFoundException(_inner) => Some(_inner),
            DetachDiskErrorKind::OperationFailureException(_inner) => Some(_inner),
            DetachDiskErrorKind::ServiceException(_inner) => Some(_inner),
            DetachDiskErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DetachDiskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachInstancesFromLoadBalancerError {
    pub kind: DetachInstancesFromLoadBalancerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachInstancesFromLoadBalancerErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachInstancesFromLoadBalancerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachInstancesFromLoadBalancerErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DetachInstancesFromLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DetachInstancesFromLoadBalancerErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            DetachInstancesFromLoadBalancerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DetachInstancesFromLoadBalancerErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            DetachInstancesFromLoadBalancerErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DetachInstancesFromLoadBalancerErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            DetachInstancesFromLoadBalancerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachInstancesFromLoadBalancerError {
    fn code(&self) -> Option<&str> {
        DetachInstancesFromLoadBalancerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachInstancesFromLoadBalancerError {
    pub fn new(kind: DetachInstancesFromLoadBalancerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachInstancesFromLoadBalancerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachInstancesFromLoadBalancerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachInstancesFromLoadBalancerErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DetachInstancesFromLoadBalancerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachInstancesFromLoadBalancerErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetachInstancesFromLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            DetachInstancesFromLoadBalancerErrorKind::InvalidInputException(_inner) => Some(_inner),
            DetachInstancesFromLoadBalancerErrorKind::NotFoundException(_inner) => Some(_inner),
            DetachInstancesFromLoadBalancerErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            DetachInstancesFromLoadBalancerErrorKind::ServiceException(_inner) => Some(_inner),
            DetachInstancesFromLoadBalancerErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            DetachInstancesFromLoadBalancerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachStaticIpError {
    pub kind: DetachStaticIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachStaticIpErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachStaticIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachStaticIpErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DetachStaticIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachStaticIpError {
    fn code(&self) -> Option<&str> {
        DetachStaticIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachStaticIpError {
    pub fn new(kind: DetachStaticIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachStaticIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachStaticIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachStaticIpErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachStaticIpErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachStaticIpErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DetachStaticIpErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachStaticIpErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DetachStaticIpErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachStaticIpErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DetachStaticIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachStaticIpErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::InvalidInputException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::NotFoundException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::OperationFailureException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::ServiceException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DetachStaticIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableAddOnError {
    pub kind: DisableAddOnErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableAddOnErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableAddOnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableAddOnErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DisableAddOnErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DisableAddOnErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DisableAddOnErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DisableAddOnErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DisableAddOnErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DisableAddOnErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableAddOnError {
    fn code(&self) -> Option<&str> {
        DisableAddOnError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableAddOnError {
    pub fn new(kind: DisableAddOnErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableAddOnErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableAddOnErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DisableAddOnErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, DisableAddOnErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DisableAddOnErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableAddOnErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, DisableAddOnErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableAddOnErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DisableAddOnError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableAddOnErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DisableAddOnErrorKind::InvalidInputException(_inner) => Some(_inner),
            DisableAddOnErrorKind::NotFoundException(_inner) => Some(_inner),
            DisableAddOnErrorKind::OperationFailureException(_inner) => Some(_inner),
            DisableAddOnErrorKind::ServiceException(_inner) => Some(_inner),
            DisableAddOnErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DisableAddOnErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DownloadDefaultKeyPairError {
    pub kind: DownloadDefaultKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DownloadDefaultKeyPairErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DownloadDefaultKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DownloadDefaultKeyPairErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DownloadDefaultKeyPairErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            DownloadDefaultKeyPairErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            DownloadDefaultKeyPairErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DownloadDefaultKeyPairErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            DownloadDefaultKeyPairErrorKind::ServiceException(_inner) => _inner.fmt(f),
            DownloadDefaultKeyPairErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            DownloadDefaultKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DownloadDefaultKeyPairError {
    fn code(&self) -> Option<&str> {
        DownloadDefaultKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DownloadDefaultKeyPairError {
    pub fn new(kind: DownloadDefaultKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DownloadDefaultKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DownloadDefaultKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DownloadDefaultKeyPairErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for DownloadDefaultKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DownloadDefaultKeyPairErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DownloadDefaultKeyPairErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            DownloadDefaultKeyPairErrorKind::InvalidInputException(_inner) => Some(_inner),
            DownloadDefaultKeyPairErrorKind::NotFoundException(_inner) => Some(_inner),
            DownloadDefaultKeyPairErrorKind::OperationFailureException(_inner) => Some(_inner),
            DownloadDefaultKeyPairErrorKind::ServiceException(_inner) => Some(_inner),
            DownloadDefaultKeyPairErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            DownloadDefaultKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableAddOnError {
    pub kind: EnableAddOnErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableAddOnErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableAddOnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableAddOnErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            EnableAddOnErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            EnableAddOnErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            EnableAddOnErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            EnableAddOnErrorKind::ServiceException(_inner) => _inner.fmt(f),
            EnableAddOnErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            EnableAddOnErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableAddOnError {
    fn code(&self) -> Option<&str> {
        EnableAddOnError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableAddOnError {
    pub fn new(kind: EnableAddOnErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableAddOnErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableAddOnErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, EnableAddOnErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, EnableAddOnErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, EnableAddOnErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableAddOnErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, EnableAddOnErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableAddOnErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for EnableAddOnError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableAddOnErrorKind::AccessDeniedException(_inner) => Some(_inner),
            EnableAddOnErrorKind::InvalidInputException(_inner) => Some(_inner),
            EnableAddOnErrorKind::NotFoundException(_inner) => Some(_inner),
            EnableAddOnErrorKind::OperationFailureException(_inner) => Some(_inner),
            EnableAddOnErrorKind::ServiceException(_inner) => Some(_inner),
            EnableAddOnErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            EnableAddOnErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExportSnapshotError {
    pub kind: ExportSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExportSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExportSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExportSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            ExportSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExportSnapshotError {
    fn code(&self) -> Option<&str> {
        ExportSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExportSnapshotError {
    pub fn new(kind: ExportSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExportSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExportSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ExportSnapshotErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ExportSnapshotErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExportSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for ExportSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExportSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            ExportSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetActiveNamesError {
    pub kind: GetActiveNamesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetActiveNamesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetActiveNamesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetActiveNamesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetActiveNamesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetActiveNamesError {
    fn code(&self) -> Option<&str> {
        GetActiveNamesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetActiveNamesError {
    pub fn new(kind: GetActiveNamesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetActiveNamesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetActiveNamesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetActiveNamesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetActiveNamesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetActiveNamesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetActiveNamesErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetActiveNamesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetActiveNamesErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetActiveNamesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetActiveNamesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetActiveNamesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::ServiceException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetActiveNamesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAlarmsError {
    pub kind: GetAlarmsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAlarmsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAlarmsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAlarmsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAlarmsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetAlarmsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAlarmsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetAlarmsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetAlarmsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetAlarmsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAlarmsError {
    fn code(&self) -> Option<&str> {
        GetAlarmsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAlarmsError {
    pub fn new(kind: GetAlarmsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAlarmsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAlarmsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetAlarmsErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetAlarmsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAlarmsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, GetAlarmsErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetAlarmsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetAlarmsErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetAlarmsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAlarmsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAlarmsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetAlarmsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAlarmsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetAlarmsErrorKind::ServiceException(_inner) => Some(_inner),
            GetAlarmsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetAlarmsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAutoSnapshotsError {
    pub kind: GetAutoSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAutoSnapshotsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAutoSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAutoSnapshotsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAutoSnapshotsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetAutoSnapshotsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAutoSnapshotsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetAutoSnapshotsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetAutoSnapshotsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetAutoSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAutoSnapshotsError {
    fn code(&self) -> Option<&str> {
        GetAutoSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAutoSnapshotsError {
    pub fn new(kind: GetAutoSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAutoSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAutoSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAutoSnapshotsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAutoSnapshotsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAutoSnapshotsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAutoSnapshotsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetAutoSnapshotsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAutoSnapshotsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetAutoSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAutoSnapshotsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAutoSnapshotsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetAutoSnapshotsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAutoSnapshotsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetAutoSnapshotsErrorKind::ServiceException(_inner) => Some(_inner),
            GetAutoSnapshotsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetAutoSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlueprintsError {
    pub kind: GetBlueprintsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlueprintsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlueprintsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlueprintsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetBlueprintsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlueprintsError {
    fn code(&self) -> Option<&str> {
        GetBlueprintsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlueprintsError {
    pub fn new(kind: GetBlueprintsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlueprintsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlueprintsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetBlueprintsErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetBlueprintsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBlueprintsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetBlueprintsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlueprintsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetBlueprintsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlueprintsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::ServiceException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetBlueprintsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBundlesError {
    pub kind: GetBundlesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBundlesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBundlesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBundlesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetBundlesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBundlesError {
    fn code(&self) -> Option<&str> {
        GetBundlesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBundlesError {
    pub fn new(kind: GetBundlesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBundlesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBundlesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetBundlesErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBundlesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetBundlesErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBundlesErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBundlesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetBundlesErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetBundlesErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetBundlesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBundlesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetBundlesErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetBundlesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetBundlesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBundlesErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetBundlesErrorKind::ServiceException(_inner) => Some(_inner),
            GetBundlesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetBundlesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCertificatesError {
    pub kind: GetCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCertificatesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCertificatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetCertificatesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetCertificatesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCertificatesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetCertificatesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCertificatesError {
    fn code(&self) -> Option<&str> {
        GetCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCertificatesError {
    pub fn new(kind: GetCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificatesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificatesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetCertificatesErrorKind::NotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetCertificatesErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificatesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCertificatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetCertificatesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetCertificatesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCertificatesErrorKind::ServiceException(_inner) => Some(_inner),
            GetCertificatesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCloudFormationStackRecordsError {
    pub kind: GetCloudFormationStackRecordsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCloudFormationStackRecordsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCloudFormationStackRecordsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCloudFormationStackRecordsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetCloudFormationStackRecordsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetCloudFormationStackRecordsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetCloudFormationStackRecordsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCloudFormationStackRecordsErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetCloudFormationStackRecordsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetCloudFormationStackRecordsErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetCloudFormationStackRecordsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCloudFormationStackRecordsError {
    fn code(&self) -> Option<&str> {
        GetCloudFormationStackRecordsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCloudFormationStackRecordsError {
    pub fn new(kind: GetCloudFormationStackRecordsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCloudFormationStackRecordsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCloudFormationStackRecordsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCloudFormationStackRecordsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetCloudFormationStackRecordsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCloudFormationStackRecordsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetCloudFormationStackRecordsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetCloudFormationStackRecordsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetCloudFormationStackRecordsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCloudFormationStackRecordsErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetCloudFormationStackRecordsErrorKind::ServiceException(_inner) => Some(_inner),
            GetCloudFormationStackRecordsErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetCloudFormationStackRecordsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactMethodsError {
    pub kind: GetContactMethodsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactMethodsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactMethodsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactMethodsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContactMethodsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContactMethodsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContactMethodsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetContactMethodsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContactMethodsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetContactMethodsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactMethodsError {
    fn code(&self) -> Option<&str> {
        GetContactMethodsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactMethodsError {
    pub fn new(kind: GetContactMethodsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactMethodsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactMethodsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactMethodsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactMethodsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetContactMethodsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactMethodsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetContactMethodsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactMethodsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContactMethodsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactMethodsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContactMethodsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContactMethodsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContactMethodsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetContactMethodsErrorKind::ServiceException(_inner) => Some(_inner),
            GetContactMethodsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetContactMethodsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerAPIMetadataError {
    pub kind: GetContainerAPIMetadataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerAPIMetadataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerAPIMetadataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerAPIMetadataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerAPIMetadataErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerAPIMetadataErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetContainerAPIMetadataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerAPIMetadataError {
    fn code(&self) -> Option<&str> {
        GetContainerAPIMetadataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerAPIMetadataError {
    pub fn new(kind: GetContainerAPIMetadataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerAPIMetadataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerAPIMetadataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerAPIMetadataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerAPIMetadataErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerAPIMetadataErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerAPIMetadataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerAPIMetadataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerAPIMetadataErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerAPIMetadataErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetContainerAPIMetadataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerImagesError {
    pub kind: GetContainerImagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerImagesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerImagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerImagesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerImagesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContainerImagesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContainerImagesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerImagesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetContainerImagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerImagesError {
    fn code(&self) -> Option<&str> {
        GetContainerImagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerImagesError {
    pub fn new(kind: GetContainerImagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerImagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerImagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerImagesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerImagesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerImagesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetContainerImagesErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerImagesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerImagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerImagesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerImagesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContainerImagesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContainerImagesErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerImagesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetContainerImagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerLogError {
    pub kind: GetContainerLogErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerLogErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerLogError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerLogErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerLogErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContainerLogErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContainerLogErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerLogErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetContainerLogErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerLogError {
    fn code(&self) -> Option<&str> {
        GetContainerLogError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerLogError {
    pub fn new(kind: GetContainerLogErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerLogErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerLogErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerLogErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerLogErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetContainerLogErrorKind::NotFoundException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetContainerLogErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerLogErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerLogError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerLogErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerLogErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContainerLogErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContainerLogErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerLogErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetContainerLogErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerServiceDeploymentsError {
    pub kind: GetContainerServiceDeploymentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerServiceDeploymentsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerServiceDeploymentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerServiceDeploymentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerServiceDeploymentsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContainerServiceDeploymentsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContainerServiceDeploymentsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerServiceDeploymentsErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetContainerServiceDeploymentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerServiceDeploymentsError {
    fn code(&self) -> Option<&str> {
        GetContainerServiceDeploymentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerServiceDeploymentsError {
    pub fn new(kind: GetContainerServiceDeploymentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerServiceDeploymentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerServiceDeploymentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceDeploymentsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceDeploymentsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceDeploymentsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceDeploymentsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceDeploymentsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerServiceDeploymentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerServiceDeploymentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerServiceDeploymentsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContainerServiceDeploymentsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContainerServiceDeploymentsErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerServiceDeploymentsErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetContainerServiceDeploymentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerServiceMetricDataError {
    pub kind: GetContainerServiceMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerServiceMetricDataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerServiceMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerServiceMetricDataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerServiceMetricDataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContainerServiceMetricDataErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContainerServiceMetricDataErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerServiceMetricDataErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetContainerServiceMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerServiceMetricDataError {
    fn code(&self) -> Option<&str> {
        GetContainerServiceMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerServiceMetricDataError {
    pub fn new(kind: GetContainerServiceMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerServiceMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerServiceMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceMetricDataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceMetricDataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceMetricDataErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceMetricDataErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServiceMetricDataErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerServiceMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerServiceMetricDataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerServiceMetricDataErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContainerServiceMetricDataErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContainerServiceMetricDataErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerServiceMetricDataErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetContainerServiceMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerServicePowersError {
    pub kind: GetContainerServicePowersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerServicePowersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerServicePowersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerServicePowersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerServicePowersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContainerServicePowersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContainerServicePowersErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerServicePowersErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetContainerServicePowersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerServicePowersError {
    fn code(&self) -> Option<&str> {
        GetContainerServicePowersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerServicePowersError {
    pub fn new(kind: GetContainerServicePowersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerServicePowersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerServicePowersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicePowersErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicePowersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicePowersErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicePowersErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicePowersErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerServicePowersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerServicePowersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerServicePowersErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContainerServicePowersErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContainerServicePowersErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerServicePowersErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetContainerServicePowersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContainerServicesError {
    pub kind: GetContainerServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContainerServicesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContainerServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContainerServicesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetContainerServicesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetContainerServicesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContainerServicesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetContainerServicesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetContainerServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContainerServicesError {
    fn code(&self) -> Option<&str> {
        GetContainerServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContainerServicesError {
    pub fn new(kind: GetContainerServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContainerServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContainerServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicesErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContainerServicesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetContainerServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContainerServicesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetContainerServicesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetContainerServicesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContainerServicesErrorKind::ServiceException(_inner) => Some(_inner),
            GetContainerServicesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetContainerServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDiskError {
    pub kind: GetDiskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDiskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDiskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDiskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDiskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDiskError {
    fn code(&self) -> Option<&str> {
        GetDiskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDiskError {
    pub fn new(kind: GetDiskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDiskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDiskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetDiskErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetDiskErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDiskErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, GetDiskErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDiskErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetDiskErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetDiskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDiskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDiskErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetDiskErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDiskErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDiskErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDiskErrorKind::ServiceException(_inner) => Some(_inner),
            GetDiskErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDiskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDisksError {
    pub kind: GetDisksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDisksErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDisksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDisksErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDisksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDisksError {
    fn code(&self) -> Option<&str> {
        GetDisksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDisksError {
    pub fn new(kind: GetDisksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDisksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDisksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetDisksErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDisksErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetDisksErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDisksErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, GetDisksErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDisksErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetDisksErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetDisksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDisksErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDisksErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetDisksErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDisksErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDisksErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDisksErrorKind::ServiceException(_inner) => Some(_inner),
            GetDisksErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDisksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDiskSnapshotError {
    pub kind: GetDiskSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDiskSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDiskSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDiskSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDiskSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDiskSnapshotError {
    fn code(&self) -> Option<&str> {
        GetDiskSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDiskSnapshotError {
    pub fn new(kind: GetDiskSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDiskSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDiskSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDiskSnapshotErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDiskSnapshotErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetDiskSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDiskSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDiskSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDiskSnapshotsError {
    pub kind: GetDiskSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDiskSnapshotsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDiskSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDiskSnapshotsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDiskSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDiskSnapshotsError {
    fn code(&self) -> Option<&str> {
        GetDiskSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDiskSnapshotsError {
    pub fn new(kind: GetDiskSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDiskSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDiskSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDiskSnapshotsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDiskSnapshotsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDiskSnapshotsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetDiskSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDiskSnapshotsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::ServiceException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDiskSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDistributionBundlesError {
    pub kind: GetDistributionBundlesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDistributionBundlesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDistributionBundlesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDistributionBundlesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDistributionBundlesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDistributionBundlesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDistributionBundlesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDistributionBundlesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDistributionBundlesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDistributionBundlesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDistributionBundlesError {
    fn code(&self) -> Option<&str> {
        GetDistributionBundlesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDistributionBundlesError {
    pub fn new(kind: GetDistributionBundlesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDistributionBundlesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDistributionBundlesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionBundlesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionBundlesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionBundlesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionBundlesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionBundlesErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionBundlesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetDistributionBundlesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDistributionBundlesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDistributionBundlesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDistributionBundlesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDistributionBundlesErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDistributionBundlesErrorKind::ServiceException(_inner) => Some(_inner),
            GetDistributionBundlesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDistributionBundlesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDistributionLatestCacheResetError {
    pub kind: GetDistributionLatestCacheResetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDistributionLatestCacheResetErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDistributionLatestCacheResetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDistributionLatestCacheResetErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetDistributionLatestCacheResetErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetDistributionLatestCacheResetErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDistributionLatestCacheResetErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetDistributionLatestCacheResetErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDistributionLatestCacheResetErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetDistributionLatestCacheResetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDistributionLatestCacheResetError {
    fn code(&self) -> Option<&str> {
        GetDistributionLatestCacheResetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDistributionLatestCacheResetError {
    pub fn new(kind: GetDistributionLatestCacheResetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDistributionLatestCacheResetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDistributionLatestCacheResetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionLatestCacheResetErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionLatestCacheResetErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionLatestCacheResetErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionLatestCacheResetErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionLatestCacheResetErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionLatestCacheResetErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetDistributionLatestCacheResetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDistributionLatestCacheResetErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDistributionLatestCacheResetErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDistributionLatestCacheResetErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDistributionLatestCacheResetErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetDistributionLatestCacheResetErrorKind::ServiceException(_inner) => Some(_inner),
            GetDistributionLatestCacheResetErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetDistributionLatestCacheResetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDistributionMetricDataError {
    pub kind: GetDistributionMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDistributionMetricDataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDistributionMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDistributionMetricDataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDistributionMetricDataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDistributionMetricDataErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDistributionMetricDataErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDistributionMetricDataErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDistributionMetricDataErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDistributionMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDistributionMetricDataError {
    fn code(&self) -> Option<&str> {
        GetDistributionMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDistributionMetricDataError {
    pub fn new(kind: GetDistributionMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDistributionMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDistributionMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionMetricDataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionMetricDataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionMetricDataErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionMetricDataErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionMetricDataErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionMetricDataErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetDistributionMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDistributionMetricDataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDistributionMetricDataErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDistributionMetricDataErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDistributionMetricDataErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDistributionMetricDataErrorKind::ServiceException(_inner) => Some(_inner),
            GetDistributionMetricDataErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDistributionMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDistributionsError {
    pub kind: GetDistributionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDistributionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDistributionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDistributionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDistributionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDistributionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDistributionsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDistributionsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDistributionsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDistributionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDistributionsError {
    fn code(&self) -> Option<&str> {
        GetDistributionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDistributionsError {
    pub fn new(kind: GetDistributionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDistributionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDistributionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDistributionsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDistributionsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDistributionsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetDistributionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDistributionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDistributionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDistributionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDistributionsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDistributionsErrorKind::ServiceException(_inner) => Some(_inner),
            GetDistributionsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDistributionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainError {
    pub kind: GetDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainError {
    fn code(&self) -> Option<&str> {
        GetDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainError {
    pub fn new(kind: GetDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDomainErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetDomainErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDomainErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDomainErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDomainErrorKind::ServiceException(_inner) => Some(_inner),
            GetDomainErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainsError {
    pub kind: GetDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainsError {
    fn code(&self) -> Option<&str> {
        GetDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainsError {
    pub fn new(kind: GetDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetDomainsErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetDomainsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDomainsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetDomainsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetDomainsErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDomainsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetDomainsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetDomainsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDomainsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetDomainsErrorKind::ServiceException(_inner) => Some(_inner),
            GetDomainsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExportSnapshotRecordsError {
    pub kind: GetExportSnapshotRecordsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExportSnapshotRecordsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExportSnapshotRecordsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExportSnapshotRecordsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetExportSnapshotRecordsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetExportSnapshotRecordsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetExportSnapshotRecordsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetExportSnapshotRecordsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetExportSnapshotRecordsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetExportSnapshotRecordsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetExportSnapshotRecordsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExportSnapshotRecordsError {
    fn code(&self) -> Option<&str> {
        GetExportSnapshotRecordsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetExportSnapshotRecordsError {
    pub fn new(kind: GetExportSnapshotRecordsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExportSnapshotRecordsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExportSnapshotRecordsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportSnapshotRecordsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetExportSnapshotRecordsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExportSnapshotRecordsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetExportSnapshotRecordsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetExportSnapshotRecordsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetExportSnapshotRecordsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetExportSnapshotRecordsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetExportSnapshotRecordsErrorKind::ServiceException(_inner) => Some(_inner),
            GetExportSnapshotRecordsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetExportSnapshotRecordsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceError {
    pub kind: GetInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceError {
    fn code(&self) -> Option<&str> {
        GetInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceError {
    pub fn new(kind: GetInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetInstanceErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetInstanceErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetInstanceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetInstanceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstanceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstanceErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstanceErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstanceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceAccessDetailsError {
    pub kind: GetInstanceAccessDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceAccessDetailsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceAccessDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceAccessDetailsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstanceAccessDetailsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetInstanceAccessDetailsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstanceAccessDetailsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceAccessDetailsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstanceAccessDetailsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstanceAccessDetailsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstanceAccessDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceAccessDetailsError {
    fn code(&self) -> Option<&str> {
        GetInstanceAccessDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceAccessDetailsError {
    pub fn new(kind: GetInstanceAccessDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceAccessDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceAccessDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceAccessDetailsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstanceAccessDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceAccessDetailsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstanceAccessDetailsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetInstanceAccessDetailsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstanceAccessDetailsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceAccessDetailsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstanceAccessDetailsErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstanceAccessDetailsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstanceAccessDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceMetricDataError {
    pub kind: GetInstanceMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceMetricDataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceMetricDataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstanceMetricDataErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetInstanceMetricDataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstanceMetricDataErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceMetricDataErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstanceMetricDataErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstanceMetricDataErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstanceMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceMetricDataError {
    fn code(&self) -> Option<&str> {
        GetInstanceMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceMetricDataError {
    pub fn new(kind: GetInstanceMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceMetricDataErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstanceMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceMetricDataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstanceMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstancePortStatesError {
    pub kind: GetInstancePortStatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstancePortStatesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstancePortStatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstancePortStatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstancePortStatesErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetInstancePortStatesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstancePortStatesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstancePortStatesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstancePortStatesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstancePortStatesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstancePortStatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstancePortStatesError {
    fn code(&self) -> Option<&str> {
        GetInstancePortStatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstancePortStatesError {
    pub fn new(kind: GetInstancePortStatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstancePortStatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstancePortStatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancePortStatesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstancePortStatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstancePortStatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstancePortStatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstancesError {
    pub kind: GetInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstancesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstancesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstancesError {
    fn code(&self) -> Option<&str> {
        GetInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstancesError {
    pub fn new(kind: GetInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetInstancesErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetInstancesErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetInstancesErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetInstancesErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstancesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstancesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstancesErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstancesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstancesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstancesErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstancesErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstancesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceSnapshotError {
    pub kind: GetInstanceSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceSnapshotError {
    fn code(&self) -> Option<&str> {
        GetInstanceSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceSnapshotError {
    pub fn new(kind: GetInstanceSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstanceSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstanceSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceSnapshotsError {
    pub kind: GetInstanceSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceSnapshotsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceSnapshotsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstanceSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceSnapshotsError {
    fn code(&self) -> Option<&str> {
        GetInstanceSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceSnapshotsError {
    pub fn new(kind: GetInstanceSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceSnapshotsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstanceSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceSnapshotsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstanceSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceStateError {
    pub kind: GetInstanceStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceStateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceStateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetInstanceStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceStateError {
    fn code(&self) -> Option<&str> {
        GetInstanceStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceStateError {
    pub fn new(kind: GetInstanceStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceStateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceStateErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceStateErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetInstanceStateErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceStateErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetInstanceStateErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceStateErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetInstanceStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceStateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::ServiceException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetInstanceStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetKeyPairError {
    pub kind: GetKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyPairErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetKeyPairErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetKeyPairError {
    fn code(&self) -> Option<&str> {
        GetKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyPairError {
    pub fn new(kind: GetKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPairErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPairErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetKeyPairErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetKeyPairErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetKeyPairErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetKeyPairErrorKind::NotFoundException(_inner) => Some(_inner),
            GetKeyPairErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetKeyPairErrorKind::ServiceException(_inner) => Some(_inner),
            GetKeyPairErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetKeyPairsError {
    pub kind: GetKeyPairsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyPairsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetKeyPairsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetKeyPairsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetKeyPairsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetKeyPairsError {
    fn code(&self) -> Option<&str> {
        GetKeyPairsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyPairsError {
    pub fn new(kind: GetKeyPairsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetKeyPairsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetKeyPairsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairsErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPairsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPairsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPairsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPairsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetKeyPairsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetKeyPairsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::ServiceException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetKeyPairsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoadBalancerError {
    pub kind: GetLoadBalancerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoadBalancerErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoadBalancerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoadBalancerErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetLoadBalancerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoadBalancerError {
    fn code(&self) -> Option<&str> {
        GetLoadBalancerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoadBalancerError {
    pub fn new(kind: GetLoadBalancerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoadBalancerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoadBalancerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetLoadBalancerErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetLoadBalancerErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetLoadBalancerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoadBalancerErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::NotFoundException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::ServiceException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetLoadBalancerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoadBalancerMetricDataError {
    pub kind: GetLoadBalancerMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoadBalancerMetricDataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoadBalancerMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoadBalancerMetricDataErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLoadBalancerMetricDataErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetLoadBalancerMetricDataErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetLoadBalancerMetricDataErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetLoadBalancerMetricDataErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetLoadBalancerMetricDataErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLoadBalancerMetricDataErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetLoadBalancerMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoadBalancerMetricDataError {
    fn code(&self) -> Option<&str> {
        GetLoadBalancerMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoadBalancerMetricDataError {
    pub fn new(kind: GetLoadBalancerMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoadBalancerMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoadBalancerMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerMetricDataErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetLoadBalancerMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoadBalancerMetricDataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLoadBalancerMetricDataErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetLoadBalancerMetricDataErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetLoadBalancerMetricDataErrorKind::NotFoundException(_inner) => Some(_inner),
            GetLoadBalancerMetricDataErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetLoadBalancerMetricDataErrorKind::ServiceException(_inner) => Some(_inner),
            GetLoadBalancerMetricDataErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetLoadBalancerMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoadBalancersError {
    pub kind: GetLoadBalancersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoadBalancersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoadBalancersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoadBalancersErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetLoadBalancersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoadBalancersError {
    fn code(&self) -> Option<&str> {
        GetLoadBalancersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoadBalancersError {
    pub fn new(kind: GetLoadBalancersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoadBalancersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoadBalancersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancersErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancersErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetLoadBalancersErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancersErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetLoadBalancersErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancersErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetLoadBalancersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoadBalancersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::NotFoundException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::ServiceException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetLoadBalancersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLoadBalancerTlsCertificatesError {
    pub kind: GetLoadBalancerTlsCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLoadBalancerTlsCertificatesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLoadBalancerTlsCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLoadBalancerTlsCertificatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLoadBalancerTlsCertificatesErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetLoadBalancerTlsCertificatesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetLoadBalancerTlsCertificatesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetLoadBalancerTlsCertificatesErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetLoadBalancerTlsCertificatesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetLoadBalancerTlsCertificatesErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetLoadBalancerTlsCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLoadBalancerTlsCertificatesError {
    fn code(&self) -> Option<&str> {
        GetLoadBalancerTlsCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLoadBalancerTlsCertificatesError {
    pub fn new(kind: GetLoadBalancerTlsCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLoadBalancerTlsCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLoadBalancerTlsCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLoadBalancerTlsCertificatesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetLoadBalancerTlsCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLoadBalancerTlsCertificatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLoadBalancerTlsCertificatesErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetLoadBalancerTlsCertificatesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetLoadBalancerTlsCertificatesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetLoadBalancerTlsCertificatesErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetLoadBalancerTlsCertificatesErrorKind::ServiceException(_inner) => Some(_inner),
            GetLoadBalancerTlsCertificatesErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetLoadBalancerTlsCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOperationError {
    pub kind: GetOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOperationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOperationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOperationError {
    fn code(&self) -> Option<&str> {
        GetOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOperationError {
    pub fn new(kind: GetOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetOperationErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetOperationErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetOperationErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetOperationErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOperationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetOperationErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetOperationErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetOperationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetOperationErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetOperationErrorKind::ServiceException(_inner) => Some(_inner),
            GetOperationErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOperationsError {
    pub kind: GetOperationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOperationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOperationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetOperationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOperationsError {
    fn code(&self) -> Option<&str> {
        GetOperationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOperationsError {
    pub fn new(kind: GetOperationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOperationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOperationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetOperationsErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetOperationsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetOperationsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetOperationsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetOperationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOperationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetOperationsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetOperationsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetOperationsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetOperationsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetOperationsErrorKind::ServiceException(_inner) => Some(_inner),
            GetOperationsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetOperationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOperationsForResourceError {
    pub kind: GetOperationsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOperationsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOperationsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOperationsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetOperationsForResourceErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetOperationsForResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetOperationsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetOperationsForResourceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetOperationsForResourceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetOperationsForResourceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetOperationsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOperationsForResourceError {
    fn code(&self) -> Option<&str> {
        GetOperationsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOperationsForResourceError {
    pub fn new(kind: GetOperationsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOperationsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOperationsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOperationsForResourceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetOperationsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOperationsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetOperationsForResourceErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetOperationsForResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetOperationsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            GetOperationsForResourceErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetOperationsForResourceErrorKind::ServiceException(_inner) => Some(_inner),
            GetOperationsForResourceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetOperationsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRegionsError {
    pub kind: GetRegionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRegionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetRegionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRegionsError {
    fn code(&self) -> Option<&str> {
        GetRegionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRegionsError {
    pub fn new(kind: GetRegionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRegionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRegionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetRegionsErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegionsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetRegionsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRegionsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRegionsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetRegionsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, GetRegionsErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for GetRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRegionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRegionsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetRegionsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRegionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRegionsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetRegionsErrorKind::ServiceException(_inner) => Some(_inner),
            GetRegionsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetRegionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseError {
    pub kind: GetRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseError {
    pub fn new(kind: GetRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseBlueprintsError {
    pub kind: GetRelationalDatabaseBlueprintsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseBlueprintsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseBlueprintsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseBlueprintsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBlueprintsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBlueprintsErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBlueprintsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseBlueprintsErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBlueprintsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseBlueprintsErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBlueprintsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseBlueprintsError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseBlueprintsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseBlueprintsError {
    pub fn new(kind: GetRelationalDatabaseBlueprintsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseBlueprintsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseBlueprintsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBlueprintsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseBlueprintsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseBlueprintsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseBlueprintsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseBlueprintsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseBlueprintsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseBlueprintsErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseBlueprintsErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseBlueprintsErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseBlueprintsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseBundlesError {
    pub kind: GetRelationalDatabaseBundlesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseBundlesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseBundlesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseBundlesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseBundlesErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBundlesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseBundlesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseBundlesErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBundlesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseBundlesErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseBundlesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseBundlesError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseBundlesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseBundlesError {
    pub fn new(kind: GetRelationalDatabaseBundlesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseBundlesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseBundlesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseBundlesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseBundlesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseBundlesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseBundlesErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseBundlesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseBundlesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseBundlesErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseBundlesErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseBundlesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetRelationalDatabaseBundlesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseEventsError {
    pub kind: GetRelationalDatabaseEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseEventsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseEventsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseEventsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseEventsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseEventsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseEventsErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseEventsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseEventsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseEventsError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseEventsError {
    pub fn new(kind: GetRelationalDatabaseEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseEventsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseEventsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseEventsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseEventsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseEventsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseEventsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetRelationalDatabaseEventsErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseEventsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetRelationalDatabaseEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseLogEventsError {
    pub kind: GetRelationalDatabaseLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseLogEventsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseLogEventsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseLogEventsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogEventsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseLogEventsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseLogEventsErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogEventsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseLogEventsErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseLogEventsError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseLogEventsError {
    pub fn new(kind: GetRelationalDatabaseLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogEventsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseLogEventsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseLogEventsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseLogEventsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseLogEventsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseLogEventsErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseLogEventsErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseLogEventsErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseLogStreamsError {
    pub kind: GetRelationalDatabaseLogStreamsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseLogStreamsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseLogStreamsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseLogStreamsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogStreamsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogStreamsErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogStreamsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseLogStreamsErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogStreamsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseLogStreamsErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseLogStreamsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseLogStreamsError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseLogStreamsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseLogStreamsError {
    pub fn new(kind: GetRelationalDatabaseLogStreamsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseLogStreamsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseLogStreamsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseLogStreamsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseLogStreamsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseLogStreamsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseLogStreamsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseLogStreamsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseLogStreamsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseLogStreamsErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseLogStreamsErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseLogStreamsErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseLogStreamsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseMasterUserPasswordError {
    pub kind: GetRelationalDatabaseMasterUserPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseMasterUserPasswordErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseMasterUserPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseMasterUserPasswordErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::AccountSetupInProgressException(
                _inner,
            ) => _inner.fmt(f),
            GetRelationalDatabaseMasterUserPasswordErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::ServiceException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseMasterUserPasswordError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseMasterUserPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseMasterUserPasswordError {
    pub fn new(
        kind: GetRelationalDatabaseMasterUserPasswordErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseMasterUserPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseMasterUserPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMasterUserPasswordErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseMasterUserPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseMasterUserPasswordErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::AccountSetupInProgressException(
                _inner,
            ) => Some(_inner),
            GetRelationalDatabaseMasterUserPasswordErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::ServiceException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMasterUserPasswordErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseMetricDataError {
    pub kind: GetRelationalDatabaseMetricDataErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseMetricDataErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseMetricDataError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseMetricDataErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMetricDataErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMetricDataErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMetricDataErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseMetricDataErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMetricDataErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseMetricDataErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseMetricDataErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseMetricDataError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseMetricDataError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseMetricDataError {
    pub fn new(kind: GetRelationalDatabaseMetricDataErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseMetricDataErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseMetricDataErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseMetricDataErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseMetricDataError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseMetricDataErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseMetricDataErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMetricDataErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseMetricDataErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseMetricDataErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMetricDataErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseMetricDataErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseMetricDataErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseParametersError {
    pub kind: GetRelationalDatabaseParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseParametersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseParametersErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseParametersErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseParametersErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseParametersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseParametersErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseParametersErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseParametersErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseParametersError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseParametersError {
    pub fn new(kind: GetRelationalDatabaseParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseParametersErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseParametersErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseParametersErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseParametersErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseParametersErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseParametersErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseParametersErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseParametersErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabasesError {
    pub kind: GetRelationalDatabasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabasesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabasesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabasesErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabasesErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabasesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabasesErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetRelationalDatabasesErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabasesErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetRelationalDatabasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabasesError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabasesError {
    pub fn new(kind: GetRelationalDatabasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabasesErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabasesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabasesErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabasesErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabasesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabasesErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetRelationalDatabasesErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabasesErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetRelationalDatabasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseSnapshotError {
    pub kind: GetRelationalDatabaseSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseSnapshotErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseSnapshotErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseSnapshotErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseSnapshotError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseSnapshotError {
    pub fn new(kind: GetRelationalDatabaseSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseSnapshotErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseSnapshotErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseSnapshotErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRelationalDatabaseSnapshotsError {
    pub kind: GetRelationalDatabaseSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRelationalDatabaseSnapshotsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRelationalDatabaseSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRelationalDatabaseSnapshotsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseSnapshotsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotsErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseSnapshotsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetRelationalDatabaseSnapshotsErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            GetRelationalDatabaseSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRelationalDatabaseSnapshotsError {
    fn code(&self) -> Option<&str> {
        GetRelationalDatabaseSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRelationalDatabaseSnapshotsError {
    pub fn new(kind: GetRelationalDatabaseSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRelationalDatabaseSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRelationalDatabaseSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRelationalDatabaseSnapshotsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetRelationalDatabaseSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRelationalDatabaseSnapshotsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseSnapshotsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotsErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseSnapshotsErrorKind::ServiceException(_inner) => Some(_inner),
            GetRelationalDatabaseSnapshotsErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            GetRelationalDatabaseSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStaticIpError {
    pub kind: GetStaticIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStaticIpErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStaticIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStaticIpErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetStaticIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStaticIpError {
    fn code(&self) -> Option<&str> {
        GetStaticIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStaticIpError {
    pub fn new(kind: GetStaticIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStaticIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStaticIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStaticIpErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStaticIpErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStaticIpErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetStaticIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStaticIpErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetStaticIpErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetStaticIpErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetStaticIpErrorKind::NotFoundException(_inner) => Some(_inner),
            GetStaticIpErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetStaticIpErrorKind::ServiceException(_inner) => Some(_inner),
            GetStaticIpErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetStaticIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStaticIpsError {
    pub kind: GetStaticIpsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStaticIpsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStaticIpsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStaticIpsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            GetStaticIpsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStaticIpsError {
    fn code(&self) -> Option<&str> {
        GetStaticIpsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStaticIpsError {
    pub fn new(kind: GetStaticIpsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStaticIpsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStaticIpsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpsErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStaticIpsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpsErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpsErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStaticIpsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, GetStaticIpsErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetStaticIpsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for GetStaticIpsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStaticIpsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::InvalidInputException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::OperationFailureException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::ServiceException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            GetStaticIpsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportKeyPairError {
    pub kind: ImportKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportKeyPairErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportKeyPairErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            ImportKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportKeyPairError {
    fn code(&self) -> Option<&str> {
        ImportKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportKeyPairError {
    pub fn new(kind: ImportKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ImportKeyPairErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyPairErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, ImportKeyPairErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ImportKeyPairErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyPairErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ImportKeyPairErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyPairErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for ImportKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportKeyPairErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::InvalidInputException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::NotFoundException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::OperationFailureException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::ServiceException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            ImportKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct IsVpcPeeredError {
    pub kind: IsVpcPeeredErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum IsVpcPeeredErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for IsVpcPeeredError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            IsVpcPeeredErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::ServiceException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            IsVpcPeeredErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for IsVpcPeeredError {
    fn code(&self) -> Option<&str> {
        IsVpcPeeredError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl IsVpcPeeredError {
    pub fn new(kind: IsVpcPeeredErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: IsVpcPeeredErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: IsVpcPeeredErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, IsVpcPeeredErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            IsVpcPeeredErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, IsVpcPeeredErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, IsVpcPeeredErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            IsVpcPeeredErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, IsVpcPeeredErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            IsVpcPeeredErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for IsVpcPeeredError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            IsVpcPeeredErrorKind::AccessDeniedException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::InvalidInputException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::NotFoundException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::OperationFailureException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::ServiceException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            IsVpcPeeredErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct OpenInstancePublicPortsError {
    pub kind: OpenInstancePublicPortsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum OpenInstancePublicPortsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for OpenInstancePublicPortsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            OpenInstancePublicPortsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            OpenInstancePublicPortsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            OpenInstancePublicPortsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            OpenInstancePublicPortsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            OpenInstancePublicPortsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            OpenInstancePublicPortsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            OpenInstancePublicPortsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            OpenInstancePublicPortsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for OpenInstancePublicPortsError {
    fn code(&self) -> Option<&str> {
        OpenInstancePublicPortsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl OpenInstancePublicPortsError {
    pub fn new(kind: OpenInstancePublicPortsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: OpenInstancePublicPortsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: OpenInstancePublicPortsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            OpenInstancePublicPortsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for OpenInstancePublicPortsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            OpenInstancePublicPortsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            OpenInstancePublicPortsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            OpenInstancePublicPortsErrorKind::InvalidInputException(_inner) => Some(_inner),
            OpenInstancePublicPortsErrorKind::NotFoundException(_inner) => Some(_inner),
            OpenInstancePublicPortsErrorKind::OperationFailureException(_inner) => Some(_inner),
            OpenInstancePublicPortsErrorKind::ServiceException(_inner) => Some(_inner),
            OpenInstancePublicPortsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            OpenInstancePublicPortsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PeerVpcError {
    pub kind: PeerVpcErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PeerVpcErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PeerVpcError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PeerVpcErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            PeerVpcErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PeerVpcError {
    fn code(&self) -> Option<&str> {
        PeerVpcError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PeerVpcError {
    pub fn new(kind: PeerVpcErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PeerVpcErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PeerVpcErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PeerVpcErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            PeerVpcErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, PeerVpcErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PeerVpcErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, PeerVpcErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, PeerVpcErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, PeerVpcErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for PeerVpcError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PeerVpcErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PeerVpcErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            PeerVpcErrorKind::InvalidInputException(_inner) => Some(_inner),
            PeerVpcErrorKind::NotFoundException(_inner) => Some(_inner),
            PeerVpcErrorKind::OperationFailureException(_inner) => Some(_inner),
            PeerVpcErrorKind::ServiceException(_inner) => Some(_inner),
            PeerVpcErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            PeerVpcErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAlarmError {
    pub kind: PutAlarmErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAlarmErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAlarmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAlarmErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutAlarmErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutAlarmErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutAlarmErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            PutAlarmErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PutAlarmErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            PutAlarmErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAlarmError {
    fn code(&self) -> Option<&str> {
        PutAlarmError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAlarmError {
    pub fn new(kind: PutAlarmErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAlarmErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAlarmErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutAlarmErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, PutAlarmErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutAlarmErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, PutAlarmErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, PutAlarmErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, PutAlarmErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for PutAlarmError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAlarmErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutAlarmErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutAlarmErrorKind::NotFoundException(_inner) => Some(_inner),
            PutAlarmErrorKind::OperationFailureException(_inner) => Some(_inner),
            PutAlarmErrorKind::ServiceException(_inner) => Some(_inner),
            PutAlarmErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            PutAlarmErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutInstancePublicPortsError {
    pub kind: PutInstancePublicPortsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutInstancePublicPortsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutInstancePublicPortsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutInstancePublicPortsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutInstancePublicPortsErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            PutInstancePublicPortsErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            PutInstancePublicPortsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutInstancePublicPortsErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            PutInstancePublicPortsErrorKind::ServiceException(_inner) => _inner.fmt(f),
            PutInstancePublicPortsErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            PutInstancePublicPortsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutInstancePublicPortsError {
    fn code(&self) -> Option<&str> {
        PutInstancePublicPortsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutInstancePublicPortsError {
    pub fn new(kind: PutInstancePublicPortsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutInstancePublicPortsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutInstancePublicPortsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutInstancePublicPortsErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for PutInstancePublicPortsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutInstancePublicPortsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutInstancePublicPortsErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            PutInstancePublicPortsErrorKind::InvalidInputException(_inner) => Some(_inner),
            PutInstancePublicPortsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutInstancePublicPortsErrorKind::OperationFailureException(_inner) => Some(_inner),
            PutInstancePublicPortsErrorKind::ServiceException(_inner) => Some(_inner),
            PutInstancePublicPortsErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            PutInstancePublicPortsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootInstanceError {
    pub kind: RebootInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            RebootInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootInstanceError {
    fn code(&self) -> Option<&str> {
        RebootInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootInstanceError {
    pub fn new(kind: RebootInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootInstanceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootInstanceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootInstanceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RebootInstanceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootInstanceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, RebootInstanceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootInstanceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for RebootInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RebootInstanceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            RebootInstanceErrorKind::InvalidInputException(_inner) => Some(_inner),
            RebootInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            RebootInstanceErrorKind::OperationFailureException(_inner) => Some(_inner),
            RebootInstanceErrorKind::ServiceException(_inner) => Some(_inner),
            RebootInstanceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            RebootInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootRelationalDatabaseError {
    pub kind: RebootRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RebootRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            RebootRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RebootRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RebootRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            RebootRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            RebootRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            RebootRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        RebootRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootRelationalDatabaseError {
    pub fn new(kind: RebootRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for RebootRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RebootRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            RebootRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            RebootRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            RebootRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            RebootRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            RebootRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            RebootRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterContainerImageError {
    pub kind: RegisterContainerImageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterContainerImageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterContainerImageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterContainerImageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RegisterContainerImageErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            RegisterContainerImageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RegisterContainerImageErrorKind::ServiceException(_inner) => _inner.fmt(f),
            RegisterContainerImageErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            RegisterContainerImageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterContainerImageError {
    fn code(&self) -> Option<&str> {
        RegisterContainerImageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterContainerImageError {
    pub fn new(kind: RegisterContainerImageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterContainerImageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterContainerImageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerImageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerImageErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerImageErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerImageErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            RegisterContainerImageErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for RegisterContainerImageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterContainerImageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RegisterContainerImageErrorKind::InvalidInputException(_inner) => Some(_inner),
            RegisterContainerImageErrorKind::NotFoundException(_inner) => Some(_inner),
            RegisterContainerImageErrorKind::ServiceException(_inner) => Some(_inner),
            RegisterContainerImageErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            RegisterContainerImageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReleaseStaticIpError {
    pub kind: ReleaseStaticIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReleaseStaticIpErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReleaseStaticIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReleaseStaticIpErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            ReleaseStaticIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReleaseStaticIpError {
    fn code(&self) -> Option<&str> {
        ReleaseStaticIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReleaseStaticIpError {
    pub fn new(kind: ReleaseStaticIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReleaseStaticIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReleaseStaticIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReleaseStaticIpErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReleaseStaticIpErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReleaseStaticIpErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ReleaseStaticIpErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReleaseStaticIpErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, ReleaseStaticIpErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReleaseStaticIpErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for ReleaseStaticIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReleaseStaticIpErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::InvalidInputException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::NotFoundException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::OperationFailureException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::ServiceException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            ReleaseStaticIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetDistributionCacheError {
    pub kind: ResetDistributionCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDistributionCacheErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetDistributionCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetDistributionCacheErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ResetDistributionCacheErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            ResetDistributionCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ResetDistributionCacheErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            ResetDistributionCacheErrorKind::ServiceException(_inner) => _inner.fmt(f),
            ResetDistributionCacheErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            ResetDistributionCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetDistributionCacheError {
    fn code(&self) -> Option<&str> {
        ResetDistributionCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDistributionCacheError {
    pub fn new(kind: ResetDistributionCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetDistributionCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetDistributionCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetDistributionCacheErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetDistributionCacheErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetDistributionCacheErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetDistributionCacheErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetDistributionCacheErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetDistributionCacheErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for ResetDistributionCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetDistributionCacheErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ResetDistributionCacheErrorKind::InvalidInputException(_inner) => Some(_inner),
            ResetDistributionCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            ResetDistributionCacheErrorKind::OperationFailureException(_inner) => Some(_inner),
            ResetDistributionCacheErrorKind::ServiceException(_inner) => Some(_inner),
            ResetDistributionCacheErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            ResetDistributionCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendContactMethodVerificationError {
    pub kind: SendContactMethodVerificationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendContactMethodVerificationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendContactMethodVerificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendContactMethodVerificationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SendContactMethodVerificationErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SendContactMethodVerificationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SendContactMethodVerificationErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            SendContactMethodVerificationErrorKind::ServiceException(_inner) => _inner.fmt(f),
            SendContactMethodVerificationErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            SendContactMethodVerificationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendContactMethodVerificationError {
    fn code(&self) -> Option<&str> {
        SendContactMethodVerificationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendContactMethodVerificationError {
    pub fn new(kind: SendContactMethodVerificationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendContactMethodVerificationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendContactMethodVerificationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendContactMethodVerificationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendContactMethodVerificationErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendContactMethodVerificationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendContactMethodVerificationErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendContactMethodVerificationErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendContactMethodVerificationErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for SendContactMethodVerificationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendContactMethodVerificationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SendContactMethodVerificationErrorKind::InvalidInputException(_inner) => Some(_inner),
            SendContactMethodVerificationErrorKind::NotFoundException(_inner) => Some(_inner),
            SendContactMethodVerificationErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            SendContactMethodVerificationErrorKind::ServiceException(_inner) => Some(_inner),
            SendContactMethodVerificationErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            SendContactMethodVerificationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetIpAddressTypeError {
    pub kind: SetIpAddressTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetIpAddressTypeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetIpAddressTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetIpAddressTypeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::ServiceException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            SetIpAddressTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetIpAddressTypeError {
    fn code(&self) -> Option<&str> {
        SetIpAddressTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetIpAddressTypeError {
    pub fn new(kind: SetIpAddressTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetIpAddressTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetIpAddressTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetIpAddressTypeErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetIpAddressTypeErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetIpAddressTypeErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, SetIpAddressTypeErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetIpAddressTypeErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, SetIpAddressTypeErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetIpAddressTypeErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for SetIpAddressTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetIpAddressTypeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::InvalidInputException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::OperationFailureException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::ServiceException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            SetIpAddressTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartInstanceError {
    pub kind: StartInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            StartInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartInstanceError {
    fn code(&self) -> Option<&str> {
        StartInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartInstanceError {
    pub fn new(kind: StartInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StartInstanceErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartInstanceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, StartInstanceErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StartInstanceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartInstanceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, StartInstanceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartInstanceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for StartInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartInstanceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            StartInstanceErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            StartInstanceErrorKind::OperationFailureException(_inner) => Some(_inner),
            StartInstanceErrorKind::ServiceException(_inner) => Some(_inner),
            StartInstanceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            StartInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartRelationalDatabaseError {
    pub kind: StartRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StartRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            StartRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StartRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            StartRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            StartRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            StartRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        StartRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartRelationalDatabaseError {
    pub fn new(kind: StartRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for StartRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StartRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            StartRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            StartRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            StartRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            StartRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            StartRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            StartRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopInstanceError {
    pub kind: StopInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            StopInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopInstanceError {
    fn code(&self) -> Option<&str> {
        StopInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopInstanceError {
    pub fn new(kind: StopInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, StopInstanceErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopInstanceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, StopInstanceErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopInstanceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopInstanceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, StopInstanceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopInstanceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for StopInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopInstanceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            StopInstanceErrorKind::InvalidInputException(_inner) => Some(_inner),
            StopInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            StopInstanceErrorKind::OperationFailureException(_inner) => Some(_inner),
            StopInstanceErrorKind::ServiceException(_inner) => Some(_inner),
            StopInstanceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            StopInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopRelationalDatabaseError {
    pub kind: StopRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            StopRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            StopRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            StopRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            StopRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            StopRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            StopRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        StopRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopRelationalDatabaseError {
    pub fn new(kind: StopRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for StopRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            StopRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            StopRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            StopRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            StopRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            StopRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            StopRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            StopRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::OperationFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::ServiceException(_inner) => Some(_inner),
            TagResourceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestAlarmError {
    pub kind: TestAlarmErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestAlarmErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestAlarmError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestAlarmErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TestAlarmErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            TestAlarmErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TestAlarmErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            TestAlarmErrorKind::ServiceException(_inner) => _inner.fmt(f),
            TestAlarmErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            TestAlarmErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestAlarmError {
    fn code(&self) -> Option<&str> {
        TestAlarmError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestAlarmError {
    pub fn new(kind: TestAlarmErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestAlarmErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestAlarmErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TestAlarmErrorKind::AccessDeniedException(_))
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, TestAlarmErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TestAlarmErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, TestAlarmErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, TestAlarmErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, TestAlarmErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for TestAlarmError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestAlarmErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TestAlarmErrorKind::InvalidInputException(_inner) => Some(_inner),
            TestAlarmErrorKind::NotFoundException(_inner) => Some(_inner),
            TestAlarmErrorKind::OperationFailureException(_inner) => Some(_inner),
            TestAlarmErrorKind::ServiceException(_inner) => Some(_inner),
            TestAlarmErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            TestAlarmErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UnpeerVpcError {
    pub kind: UnpeerVpcErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UnpeerVpcErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UnpeerVpcError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UnpeerVpcErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UnpeerVpcErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UnpeerVpcError {
    fn code(&self) -> Option<&str> {
        UnpeerVpcError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UnpeerVpcError {
    pub fn new(kind: UnpeerVpcErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UnpeerVpcErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UnpeerVpcErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UnpeerVpcErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UnpeerVpcErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UnpeerVpcErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UnpeerVpcErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(&self.kind, UnpeerVpcErrorKind::OperationFailureException(_))
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UnpeerVpcErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(&self.kind, UnpeerVpcErrorKind::UnauthenticatedException(_))
    }
}
impl std::error::Error for UnpeerVpcError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UnpeerVpcErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::InvalidInputException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::NotFoundException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::OperationFailureException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::ServiceException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UnpeerVpcErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidInputException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidInputException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::OperationFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServiceException(_inner) => Some(_inner),
            UntagResourceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContainerServiceError {
    pub kind: UpdateContainerServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContainerServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContainerServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContainerServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateContainerServiceErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateContainerServiceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateContainerServiceErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateContainerServiceErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UpdateContainerServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContainerServiceError {
    fn code(&self) -> Option<&str> {
        UpdateContainerServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContainerServiceError {
    pub fn new(kind: UpdateContainerServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContainerServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContainerServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerServiceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerServiceErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerServiceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerServiceErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContainerServiceErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateContainerServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContainerServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateContainerServiceErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateContainerServiceErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateContainerServiceErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateContainerServiceErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UpdateContainerServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDistributionError {
    pub kind: UpdateDistributionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDistributionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDistributionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDistributionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDistributionErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateDistributionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDistributionErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            UpdateDistributionErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateDistributionErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UpdateDistributionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDistributionError {
    fn code(&self) -> Option<&str> {
        UpdateDistributionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDistributionError {
    pub fn new(kind: UpdateDistributionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDistributionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDistributionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UpdateDistributionErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateDistributionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDistributionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDistributionErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateDistributionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDistributionErrorKind::OperationFailureException(_inner) => Some(_inner),
            UpdateDistributionErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateDistributionErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UpdateDistributionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDistributionBundleError {
    pub kind: UpdateDistributionBundleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDistributionBundleErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDistributionBundleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDistributionBundleErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDistributionBundleErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateDistributionBundleErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDistributionBundleErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            UpdateDistributionBundleErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateDistributionBundleErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UpdateDistributionBundleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDistributionBundleError {
    fn code(&self) -> Option<&str> {
        UpdateDistributionBundleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDistributionBundleError {
    pub fn new(kind: UpdateDistributionBundleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDistributionBundleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDistributionBundleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionBundleErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionBundleErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionBundleErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionBundleErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionBundleErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDistributionBundleErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateDistributionBundleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDistributionBundleErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDistributionBundleErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateDistributionBundleErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDistributionBundleErrorKind::OperationFailureException(_inner) => Some(_inner),
            UpdateDistributionBundleErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateDistributionBundleErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UpdateDistributionBundleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainEntryError {
    pub kind: UpdateDomainEntryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainEntryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainEntryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainEntryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::AccountSetupInProgressException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UpdateDomainEntryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainEntryError {
    fn code(&self) -> Option<&str> {
        UpdateDomainEntryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainEntryError {
    pub fn new(kind: UpdateDomainEntryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainEntryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainEntryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainEntryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainEntryErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainEntryErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateDomainEntryErrorKind::NotFoundException(_))
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainEntryErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(&self.kind, UpdateDomainEntryErrorKind::ServiceException(_))
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainEntryErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateDomainEntryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainEntryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::AccountSetupInProgressException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::OperationFailureException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UpdateDomainEntryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLoadBalancerAttributeError {
    pub kind: UpdateLoadBalancerAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLoadBalancerAttributeErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLoadBalancerAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLoadBalancerAttributeErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateLoadBalancerAttributeErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLoadBalancerAttributeErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateLoadBalancerAttributeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateLoadBalancerAttributeErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLoadBalancerAttributeErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateLoadBalancerAttributeErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UpdateLoadBalancerAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLoadBalancerAttributeError {
    fn code(&self) -> Option<&str> {
        UpdateLoadBalancerAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLoadBalancerAttributeError {
    pub fn new(kind: UpdateLoadBalancerAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLoadBalancerAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLoadBalancerAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLoadBalancerAttributeErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateLoadBalancerAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLoadBalancerAttributeErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateLoadBalancerAttributeErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            UpdateLoadBalancerAttributeErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateLoadBalancerAttributeErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateLoadBalancerAttributeErrorKind::OperationFailureException(_inner) => Some(_inner),
            UpdateLoadBalancerAttributeErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateLoadBalancerAttributeErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UpdateLoadBalancerAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRelationalDatabaseError {
    pub kind: UpdateRelationalDatabaseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRelationalDatabaseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRelationalDatabaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRelationalDatabaseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRelationalDatabaseErrorKind::InvalidInputException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseErrorKind::OperationFailureException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRelationalDatabaseError {
    fn code(&self) -> Option<&str> {
        UpdateRelationalDatabaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRelationalDatabaseError {
    pub fn new(kind: UpdateRelationalDatabaseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRelationalDatabaseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRelationalDatabaseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateRelationalDatabaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRelationalDatabaseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateRelationalDatabaseErrorKind::AccountSetupInProgressException(_inner) => {
                Some(_inner)
            }
            UpdateRelationalDatabaseErrorKind::InvalidInputException(_inner) => Some(_inner),
            UpdateRelationalDatabaseErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRelationalDatabaseErrorKind::OperationFailureException(_inner) => Some(_inner),
            UpdateRelationalDatabaseErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateRelationalDatabaseErrorKind::UnauthenticatedException(_inner) => Some(_inner),
            UpdateRelationalDatabaseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRelationalDatabaseParametersError {
    pub kind: UpdateRelationalDatabaseParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRelationalDatabaseParametersErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AccountSetupInProgressException(crate::error::AccountSetupInProgressException),
    InvalidInputException(crate::error::InvalidInputException),
    NotFoundException(crate::error::NotFoundException),
    OperationFailureException(crate::error::OperationFailureException),
    ServiceException(crate::error::ServiceException),
    UnauthenticatedException(crate::error::UnauthenticatedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRelationalDatabaseParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRelationalDatabaseParametersErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRelationalDatabaseParametersErrorKind::AccountSetupInProgressException(
                _inner,
            ) => _inner.fmt(f),
            UpdateRelationalDatabaseParametersErrorKind::InvalidInputException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRelationalDatabaseParametersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseParametersErrorKind::OperationFailureException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRelationalDatabaseParametersErrorKind::ServiceException(_inner) => _inner.fmt(f),
            UpdateRelationalDatabaseParametersErrorKind::UnauthenticatedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRelationalDatabaseParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRelationalDatabaseParametersError {
    fn code(&self) -> Option<&str> {
        UpdateRelationalDatabaseParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRelationalDatabaseParametersError {
    pub fn new(
        kind: UpdateRelationalDatabaseParametersErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRelationalDatabaseParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRelationalDatabaseParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_account_setup_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::AccountSetupInProgressException(_)
        )
    }
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::InvalidInputException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::NotFoundException(_)
        )
    }
    pub fn is_operation_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::OperationFailureException(_)
        )
    }
    pub fn is_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::ServiceException(_)
        )
    }
    pub fn is_unauthenticated_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRelationalDatabaseParametersErrorKind::UnauthenticatedException(_)
        )
    }
}
impl std::error::Error for UpdateRelationalDatabaseParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRelationalDatabaseParametersErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateRelationalDatabaseParametersErrorKind::AccountSetupInProgressException(
                _inner,
            ) => Some(_inner),
            UpdateRelationalDatabaseParametersErrorKind::InvalidInputException(_inner) => {
                Some(_inner)
            }
            UpdateRelationalDatabaseParametersErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRelationalDatabaseParametersErrorKind::OperationFailureException(_inner) => {
                Some(_inner)
            }
            UpdateRelationalDatabaseParametersErrorKind::ServiceException(_inner) => Some(_inner),
            UpdateRelationalDatabaseParametersErrorKind::UnauthenticatedException(_inner) => {
                Some(_inner)
            }
            UpdateRelationalDatabaseParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Lightsail throws this exception when the user has not been authenticated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthenticatedException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthenticatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthenticatedException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl UnauthenticatedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthenticatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthenticatedException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthenticatedException {}
/// See [`UnauthenticatedException`](crate::error::UnauthenticatedException)
pub mod unauthenticated_exception {
    /// A builder for [`UnauthenticatedException`](crate::error::UnauthenticatedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthenticatedException`](crate::error::UnauthenticatedException)
        pub fn build(self) -> crate::error::UnauthenticatedException {
            crate::error::UnauthenticatedException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl UnauthenticatedException {
    /// Creates a new builder-style object to manufacture [`UnauthenticatedException`](crate::error::UnauthenticatedException)
    pub fn builder() -> crate::error::unauthenticated_exception::Builder {
        crate::error::unauthenticated_exception::Builder::default()
    }
}

/// <p>A general service exception.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl ServiceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceException {}
/// See [`ServiceException`](crate::error::ServiceException)
pub mod service_exception {
    /// A builder for [`ServiceException`](crate::error::ServiceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceException`](crate::error::ServiceException)
        pub fn build(self) -> crate::error::ServiceException {
            crate::error::ServiceException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl ServiceException {
    /// Creates a new builder-style object to manufacture [`ServiceException`](crate::error::ServiceException)
    pub fn builder() -> crate::error::service_exception::Builder {
        crate::error::service_exception::Builder::default()
    }
}

/// <p>Lightsail throws this exception when an operation fails to execute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationFailureException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationFailureException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl OperationFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationFailureException {}
/// See [`OperationFailureException`](crate::error::OperationFailureException)
pub mod operation_failure_exception {
    /// A builder for [`OperationFailureException`](crate::error::OperationFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationFailureException`](crate::error::OperationFailureException)
        pub fn build(self) -> crate::error::OperationFailureException {
            crate::error::OperationFailureException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl OperationFailureException {
    /// Creates a new builder-style object to manufacture [`OperationFailureException`](crate::error::OperationFailureException)
    pub fn builder() -> crate::error::operation_failure_exception::Builder {
        crate::error::operation_failure_exception::Builder::default()
    }
}

/// <p>Lightsail throws this exception when it cannot find a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>Lightsail throws this exception when user input does not conform to the validation rules
/// of an input field.</p>
/// <note>
/// <p>Domain and distribution APIs are only available in the N. Virginia
/// (<code>us-east-1</code>) AWS Region. Please set your AWS Region configuration to
/// <code>us-east-1</code> to create, view, or edit these resources.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidInputException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidInputException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl InvalidInputException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputException {}
/// See [`InvalidInputException`](crate::error::InvalidInputException)
pub mod invalid_input_exception {
    /// A builder for [`InvalidInputException`](crate::error::InvalidInputException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputException`](crate::error::InvalidInputException)
        pub fn build(self) -> crate::error::InvalidInputException {
            crate::error::InvalidInputException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl InvalidInputException {
    /// Creates a new builder-style object to manufacture [`InvalidInputException`](crate::error::InvalidInputException)
    pub fn builder() -> crate::error::invalid_input_exception::Builder {
        crate::error::invalid_input_exception::Builder::default()
    }
}

/// <p>Lightsail throws this exception when an account is still in the setup in progress
/// state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountSetupInProgressException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountSetupInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountSetupInProgressException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl AccountSetupInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccountSetupInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccountSetupInProgressException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccountSetupInProgressException {}
/// See [`AccountSetupInProgressException`](crate::error::AccountSetupInProgressException)
pub mod account_setup_in_progress_exception {
    /// A builder for [`AccountSetupInProgressException`](crate::error::AccountSetupInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSetupInProgressException`](crate::error::AccountSetupInProgressException)
        pub fn build(self) -> crate::error::AccountSetupInProgressException {
            crate::error::AccountSetupInProgressException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl AccountSetupInProgressException {
    /// Creates a new builder-style object to manufacture [`AccountSetupInProgressException`](crate::error::AccountSetupInProgressException)
    pub fn builder() -> crate::error::account_setup_in_progress_exception::Builder {
        crate::error::account_setup_in_progress_exception::Builder::default()
    }
}

/// <p>Lightsail throws this exception when the user cannot be authenticated or uses invalid
/// credentials to access a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub code: std::option::Option<std::string::String>,
    pub docs: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
    pub tip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("code", &self.code);
        formatter.field("docs", &self.docs);
        formatter.field("message", &self.message);
        formatter.field("tip", &self.tip);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) docs: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) tip: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        pub fn docs(mut self, input: impl Into<std::string::String>) -> Self {
            self.docs = Some(input.into());
            self
        }
        pub fn set_docs(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.docs = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn tip(mut self, input: impl Into<std::string::String>) -> Self {
            self.tip = Some(input.into());
            self
        }
        pub fn set_tip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tip = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                code: self.code,
                docs: self.docs,
                message: self.message,
                tip: self.tip,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
