// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a load balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoadBalancer {
    /// <p>The name of the load balancer (e.g., <code>my-load-balancer</code>).</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The support code. Include this code in your email to support when you have questions about your Lightsail load balancer. This code enables our support team to look up your Lightsail information more easily.</p>
    #[doc(hidden)]
    pub support_code: std::option::Option<std::string::String>,
    /// <p>The date when your load balancer was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The AWS Region where your load balancer was created (e.g., <code>us-east-2a</code>). Lightsail automatically creates your load balancer across Availability Zones.</p>
    #[doc(hidden)]
    pub location: std::option::Option<crate::types::ResourceLocation>,
    /// <p>The resource type (e.g., <code>LoadBalancer</code>.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::types::ResourceType>,
    /// <p>The tag keys and optional values for the resource. For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    /// <p>The DNS name of your Lightsail load balancer.</p>
    #[doc(hidden)]
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>The status of your load balancer. Valid values are below.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::types::LoadBalancerState>,
    /// <p>The protocol you have enabled for your load balancer. Valid values are below.</p>
    /// <p>You can't just have <code>HTTP_HTTPS</code>, but you can have just <code>HTTP</code>.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::types::LoadBalancerProtocol>,
    /// <p>An array of public port settings for your load balancer. For HTTP, use port 80. For HTTPS, use port 443.</p>
    #[doc(hidden)]
    pub public_ports: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The path you specified to perform your health checks. If no path is specified, the load balancer tries to make a request to the default (root) page.</p>
    #[doc(hidden)]
    pub health_check_path: std::option::Option<std::string::String>,
    /// <p>The port where the load balancer will direct traffic to your Lightsail instances. For HTTP traffic, it's port 80. For HTTPS traffic, it's port 443.</p>
    #[doc(hidden)]
    pub instance_port: std::option::Option<i32>,
    /// <p>An array of InstanceHealthSummary objects describing the health of the load balancer.</p>
    #[doc(hidden)]
    pub instance_health_summary:
        std::option::Option<std::vec::Vec<crate::types::InstanceHealthSummary>>,
    /// <p>An array of LoadBalancerTlsCertificateSummary objects that provide additional information about the SSL/TLS certificates. For example, if <code>true</code>, the certificate is attached to the load balancer.</p>
    #[doc(hidden)]
    pub tls_certificate_summaries:
        std::option::Option<std::vec::Vec<crate::types::LoadBalancerTlsCertificateSummary>>,
    /// <p>A string to string map of the configuration options for your load balancer. Valid values are listed below.</p>
    #[doc(hidden)]
    pub configuration_options: std::option::Option<
        std::collections::HashMap<crate::types::LoadBalancerAttributeName, std::string::String>,
    >,
    /// <p>The IP address type of the load balancer.</p>
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for IPv4 and IPv6.</p>
    #[doc(hidden)]
    pub ip_address_type: std::option::Option<crate::types::IpAddressType>,
    /// <p>A Boolean value that indicates whether HTTPS redirection is enabled for the load balancer.</p>
    #[doc(hidden)]
    pub https_redirection_enabled: std::option::Option<bool>,
    /// <p>The name of the TLS security policy for the load balancer.</p>
    #[doc(hidden)]
    pub tls_policy_name: std::option::Option<std::string::String>,
}
impl LoadBalancer {
    /// <p>The name of the load balancer (e.g., <code>my-load-balancer</code>).</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The support code. Include this code in your email to support when you have questions about your Lightsail load balancer. This code enables our support team to look up your Lightsail information more easily.</p>
    pub fn support_code(&self) -> std::option::Option<&str> {
        self.support_code.as_deref()
    }
    /// <p>The date when your load balancer was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The AWS Region where your load balancer was created (e.g., <code>us-east-2a</code>). Lightsail automatically creates your load balancer across Availability Zones.</p>
    pub fn location(&self) -> std::option::Option<&crate::types::ResourceLocation> {
        self.location.as_ref()
    }
    /// <p>The resource type (e.g., <code>LoadBalancer</code>.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::types::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The tag keys and optional values for the resource. For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The DNS name of your Lightsail load balancer.</p>
    pub fn dns_name(&self) -> std::option::Option<&str> {
        self.dns_name.as_deref()
    }
    /// <p>The status of your load balancer. Valid values are below.</p>
    pub fn state(&self) -> std::option::Option<&crate::types::LoadBalancerState> {
        self.state.as_ref()
    }
    /// <p>The protocol you have enabled for your load balancer. Valid values are below.</p>
    /// <p>You can't just have <code>HTTP_HTTPS</code>, but you can have just <code>HTTP</code>.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::types::LoadBalancerProtocol> {
        self.protocol.as_ref()
    }
    /// <p>An array of public port settings for your load balancer. For HTTP, use port 80. For HTTPS, use port 443.</p>
    pub fn public_ports(&self) -> std::option::Option<&[i32]> {
        self.public_ports.as_deref()
    }
    /// <p>The path you specified to perform your health checks. If no path is specified, the load balancer tries to make a request to the default (root) page.</p>
    pub fn health_check_path(&self) -> std::option::Option<&str> {
        self.health_check_path.as_deref()
    }
    /// <p>The port where the load balancer will direct traffic to your Lightsail instances. For HTTP traffic, it's port 80. For HTTPS traffic, it's port 443.</p>
    pub fn instance_port(&self) -> std::option::Option<i32> {
        self.instance_port
    }
    /// <p>An array of InstanceHealthSummary objects describing the health of the load balancer.</p>
    pub fn instance_health_summary(
        &self,
    ) -> std::option::Option<&[crate::types::InstanceHealthSummary]> {
        self.instance_health_summary.as_deref()
    }
    /// <p>An array of LoadBalancerTlsCertificateSummary objects that provide additional information about the SSL/TLS certificates. For example, if <code>true</code>, the certificate is attached to the load balancer.</p>
    pub fn tls_certificate_summaries(
        &self,
    ) -> std::option::Option<&[crate::types::LoadBalancerTlsCertificateSummary]> {
        self.tls_certificate_summaries.as_deref()
    }
    /// <p>A string to string map of the configuration options for your load balancer. Valid values are listed below.</p>
    pub fn configuration_options(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::types::LoadBalancerAttributeName, std::string::String>,
    > {
        self.configuration_options.as_ref()
    }
    /// <p>The IP address type of the load balancer.</p>
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for IPv4 and IPv6.</p>
    pub fn ip_address_type(&self) -> std::option::Option<&crate::types::IpAddressType> {
        self.ip_address_type.as_ref()
    }
    /// <p>A Boolean value that indicates whether HTTPS redirection is enabled for the load balancer.</p>
    pub fn https_redirection_enabled(&self) -> std::option::Option<bool> {
        self.https_redirection_enabled
    }
    /// <p>The name of the TLS security policy for the load balancer.</p>
    pub fn tls_policy_name(&self) -> std::option::Option<&str> {
        self.tls_policy_name.as_deref()
    }
}
impl LoadBalancer {
    /// Creates a new builder-style object to manufacture [`LoadBalancer`](crate::types::LoadBalancer).
    pub fn builder() -> crate::types::builders::LoadBalancerBuilder {
        crate::types::builders::LoadBalancerBuilder::default()
    }
}

/// A builder for [`LoadBalancer`](crate::types::LoadBalancer).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct LoadBalancerBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) support_code: std::option::Option<std::string::String>,
    pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) location: std::option::Option<crate::types::ResourceLocation>,
    pub(crate) resource_type: std::option::Option<crate::types::ResourceType>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    pub(crate) dns_name: std::option::Option<std::string::String>,
    pub(crate) state: std::option::Option<crate::types::LoadBalancerState>,
    pub(crate) protocol: std::option::Option<crate::types::LoadBalancerProtocol>,
    pub(crate) public_ports: std::option::Option<std::vec::Vec<i32>>,
    pub(crate) health_check_path: std::option::Option<std::string::String>,
    pub(crate) instance_port: std::option::Option<i32>,
    pub(crate) instance_health_summary:
        std::option::Option<std::vec::Vec<crate::types::InstanceHealthSummary>>,
    pub(crate) tls_certificate_summaries:
        std::option::Option<std::vec::Vec<crate::types::LoadBalancerTlsCertificateSummary>>,
    pub(crate) configuration_options: std::option::Option<
        std::collections::HashMap<crate::types::LoadBalancerAttributeName, std::string::String>,
    >,
    pub(crate) ip_address_type: std::option::Option<crate::types::IpAddressType>,
    pub(crate) https_redirection_enabled: std::option::Option<bool>,
    pub(crate) tls_policy_name: std::option::Option<std::string::String>,
}
impl LoadBalancerBuilder {
    /// <p>The name of the load balancer (e.g., <code>my-load-balancer</code>).</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the load balancer (e.g., <code>my-load-balancer</code>).</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The support code. Include this code in your email to support when you have questions about your Lightsail load balancer. This code enables our support team to look up your Lightsail information more easily.</p>
    pub fn support_code(mut self, input: impl Into<std::string::String>) -> Self {
        self.support_code = Some(input.into());
        self
    }
    /// <p>The support code. Include this code in your email to support when you have questions about your Lightsail load balancer. This code enables our support team to look up your Lightsail information more easily.</p>
    pub fn set_support_code(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.support_code = input;
        self
    }
    /// <p>The date when your load balancer was created.</p>
    pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.created_at = Some(input);
        self
    }
    /// <p>The date when your load balancer was created.</p>
    pub fn set_created_at(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The AWS Region where your load balancer was created (e.g., <code>us-east-2a</code>). Lightsail automatically creates your load balancer across Availability Zones.</p>
    pub fn location(mut self, input: crate::types::ResourceLocation) -> Self {
        self.location = Some(input);
        self
    }
    /// <p>The AWS Region where your load balancer was created (e.g., <code>us-east-2a</code>). Lightsail automatically creates your load balancer across Availability Zones.</p>
    pub fn set_location(
        mut self,
        input: std::option::Option<crate::types::ResourceLocation>,
    ) -> Self {
        self.location = input;
        self
    }
    /// <p>The resource type (e.g., <code>LoadBalancer</code>.</p>
    pub fn resource_type(mut self, input: crate::types::ResourceType) -> Self {
        self.resource_type = Some(input);
        self
    }
    /// <p>The resource type (e.g., <code>LoadBalancer</code>.</p>
    pub fn set_resource_type(
        mut self,
        input: std::option::Option<crate::types::ResourceType>,
    ) -> Self {
        self.resource_type = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tag keys and optional values for the resource. For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>The tag keys and optional values for the resource. For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>The DNS name of your Lightsail load balancer.</p>
    pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.dns_name = Some(input.into());
        self
    }
    /// <p>The DNS name of your Lightsail load balancer.</p>
    pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.dns_name = input;
        self
    }
    /// <p>The status of your load balancer. Valid values are below.</p>
    pub fn state(mut self, input: crate::types::LoadBalancerState) -> Self {
        self.state = Some(input);
        self
    }
    /// <p>The status of your load balancer. Valid values are below.</p>
    pub fn set_state(
        mut self,
        input: std::option::Option<crate::types::LoadBalancerState>,
    ) -> Self {
        self.state = input;
        self
    }
    /// <p>The protocol you have enabled for your load balancer. Valid values are below.</p>
    /// <p>You can't just have <code>HTTP_HTTPS</code>, but you can have just <code>HTTP</code>.</p>
    pub fn protocol(mut self, input: crate::types::LoadBalancerProtocol) -> Self {
        self.protocol = Some(input);
        self
    }
    /// <p>The protocol you have enabled for your load balancer. Valid values are below.</p>
    /// <p>You can't just have <code>HTTP_HTTPS</code>, but you can have just <code>HTTP</code>.</p>
    pub fn set_protocol(
        mut self,
        input: std::option::Option<crate::types::LoadBalancerProtocol>,
    ) -> Self {
        self.protocol = input;
        self
    }
    /// Appends an item to `public_ports`.
    ///
    /// To override the contents of this collection use [`set_public_ports`](Self::set_public_ports).
    ///
    /// <p>An array of public port settings for your load balancer. For HTTP, use port 80. For HTTPS, use port 443.</p>
    pub fn public_ports(mut self, input: i32) -> Self {
        let mut v = self.public_ports.unwrap_or_default();
        v.push(input);
        self.public_ports = Some(v);
        self
    }
    /// <p>An array of public port settings for your load balancer. For HTTP, use port 80. For HTTPS, use port 443.</p>
    pub fn set_public_ports(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
        self.public_ports = input;
        self
    }
    /// <p>The path you specified to perform your health checks. If no path is specified, the load balancer tries to make a request to the default (root) page.</p>
    pub fn health_check_path(mut self, input: impl Into<std::string::String>) -> Self {
        self.health_check_path = Some(input.into());
        self
    }
    /// <p>The path you specified to perform your health checks. If no path is specified, the load balancer tries to make a request to the default (root) page.</p>
    pub fn set_health_check_path(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.health_check_path = input;
        self
    }
    /// <p>The port where the load balancer will direct traffic to your Lightsail instances. For HTTP traffic, it's port 80. For HTTPS traffic, it's port 443.</p>
    pub fn instance_port(mut self, input: i32) -> Self {
        self.instance_port = Some(input);
        self
    }
    /// <p>The port where the load balancer will direct traffic to your Lightsail instances. For HTTP traffic, it's port 80. For HTTPS traffic, it's port 443.</p>
    pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
        self.instance_port = input;
        self
    }
    /// Appends an item to `instance_health_summary`.
    ///
    /// To override the contents of this collection use [`set_instance_health_summary`](Self::set_instance_health_summary).
    ///
    /// <p>An array of InstanceHealthSummary objects describing the health of the load balancer.</p>
    pub fn instance_health_summary(mut self, input: crate::types::InstanceHealthSummary) -> Self {
        let mut v = self.instance_health_summary.unwrap_or_default();
        v.push(input);
        self.instance_health_summary = Some(v);
        self
    }
    /// <p>An array of InstanceHealthSummary objects describing the health of the load balancer.</p>
    pub fn set_instance_health_summary(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::InstanceHealthSummary>>,
    ) -> Self {
        self.instance_health_summary = input;
        self
    }
    /// Appends an item to `tls_certificate_summaries`.
    ///
    /// To override the contents of this collection use [`set_tls_certificate_summaries`](Self::set_tls_certificate_summaries).
    ///
    /// <p>An array of LoadBalancerTlsCertificateSummary objects that provide additional information about the SSL/TLS certificates. For example, if <code>true</code>, the certificate is attached to the load balancer.</p>
    pub fn tls_certificate_summaries(
        mut self,
        input: crate::types::LoadBalancerTlsCertificateSummary,
    ) -> Self {
        let mut v = self.tls_certificate_summaries.unwrap_or_default();
        v.push(input);
        self.tls_certificate_summaries = Some(v);
        self
    }
    /// <p>An array of LoadBalancerTlsCertificateSummary objects that provide additional information about the SSL/TLS certificates. For example, if <code>true</code>, the certificate is attached to the load balancer.</p>
    pub fn set_tls_certificate_summaries(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::LoadBalancerTlsCertificateSummary>>,
    ) -> Self {
        self.tls_certificate_summaries = input;
        self
    }
    /// Adds a key-value pair to `configuration_options`.
    ///
    /// To override the contents of this collection use [`set_configuration_options`](Self::set_configuration_options).
    ///
    /// <p>A string to string map of the configuration options for your load balancer. Valid values are listed below.</p>
    pub fn configuration_options(
        mut self,
        k: crate::types::LoadBalancerAttributeName,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.configuration_options.unwrap_or_default();
        hash_map.insert(k, v.into());
        self.configuration_options = Some(hash_map);
        self
    }
    /// <p>A string to string map of the configuration options for your load balancer. Valid values are listed below.</p>
    pub fn set_configuration_options(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<crate::types::LoadBalancerAttributeName, std::string::String>,
        >,
    ) -> Self {
        self.configuration_options = input;
        self
    }
    /// <p>The IP address type of the load balancer.</p>
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for IPv4 and IPv6.</p>
    pub fn ip_address_type(mut self, input: crate::types::IpAddressType) -> Self {
        self.ip_address_type = Some(input);
        self
    }
    /// <p>The IP address type of the load balancer.</p>
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for IPv4 and IPv6.</p>
    pub fn set_ip_address_type(
        mut self,
        input: std::option::Option<crate::types::IpAddressType>,
    ) -> Self {
        self.ip_address_type = input;
        self
    }
    /// <p>A Boolean value that indicates whether HTTPS redirection is enabled for the load balancer.</p>
    pub fn https_redirection_enabled(mut self, input: bool) -> Self {
        self.https_redirection_enabled = Some(input);
        self
    }
    /// <p>A Boolean value that indicates whether HTTPS redirection is enabled for the load balancer.</p>
    pub fn set_https_redirection_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.https_redirection_enabled = input;
        self
    }
    /// <p>The name of the TLS security policy for the load balancer.</p>
    pub fn tls_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.tls_policy_name = Some(input.into());
        self
    }
    /// <p>The name of the TLS security policy for the load balancer.</p>
    pub fn set_tls_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.tls_policy_name = input;
        self
    }
    /// Consumes the builder and constructs a [`LoadBalancer`](crate::types::LoadBalancer).
    pub fn build(self) -> crate::types::LoadBalancer {
        crate::types::LoadBalancer {
            name: self.name,
            arn: self.arn,
            support_code: self.support_code,
            created_at: self.created_at,
            location: self.location,
            resource_type: self.resource_type,
            tags: self.tags,
            dns_name: self.dns_name,
            state: self.state,
            protocol: self.protocol,
            public_ports: self.public_ports,
            health_check_path: self.health_check_path,
            instance_port: self.instance_port,
            instance_health_summary: self.instance_health_summary,
            tls_certificate_summaries: self.tls_certificate_summaries,
            configuration_options: self.configuration_options,
            ip_address_type: self.ip_address_type,
            https_redirection_enabled: self.https_redirection_enabled,
            tls_policy_name: self.tls_policy_name,
        }
    }
}
