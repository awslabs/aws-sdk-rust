// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn allocate_static_ip(&self) -> fluent_builders::AllocateStaticIp<C> {
        fluent_builders::AllocateStaticIp::new(self.handle.clone())
    }
    pub fn attach_certificate_to_distribution(
        &self,
    ) -> fluent_builders::AttachCertificateToDistribution<C> {
        fluent_builders::AttachCertificateToDistribution::new(self.handle.clone())
    }
    pub fn attach_disk(&self) -> fluent_builders::AttachDisk<C> {
        fluent_builders::AttachDisk::new(self.handle.clone())
    }
    pub fn attach_instances_to_load_balancer(
        &self,
    ) -> fluent_builders::AttachInstancesToLoadBalancer<C> {
        fluent_builders::AttachInstancesToLoadBalancer::new(self.handle.clone())
    }
    pub fn attach_load_balancer_tls_certificate(
        &self,
    ) -> fluent_builders::AttachLoadBalancerTlsCertificate<C> {
        fluent_builders::AttachLoadBalancerTlsCertificate::new(self.handle.clone())
    }
    pub fn attach_static_ip(&self) -> fluent_builders::AttachStaticIp<C> {
        fluent_builders::AttachStaticIp::new(self.handle.clone())
    }
    pub fn close_instance_public_ports(&self) -> fluent_builders::CloseInstancePublicPorts<C> {
        fluent_builders::CloseInstancePublicPorts::new(self.handle.clone())
    }
    pub fn copy_snapshot(&self) -> fluent_builders::CopySnapshot<C> {
        fluent_builders::CopySnapshot::new(self.handle.clone())
    }
    pub fn create_certificate(&self) -> fluent_builders::CreateCertificate<C> {
        fluent_builders::CreateCertificate::new(self.handle.clone())
    }
    pub fn create_cloud_formation_stack(&self) -> fluent_builders::CreateCloudFormationStack<C> {
        fluent_builders::CreateCloudFormationStack::new(self.handle.clone())
    }
    pub fn create_contact_method(&self) -> fluent_builders::CreateContactMethod<C> {
        fluent_builders::CreateContactMethod::new(self.handle.clone())
    }
    pub fn create_container_service(&self) -> fluent_builders::CreateContainerService<C> {
        fluent_builders::CreateContainerService::new(self.handle.clone())
    }
    pub fn create_container_service_deployment(
        &self,
    ) -> fluent_builders::CreateContainerServiceDeployment<C> {
        fluent_builders::CreateContainerServiceDeployment::new(self.handle.clone())
    }
    pub fn create_container_service_registry_login(
        &self,
    ) -> fluent_builders::CreateContainerServiceRegistryLogin<C> {
        fluent_builders::CreateContainerServiceRegistryLogin::new(self.handle.clone())
    }
    pub fn create_disk(&self) -> fluent_builders::CreateDisk<C> {
        fluent_builders::CreateDisk::new(self.handle.clone())
    }
    pub fn create_disk_from_snapshot(&self) -> fluent_builders::CreateDiskFromSnapshot<C> {
        fluent_builders::CreateDiskFromSnapshot::new(self.handle.clone())
    }
    pub fn create_disk_snapshot(&self) -> fluent_builders::CreateDiskSnapshot<C> {
        fluent_builders::CreateDiskSnapshot::new(self.handle.clone())
    }
    pub fn create_distribution(&self) -> fluent_builders::CreateDistribution<C> {
        fluent_builders::CreateDistribution::new(self.handle.clone())
    }
    pub fn create_domain(&self) -> fluent_builders::CreateDomain<C> {
        fluent_builders::CreateDomain::new(self.handle.clone())
    }
    pub fn create_domain_entry(&self) -> fluent_builders::CreateDomainEntry<C> {
        fluent_builders::CreateDomainEntry::new(self.handle.clone())
    }
    pub fn create_instances(&self) -> fluent_builders::CreateInstances<C> {
        fluent_builders::CreateInstances::new(self.handle.clone())
    }
    pub fn create_instances_from_snapshot(
        &self,
    ) -> fluent_builders::CreateInstancesFromSnapshot<C> {
        fluent_builders::CreateInstancesFromSnapshot::new(self.handle.clone())
    }
    pub fn create_instance_snapshot(&self) -> fluent_builders::CreateInstanceSnapshot<C> {
        fluent_builders::CreateInstanceSnapshot::new(self.handle.clone())
    }
    pub fn create_key_pair(&self) -> fluent_builders::CreateKeyPair<C> {
        fluent_builders::CreateKeyPair::new(self.handle.clone())
    }
    pub fn create_load_balancer(&self) -> fluent_builders::CreateLoadBalancer<C> {
        fluent_builders::CreateLoadBalancer::new(self.handle.clone())
    }
    pub fn create_load_balancer_tls_certificate(
        &self,
    ) -> fluent_builders::CreateLoadBalancerTlsCertificate<C> {
        fluent_builders::CreateLoadBalancerTlsCertificate::new(self.handle.clone())
    }
    pub fn create_relational_database(&self) -> fluent_builders::CreateRelationalDatabase<C> {
        fluent_builders::CreateRelationalDatabase::new(self.handle.clone())
    }
    pub fn create_relational_database_from_snapshot(
        &self,
    ) -> fluent_builders::CreateRelationalDatabaseFromSnapshot<C> {
        fluent_builders::CreateRelationalDatabaseFromSnapshot::new(self.handle.clone())
    }
    pub fn create_relational_database_snapshot(
        &self,
    ) -> fluent_builders::CreateRelationalDatabaseSnapshot<C> {
        fluent_builders::CreateRelationalDatabaseSnapshot::new(self.handle.clone())
    }
    pub fn delete_alarm(&self) -> fluent_builders::DeleteAlarm<C> {
        fluent_builders::DeleteAlarm::new(self.handle.clone())
    }
    pub fn delete_auto_snapshot(&self) -> fluent_builders::DeleteAutoSnapshot<C> {
        fluent_builders::DeleteAutoSnapshot::new(self.handle.clone())
    }
    pub fn delete_certificate(&self) -> fluent_builders::DeleteCertificate<C> {
        fluent_builders::DeleteCertificate::new(self.handle.clone())
    }
    pub fn delete_contact_method(&self) -> fluent_builders::DeleteContactMethod<C> {
        fluent_builders::DeleteContactMethod::new(self.handle.clone())
    }
    pub fn delete_container_image(&self) -> fluent_builders::DeleteContainerImage<C> {
        fluent_builders::DeleteContainerImage::new(self.handle.clone())
    }
    pub fn delete_container_service(&self) -> fluent_builders::DeleteContainerService<C> {
        fluent_builders::DeleteContainerService::new(self.handle.clone())
    }
    pub fn delete_disk(&self) -> fluent_builders::DeleteDisk<C> {
        fluent_builders::DeleteDisk::new(self.handle.clone())
    }
    pub fn delete_disk_snapshot(&self) -> fluent_builders::DeleteDiskSnapshot<C> {
        fluent_builders::DeleteDiskSnapshot::new(self.handle.clone())
    }
    pub fn delete_distribution(&self) -> fluent_builders::DeleteDistribution<C> {
        fluent_builders::DeleteDistribution::new(self.handle.clone())
    }
    pub fn delete_domain(&self) -> fluent_builders::DeleteDomain<C> {
        fluent_builders::DeleteDomain::new(self.handle.clone())
    }
    pub fn delete_domain_entry(&self) -> fluent_builders::DeleteDomainEntry<C> {
        fluent_builders::DeleteDomainEntry::new(self.handle.clone())
    }
    pub fn delete_instance(&self) -> fluent_builders::DeleteInstance<C> {
        fluent_builders::DeleteInstance::new(self.handle.clone())
    }
    pub fn delete_instance_snapshot(&self) -> fluent_builders::DeleteInstanceSnapshot<C> {
        fluent_builders::DeleteInstanceSnapshot::new(self.handle.clone())
    }
    pub fn delete_key_pair(&self) -> fluent_builders::DeleteKeyPair<C> {
        fluent_builders::DeleteKeyPair::new(self.handle.clone())
    }
    pub fn delete_known_host_keys(&self) -> fluent_builders::DeleteKnownHostKeys<C> {
        fluent_builders::DeleteKnownHostKeys::new(self.handle.clone())
    }
    pub fn delete_load_balancer(&self) -> fluent_builders::DeleteLoadBalancer<C> {
        fluent_builders::DeleteLoadBalancer::new(self.handle.clone())
    }
    pub fn delete_load_balancer_tls_certificate(
        &self,
    ) -> fluent_builders::DeleteLoadBalancerTlsCertificate<C> {
        fluent_builders::DeleteLoadBalancerTlsCertificate::new(self.handle.clone())
    }
    pub fn delete_relational_database(&self) -> fluent_builders::DeleteRelationalDatabase<C> {
        fluent_builders::DeleteRelationalDatabase::new(self.handle.clone())
    }
    pub fn delete_relational_database_snapshot(
        &self,
    ) -> fluent_builders::DeleteRelationalDatabaseSnapshot<C> {
        fluent_builders::DeleteRelationalDatabaseSnapshot::new(self.handle.clone())
    }
    pub fn detach_certificate_from_distribution(
        &self,
    ) -> fluent_builders::DetachCertificateFromDistribution<C> {
        fluent_builders::DetachCertificateFromDistribution::new(self.handle.clone())
    }
    pub fn detach_disk(&self) -> fluent_builders::DetachDisk<C> {
        fluent_builders::DetachDisk::new(self.handle.clone())
    }
    pub fn detach_instances_from_load_balancer(
        &self,
    ) -> fluent_builders::DetachInstancesFromLoadBalancer<C> {
        fluent_builders::DetachInstancesFromLoadBalancer::new(self.handle.clone())
    }
    pub fn detach_static_ip(&self) -> fluent_builders::DetachStaticIp<C> {
        fluent_builders::DetachStaticIp::new(self.handle.clone())
    }
    pub fn disable_add_on(&self) -> fluent_builders::DisableAddOn<C> {
        fluent_builders::DisableAddOn::new(self.handle.clone())
    }
    pub fn download_default_key_pair(&self) -> fluent_builders::DownloadDefaultKeyPair<C> {
        fluent_builders::DownloadDefaultKeyPair::new(self.handle.clone())
    }
    pub fn enable_add_on(&self) -> fluent_builders::EnableAddOn<C> {
        fluent_builders::EnableAddOn::new(self.handle.clone())
    }
    pub fn export_snapshot(&self) -> fluent_builders::ExportSnapshot<C> {
        fluent_builders::ExportSnapshot::new(self.handle.clone())
    }
    pub fn get_active_names(&self) -> fluent_builders::GetActiveNames<C> {
        fluent_builders::GetActiveNames::new(self.handle.clone())
    }
    pub fn get_alarms(&self) -> fluent_builders::GetAlarms<C> {
        fluent_builders::GetAlarms::new(self.handle.clone())
    }
    pub fn get_auto_snapshots(&self) -> fluent_builders::GetAutoSnapshots<C> {
        fluent_builders::GetAutoSnapshots::new(self.handle.clone())
    }
    pub fn get_blueprints(&self) -> fluent_builders::GetBlueprints<C> {
        fluent_builders::GetBlueprints::new(self.handle.clone())
    }
    pub fn get_bundles(&self) -> fluent_builders::GetBundles<C> {
        fluent_builders::GetBundles::new(self.handle.clone())
    }
    pub fn get_certificates(&self) -> fluent_builders::GetCertificates<C> {
        fluent_builders::GetCertificates::new(self.handle.clone())
    }
    pub fn get_cloud_formation_stack_records(
        &self,
    ) -> fluent_builders::GetCloudFormationStackRecords<C> {
        fluent_builders::GetCloudFormationStackRecords::new(self.handle.clone())
    }
    pub fn get_contact_methods(&self) -> fluent_builders::GetContactMethods<C> {
        fluent_builders::GetContactMethods::new(self.handle.clone())
    }
    pub fn get_container_api_metadata(&self) -> fluent_builders::GetContainerAPIMetadata<C> {
        fluent_builders::GetContainerAPIMetadata::new(self.handle.clone())
    }
    pub fn get_container_images(&self) -> fluent_builders::GetContainerImages<C> {
        fluent_builders::GetContainerImages::new(self.handle.clone())
    }
    pub fn get_container_log(&self) -> fluent_builders::GetContainerLog<C> {
        fluent_builders::GetContainerLog::new(self.handle.clone())
    }
    pub fn get_container_service_deployments(
        &self,
    ) -> fluent_builders::GetContainerServiceDeployments<C> {
        fluent_builders::GetContainerServiceDeployments::new(self.handle.clone())
    }
    pub fn get_container_service_metric_data(
        &self,
    ) -> fluent_builders::GetContainerServiceMetricData<C> {
        fluent_builders::GetContainerServiceMetricData::new(self.handle.clone())
    }
    pub fn get_container_service_powers(&self) -> fluent_builders::GetContainerServicePowers<C> {
        fluent_builders::GetContainerServicePowers::new(self.handle.clone())
    }
    pub fn get_container_services(&self) -> fluent_builders::GetContainerServices<C> {
        fluent_builders::GetContainerServices::new(self.handle.clone())
    }
    pub fn get_disk(&self) -> fluent_builders::GetDisk<C> {
        fluent_builders::GetDisk::new(self.handle.clone())
    }
    pub fn get_disks(&self) -> fluent_builders::GetDisks<C> {
        fluent_builders::GetDisks::new(self.handle.clone())
    }
    pub fn get_disk_snapshot(&self) -> fluent_builders::GetDiskSnapshot<C> {
        fluent_builders::GetDiskSnapshot::new(self.handle.clone())
    }
    pub fn get_disk_snapshots(&self) -> fluent_builders::GetDiskSnapshots<C> {
        fluent_builders::GetDiskSnapshots::new(self.handle.clone())
    }
    pub fn get_distribution_bundles(&self) -> fluent_builders::GetDistributionBundles<C> {
        fluent_builders::GetDistributionBundles::new(self.handle.clone())
    }
    pub fn get_distribution_latest_cache_reset(
        &self,
    ) -> fluent_builders::GetDistributionLatestCacheReset<C> {
        fluent_builders::GetDistributionLatestCacheReset::new(self.handle.clone())
    }
    pub fn get_distribution_metric_data(&self) -> fluent_builders::GetDistributionMetricData<C> {
        fluent_builders::GetDistributionMetricData::new(self.handle.clone())
    }
    pub fn get_distributions(&self) -> fluent_builders::GetDistributions<C> {
        fluent_builders::GetDistributions::new(self.handle.clone())
    }
    pub fn get_domain(&self) -> fluent_builders::GetDomain<C> {
        fluent_builders::GetDomain::new(self.handle.clone())
    }
    pub fn get_domains(&self) -> fluent_builders::GetDomains<C> {
        fluent_builders::GetDomains::new(self.handle.clone())
    }
    pub fn get_export_snapshot_records(&self) -> fluent_builders::GetExportSnapshotRecords<C> {
        fluent_builders::GetExportSnapshotRecords::new(self.handle.clone())
    }
    pub fn get_instance(&self) -> fluent_builders::GetInstance<C> {
        fluent_builders::GetInstance::new(self.handle.clone())
    }
    pub fn get_instance_access_details(&self) -> fluent_builders::GetInstanceAccessDetails<C> {
        fluent_builders::GetInstanceAccessDetails::new(self.handle.clone())
    }
    pub fn get_instance_metric_data(&self) -> fluent_builders::GetInstanceMetricData<C> {
        fluent_builders::GetInstanceMetricData::new(self.handle.clone())
    }
    pub fn get_instance_port_states(&self) -> fluent_builders::GetInstancePortStates<C> {
        fluent_builders::GetInstancePortStates::new(self.handle.clone())
    }
    pub fn get_instances(&self) -> fluent_builders::GetInstances<C> {
        fluent_builders::GetInstances::new(self.handle.clone())
    }
    pub fn get_instance_snapshot(&self) -> fluent_builders::GetInstanceSnapshot<C> {
        fluent_builders::GetInstanceSnapshot::new(self.handle.clone())
    }
    pub fn get_instance_snapshots(&self) -> fluent_builders::GetInstanceSnapshots<C> {
        fluent_builders::GetInstanceSnapshots::new(self.handle.clone())
    }
    pub fn get_instance_state(&self) -> fluent_builders::GetInstanceState<C> {
        fluent_builders::GetInstanceState::new(self.handle.clone())
    }
    pub fn get_key_pair(&self) -> fluent_builders::GetKeyPair<C> {
        fluent_builders::GetKeyPair::new(self.handle.clone())
    }
    pub fn get_key_pairs(&self) -> fluent_builders::GetKeyPairs<C> {
        fluent_builders::GetKeyPairs::new(self.handle.clone())
    }
    pub fn get_load_balancer(&self) -> fluent_builders::GetLoadBalancer<C> {
        fluent_builders::GetLoadBalancer::new(self.handle.clone())
    }
    pub fn get_load_balancer_metric_data(&self) -> fluent_builders::GetLoadBalancerMetricData<C> {
        fluent_builders::GetLoadBalancerMetricData::new(self.handle.clone())
    }
    pub fn get_load_balancers(&self) -> fluent_builders::GetLoadBalancers<C> {
        fluent_builders::GetLoadBalancers::new(self.handle.clone())
    }
    pub fn get_load_balancer_tls_certificates(
        &self,
    ) -> fluent_builders::GetLoadBalancerTlsCertificates<C> {
        fluent_builders::GetLoadBalancerTlsCertificates::new(self.handle.clone())
    }
    pub fn get_operation(&self) -> fluent_builders::GetOperation<C> {
        fluent_builders::GetOperation::new(self.handle.clone())
    }
    pub fn get_operations(&self) -> fluent_builders::GetOperations<C> {
        fluent_builders::GetOperations::new(self.handle.clone())
    }
    pub fn get_operations_for_resource(&self) -> fluent_builders::GetOperationsForResource<C> {
        fluent_builders::GetOperationsForResource::new(self.handle.clone())
    }
    pub fn get_regions(&self) -> fluent_builders::GetRegions<C> {
        fluent_builders::GetRegions::new(self.handle.clone())
    }
    pub fn get_relational_database(&self) -> fluent_builders::GetRelationalDatabase<C> {
        fluent_builders::GetRelationalDatabase::new(self.handle.clone())
    }
    pub fn get_relational_database_blueprints(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseBlueprints<C> {
        fluent_builders::GetRelationalDatabaseBlueprints::new(self.handle.clone())
    }
    pub fn get_relational_database_bundles(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseBundles<C> {
        fluent_builders::GetRelationalDatabaseBundles::new(self.handle.clone())
    }
    pub fn get_relational_database_events(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseEvents<C> {
        fluent_builders::GetRelationalDatabaseEvents::new(self.handle.clone())
    }
    pub fn get_relational_database_log_events(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseLogEvents<C> {
        fluent_builders::GetRelationalDatabaseLogEvents::new(self.handle.clone())
    }
    pub fn get_relational_database_log_streams(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseLogStreams<C> {
        fluent_builders::GetRelationalDatabaseLogStreams::new(self.handle.clone())
    }
    pub fn get_relational_database_master_user_password(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseMasterUserPassword<C> {
        fluent_builders::GetRelationalDatabaseMasterUserPassword::new(self.handle.clone())
    }
    pub fn get_relational_database_metric_data(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseMetricData<C> {
        fluent_builders::GetRelationalDatabaseMetricData::new(self.handle.clone())
    }
    pub fn get_relational_database_parameters(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseParameters<C> {
        fluent_builders::GetRelationalDatabaseParameters::new(self.handle.clone())
    }
    pub fn get_relational_databases(&self) -> fluent_builders::GetRelationalDatabases<C> {
        fluent_builders::GetRelationalDatabases::new(self.handle.clone())
    }
    pub fn get_relational_database_snapshot(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseSnapshot<C> {
        fluent_builders::GetRelationalDatabaseSnapshot::new(self.handle.clone())
    }
    pub fn get_relational_database_snapshots(
        &self,
    ) -> fluent_builders::GetRelationalDatabaseSnapshots<C> {
        fluent_builders::GetRelationalDatabaseSnapshots::new(self.handle.clone())
    }
    pub fn get_static_ip(&self) -> fluent_builders::GetStaticIp<C> {
        fluent_builders::GetStaticIp::new(self.handle.clone())
    }
    pub fn get_static_ips(&self) -> fluent_builders::GetStaticIps<C> {
        fluent_builders::GetStaticIps::new(self.handle.clone())
    }
    pub fn import_key_pair(&self) -> fluent_builders::ImportKeyPair<C> {
        fluent_builders::ImportKeyPair::new(self.handle.clone())
    }
    pub fn is_vpc_peered(&self) -> fluent_builders::IsVpcPeered<C> {
        fluent_builders::IsVpcPeered::new(self.handle.clone())
    }
    pub fn open_instance_public_ports(&self) -> fluent_builders::OpenInstancePublicPorts<C> {
        fluent_builders::OpenInstancePublicPorts::new(self.handle.clone())
    }
    pub fn peer_vpc(&self) -> fluent_builders::PeerVpc<C> {
        fluent_builders::PeerVpc::new(self.handle.clone())
    }
    pub fn put_alarm(&self) -> fluent_builders::PutAlarm<C> {
        fluent_builders::PutAlarm::new(self.handle.clone())
    }
    pub fn put_instance_public_ports(&self) -> fluent_builders::PutInstancePublicPorts<C> {
        fluent_builders::PutInstancePublicPorts::new(self.handle.clone())
    }
    pub fn reboot_instance(&self) -> fluent_builders::RebootInstance<C> {
        fluent_builders::RebootInstance::new(self.handle.clone())
    }
    pub fn reboot_relational_database(&self) -> fluent_builders::RebootRelationalDatabase<C> {
        fluent_builders::RebootRelationalDatabase::new(self.handle.clone())
    }
    pub fn register_container_image(&self) -> fluent_builders::RegisterContainerImage<C> {
        fluent_builders::RegisterContainerImage::new(self.handle.clone())
    }
    pub fn release_static_ip(&self) -> fluent_builders::ReleaseStaticIp<C> {
        fluent_builders::ReleaseStaticIp::new(self.handle.clone())
    }
    pub fn reset_distribution_cache(&self) -> fluent_builders::ResetDistributionCache<C> {
        fluent_builders::ResetDistributionCache::new(self.handle.clone())
    }
    pub fn send_contact_method_verification(
        &self,
    ) -> fluent_builders::SendContactMethodVerification<C> {
        fluent_builders::SendContactMethodVerification::new(self.handle.clone())
    }
    pub fn set_ip_address_type(&self) -> fluent_builders::SetIpAddressType<C> {
        fluent_builders::SetIpAddressType::new(self.handle.clone())
    }
    pub fn start_instance(&self) -> fluent_builders::StartInstance<C> {
        fluent_builders::StartInstance::new(self.handle.clone())
    }
    pub fn start_relational_database(&self) -> fluent_builders::StartRelationalDatabase<C> {
        fluent_builders::StartRelationalDatabase::new(self.handle.clone())
    }
    pub fn stop_instance(&self) -> fluent_builders::StopInstance<C> {
        fluent_builders::StopInstance::new(self.handle.clone())
    }
    pub fn stop_relational_database(&self) -> fluent_builders::StopRelationalDatabase<C> {
        fluent_builders::StopRelationalDatabase::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn test_alarm(&self) -> fluent_builders::TestAlarm<C> {
        fluent_builders::TestAlarm::new(self.handle.clone())
    }
    pub fn unpeer_vpc(&self) -> fluent_builders::UnpeerVpc<C> {
        fluent_builders::UnpeerVpc::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_container_service(&self) -> fluent_builders::UpdateContainerService<C> {
        fluent_builders::UpdateContainerService::new(self.handle.clone())
    }
    pub fn update_distribution(&self) -> fluent_builders::UpdateDistribution<C> {
        fluent_builders::UpdateDistribution::new(self.handle.clone())
    }
    pub fn update_distribution_bundle(&self) -> fluent_builders::UpdateDistributionBundle<C> {
        fluent_builders::UpdateDistributionBundle::new(self.handle.clone())
    }
    pub fn update_domain_entry(&self) -> fluent_builders::UpdateDomainEntry<C> {
        fluent_builders::UpdateDomainEntry::new(self.handle.clone())
    }
    pub fn update_load_balancer_attribute(
        &self,
    ) -> fluent_builders::UpdateLoadBalancerAttribute<C> {
        fluent_builders::UpdateLoadBalancerAttribute::new(self.handle.clone())
    }
    pub fn update_relational_database(&self) -> fluent_builders::UpdateRelationalDatabase<C> {
        fluent_builders::UpdateRelationalDatabase::new(self.handle.clone())
    }
    pub fn update_relational_database_parameters(
        &self,
    ) -> fluent_builders::UpdateRelationalDatabaseParameters<C> {
        fluent_builders::UpdateRelationalDatabaseParameters::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AllocateStaticIp<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::allocate_static_ip_input::Builder,
    }
    impl<C> AllocateStaticIp<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AllocateStaticIpOutput,
            smithy_http::result::SdkError<crate::error::AllocateStaticIpError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the static IP address.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.static_ip_name(input);
            self
        }
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_static_ip_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachCertificateToDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_certificate_to_distribution_input::Builder,
    }
    impl<C> AttachCertificateToDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachCertificateToDistributionOutput,
            smithy_http::result::SdkError<crate::error::AttachCertificateToDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution that the certificate will be attached to.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
        /// <p>The name of the certificate to attach to a distribution.</p>
        /// <p>Only certificates with a status of <code>ISSUED</code> can be attached to a
        /// distribution.</p>
        /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
        /// can specify.</p>
        /// <note>
        /// <p>This is the name of the certificate resource type and is used only to reference the
        /// certificate in other API actions. It can be different than the domain name of the
        /// certificate. For example, your certificate name might be
        /// <code>WordPress-Blog-Certificate</code> and the domain name of the certificate might be
        /// <code>example.com</code>.</p>
        /// </note>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachDisk<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_disk_input::Builder,
    }
    impl<C> AttachDisk<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachDiskOutput,
            smithy_http::result::SdkError<crate::error::AttachDiskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
        /// <p>The name of the Lightsail instance where you want to utilize the storage disk.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>The disk path to expose to the instance (e.g., <code>/dev/xvdf</code>).</p>
        pub fn disk_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_path(input);
            self
        }
        pub fn set_disk_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachInstancesToLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_instances_to_load_balancer_input::Builder,
    }
    impl<C> AttachInstancesToLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachInstancesToLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::AttachInstancesToLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>An array of strings representing the instance name(s) you want to attach to your load
        /// balancer.</p>
        /// <p>An instance must be <code>running</code> before you can attach it to your load
        /// balancer.</p>
        /// <p>There are no additional limits on the number of instances you can attach to your load
        /// balancer, aside from the limit of Lightsail instances you can create in your account
        /// (20).</p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachLoadBalancerTlsCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_load_balancer_tls_certificate_input::Builder,
    }
    impl<C> AttachLoadBalancerTlsCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachLoadBalancerTlsCertificateOutput,
            smithy_http::result::SdkError<crate::error::AttachLoadBalancerTlsCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer to which you want to associate the SSL/TLS
        /// certificate.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The name of your SSL/TLS certificate.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachStaticIp<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_static_ip_input::Builder,
    }
    impl<C> AttachStaticIp<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachStaticIpOutput,
            smithy_http::result::SdkError<crate::error::AttachStaticIpError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the static IP.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.static_ip_name(input);
            self
        }
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_static_ip_name(input);
            self
        }
        /// <p>The instance name to which you want to attach the static IP address.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CloseInstancePublicPorts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::close_instance_public_ports_input::Builder,
    }
    impl<C> CloseInstancePublicPorts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CloseInstancePublicPortsOutput,
            smithy_http::result::SdkError<crate::error::CloseInstancePublicPortsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An object to describe the ports to close for the specified instance.</p>
        pub fn port_info(mut self, input: crate::model::PortInfo) -> Self {
            self.inner = self.inner.port_info(input);
            self
        }
        pub fn set_port_info(mut self, input: std::option::Option<crate::model::PortInfo>) -> Self {
            self.inner = self.inner.set_port_info(input);
            self
        }
        /// <p>The name of the instance for which to close ports.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CopySnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_snapshot_input::Builder,
    }
    impl<C> CopySnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CopySnapshotOutput,
            smithy_http::result::SdkError<crate::error::CopySnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the source manual snapshot to copy.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>Define this parameter only when copying a manual snapshot as another manual
        /// snapshot.</p>
        /// </li>
        /// </ul>
        pub fn source_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_snapshot_name(input);
            self
        }
        pub fn set_source_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_snapshot_name(input);
            self
        }
        /// <p>The name of the source instance or disk from which the source automatic snapshot was
        /// created.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn source_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_resource_name(input);
            self
        }
        pub fn set_source_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_resource_name(input);
            self
        }
        /// <p>The date of the source automatic snapshot to copy. Use the <code>get auto snapshots</code>
        /// operation to identify the dates of the available automatic snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn restore_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.restore_date(input);
            self
        }
        pub fn set_restore_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_restore_date(input);
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot of the
        /// specified source instance or disk.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn use_latest_restorable_auto_snapshot(mut self, input: bool) -> Self {
            self.inner = self.inner.use_latest_restorable_auto_snapshot(input);
            self
        }
        pub fn set_use_latest_restorable_auto_snapshot(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_use_latest_restorable_auto_snapshot(input);
            self
        }
        /// <p>The name of the new manual snapshot to be created as a copy.</p>
        pub fn target_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_snapshot_name(input);
            self
        }
        pub fn set_target_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_snapshot_name(input);
            self
        }
        /// <p>The AWS Region where the source manual or automatic snapshot is located.</p>
        pub fn source_region(mut self, input: crate::model::RegionName) -> Self {
            self.inner = self.inner.source_region(input);
            self
        }
        pub fn set_source_region(
            mut self,
            input: std::option::Option<crate::model::RegionName>,
        ) -> Self {
            self.inner = self.inner.set_source_region(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_certificate_input::Builder,
    }
    impl<C> CreateCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCertificateOutput,
            smithy_http::result::SdkError<crate::error::CreateCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the certificate.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for the certificate.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>An array of strings that specify the alternate domains (e.g., <code>example2.com</code>)
        /// and subdomains (e.g., <code>blog.example.com</code>) for the certificate.</p>
        /// <p>You can specify a maximum of nine alternate domains (in addition to the primary domain
        /// name).</p>
        /// <p>Wildcard domain entries (e.g., <code>*.example.com</code>) are not supported.</p>
        pub fn subject_alternative_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subject_alternative_names(inp);
            self
        }
        pub fn set_subject_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subject_alternative_names(input);
            self
        }
        /// <p>The tag keys and optional values to add to the certificate during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCloudFormationStack<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cloud_formation_stack_input::Builder,
    }
    impl<C> CreateCloudFormationStack<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCloudFormationStackOutput,
            smithy_http::result::SdkError<crate::error::CreateCloudFormationStackError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of parameters that will be used to create the new Amazon EC2 instance. You can only
        /// pass one instance entry at a time in this array. You will get an invalid parameter error if
        /// you pass more than one instance entry in this array.</p>
        pub fn instances(mut self, inp: impl Into<crate::model::InstanceEntry>) -> Self {
            self.inner = self.inner.instances(inp);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceEntry>>,
        ) -> Self {
            self.inner = self.inner.set_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateContactMethod<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_contact_method_input::Builder,
    }
    impl<C> CreateContactMethod<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateContactMethodOutput,
            smithy_http::result::SdkError<crate::error::CreateContactMethodError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The protocol of the contact method, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        /// <p>The <code>SMS</code> protocol is supported only in the following AWS Regions.</p>
        /// <ul>
        /// <li>
        /// <p>US East (N. Virginia) (<code>us-east-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>US West (Oregon) (<code>us-west-2</code>)</p>
        /// </li>
        /// <li>
        /// <p>Europe (Ireland) (<code>eu-west-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Tokyo) (<code>ap-northeast-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Singapore) (<code>ap-southeast-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Sydney) (<code>ap-southeast-2</code>)</p>
        /// </li>
        /// </ul>
        /// <p>For a list of countries/regions where SMS text messages can be sent, and the latest AWS
        /// Regions where SMS text messaging is supported, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-supported-regions-countries.html">Supported Regions and Countries</a> in the <i>Amazon SNS Developer
        /// Guide</i>.</p>
        /// <p>For more information about notifications in Amazon Lightsail, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
        pub fn protocol(mut self, input: crate::model::ContactProtocol) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ContactProtocol>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The destination of the contact method, such as an email address or a mobile phone
        /// number.</p>
        /// <p>Use the E.164 format when specifying a mobile phone number. E.164 is a standard for the
        /// phone number structure used for international telecommunication. Phone numbers that follow
        /// this format can have a maximum of 15 digits, and they are prefixed with the plus character (+)
        /// and the country code. For example, a U.S. phone number in E.164 format would be specified as
        /// +1XXX5550100. For more information, see <a href="https://en.wikipedia.org/wiki/E.164">E.164</a> on <i>Wikipedia</i>.</p>
        pub fn contact_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.contact_endpoint(input);
            self
        }
        pub fn set_contact_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_contact_endpoint(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateContainerService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_container_service_input::Builder,
    }
    impl<C> CreateContainerService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateContainerServiceOutput,
            smithy_http::result::SdkError<crate::error::CreateContainerServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the container service.</p>
        /// <p>The name that you specify for your container service will make up part of its default
        /// domain. The default domain of a container service is typically
        /// <code>https://<ServiceName>.<RandomGUID>.<AWSRegion>.cs.amazonlightsail.com</code>.
        /// If the name of your container service is <code>container-service-1</code>, and it's located in
        /// the US East (Ohio) AWS region (<code>us-east-2</code>), then the domain for your container
        /// service will be like the following example:
        /// <code>https://container-service-1.ur4EXAMPLE2uq.us-east-2.cs.amazonlightsail.com</code>
        /// </p>
        /// <p>The following are the requirements for container service names:</p>
        /// <ul>
        /// <li>
        /// <p>Must be unique within each AWS Region in your Lightsail account.</p>
        /// </li>
        /// <li>
        /// <p>Must contain 1 to 63 characters.</p>
        /// </li>
        /// <li>
        /// <p>Must contain only alphanumeric characters and hyphens.</p>
        /// </li>
        /// <li>
        /// <p>A hyphen (-) can separate words but cannot be at the start or end of the name.</p>
        /// </li>
        /// </ul>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The power specification for the container service.</p>
        /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
        /// container service. The <code>power</code> and <code>scale</code> of a container service makes
        /// up its configured capacity. To determine the monthly price of your container service, multiply
        /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
        /// the service.</p>
        /// <p>Use the <code>GetContainerServicePowers</code> action to get a list of power options that
        /// you can specify using this parameter, and their base monthly cost.</p>
        pub fn power(mut self, input: crate::model::ContainerServicePowerName) -> Self {
            self.inner = self.inner.power(input);
            self
        }
        pub fn set_power(
            mut self,
            input: std::option::Option<crate::model::ContainerServicePowerName>,
        ) -> Self {
            self.inner = self.inner.set_power(input);
            self
        }
        /// <p>The scale specification for the container service.</p>
        /// <p>The scale specifies the allocated compute nodes of the container service. The
        /// <code>power</code> and <code>scale</code> of a container service makes up its configured
        /// capacity. To determine the monthly price of your container service, multiply the base price of
        /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
        /// service.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.inner = self.inner.scale(input);
            self
        }
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_scale(input);
            self
        }
        /// <p>The tag keys and optional values for the container service.</p>
        /// <p>For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en/articles/amazon-lightsail-tags">Lightsail
        /// Dev Guide</a>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The public domain names to use with the container service, such as
        /// <code>example.com</code> and <code>www.example.com</code>.</p>
        /// <p>You can specify up to four public domain names for a container service. The domain names
        /// that you specify are used when you create a deployment with a container configured as the
        /// public endpoint of your container service.</p>
        /// <p>If you don't specify public domain names, then you can use the default domain of the
        /// container service.</p>
        /// <important>
        /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
        /// names with your container service. Use the <code>CreateCertificate</code> action to create a
        /// certificate for the public domain names you want to use with your container service.</p>
        /// </important>
        /// <p>You can specify public domain names using a string to array map as shown in the example
        /// later on this page.</p>
        pub fn public_domain_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.public_domain_names(k, v);
            self
        }
        pub fn set_public_domain_names(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_public_domain_names(input);
            self
        }
        /// <p>An object that describes a deployment for the container service.</p>
        /// <p>A deployment specifies the containers that will be launched on the container service and
        /// their settings, such as the ports to open, the environment variables to apply, and the launch
        /// command to run. It also specifies the container that will serve as the public endpoint of the
        /// deployment and its settings, such as the HTTP or HTTPS port to use, and the health check
        /// configuration.</p>
        pub fn deployment(
            mut self,
            input: crate::model::ContainerServiceDeploymentRequest,
        ) -> Self {
            self.inner = self.inner.deployment(input);
            self
        }
        pub fn set_deployment(
            mut self,
            input: std::option::Option<crate::model::ContainerServiceDeploymentRequest>,
        ) -> Self {
            self.inner = self.inner.set_deployment(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateContainerServiceDeployment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_container_service_deployment_input::Builder,
    }
    impl<C> CreateContainerServiceDeployment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateContainerServiceDeploymentOutput,
            smithy_http::result::SdkError<crate::error::CreateContainerServiceDeploymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to create the deployment.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>An object that describes the settings of the containers that will be launched on the
        /// container service.</p>
        pub fn containers(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Container>,
        ) -> Self {
            self.inner = self.inner.containers(k, v);
            self
        }
        pub fn set_containers(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Container>,
            >,
        ) -> Self {
            self.inner = self.inner.set_containers(input);
            self
        }
        /// <p>An object that describes the settings of the public endpoint for the container
        /// service.</p>
        pub fn public_endpoint(mut self, input: crate::model::EndpointRequest) -> Self {
            self.inner = self.inner.public_endpoint(input);
            self
        }
        pub fn set_public_endpoint(
            mut self,
            input: std::option::Option<crate::model::EndpointRequest>,
        ) -> Self {
            self.inner = self.inner.set_public_endpoint(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateContainerServiceRegistryLogin<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_container_service_registry_login_input::Builder,
    }
    impl<C> CreateContainerServiceRegistryLogin<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateContainerServiceRegistryLoginOutput,
            smithy_http::result::SdkError<crate::error::CreateContainerServiceRegistryLoginError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDisk<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_disk_input::Builder,
    }
    impl<C> CreateDisk<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDiskOutput,
            smithy_http::result::SdkError<crate::error::CreateDiskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
        /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
        /// Use the same Availability Zone as the Lightsail instance to which you want to attach the
        /// disk.</p>
        /// <p>Use the <code>get regions</code> operation to list the Availability Zones where
        /// Lightsail is currently available.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
        pub fn size_in_gb(mut self, input: i32) -> Self {
            self.inner = self.inner.size_in_gb(input);
            self
        }
        pub fn set_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_size_in_gb(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
        pub fn add_ons(mut self, inp: impl Into<crate::model::AddOnRequest>) -> Self {
            self.inner = self.inner.add_ons(inp);
            self
        }
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.inner = self.inner.set_add_ons(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDiskFromSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_disk_from_snapshot_input::Builder,
    }
    impl<C> CreateDiskFromSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDiskFromSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateDiskFromSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
        /// <p>The name of the disk snapshot (e.g., <code>my-snapshot</code>) from which to create the
        /// new storage disk.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>source disk name</code>
        /// parameter. The <code>disk snapshot name</code> and <code>source disk name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// </ul>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_snapshot_name(input);
            self
        }
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_disk_snapshot_name(input);
            self
        }
        /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
        /// Choose the same Availability Zone as the Lightsail instance where you want to create the
        /// disk.</p>
        /// <p>Use the GetRegions operation to list the Availability Zones where Lightsail is currently
        /// available.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
        pub fn size_in_gb(mut self, input: i32) -> Self {
            self.inner = self.inner.size_in_gb(input);
            self
        }
        pub fn set_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_size_in_gb(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
        pub fn add_ons(mut self, inp: impl Into<crate::model::AddOnRequest>) -> Self {
            self.inner = self.inner.add_ons(inp);
            self
        }
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.inner = self.inner.set_add_ons(input);
            self
        }
        /// <p>The name of the source disk from which the source automatic snapshot was created.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>disk snapshot name</code>
        /// parameter. The <code>source disk name</code> and <code>disk snapshot name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn source_disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_disk_name(input);
            self
        }
        pub fn set_source_disk_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_disk_name(input);
            self
        }
        /// <p>The date of the automatic snapshot to use for the new disk. Use the <code>get auto
        /// snapshots</code> operation to identify the dates of the available automatic
        /// snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn restore_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.restore_date(input);
            self
        }
        pub fn set_restore_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_restore_date(input);
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn use_latest_restorable_auto_snapshot(mut self, input: bool) -> Self {
            self.inner = self.inner.use_latest_restorable_auto_snapshot(input);
            self
        }
        pub fn set_use_latest_restorable_auto_snapshot(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_use_latest_restorable_auto_snapshot(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDiskSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_disk_snapshot_input::Builder,
    }
    impl<C> CreateDiskSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDiskSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateDiskSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the source disk (e.g., <code>Disk-Virginia-1</code>).</p>
        /// <note>
        /// <p>This parameter cannot be defined together with the <code>instance name</code> parameter.
        /// The <code>disk name</code> and <code>instance name</code> parameters are mutually
        /// exclusive.</p>
        /// </note>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
        /// <p>The name of the destination disk snapshot (e.g., <code>my-disk-snapshot</code>) based on
        /// the source disk.</p>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_snapshot_name(input);
            self
        }
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_disk_snapshot_name(input);
            self
        }
        /// <p>The unique name of the source instance (e.g., <code>Amazon_Linux-512MB-Virginia-1</code>).
        /// When this is defined, a snapshot of the instance's system volume is created.</p>
        /// <note>
        /// <p>This parameter cannot be defined together with the <code>disk name</code> parameter. The
        /// <code>instance name</code> and <code>disk name</code> parameters are mutually
        /// exclusive.</p>
        /// </note>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_distribution_input::Builder,
    }
    impl<C> CreateDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDistributionOutput,
            smithy_http::result::SdkError<crate::error::CreateDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the distribution.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
        /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
        /// instance or load balancer.</p>
        /// <p>The distribution pulls, caches, and serves content from the origin.</p>
        pub fn origin(mut self, input: crate::model::InputOrigin) -> Self {
            self.inner = self.inner.origin(input);
            self
        }
        pub fn set_origin(mut self, input: std::option::Option<crate::model::InputOrigin>) -> Self {
            self.inner = self.inner.set_origin(input);
            self
        }
        /// <p>An object that describes the default cache behavior for the distribution.</p>
        pub fn default_cache_behavior(mut self, input: crate::model::CacheBehavior) -> Self {
            self.inner = self.inner.default_cache_behavior(input);
            self
        }
        pub fn set_default_cache_behavior(
            mut self,
            input: std::option::Option<crate::model::CacheBehavior>,
        ) -> Self {
            self.inner = self.inner.set_default_cache_behavior(input);
            self
        }
        /// <p>An object that describes the cache behavior settings for the distribution.</p>
        pub fn cache_behavior_settings(mut self, input: crate::model::CacheSettings) -> Self {
            self.inner = self.inner.cache_behavior_settings(input);
            self
        }
        pub fn set_cache_behavior_settings(
            mut self,
            input: std::option::Option<crate::model::CacheSettings>,
        ) -> Self {
            self.inner = self.inner.set_cache_behavior_settings(input);
            self
        }
        /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
        pub fn cache_behaviors(
            mut self,
            inp: impl Into<crate::model::CacheBehaviorPerPath>,
        ) -> Self {
            self.inner = self.inner.cache_behaviors(inp);
            self
        }
        pub fn set_cache_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
        ) -> Self {
            self.inner = self.inner.set_cache_behaviors(input);
            self
        }
        /// <p>The bundle ID to use for the distribution.</p>
        /// <p>A distribution bundle describes the specifications of your distribution, such as the
        /// monthly cost and monthly network transfer quota.</p>
        /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
        /// IDs that you can specify.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bundle_id(input);
            self
        }
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bundle_id(input);
            self
        }
        /// <p>The IP address type for the distribution.</p>
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
        /// <p>The tag keys and optional values to add to the distribution during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_domain_input::Builder,
    }
    impl<C> CreateDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDomainOutput,
            smithy_http::result::SdkError<crate::error::CreateDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain name to manage (e.g., <code>example.com</code>).</p>
        /// <note>
        /// <p>You cannot register a new domain name using Lightsail. You must register a domain name
        /// using Amazon Route 53 or another domain name registrar. If you have already registered your
        /// domain, you can enter its name in this parameter to manage the DNS records for that domain
        /// using Lightsail.</p>
        /// </note>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDomainEntry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_domain_entry_input::Builder,
    }
    impl<C> CreateDomainEntry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDomainEntryOutput,
            smithy_http::result::SdkError<crate::error::CreateDomainEntryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for which you want to create the domain
        /// entry.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>An array of key-value pairs containing information about the domain entry request.</p>
        pub fn domain_entry(mut self, input: crate::model::DomainEntry) -> Self {
            self.inner = self.inner.domain_entry(input);
            self
        }
        pub fn set_domain_entry(
            mut self,
            input: std::option::Option<crate::model::DomainEntry>,
        ) -> Self {
            self.inner = self.inner.set_domain_entry(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_instances_input::Builder,
    }
    impl<C> CreateInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInstancesOutput,
            smithy_http::result::SdkError<crate::error::CreateInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names to use for your new Lightsail instances. Separate multiple values using
        /// quotation marks and commas, for example:
        /// <code>["MyFirstInstance","MySecondInstance"]</code>
        /// </p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
        /// <p>The Availability Zone in which to create your instance. Use the following format:
        /// <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones by using
        /// the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
        /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
        /// parameter to your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>(Deprecated) The name for your custom image.</p>
        /// <note>
        /// <p>In releases prior to June 12, 2017, this parameter was ignored by the API. It is now
        /// deprecated.</p>
        /// </note>
        pub fn custom_image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.custom_image_name(input);
            self
        }
        pub fn set_custom_image_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_custom_image_name(input);
            self
        }
        /// <p>The ID for a virtual private server image (e.g., <code>app_wordpress_4_4</code> or
        /// <code>app_lamp_7_0</code>). Use the <code>get blueprints</code> operation to return a list
        /// of available images (or <i>blueprints</i>).</p>
        /// <note>
        /// <p>Use active blueprints when creating new instances. Inactive blueprints are listed to
        /// support customers with existing instances and are not necessarily available to create new
        /// instances. Blueprints are marked inactive when they become outdated due to operating system
        /// updates or new application releases.</p>
        /// </note>
        pub fn blueprint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.blueprint_id(input);
            self
        }
        pub fn set_blueprint_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_blueprint_id(input);
            self
        }
        /// <p>The bundle of specification information for your virtual private server (or
        /// <i>instance</i>), including the pricing plan (e.g.,
        /// <code>micro_1_0</code>).</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bundle_id(input);
            self
        }
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bundle_id(input);
            self
        }
        /// <p>A launch script you can create that configures a server with additional user data. For
        /// example, you might want to run <code>apt-get -y update</code>.</p>
        /// <note>
        /// <p>Depending on the machine image you choose, the command to get software on your instance
        /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
        /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/getting-started/article/compare-options-choose-lightsail-instance-image">Dev Guide</a>.</p>
        /// </note>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_data(input);
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_data(input);
            self
        }
        /// <p>The name of your key pair.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_name(input);
            self
        }
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
        pub fn add_ons(mut self, inp: impl Into<crate::model::AddOnRequest>) -> Self {
            self.inner = self.inner.add_ons(inp);
            self
        }
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.inner = self.inner.set_add_ons(input);
            self
        }
        /// <p>The IP address type for the instance.</p>
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInstancesFromSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_instances_from_snapshot_input::Builder,
    }
    impl<C> CreateInstancesFromSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInstancesFromSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateInstancesFromSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names for your new instances.</p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
        /// <p>An object containing information about one or more disk mappings.</p>
        pub fn attached_disk_mapping(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<crate::model::DiskMap>>,
        ) -> Self {
            self.inner = self.inner.attached_disk_mapping(k, v);
            self
        }
        pub fn set_attached_disk_mapping(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::vec::Vec<crate::model::DiskMap>,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_attached_disk_mapping(input);
            self
        }
        /// <p>The Availability Zone where you want to create your instances. Use the following
        /// formatting: <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones
        /// by using the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
        /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
        /// parameter to your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The name of the instance snapshot on which you are basing your new instances. Use the get
        /// instance snapshots operation to return information about your existing snapshots.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>source instance name</code>
        /// parameter. The <code>instance snapshot name</code> and <code>source instance name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// </ul>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_snapshot_name(input);
            self
        }
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_snapshot_name(input);
            self
        }
        /// <p>The bundle of specification information for your virtual private server (or
        /// <i>instance</i>), including the pricing plan (e.g.,
        /// <code>micro_1_0</code>).</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bundle_id(input);
            self
        }
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bundle_id(input);
            self
        }
        /// <p>You can create a launch script that configures a server with additional user data. For
        /// example, <code>apt-get -y update</code>.</p>
        /// <note>
        /// <p>Depending on the machine image you choose, the command to get software on your instance
        /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
        /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/getting-started/article/compare-options-choose-lightsail-instance-image">Dev Guide</a>.</p>
        /// </note>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_data(input);
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_data(input);
            self
        }
        /// <p>The name for your key pair.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_name(input);
            self
        }
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
        pub fn add_ons(mut self, inp: impl Into<crate::model::AddOnRequest>) -> Self {
            self.inner = self.inner.add_ons(inp);
            self
        }
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.inner = self.inner.set_add_ons(input);
            self
        }
        /// <p>The IP address type for the instance.</p>
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
        /// <p>The name of the source instance from which the source automatic snapshot was
        /// created.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>instance snapshot name</code>
        /// parameter. The <code>source instance name</code> and <code>instance snapshot name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn source_instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_instance_name(input);
            self
        }
        pub fn set_source_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_instance_name(input);
            self
        }
        /// <p>The date of the automatic snapshot to use for the new instance. Use the <code>get auto
        /// snapshots</code> operation to identify the dates of the available automatic
        /// snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn restore_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.restore_date(input);
            self
        }
        pub fn set_restore_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_restore_date(input);
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Lightsail Dev Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn use_latest_restorable_auto_snapshot(mut self, input: bool) -> Self {
            self.inner = self.inner.use_latest_restorable_auto_snapshot(input);
            self
        }
        pub fn set_use_latest_restorable_auto_snapshot(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_use_latest_restorable_auto_snapshot(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInstanceSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_instance_snapshot_input::Builder,
    }
    impl<C> CreateInstanceSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInstanceSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateInstanceSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for your new snapshot.</p>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_snapshot_name(input);
            self
        }
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_snapshot_name(input);
            self
        }
        /// <p>The Lightsail instance on which to base your snapshot.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_key_pair_input::Builder,
    }
    impl<C> CreateKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateKeyPairOutput,
            smithy_http::result::SdkError<crate::error::CreateKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for your new key pair.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_name(input);
            self
        }
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_load_balancer_input::Builder,
    }
    impl<C> CreateLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The instance port where you're creating your load balancer.</p>
        pub fn instance_port(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_port(input);
            self
        }
        pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_port(input);
            self
        }
        /// <p>The path you provided to perform the load balancer health check. If you didn't specify a
        /// health check path, Lightsail uses the root path of your website (e.g.,
        /// <code>"/"</code>).</p>
        /// <p>You may want to specify a custom health check path other than the root of your application
        /// if your home page loads slowly or has a lot of media or scripting on it.</p>
        pub fn health_check_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_path(input);
            self
        }
        pub fn set_health_check_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_path(input);
            self
        }
        /// <p>The name of the SSL/TLS certificate.</p>
        /// <p>If you specify <code>certificateName</code>, then <code>certificateDomainName</code> is
        /// required (and vice-versa).</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
        /// <p>The domain name with which your certificate is associated (e.g.,
        /// <code>example.com</code>).</p>
        /// <p>If you specify <code>certificateDomainName</code>, then <code>certificateName</code> is
        /// required (and vice-versa).</p>
        pub fn certificate_domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_domain_name(input);
            self
        }
        pub fn set_certificate_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_domain_name(input);
            self
        }
        /// <p>The optional alternative domains and subdomains to use with your SSL/TLS certificate
        /// (e.g., <code>www.example.com</code>, <code>example.com</code>, <code>m.example.com</code>,
        /// <code>blog.example.com</code>).</p>
        pub fn certificate_alternative_names(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.certificate_alternative_names(inp);
            self
        }
        pub fn set_certificate_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_certificate_alternative_names(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The IP address type for the load balancer.</p>
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancerTlsCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_load_balancer_tls_certificate_input::Builder,
    }
    impl<C> CreateLoadBalancerTlsCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerTlsCertificateOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerTlsCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The load balancer name where you want to create the SSL/TLS certificate.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The SSL/TLS certificate name.</p>
        /// <p>You can have up to 10 certificates in your account at one time. Each Lightsail load
        /// balancer can have up to 2 certificates associated with it at one time. There is also an
        /// overall limit to the number of certificates that can be issue in a 365-day period. For more
        /// information, see <a href="http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Limits</a>.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for your SSL/TLS certificate.</p>
        pub fn certificate_domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_domain_name(input);
            self
        }
        pub fn set_certificate_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_domain_name(input);
            self
        }
        /// <p>An array of strings listing alternative domains and subdomains for your SSL/TLS
        /// certificate. Lightsail will de-dupe the names for you. You can have a maximum of 9
        /// alternative names (in addition to the 1 primary domain). We do not support wildcards (e.g.,
        /// <code>*.example.com</code>).</p>
        pub fn certificate_alternative_names(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.certificate_alternative_names(inp);
            self
        }
        pub fn set_certificate_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_certificate_alternative_names(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_relational_database_input::Builder,
    }
    impl<C> CreateRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::CreateRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name to use for your new Lightsail database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The Availability Zone in which to create your new database. Use the
        /// <code>us-east-2a</code> case-sensitive format.</p>
        /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
        /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
        /// your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The blueprint ID for your new database. A blueprint describes the major engine version of
        /// a database.</p>
        /// <p>You can get a list of database blueprints IDs by using the <code>get relational database
        /// blueprints</code> operation.</p>
        pub fn relational_database_blueprint_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_blueprint_id(input);
            self
        }
        pub fn set_relational_database_blueprint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_blueprint_id(input);
            self
        }
        /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
        /// your database.</p>
        /// <p>You can get a list of database bundle IDs by using the <code>get relational database
        /// bundles</code> operation.</p>
        pub fn relational_database_bundle_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_bundle_id(input);
            self
        }
        pub fn set_relational_database_bundle_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_bundle_id(input);
            self
        }
        /// <p>The meaning of this parameter differs according to the database engine you use.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>The name of the database to create when the Lightsail database resource is created. If
        /// this parameter isn't specified, no database is created in the database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1 to 64 letters or numbers.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
        /// (0- 9).</p>
        /// </li>
        /// <li>
        /// <p>Can't be a word reserved by the specified database engine.</p>
        /// <p>For more information about reserved words in MySQL, see the Keywords and Reserved
        /// Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>The name of the database to create when the Lightsail database resource is created. If
        /// this parameter isn't specified, a database named <code>postgres</code> is created in the
        /// database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1 to 63 letters or numbers.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
        /// (0- 9).</p>
        /// </li>
        /// <li>
        /// <p>Can't be a word reserved by the specified database engine.</p>
        /// <p>For more information about reserved words in PostgreSQL, see the SQL Key Words
        /// articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL
        /// 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
        /// 12</a>.</p>
        /// </li>
        /// </ul>
        pub fn master_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.master_database_name(input);
            self
        }
        pub fn set_master_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_master_database_name(input);
            self
        }
        /// <p>The name for the master user.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Required for MySQL.</p>
        /// </li>
        /// <li>
        /// <p>Must be 1 to 16 letters or numbers. Can contain underscores.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't be a reserved word for the chosen database engine.</p>
        /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
        /// Reserved Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Required for PostgreSQL.</p>
        /// </li>
        /// <li>
        /// <p>Must be 1 to 63 letters or numbers. Can contain underscores.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't be a reserved word for the chosen database engine.</p>
        /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
        /// Reserved Words articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL
        /// 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL
        /// 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
        /// 12</a>.</p>
        /// </li>
        /// </ul>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.master_username(input);
            self
        }
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_master_username(input);
            self
        }
        /// <p>The password for the master user. The password can include any printable ASCII character
        /// except "/", """, or "@". It cannot contain spaces.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 41 characters.</p>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 128 characters.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.master_user_password(input);
            self
        }
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_master_user_password(input);
            self
        }
        /// <p>The daily time range during which automated backups are created for your new database if
        /// automated backups are enabled.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region. For more information about the preferred backup window time blocks for each
        /// region, see the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Working With Backups</a> guide in the Amazon Relational Database Service (Amazon RDS) documentation.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
        /// <p>Example: <code>16:00-16:30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Must not conflict with the preferred maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// </ul>
        pub fn preferred_backup_window(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.preferred_backup_window(input);
            self
        }
        pub fn set_preferred_backup_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_backup_window(input);
            self
        }
        /// <p>The weekly time range during which system maintenance can occur on your new
        /// database.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region, occurring on a random day of the week.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
        /// </li>
        /// <li>
        /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.preferred_maintenance_window(input);
            self
        }
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_maintenance_window(input);
            self
        }
        /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.inner = self.inner.publicly_accessible(input);
            self
        }
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_publicly_accessible(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRelationalDatabaseFromSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_relational_database_from_snapshot_input::Builder,
    }
    impl<C> CreateRelationalDatabaseFromSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRelationalDatabaseFromSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateRelationalDatabaseFromSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name to use for your new Lightsail database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The Availability Zone in which to create your new database. Use the
        /// <code>us-east-2a</code> case-sensitive format.</p>
        /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
        /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
        /// your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.inner = self.inner.publicly_accessible(input);
            self
        }
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_publicly_accessible(input);
            self
        }
        /// <p>The name of the database snapshot from which to create your new database.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_snapshot_name(input);
            self
        }
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_snapshot_name(input);
            self
        }
        /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
        /// your database.</p>
        /// <p>You can get a list of database bundle IDs by using the <code>get relational database
        /// bundles</code> operation.</p>
        /// <p>When creating a new database from a snapshot, you cannot choose a bundle that is smaller
        /// than the bundle of the source database.</p>
        pub fn relational_database_bundle_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_bundle_id(input);
            self
        }
        pub fn set_relational_database_bundle_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_bundle_id(input);
            self
        }
        /// <p>The name of the source database.</p>
        pub fn source_relational_database_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.source_relational_database_name(input);
            self
        }
        pub fn set_source_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_relational_database_name(input);
            self
        }
        /// <p>The date and time to restore your database from.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be before the latest restorable time for the database.</p>
        /// </li>
        /// <li>
        /// <p>Cannot be specified if the <code>use latest restorable time</code> parameter is
        /// <code>true</code>.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a restore time of October 1, 2018, at 8 PM UTC, then
        /// you input <code>1538424000</code> as the restore time.</p>
        /// </li>
        /// </ul>
        pub fn restore_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.restore_time(input);
            self
        }
        pub fn set_restore_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_restore_time(input);
            self
        }
        /// <p>Specifies whether your database is restored from the latest backup time. A value of
        /// <code>true</code> restores from the latest backup time. </p>
        /// <p>Default: <code>false</code>
        /// </p>
        /// <p>Constraints: Cannot be specified if the <code>restore time</code> parameter is
        /// provided.</p>
        pub fn use_latest_restorable_time(mut self, input: bool) -> Self {
            self.inner = self.inner.use_latest_restorable_time(input);
            self
        }
        pub fn set_use_latest_restorable_time(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_use_latest_restorable_time(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRelationalDatabaseSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_relational_database_snapshot_input::Builder,
    }
    impl<C> CreateRelationalDatabaseSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRelationalDatabaseSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateRelationalDatabaseSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the database on which to base your new snapshot.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The name for your new database snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_snapshot_name(input);
            self
        }
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_snapshot_name(input);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAlarm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_alarm_input::Builder,
    }
    impl<C> DeleteAlarm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAlarmOutput,
            smithy_http::result::SdkError<crate::error::DeleteAlarmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the alarm to delete.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAutoSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_auto_snapshot_input::Builder,
    }
    impl<C> DeleteAutoSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAutoSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteAutoSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the source instance or disk from which to delete the automatic
        /// snapshot.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>The date of the automatic snapshot to delete in <code>YYYY-MM-DD</code> format. Use the
        /// <code>get auto snapshots</code> operation to get the available automatic snapshots for a
        /// resource.</p>
        pub fn date(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.date(input);
            self
        }
        pub fn set_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_date(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_certificate_input::Builder,
    }
    impl<C> DeleteCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the certificate to delete.</p>
        /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
        /// can specify.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteContactMethod<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_contact_method_input::Builder,
    }
    impl<C> DeleteContactMethod<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteContactMethodOutput,
            smithy_http::result::SdkError<crate::error::DeleteContactMethodError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The protocol that will be deleted, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        /// <note>
        /// <p>To delete an <code>Email</code> and an <code>SMS</code> contact method if you added
        /// both, you must run separate <code>DeleteContactMethod</code> actions to delete each
        /// protocol.</p>
        /// </note>
        pub fn protocol(mut self, input: crate::model::ContactProtocol) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ContactProtocol>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteContainerImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_container_image_input::Builder,
    }
    impl<C> DeleteContainerImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteContainerImageOutput,
            smithy_http::result::SdkError<crate::error::DeleteContainerImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to delete a registered container image.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The name of the container image to delete from the container service.</p>
        /// <p>Use the <code>GetContainerImages</code> action to get the name of the container images
        /// that are registered to a container service.</p>
        /// <note>
        /// <p>Container images sourced from your Lightsail container service, that are registered
        /// and stored on your service, start with a colon (<code>:</code>). For example,
        /// <code>:container-service-1.mystaticwebsite.1</code>. Container images sourced from a
        /// public registry like Docker Hub don't start with a colon. For example,
        /// <code>nginx:latest</code> or <code>nginx</code>.</p>
        /// </note>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image(input);
            self
        }
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteContainerService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_container_service_input::Builder,
    }
    impl<C> DeleteContainerService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteContainerServiceOutput,
            smithy_http::result::SdkError<crate::error::DeleteContainerServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service to delete.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDisk<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_disk_input::Builder,
    }
    impl<C> DeleteDisk<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDiskOutput,
            smithy_http::result::SdkError<crate::error::DeleteDiskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the disk you want to delete (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
        /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
        pub fn force_delete_add_ons(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete_add_ons(input);
            self
        }
        pub fn set_force_delete_add_ons(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete_add_ons(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDiskSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_disk_snapshot_input::Builder,
    }
    impl<C> DeleteDiskSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDiskSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteDiskSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the disk snapshot you want to delete (e.g.,
        /// <code>my-disk-snapshot</code>).</p>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_snapshot_name(input);
            self
        }
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_disk_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_distribution_input::Builder,
    }
    impl<C> DeleteDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDistributionOutput,
            smithy_http::result::SdkError<crate::error::DeleteDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution to delete.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_domain_input::Builder,
    }
    impl<C> DeleteDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDomainOutput,
            smithy_http::result::SdkError<crate::error::DeleteDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The specific domain name to delete.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDomainEntry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_domain_entry_input::Builder,
    }
    impl<C> DeleteDomainEntry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDomainEntryOutput,
            smithy_http::result::SdkError<crate::error::DeleteDomainEntryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain entry to delete.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>An array of key-value pairs containing information about your domain entries.</p>
        pub fn domain_entry(mut self, input: crate::model::DomainEntry) -> Self {
            self.inner = self.inner.domain_entry(input);
            self
        }
        pub fn set_domain_entry(
            mut self,
            input: std::option::Option<crate::model::DomainEntry>,
        ) -> Self {
            self.inner = self.inner.set_domain_entry(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_instance_input::Builder,
    }
    impl<C> DeleteInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeleteInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance to delete.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
        pub fn force_delete_add_ons(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete_add_ons(input);
            self
        }
        pub fn set_force_delete_add_ons(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete_add_ons(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInstanceSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_instance_snapshot_input::Builder,
    }
    impl<C> DeleteInstanceSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteInstanceSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteInstanceSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the snapshot to delete.</p>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_snapshot_name(input);
            self
        }
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_key_pair_input::Builder,
    }
    impl<C> DeleteKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteKeyPairOutput,
            smithy_http::result::SdkError<crate::error::DeleteKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the key pair to delete.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_name(input);
            self
        }
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteKnownHostKeys<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_known_host_keys_input::Builder,
    }
    impl<C> DeleteKnownHostKeys<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteKnownHostKeysOutput,
            smithy_http::result::SdkError<crate::error::DeleteKnownHostKeysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance for which you want to reset the host key or certificate.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_load_balancer_input::Builder,
    }
    impl<C> DeleteLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer you want to delete.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancerTlsCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_load_balancer_tls_certificate_input::Builder,
    }
    impl<C> DeleteLoadBalancerTlsCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerTlsCertificateOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerTlsCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The load balancer name.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The SSL/TLS certificate name.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
        /// <p>When <code>true</code>, forces the deletion of an SSL/TLS certificate.</p>
        /// <p>There can be two certificates associated with a Lightsail load balancer: the primary and
        /// the backup. The <code>force</code> parameter is required when the primary SSL/TLS certificate
        /// is in use by an instance attached to the load balancer.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_relational_database_input::Builder,
    }
    impl<C> DeleteRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::DeleteRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the database that you are deleting.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>Determines whether a final database snapshot is created before your database is deleted.
        /// If <code>true</code> is specified, no database snapshot is created. If <code>false</code> is
        /// specified, a database snapshot is created before your database is deleted.</p>
        /// <p>You must specify the <code>final relational database snapshot name</code> parameter if the
        /// <code>skip final snapshot</code> parameter is <code>false</code>.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn skip_final_snapshot(mut self, input: bool) -> Self {
            self.inner = self.inner.skip_final_snapshot(input);
            self
        }
        pub fn set_skip_final_snapshot(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_skip_final_snapshot(input);
            self
        }
        /// <p>The name of the database snapshot created if <code>skip final snapshot</code> is
        /// <code>false</code>, which is the default value for that parameter.</p>
        /// <note>
        /// <p>Specifying this parameter and also specifying the <code>skip final snapshot</code>
        /// parameter to <code>true</code> results in an error.</p>
        /// </note>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn final_relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.final_relational_database_snapshot_name(input);
            self
        }
        pub fn set_final_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_final_relational_database_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRelationalDatabaseSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_relational_database_snapshot_input::Builder,
    }
    impl<C> DeleteRelationalDatabaseSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRelationalDatabaseSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteRelationalDatabaseSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the database snapshot that you are deleting.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_snapshot_name(input);
            self
        }
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachCertificateFromDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_certificate_from_distribution_input::Builder,
    }
    impl<C> DetachCertificateFromDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachCertificateFromDistributionOutput,
            smithy_http::result::SdkError<crate::error::DetachCertificateFromDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution from which to detach the certificate.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachDisk<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_disk_input::Builder,
    }
    impl<C> DetachDisk<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachDiskOutput,
            smithy_http::result::SdkError<crate::error::DetachDiskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the disk you want to detach from your instance (e.g.,
        /// <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachInstancesFromLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_instances_from_load_balancer_input::Builder,
    }
    impl<C> DetachInstancesFromLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachInstancesFromLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::DetachInstancesFromLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Lightsail load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>An array of strings containing the names of the instances you want to detach from the load
        /// balancer.</p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachStaticIp<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_static_ip_input::Builder,
    }
    impl<C> DetachStaticIp<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachStaticIpOutput,
            smithy_http::result::SdkError<crate::error::DetachStaticIpError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the static IP to detach from the instance.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.static_ip_name(input);
            self
        }
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_static_ip_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableAddOn<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_add_on_input::Builder,
    }
    impl<C> DisableAddOn<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableAddOnOutput,
            smithy_http::result::SdkError<crate::error::DisableAddOnError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The add-on type to disable.</p>
        pub fn add_on_type(mut self, input: crate::model::AddOnType) -> Self {
            self.inner = self.inner.add_on_type(input);
            self
        }
        pub fn set_add_on_type(
            mut self,
            input: std::option::Option<crate::model::AddOnType>,
        ) -> Self {
            self.inner = self.inner.set_add_on_type(input);
            self
        }
        /// <p>The name of the source resource for which to disable the add-on.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DownloadDefaultKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::download_default_key_pair_input::Builder,
    }
    impl<C> DownloadDefaultKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DownloadDefaultKeyPairOutput,
            smithy_http::result::SdkError<crate::error::DownloadDefaultKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableAddOn<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_add_on_input::Builder,
    }
    impl<C> EnableAddOn<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableAddOnOutput,
            smithy_http::result::SdkError<crate::error::EnableAddOnError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the source resource for which to enable or modify the add-on.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>An array of strings representing the add-on to enable or modify.</p>
        pub fn add_on_request(mut self, input: crate::model::AddOnRequest) -> Self {
            self.inner = self.inner.add_on_request(input);
            self
        }
        pub fn set_add_on_request(
            mut self,
            input: std::option::Option<crate::model::AddOnRequest>,
        ) -> Self {
            self.inner = self.inner.set_add_on_request(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::export_snapshot_input::Builder,
    }
    impl<C> ExportSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportSnapshotOutput,
            smithy_http::result::SdkError<crate::error::ExportSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance or disk snapshot to be exported to Amazon EC2.</p>
        pub fn source_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_snapshot_name(input);
            self
        }
        pub fn set_source_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetActiveNames<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_active_names_input::Builder,
    }
    impl<C> GetActiveNames<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetActiveNamesOutput,
            smithy_http::result::SdkError<crate::error::GetActiveNamesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetActiveNames</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAlarms<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_alarms_input::Builder,
    }
    impl<C> GetAlarms<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAlarmsOutput,
            smithy_http::result::SdkError<crate::error::GetAlarmsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the alarm.</p>
        /// <p>Specify an alarm name to return information about a specific alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetAlarms</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
        /// <p>The name of the Lightsail resource being monitored by the alarm.</p>
        /// <p>Specify a monitored resource name to return information about all alarms for a specific
        /// resource.</p>
        pub fn monitored_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitored_resource_name(input);
            self
        }
        pub fn set_monitored_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_monitored_resource_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAutoSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_auto_snapshots_input::Builder,
    }
    impl<C> GetAutoSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAutoSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::GetAutoSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the source instance or disk from which to get automatic snapshot
        /// information.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBlueprints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_blueprints_input::Builder,
    }
    impl<C> GetBlueprints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBlueprintsOutput,
            smithy_http::result::SdkError<crate::error::GetBlueprintsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A Boolean value indicating whether to include inactive results in your request.</p>
        pub fn include_inactive(mut self, input: bool) -> Self {
            self.inner = self.inner.include_inactive(input);
            self
        }
        pub fn set_include_inactive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_inactive(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetBlueprints</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBundles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bundles_input::Builder,
    }
    impl<C> GetBundles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBundlesOutput,
            smithy_http::result::SdkError<crate::error::GetBundlesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A Boolean value that indicates whether to include inactive bundle results in your
        /// request.</p>
        pub fn include_inactive(mut self, input: bool) -> Self {
            self.inner = self.inner.include_inactive(input);
            self
        }
        pub fn set_include_inactive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_inactive(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetBundles</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_certificates_input::Builder,
    }
    impl<C> GetCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCertificatesOutput,
            smithy_http::result::SdkError<crate::error::GetCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The status of the certificates for which to return information.</p>
        /// <p>For example, specify <code>ISSUED</code> to return only certificates with an
        /// <code>ISSUED</code> status.</p>
        /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
        /// request is made, regardless of their current status.</p>
        pub fn certificate_statuses(
            mut self,
            inp: impl Into<crate::model::CertificateStatus>,
        ) -> Self {
            self.inner = self.inner.certificate_statuses(inp);
            self
        }
        pub fn set_certificate_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CertificateStatus>>,
        ) -> Self {
            self.inner = self.inner.set_certificate_statuses(input);
            self
        }
        /// <p>Indicates whether to include detailed information about the certificates in the
        /// response.</p>
        /// <p>When omitted, the response includes only the certificate names, Amazon Resource Names
        /// (ARNs), domain names, and tags.</p>
        pub fn include_certificate_details(mut self, input: bool) -> Self {
            self.inner = self.inner.include_certificate_details(input);
            self
        }
        pub fn set_include_certificate_details(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_certificate_details(input);
            self
        }
        /// <p>The name for the certificate for which to return information.</p>
        /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
        /// request is made.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_name(input);
            self
        }
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCloudFormationStackRecords<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cloud_formation_stack_records_input::Builder,
    }
    impl<C> GetCloudFormationStackRecords<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCloudFormationStackRecordsOutput,
            smithy_http::result::SdkError<crate::error::GetCloudFormationStackRecordsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetClouFormationStackRecords</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContactMethods<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_contact_methods_input::Builder,
    }
    impl<C> GetContactMethods<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContactMethodsOutput,
            smithy_http::result::SdkError<crate::error::GetContactMethodsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The protocols used to send notifications, such as <code>Email</code>, or <code>SMS</code>
        /// (text messaging).</p>
        /// <p>Specify a protocol in your request to return information about a specific contact method
        /// protocol.</p>
        pub fn protocols(mut self, inp: impl Into<crate::model::ContactProtocol>) -> Self {
            self.inner = self.inner.protocols(inp);
            self
        }
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
        ) -> Self {
            self.inner = self.inner.set_protocols(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerAPIMetadata<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_api_metadata_input::Builder,
    }
    impl<C> GetContainerAPIMetadata<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerApiMetadataOutput,
            smithy_http::result::SdkError<crate::error::GetContainerAPIMetadataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_images_input::Builder,
    }
    impl<C> GetContainerImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerImagesOutput,
            smithy_http::result::SdkError<crate::error::GetContainerImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to return registered container images.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerLog<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_log_input::Builder,
    }
    impl<C> GetContainerLog<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerLogOutput,
            smithy_http::result::SdkError<crate::error::GetContainerLogError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to get a container log.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The name of the container that is either running or previously ran on the container
        /// service for which to return a log.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.container_name(input);
            self
        }
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_container_name(input);
            self
        }
        /// <p>The start of the time interval for which to get log data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
        /// <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time interval for which to get log data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
        /// <code>1538427600</code> as the end time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The pattern to use to filter the returned log events to a specific term.</p>
        /// <p>The following are a few examples of filter patterns that you can specify:</p>
        /// <ul>
        /// <li>
        /// <p>To return all log events, specify a filter pattern of <code>""</code>.</p>
        /// </li>
        /// <li>
        /// <p>To exclude log events that contain the <code>ERROR</code> term, and return all other
        /// log events, specify a filter pattern of <code>"-ERROR"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain the <code>ERROR</code> term, specify a filter
        /// pattern of <code>"ERROR"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain both the <code>ERROR</code> and
        /// <code>Exception</code> terms, specify a filter pattern of <code>"ERROR
        /// Exception"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain the <code>ERROR</code>
        /// <i>or</i> the <code>Exception</code> term, specify a filter pattern of
        /// <code>"?ERROR ?Exception"</code>.</p>
        /// </li>
        /// </ul>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(input);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetContainerLog</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerServiceDeployments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_service_deployments_input::Builder,
    }
    impl<C> GetContainerServiceDeployments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerServiceDeploymentsOutput,
            smithy_http::result::SdkError<crate::error::GetContainerServiceDeploymentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to return deployments.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerServiceMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_service_metric_data_input::Builder,
    }
    impl<C> GetContainerServiceMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerServiceMetricDataOutput,
            smithy_http::result::SdkError<crate::error::GetContainerServiceMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to get metric data.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid container service metric names are listed below, along with the most useful
        /// statistics to include in your request, and the published unit value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CPUUtilization</code> - The average percentage of compute units that are
        /// currently in use across all nodes of the container service. This metric identifies the
        /// processing power required to run containers on each node of the container service.</p>
        /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MemoryUtilization</code> - The average percentage of available memory that is
        /// currently in use across all nodes of the container service. This metric identifies the
        /// memory required to run containers on each node of the container service.</p>
        /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::ContainerServiceMetricName) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::ContainerServiceMetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The start time of the time period.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time of the time period.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>All container service metric data is available in 5-minute (300 seconds)
        /// granularity.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
        /// the specified period. By comparing this statistic with the <code>Minimum</code> and
        /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
        /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, inp: impl Into<crate::model::MetricStatistic>) -> Self {
            self.inner = self.inner.statistics(inp);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.inner = self.inner.set_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerServicePowers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_service_powers_input::Builder,
    }
    impl<C> GetContainerServicePowers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerServicePowersOutput,
            smithy_http::result::SdkError<crate::error::GetContainerServicePowersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetContainerServices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_container_services_input::Builder,
    }
    impl<C> GetContainerServices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetContainerServicesOutput,
            smithy_http::result::SdkError<crate::error::GetContainerServicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to return information.</p>
        /// <p>When omitted, the response includes all of your container services in the AWS Region
        /// where the request is made.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDisk<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_disk_input::Builder,
    }
    impl<C> GetDisk<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDiskOutput,
            smithy_http::result::SdkError<crate::error::GetDiskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the disk (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_name(input);
            self
        }
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDisks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_disks_input::Builder,
    }
    impl<C> GetDisks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDisksOutput,
            smithy_http::result::SdkError<crate::error::GetDisksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDisks</code> request. If your results are
        /// paginated, the response will return a next page token that you can specify as the page token
        /// in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDiskSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_disk_snapshot_input::Builder,
    }
    impl<C> GetDiskSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDiskSnapshotOutput,
            smithy_http::result::SdkError<crate::error::GetDiskSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the disk snapshot (e.g., <code>my-disk-snapshot</code>).</p>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_snapshot_name(input);
            self
        }
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_disk_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDiskSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_disk_snapshots_input::Builder,
    }
    impl<C> GetDiskSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDiskSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::GetDiskSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDiskSnapshots</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributionBundles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distribution_bundles_input::Builder,
    }
    impl<C> GetDistributionBundles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionBundlesOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionBundlesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributionLatestCacheReset<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distribution_latest_cache_reset_input::Builder,
    }
    impl<C> GetDistributionLatestCacheReset<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionLatestCacheResetOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionLatestCacheResetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution for which to return the timestamp of the last cache
        /// reset.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        /// <p>When omitted, the response includes the latest cache reset timestamp of all your
        /// distributions.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributionMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distribution_metric_data_input::Builder,
    }
    impl<C> GetDistributionMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionMetricDataOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution for which to get metric data.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid distribution metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>Requests</code>
        /// </b> - The total number of viewer
        /// requests received by your Lightsail distribution, for all HTTP methods, and for both
        /// HTTP and HTTPS requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BytesDownloaded</code>
        /// </b> - The number of bytes
        /// downloaded by viewers for GET, HEAD, and OPTIONS requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BytesUploaded </code>
        /// </b> - The number of bytes
        /// uploaded to your origin by your Lightsail distribution, using POST and PUT
        /// requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>TotalErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status code was 4xx or 5xx.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>4xxErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status cod was 4xx. In these cases, the
        /// client or client viewer may have made an error. For example, a status code of 404 (Not
        /// Found) means that the client requested an object that could not be found.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>5xxErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status code was 5xx. In these cases, the
        /// origin server did not satisfy the requests. For example, a status code of 503 (Service
        /// Unavailable) means that the origin server is currently unavailable.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::DistributionMetricName) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::DistributionMetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The start of the time interval for which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
        /// <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time interval for which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
        /// <code>1538427600</code> as the end time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The granularity, in seconds, for the metric data points that will be returned.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The unit for the metric data request.</p>
        /// <p>Valid units depend on the metric data being requested. For the valid units with each
        /// available metric, see the <code>metricName</code> parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, inp: impl Into<crate::model::MetricStatistic>) -> Self {
            self.inner = self.inner.statistics(inp);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.inner = self.inner.set_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDistributions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_distributions_input::Builder,
    }
    impl<C> GetDistributions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDistributionsOutput,
            smithy_http::result::SdkError<crate::error::GetDistributionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution for which to return information.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        /// <p>When omitted, the response includes all of your distributions in the AWS Region where
        /// the request is made.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDistributions</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_domain_input::Builder,
    }
    impl<C> GetDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainOutput,
            smithy_http::result::SdkError<crate::error::GetDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain name for which your want to return information about.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_domains_input::Builder,
    }
    impl<C> GetDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDomainsOutput,
            smithy_http::result::SdkError<crate::error::GetDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDomains</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetExportSnapshotRecords<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_export_snapshot_records_input::Builder,
    }
    impl<C> GetExportSnapshotRecords<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetExportSnapshotRecordsOutput,
            smithy_http::result::SdkError<crate::error::GetExportSnapshotRecordsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetExportSnapshotRecords</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_input::Builder,
    }
    impl<C> GetInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceAccessDetails<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_access_details_input::Builder,
    }
    impl<C> GetInstanceAccessDetails<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceAccessDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceAccessDetailsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance to access.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>The protocol to use to connect to your instance. Defaults to <code>ssh</code>.</p>
        pub fn protocol(mut self, input: crate::model::InstanceAccessProtocol) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::InstanceAccessProtocol>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_metric_data_input::Builder,
    }
    impl<C> GetInstanceMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceMetricDataOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance for which you want to get metrics data.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid instance metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BurstCapacityPercentage</code>
        /// </b> - The percentage
        /// of CPU performance available for your instance to burst above its baseline. Your instance
        /// continuously accrues and consumes burst capacity. Burst capacity stops accruing when your
        /// instance's <code>BurstCapacityPercentage</code> reaches 100%. For more information, see
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BurstCapacityTime</code>
        /// </b> - The available amount
        /// of time for your instance to burst at 100% CPU utilization. Your instance continuously
        /// accrues and consumes burst capacity. Burst capacity time stops accruing when your
        /// instance's <code>BurstCapacityPercentage</code> metric reaches 100%.</p>
        /// <p>Burst capacity time is consumed at the full rate only when your instance operates at
        /// 100% CPU utilization. For example, if your instance operates at 50% CPU utilization in the
        /// burstable zone for a 5-minute period, then it consumes CPU burst capacity minutes at a 50%
        /// rate in that period. Your instance consumed 2 minutes and 30 seconds of CPU burst capacity
        /// minutes in the 5-minute period. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>CPUUtilization</code>
        /// </b> - The percentage of
        /// allocated compute units that are currently in use on the instance. This metric identifies
        /// the processing power to run the applications on the instance. Tools in your operating
        /// system can show a lower percentage than Lightsail when the instance is not allocated a
        /// full processor core.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkIn</code>
        /// </b> - The number of bytes received
        /// on all network interfaces by the instance. This metric identifies the volume of incoming
        /// network traffic to the instance. The number reported is the number of bytes received
        /// during the period. Because this metric is reported in 5-minute intervals, divide the
        /// reported number by 300 to find Bytes/second.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkOut</code>
        /// </b> - The number of bytes sent
        /// out on all network interfaces by the instance. This metric identifies the volume of
        /// outgoing network traffic from the instance. The number reported is the number of bytes
        /// sent during the period. Because this metric is reported in 5-minute intervals, divide the
        /// reported number by 300 to find Bytes/second.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed</code>
        /// </b> - Reports whether the
        /// instance passed or failed both the instance status check and the system status check. This
        /// metric can be either 0 (passed) or 1 (failed). This metric data is available in 1-minute
        /// (60 seconds) granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed_Instance</code>
        /// </b> - Reports
        /// whether the instance passed or failed the instance status check. This metric can be either
        /// 0 (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed_System</code>
        /// </b> - Reports
        /// whether the instance passed or failed the system status check. This metric can be either 0
        /// (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::InstanceMetricName) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::InstanceMetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>The <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and
        /// <code>StatusCheckFailed_System</code> instance metric data is available in 1-minute (60
        /// seconds) granularity. All other instance metric data is available in 5-minute (300 seconds)
        /// granularity.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The start time of the time period.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time of the time period.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units to specify with each available metric, see the
        /// <code>metricName</code> parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, inp: impl Into<crate::model::MetricStatistic>) -> Self {
            self.inner = self.inner.statistics(inp);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.inner = self.inner.set_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstancePortStates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_port_states_input::Builder,
    }
    impl<C> GetInstancePortStates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstancePortStatesOutput,
            smithy_http::result::SdkError<crate::error::GetInstancePortStatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance for which to return firewall port states.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instances_input::Builder,
    }
    impl<C> GetInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstancesOutput,
            smithy_http::result::SdkError<crate::error::GetInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetInstances</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_snapshot_input::Builder,
    }
    impl<C> GetInstanceSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceSnapshotOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the snapshot for which you are requesting information.</p>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_snapshot_name(input);
            self
        }
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_snapshots_input::Builder,
    }
    impl<C> GetInstanceSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetInstanceSnapshots</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstanceState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_instance_state_input::Builder,
    }
    impl<C> GetInstanceState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceStateOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance to get state information about.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_key_pair_input::Builder,
    }
    impl<C> GetKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetKeyPairOutput,
            smithy_http::result::SdkError<crate::error::GetKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the key pair for which you are requesting information.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_name(input);
            self
        }
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetKeyPairs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_key_pairs_input::Builder,
    }
    impl<C> GetKeyPairs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetKeyPairsOutput,
            smithy_http::result::SdkError<crate::error::GetKeyPairsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetKeyPairs</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_load_balancer_input::Builder,
    }
    impl<C> GetLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::GetLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoadBalancerMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_load_balancer_metric_data_input::Builder,
    }
    impl<C> GetLoadBalancerMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLoadBalancerMetricDataOutput,
            smithy_http::result::SdkError<crate::error::GetLoadBalancerMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid load balancer metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>ClientTLSNegotiationErrorCount</code>
        /// </b> - The
        /// number of TLS connections initiated by the client that did not establish a session with
        /// the load balancer due to a TLS error generated by the load balancer. Possible causes
        /// include a mismatch of ciphers or protocols.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HealthyHostCount</code>
        /// </b> - The number of target
        /// instances that are considered healthy.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
        /// <code>Minimum</code>, and <code>Maximum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_2XX_Count</code>
        /// </b> - The number
        /// of HTTP 2XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_3XX_Count</code>
        /// </b> - The number
        /// of HTTP 3XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_4XX_Count</code>
        /// </b> - The number
        /// of HTTP 4XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_5XX_Count</code>
        /// </b> - The number
        /// of HTTP 5XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_LB_4XX_Count</code>
        /// </b> - The number of
        /// HTTP 4XX client error codes that originated from the load balancer. Client errors are
        /// generated when requests are malformed or incomplete. These requests were not received by
        /// the target instance. This count does not include response codes generated by the target
        /// instances.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_LB_5XX_Count</code>
        /// </b> - The number of
        /// HTTP 5XX server error codes that originated from the load balancer. This does not include
        /// any response codes generated by the target instance. This metric is reported if there are
        /// no healthy instances attached to the load balancer, or if the request rate exceeds the
        /// capacity of the instances (spillover) or the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>InstanceResponseTime</code>
        /// </b> - The time elapsed,
        /// in seconds, after the request leaves the load balancer until a response from the target
        /// instance is received.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>RejectedConnectionCount</code>
        /// </b> - The number of
        /// connections that were rejected because the load balancer had reached its maximum number of
        /// connections.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>RequestCount</code>
        /// </b> - The number of requests
        /// processed over IPv4. This count includes only the requests with a response generated by a
        /// target instance of the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>UnhealthyHostCount</code>
        /// </b> - The number of
        /// target instances that are considered unhealthy.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
        /// <code>Minimum</code>, and <code>Maximum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::LoadBalancerMetricName) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerMetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The start time of the period.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time of the period.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units with each available metric, see the <code>metricName</code>
        /// parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, inp: impl Into<crate::model::MetricStatistic>) -> Self {
            self.inner = self.inner.statistics(inp);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.inner = self.inner.set_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoadBalancers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_load_balancers_input::Builder,
    }
    impl<C> GetLoadBalancers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::GetLoadBalancersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetLoadBalancers</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLoadBalancerTlsCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_load_balancer_tls_certificates_input::Builder,
    }
    impl<C> GetLoadBalancerTlsCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLoadBalancerTlsCertificatesOutput,
            smithy_http::result::SdkError<crate::error::GetLoadBalancerTlsCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer you associated with your SSL/TLS certificate.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOperation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_operation_input::Builder,
    }
    impl<C> GetOperation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOperationOutput,
            smithy_http::result::SdkError<crate::error::GetOperationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A GUID used to identify the operation.</p>
        pub fn operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.operation_id(input);
            self
        }
        pub fn set_operation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_operation_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOperations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_operations_input::Builder,
    }
    impl<C> GetOperations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOperationsOutput,
            smithy_http::result::SdkError<crate::error::GetOperationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetOperations</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOperationsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_operations_for_resource_input::Builder,
    }
    impl<C> GetOperationsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOperationsForResourceOutput,
            smithy_http::result::SdkError<crate::error::GetOperationsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the resource for which you are requesting information.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetOperationsForResource</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRegions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_regions_input::Builder,
    }
    impl<C> GetRegions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRegionsOutput,
            smithy_http::result::SdkError<crate::error::GetRegionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A Boolean value indicating whether to also include Availability Zones in your get regions
        /// request. Availability Zones are indicated with a letter: e.g., <code>us-east-2a</code>.</p>
        pub fn include_availability_zones(mut self, input: bool) -> Self {
            self.inner = self.inner.include_availability_zones(input);
            self
        }
        pub fn set_include_availability_zones(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_availability_zones(input);
            self
        }
        /// <p>A Boolean value indicating whether to also include Availability Zones for databases in
        /// your get regions request. Availability Zones are indicated with a letter (e.g.,
        /// <code>us-east-2a</code>).</p>
        pub fn include_relational_database_availability_zones(mut self, input: bool) -> Self {
            self.inner = self
                .inner
                .include_relational_database_availability_zones(input);
            self
        }
        pub fn set_include_relational_database_availability_zones(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self
                .inner
                .set_include_relational_database_availability_zones(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_input::Builder,
    }
    impl<C> GetRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the database that you are looking up.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseBlueprints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_blueprints_input::Builder,
    }
    impl<C> GetRelationalDatabaseBlueprints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseBlueprintsOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseBlueprintsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBlueprints</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseBundles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_bundles_input::Builder,
    }
    impl<C> GetRelationalDatabaseBundles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseBundlesOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseBundlesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBundles</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_events_input::Builder,
    }
    impl<C> GetRelationalDatabaseEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseEventsOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the database from which to get events.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The number of minutes in the past from which to retrieve events. For example, to get all
        /// events from the past 2 hours, enter 120.</p>
        /// <p>Default: <code>60</code>
        /// </p>
        /// <p>The minimum is 1 and the maximum is 14 days (20160 minutes).</p>
        pub fn duration_in_minutes(mut self, input: i32) -> Self {
            self.inner = self.inner.duration_in_minutes(input);
            self
        }
        pub fn set_duration_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_in_minutes(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseEvents</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseLogEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_log_events_input::Builder,
    }
    impl<C> GetRelationalDatabaseLogEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseLogEventsOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseLogEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database for which to get log events.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        /// <p>Use the <code>get relational database log streams</code> operation to get a list of
        /// available log streams.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(input);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
        /// <p>The start of the time interval from which to get log events.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time interval from which to get log events.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the end time.</p>
        /// </li>
        /// </ul>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>Parameter to specify if the log should start from head or tail. If <code>true</code> is
        /// specified, the log event starts from the head of the log. If <code>false</code> is specified,
        /// the log event starts from the tail of the log.</p>
        /// <note>
        /// <p>For PostgreSQL, the default value of <code>false</code> is the only option
        /// available.</p>
        /// </note>
        pub fn start_from_head(mut self, input: bool) -> Self {
            self.inner = self.inner.start_from_head(input);
            self
        }
        pub fn set_start_from_head(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_start_from_head(input);
            self
        }
        /// <p>The token to advance to the next or previous page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseLogEvents</code>
        /// request. If your results are paginated, the response will return a next forward token and/or
        /// next backward token that you can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseLogStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_log_streams_input::Builder,
    }
    impl<C> GetRelationalDatabaseLogStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseLogStreamsOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseLogStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database for which to get log streams.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseMasterUserPassword<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_master_user_password_input::Builder,
    }
    impl<C> GetRelationalDatabaseMasterUserPassword<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseMasterUserPasswordOutput,
            smithy_http::result::SdkError<
                crate::error::GetRelationalDatabaseMasterUserPasswordError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database for which to get the master user password.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The password version to return.</p>
        /// <p>Specifying <code>CURRENT</code> or <code>PREVIOUS</code> returns the current or previous
        /// passwords respectively. Specifying <code>PENDING</code> returns the newest version of the
        /// password that will rotate to <code>CURRENT</code>. After the <code>PENDING</code> password
        /// rotates to <code>CURRENT</code>, the <code>PENDING</code> password is no longer
        /// available.</p>
        /// <p>Default: <code>CURRENT</code>
        /// </p>
        pub fn password_version(
            mut self,
            input: crate::model::RelationalDatabasePasswordVersion,
        ) -> Self {
            self.inner = self.inner.password_version(input);
            self
        }
        pub fn set_password_version(
            mut self,
            input: std::option::Option<crate::model::RelationalDatabasePasswordVersion>,
        ) -> Self {
            self.inner = self.inner.set_password_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_metric_data_input::Builder,
    }
    impl<C> GetRelationalDatabaseMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseMetricDataOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database from which to get metric data.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid relational database metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value. All relational database metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>CPUUtilization</code>
        /// </b> - The percentage of CPU
        /// utilization currently in use on the database.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>DatabaseConnections</code>
        /// </b> - The number of
        /// database connections in use.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>DiskQueueDepth</code>
        /// </b> - The number of
        /// outstanding IOs (read/write requests) that are waiting to access the disk.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>FreeStorageSpace</code>
        /// </b> - The amount of
        /// available storage space.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkReceiveThroughput</code>
        /// </b> - The incoming
        /// (Receive) network traffic on the database, including both customer database traffic and
        /// AWS traffic used for monitoring and replication.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkTransmitThroughput</code>
        /// </b> - The outgoing
        /// (Transmit) network traffic on the database, including both customer database traffic and
        /// AWS traffic used for monitoring and replication.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::RelationalDatabaseMetricName) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::RelationalDatabaseMetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>All relational database metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The start of the time interval from which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time interval from which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the end time.</p>
        /// </li>
        /// </ul>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units with each available metric, see the <code>metricName</code>
        /// parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, inp: impl Into<crate::model::MetricStatistic>) -> Self {
            self.inner = self.inner.statistics(inp);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.inner = self.inner.set_statistics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseParameters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_parameters_input::Builder,
    }
    impl<C> GetRelationalDatabaseParameters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseParametersOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseParametersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database for which to get parameters.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseParameters</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabases<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_databases_input::Builder,
    }
    impl<C> GetRelationalDatabases<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabasesOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabasesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabases</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_snapshot_input::Builder,
    }
    impl<C> GetRelationalDatabaseSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseSnapshotOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the database snapshot for which to get information.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_snapshot_name(input);
            self
        }
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRelationalDatabaseSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_relational_database_snapshots_input::Builder,
    }
    impl<C> GetRelationalDatabaseSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRelationalDatabaseSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::GetRelationalDatabaseSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseSnapshots</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStaticIp<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_static_ip_input::Builder,
    }
    impl<C> GetStaticIp<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStaticIpOutput,
            smithy_http::result::SdkError<crate::error::GetStaticIpError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the static IP in Lightsail.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.static_ip_name(input);
            self
        }
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_static_ip_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStaticIps<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_static_ips_input::Builder,
    }
    impl<C> GetStaticIps<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStaticIpsOutput,
            smithy_http::result::SdkError<crate::error::GetStaticIpsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetStaticIps</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.page_token(input);
            self
        }
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_key_pair_input::Builder,
    }
    impl<C> ImportKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportKeyPairOutput,
            smithy_http::result::SdkError<crate::error::ImportKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the key pair for which you want to import the public key.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_name(input);
            self
        }
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_name(input);
            self
        }
        /// <p>A base64-encoded public key of the <code>ssh-rsa</code> type.</p>
        pub fn public_key_base64(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_key_base64(input);
            self
        }
        pub fn set_public_key_base64(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_public_key_base64(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct IsVpcPeered<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::is_vpc_peered_input::Builder,
    }
    impl<C> IsVpcPeered<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::IsVpcPeeredOutput,
            smithy_http::result::SdkError<crate::error::IsVpcPeeredError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct OpenInstancePublicPorts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::open_instance_public_ports_input::Builder,
    }
    impl<C> OpenInstancePublicPorts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::OpenInstancePublicPortsOutput,
            smithy_http::result::SdkError<crate::error::OpenInstancePublicPortsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An object to describe the ports to open for the specified instance.</p>
        pub fn port_info(mut self, input: crate::model::PortInfo) -> Self {
            self.inner = self.inner.port_info(input);
            self
        }
        pub fn set_port_info(mut self, input: std::option::Option<crate::model::PortInfo>) -> Self {
            self.inner = self.inner.set_port_info(input);
            self
        }
        /// <p>The name of the instance for which to open ports.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PeerVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::peer_vpc_input::Builder,
    }
    impl<C> PeerVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PeerVpcOutput,
            smithy_http::result::SdkError<crate::error::PeerVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAlarm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_alarm_input::Builder,
    }
    impl<C> PutAlarm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAlarmOutput,
            smithy_http::result::SdkError<crate::error::PutAlarmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the
        /// previous configuration of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>The name of the metric to associate with the alarm.</p>
        /// <p>You can configure up to two alarms per metric.</p>
        /// <p>The following metrics are available for each resource type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Instances</b>: <code>BurstCapacityPercentage</code>,
        /// <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>,
        /// <code>NetworkOut</code>, <code>StatusCheckFailed</code>,
        /// <code>StatusCheckFailed_Instance</code>, and
        /// <code>StatusCheckFailed_System</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Load balancers</b>:
        /// <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>,
        /// <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>,
        /// <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>,
        /// <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>,
        /// <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>,
        /// <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Relational databases</b>: <code>CPUUtilization</code>,
        /// <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>,
        /// <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and
        /// <code>NetworkTransmitThroughput</code>.</p>
        /// </li>
        /// </ul>
        /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
        pub fn metric_name(mut self, input: crate::model::MetricName) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::MetricName>,
        ) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The name of the Lightsail resource that will be monitored.</p>
        /// <p>Instances, load balancers, and relational databases are the only Lightsail resources
        /// that can currently be monitored by alarms.</p>
        pub fn monitored_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitored_resource_name(input);
            self
        }
        pub fn set_monitored_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_monitored_resource_name(input);
            self
        }
        /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold.
        /// The specified statistic value is used as the first operand.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.inner = self.inner.comparison_operator(input);
            self
        }
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.inner = self.inner.set_comparison_operator(input);
            self
        }
        /// <p>The value against which the specified statistic is compared.</p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.inner = self.inner.threshold(input);
            self
        }
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_threshold(input);
            self
        }
        /// <p>The number of most recent periods over which data is compared to the specified threshold.
        /// If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the
        /// N.</p>
        /// <p>If you are setting an alarm that requires that a number of consecutive data points be
        /// breaching to trigger the alarm, this value specifies the rolling period of time in which data
        /// points are evaluated.</p>
        /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of
        /// 24 to evaluate a metric over a rolling period of two hours.</p>
        /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation
        /// period of 288 (24 hours).</p>
        pub fn evaluation_periods(mut self, input: i32) -> Self {
            self.inner = self.inner.evaluation_periods(input);
            self
        }
        pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_evaluation_periods(input);
            self
        }
        /// <p>The number of data points that must be not within the specified threshold to trigger the
        /// alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>)
        /// is the M.</p>
        pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
            self.inner = self.inner.datapoints_to_alarm(input);
            self
        }
        pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_datapoints_to_alarm(input);
            self
        }
        /// <p>Sets how this alarm will handle missing data points.</p>
        /// <p>An alarm can treat missing data in the following ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>breaching</code> - Assume the missing data is not within the threshold. Missing
        /// data counts towards the number of times the metric is not within the threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>notBreaching</code> - Assume the missing data is within the threshold. Missing
        /// data does not count towards the number of times the metric is not within the
        /// threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ignore</code> - Ignore the missing data. Maintains the current alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>missing</code> - Missing data is treated as missing.</p>
        /// </li>
        /// </ul>
        /// <p>If <code>treatMissingData</code> is not specified, the default behavior of
        /// <code>missing</code> is used.</p>
        pub fn treat_missing_data(mut self, input: crate::model::TreatMissingData) -> Self {
            self.inner = self.inner.treat_missing_data(input);
            self
        }
        pub fn set_treat_missing_data(
            mut self,
            input: std::option::Option<crate::model::TreatMissingData>,
        ) -> Self {
            self.inner = self.inner.set_treat_missing_data(input);
            self
        }
        /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code>
        /// (text messaging), or both.</p>
        /// <p>A notification is sent via the specified contact protocol if notifications are enabled for
        /// the alarm, and when the alarm is triggered.</p>
        /// <p>A notification is not sent if a contact protocol is not specified, if the specified
        /// contact protocol is not configured in the AWS Region, or if notifications are not enabled
        /// for the alarm using the <code>notificationEnabled</code> paramater.</p>
        /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an
        /// AWS Region.</p>
        pub fn contact_protocols(mut self, inp: impl Into<crate::model::ContactProtocol>) -> Self {
            self.inner = self.inner.contact_protocols(inp);
            self
        }
        pub fn set_contact_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
        ) -> Self {
            self.inner = self.inner.set_contact_protocols(input);
            self
        }
        /// <p>The alarm states that trigger a notification.</p>
        /// <p>An alarm has the following possible states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
        /// available, or not enough data is available for the metric to determine the alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK</code> - The metric is within the defined threshold.</p>
        /// </li>
        /// </ul>
        /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified.
        /// The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to
        /// the <code>ALARM</code> state.</p>
        /// <ul>
        /// <li>
        /// <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the
        /// alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to
        /// an <code>OK</code> state. This can be thought of as an <i>all clear</i>
        /// alarm notification.</p>
        /// </li>
        /// <li>
        /// <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is
        /// sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to
        /// an <code>INSUFFICIENT_DATA</code> state.</p>
        /// </li>
        /// </ul>
        /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this
        /// parameter.</p>
        pub fn notification_triggers(mut self, inp: impl Into<crate::model::AlarmState>) -> Self {
            self.inner = self.inner.notification_triggers(inp);
            self
        }
        pub fn set_notification_triggers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlarmState>>,
        ) -> Self {
            self.inner = self.inner.set_notification_triggers(input);
            self
        }
        /// <p>Indicates whether the alarm is enabled.</p>
        /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
        pub fn notification_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.notification_enabled(input);
            self
        }
        pub fn set_notification_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_notification_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutInstancePublicPorts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_instance_public_ports_input::Builder,
    }
    impl<C> PutInstancePublicPorts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutInstancePublicPortsOutput,
            smithy_http::result::SdkError<crate::error::PutInstancePublicPortsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of objects to describe the ports to open for the specified instance.</p>
        pub fn port_infos(mut self, inp: impl Into<crate::model::PortInfo>) -> Self {
            self.inner = self.inner.port_infos(inp);
            self
        }
        pub fn set_port_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortInfo>>,
        ) -> Self {
            self.inner = self.inner.set_port_infos(input);
            self
        }
        /// <p>The name of the instance for which to open ports.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_instance_input::Builder,
    }
    impl<C> RebootInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootInstanceOutput,
            smithy_http::result::SdkError<crate::error::RebootInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance to reboot.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_relational_database_input::Builder,
    }
    impl<C> RebootRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::RebootRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database to reboot.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterContainerImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_container_image_input::Builder,
    }
    impl<C> RegisterContainerImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterContainerImageOutput,
            smithy_http::result::SdkError<crate::error::RegisterContainerImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service for which to register a container image.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The label for the container image when it's registered to the container service.</p>
        /// <p>Use a descriptive label that you can use to track the different versions of your
        /// registered container images.</p>
        /// <p>Use the <code>GetContainerImages</code> action to return the container images registered
        /// to a Lightsail container service. The label is the <code><imagelabel></code> portion
        /// of the following image name example:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>:container-service-1.<imagelabel>.1</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If the name of your container service is <code>mycontainerservice</code>, and the label
        /// that you specify is <code>mystaticwebsite</code>, then the name of the registered container
        /// image will be <code>:mycontainerservice.mystaticwebsite.1</code>.</p>
        /// <p>The number at the end of these image name examples represents the version of the
        /// registered container image. If you push and register another container image to the same
        /// Lightsail container service, with the same label, then the version number for the new
        /// registered container image will be <code>2</code>. If you push and register another container
        /// image, the version number will be <code>3</code>, and so on.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.label(input);
            self
        }
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_label(input);
            self
        }
        /// <p>The digest of the container image to be registered.</p>
        pub fn digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.digest(input);
            self
        }
        pub fn set_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_digest(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReleaseStaticIp<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::release_static_ip_input::Builder,
    }
    impl<C> ReleaseStaticIp<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReleaseStaticIpOutput,
            smithy_http::result::SdkError<crate::error::ReleaseStaticIpError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the static IP to delete.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.static_ip_name(input);
            self
        }
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_static_ip_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetDistributionCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_distribution_cache_input::Builder,
    }
    impl<C> ResetDistributionCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetDistributionCacheOutput,
            smithy_http::result::SdkError<crate::error::ResetDistributionCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution for which to reset cache.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendContactMethodVerification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_contact_method_verification_input::Builder,
    }
    impl<C> SendContactMethodVerification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendContactMethodVerificationOutput,
            smithy_http::result::SdkError<crate::error::SendContactMethodVerificationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The protocol to verify, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        pub fn protocol(mut self, input: crate::model::ContactMethodVerificationProtocol) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ContactMethodVerificationProtocol>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIpAddressType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_ip_address_type_input::Builder,
    }
    impl<C> SetIpAddressType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIpAddressTypeOutput,
            smithy_http::result::SdkError<crate::error::SetIpAddressTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The resource type.</p>
        /// <p>The possible values are <code>Distribution</code>, <code>Instance</code>, and
        /// <code>LoadBalancer</code>.</p>
        /// <note>
        /// <p>Distribution-related APIs are available only in the N. Virginia (<code>us-east-1</code>)
        /// AWS Region. Set your AWS Region configuration to <code>us-east-1</code> to create, view,
        /// or edit distributions.</p>
        /// </note>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.inner = self.inner.resource_type(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(input);
            self
        }
        /// <p>The name of the resource for which to set the IP address type.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>The IP address type to set for the specified resource.</p>
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_instance_input::Builder,
    }
    impl<C> StartInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartInstanceOutput,
            smithy_http::result::SdkError<crate::error::StartInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance (a virtual private server) to start.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_relational_database_input::Builder,
    }
    impl<C> StartRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::StartRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database to start.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_instance_input::Builder,
    }
    impl<C> StopInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopInstanceOutput,
            smithy_http::result::SdkError<crate::error::StopInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the instance (a virtual private server) to stop.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>When set to <code>True</code>, forces a Lightsail instance that is stuck in a
        /// <code>stopping</code> state to stop.</p>
        /// <important>
        /// <p>Only use the <code>force</code> parameter if your instance is stuck in the
        /// <code>stopping</code> state. In any other state, your instance should stop normally
        /// without adding this parameter to your API request.</p>
        /// </important>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_relational_database_input::Builder,
    }
    impl<C> StopRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::StopRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database to stop.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The name of your new database snapshot to be created before stopping your database.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.relational_database_snapshot_name(input);
            self
        }
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_snapshot_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the resource to which you are adding tags.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add a tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tag key and optional value.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestAlarm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_alarm_input::Builder,
    }
    impl<C> TestAlarm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestAlarmOutput,
            smithy_http::result::SdkError<crate::error::TestAlarmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the alarm to test.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>The alarm state to test.</p>
        /// <p>An alarm has the following possible states that can be tested:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
        /// available, or not enough data is available for the metric to determine the alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK</code> - The metric is within the defined threshold.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: crate::model::AlarmState) -> Self {
            self.inner = self.inner.state(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::AlarmState>) -> Self {
            self.inner = self.inner.set_state(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UnpeerVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::unpeer_vpc_input::Builder,
    }
    impl<C> UnpeerVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UnpeerVpcOutput,
            smithy_http::result::SdkError<crate::error::UnpeerVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the resource from which you are removing a tag.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_name(input);
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove a tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tag keys to delete from the specified resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateContainerService<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_container_service_input::Builder,
    }
    impl<C> UpdateContainerService<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateContainerServiceOutput,
            smithy_http::result::SdkError<crate::error::UpdateContainerServiceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the container service to update.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The power for the container service.</p>
        /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
        /// container service. The <code>power</code> and <code>scale</code> of a container service makes
        /// up its configured capacity. To determine the monthly price of your container service, multiply
        /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
        /// the service.</p>
        /// <p>Use the <code>GetContainerServicePowers</code> action to view the specifications of each
        /// power option.</p>
        pub fn power(mut self, input: crate::model::ContainerServicePowerName) -> Self {
            self.inner = self.inner.power(input);
            self
        }
        pub fn set_power(
            mut self,
            input: std::option::Option<crate::model::ContainerServicePowerName>,
        ) -> Self {
            self.inner = self.inner.set_power(input);
            self
        }
        /// <p>The scale for the container service.</p>
        /// <p>The scale specifies the allocated compute nodes of the container service. The
        /// <code>power</code> and <code>scale</code> of a container service makes up its configured
        /// capacity. To determine the monthly price of your container service, multiply the base price of
        /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
        /// service.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.inner = self.inner.scale(input);
            self
        }
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_scale(input);
            self
        }
        /// <p>A Boolean value to indicate whether the container service is disabled.</p>
        pub fn is_disabled(mut self, input: bool) -> Self {
            self.inner = self.inner.is_disabled(input);
            self
        }
        pub fn set_is_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_is_disabled(input);
            self
        }
        /// <p>The public domain names to use with the container service, such as
        /// <code>example.com</code> and <code>www.example.com</code>.</p>
        /// <p>You can specify up to four public domain names for a container service. The domain names
        /// that you specify are used when you create a deployment with a container configured as the
        /// public endpoint of your container service.</p>
        /// <p>If you don't specify public domain names, then you can use the default domain of the
        /// container service.</p>
        /// <important>
        /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
        /// names with your container service. Use the <code>CreateCertificate</code> action to create a
        /// certificate for the public domain names you want to use with your container service.</p>
        /// </important>
        /// <p>You can specify public domain names using a string to array map as shown in the example
        /// later on this page.</p>
        pub fn public_domain_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.public_domain_names(k, v);
            self
        }
        pub fn set_public_domain_names(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.inner = self.inner.set_public_domain_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDistribution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_distribution_input::Builder,
    }
    impl<C> UpdateDistribution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDistributionOutput,
            smithy_http::result::SdkError<crate::error::UpdateDistributionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution to update.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
        /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
        /// instance or load balancer.</p>
        /// <p>The distribution pulls, caches, and serves content from the origin.</p>
        pub fn origin(mut self, input: crate::model::InputOrigin) -> Self {
            self.inner = self.inner.origin(input);
            self
        }
        pub fn set_origin(mut self, input: std::option::Option<crate::model::InputOrigin>) -> Self {
            self.inner = self.inner.set_origin(input);
            self
        }
        /// <p>An object that describes the default cache behavior for the distribution.</p>
        pub fn default_cache_behavior(mut self, input: crate::model::CacheBehavior) -> Self {
            self.inner = self.inner.default_cache_behavior(input);
            self
        }
        pub fn set_default_cache_behavior(
            mut self,
            input: std::option::Option<crate::model::CacheBehavior>,
        ) -> Self {
            self.inner = self.inner.set_default_cache_behavior(input);
            self
        }
        /// <p>An object that describes the cache behavior settings for the distribution.</p>
        /// <note>
        /// <p>The <code>cacheBehaviorSettings</code> specified in your
        /// <code>UpdateDistributionRequest</code> will replace your distribution's existing
        /// settings.</p>
        /// </note>
        pub fn cache_behavior_settings(mut self, input: crate::model::CacheSettings) -> Self {
            self.inner = self.inner.cache_behavior_settings(input);
            self
        }
        pub fn set_cache_behavior_settings(
            mut self,
            input: std::option::Option<crate::model::CacheSettings>,
        ) -> Self {
            self.inner = self.inner.set_cache_behavior_settings(input);
            self
        }
        /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
        pub fn cache_behaviors(
            mut self,
            inp: impl Into<crate::model::CacheBehaviorPerPath>,
        ) -> Self {
            self.inner = self.inner.cache_behaviors(inp);
            self
        }
        pub fn set_cache_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
        ) -> Self {
            self.inner = self.inner.set_cache_behaviors(input);
            self
        }
        /// <p>Indicates whether to enable the distribution.</p>
        pub fn is_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.is_enabled(input);
            self
        }
        pub fn set_is_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_is_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDistributionBundle<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_distribution_bundle_input::Builder,
    }
    impl<C> UpdateDistributionBundle<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDistributionBundleOutput,
            smithy_http::result::SdkError<crate::error::UpdateDistributionBundleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the distribution for which to update the bundle.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.distribution_name(input);
            self
        }
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_distribution_name(input);
            self
        }
        /// <p>The bundle ID of the new bundle to apply to your distribution.</p>
        /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
        /// IDs that you can specify.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bundle_id(input);
            self
        }
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bundle_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDomainEntry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_domain_entry_input::Builder,
    }
    impl<C> UpdateDomainEntry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDomainEntryOutput,
            smithy_http::result::SdkError<crate::error::UpdateDomainEntryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain recordset to update.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>An array of key-value pairs containing information about the domain entry.</p>
        pub fn domain_entry(mut self, input: crate::model::DomainEntry) -> Self {
            self.inner = self.inner.domain_entry(input);
            self
        }
        pub fn set_domain_entry(
            mut self,
            input: std::option::Option<crate::model::DomainEntry>,
        ) -> Self {
            self.inner = self.inner.set_domain_entry(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLoadBalancerAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_load_balancer_attribute_input::Builder,
    }
    impl<C> UpdateLoadBalancerAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLoadBalancerAttributeOutput,
            smithy_http::result::SdkError<crate::error::UpdateLoadBalancerAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer that you want to modify (e.g.,
        /// <code>my-load-balancer</code>.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(input);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The name of the attribute you want to update. Valid values are below.</p>
        pub fn attribute_name(mut self, input: crate::model::LoadBalancerAttributeName) -> Self {
            self.inner = self.inner.attribute_name(input);
            self
        }
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute_name(input);
            self
        }
        /// <p>The value that you want to specify for the attribute name.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute_value(input);
            self
        }
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attribute_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRelationalDatabase<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_relational_database_input::Builder,
    }
    impl<C> UpdateRelationalDatabase<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRelationalDatabaseOutput,
            smithy_http::result::SdkError<crate::error::UpdateRelationalDatabaseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your Lightsail database resource to update.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The password for the master user. The password can include any printable ASCII character
        /// except "/", """, or "@".</p>
        /// <p>My<b>SQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 41 characters.</p>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 128 characters.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.master_user_password(input);
            self
        }
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_master_user_password(input);
            self
        }
        /// <p>When <code>true</code>, the master user password is changed to a new strong password
        /// generated by Lightsail.</p>
        /// <p>Use the <code>get relational database master user password</code> operation to get the new
        /// password.</p>
        pub fn rotate_master_user_password(mut self, input: bool) -> Self {
            self.inner = self.inner.rotate_master_user_password(input);
            self
        }
        pub fn set_rotate_master_user_password(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_rotate_master_user_password(input);
            self
        }
        /// <p>The daily time range during which automated backups are created for your database if
        /// automated backups are enabled.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
        /// <p>Example: <code>16:00-16:30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Must not conflict with the preferred maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// </ul>
        pub fn preferred_backup_window(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.preferred_backup_window(input);
            self
        }
        pub fn set_preferred_backup_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_backup_window(input);
            self
        }
        /// <p>The weekly time range during which system maintenance can occur on your database.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region, occurring on a random day of the week.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
        /// </li>
        /// <li>
        /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.preferred_maintenance_window(input);
            self
        }
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_preferred_maintenance_window(input);
            self
        }
        /// <p>When <code>true</code>, enables automated backup retention for your database.</p>
        /// <p>Updates are applied during the next maintenance window because this can result in an
        /// outage.</p>
        pub fn enable_backup_retention(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_backup_retention(input);
            self
        }
        pub fn set_enable_backup_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enable_backup_retention(input);
            self
        }
        /// <p>When <code>true</code>, disables automated backup retention for your database.</p>
        /// <p>Disabling backup retention deletes all automated database backups. Before disabling this,
        /// you may want to create a snapshot of your database using the <code>create relational database
        /// snapshot</code> operation.</p>
        /// <p>Updates are applied during the next maintenance window because this can result in an
        /// outage.</p>
        pub fn disable_backup_retention(mut self, input: bool) -> Self {
            self.inner = self.inner.disable_backup_retention(input);
            self
        }
        pub fn set_disable_backup_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_disable_backup_retention(input);
            self
        }
        /// <p>Specifies the accessibility options for your database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.inner = self.inner.publicly_accessible(input);
            self
        }
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_publicly_accessible(input);
            self
        }
        /// <p>When <code>true</code>, applies changes immediately. When <code>false</code>, applies
        /// changes during the preferred maintenance window. Some changes may cause an outage.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn apply_immediately(mut self, input: bool) -> Self {
            self.inner = self.inner.apply_immediately(input);
            self
        }
        pub fn set_apply_immediately(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_apply_immediately(input);
            self
        }
        /// <p>Indicates the certificate that needs to be associated with the database.</p>
        pub fn ca_certificate_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ca_certificate_identifier(input);
            self
        }
        pub fn set_ca_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ca_certificate_identifier(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRelationalDatabaseParameters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_relational_database_parameters_input::Builder,
    }
    impl<C> UpdateRelationalDatabaseParameters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRelationalDatabaseParametersOutput,
            smithy_http::result::SdkError<crate::error::UpdateRelationalDatabaseParametersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of your database for which to update parameters.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.relational_database_name(input);
            self
        }
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_name(input);
            self
        }
        /// <p>The database parameters to update.</p>
        pub fn parameters(
            mut self,
            inp: impl Into<crate::model::RelationalDatabaseParameter>,
        ) -> Self {
            self.inner = self.inner.parameters(inp);
            self
        }
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelationalDatabaseParameter>>,
        ) -> Self {
            self.inner = self.inner.set_parameters(input);
            self
        }
    }
}
