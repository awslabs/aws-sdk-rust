// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Allocates a static IP address.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AllocateStaticIp {
    _private: (),
}
impl AllocateStaticIp {
    /// Creates a new builder-style object to manufacture [`AllocateStaticIpInput`](crate::input::AllocateStaticIpInput)
    pub fn builder() -> crate::input::allocate_static_ip_input::Builder {
        crate::input::allocate_static_ip_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AllocateStaticIp {
    type Output = std::result::Result<
        crate::output::AllocateStaticIpOutput,
        crate::error::AllocateStaticIpError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_allocate_static_ip_error(response)
        } else {
            crate::operation_deser::parse_allocate_static_ip_response(response)
        }
    }
}

/// <p>Attaches an SSL/TLS certificate to your Amazon Lightsail content delivery network (CDN)
/// distribution.</p>
/// <p>After the certificate is attached, your distribution accepts HTTPS traffic for all of the
/// domains that are associated with the certificate.</p>
/// <p>Use the <code>CreateCertificate</code> action to create a certificate that you can attach
/// to your distribution.</p>
/// <important>
/// <p>Only certificates created in the <code>us-east-1</code> AWS Region can be attached to
/// Lightsail distributions. Lightsail distributions are global resources that can reference
/// an origin in any AWS Region, and distribute its content globally. However, all
/// distributions are located in the <code>us-east-1</code> Region.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachCertificateToDistribution {
    _private: (),
}
impl AttachCertificateToDistribution {
    /// Creates a new builder-style object to manufacture [`AttachCertificateToDistributionInput`](crate::input::AttachCertificateToDistributionInput)
    pub fn builder() -> crate::input::attach_certificate_to_distribution_input::Builder {
        crate::input::attach_certificate_to_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachCertificateToDistribution {
    type Output = std::result::Result<
        crate::output::AttachCertificateToDistributionOutput,
        crate::error::AttachCertificateToDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_certificate_to_distribution_error(response)
        } else {
            crate::operation_deser::parse_attach_certificate_to_distribution_response(response)
        }
    }
}

/// <p>Attaches a block storage disk to a running or stopped Lightsail instance and exposes it
/// to the instance with the specified disk name.</p>
/// <p>The <code>attach disk</code> operation supports tag-based access control via resource tags
/// applied to the resource identified by <code>disk name</code>. For more information, see the
/// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachDisk {
    _private: (),
}
impl AttachDisk {
    /// Creates a new builder-style object to manufacture [`AttachDiskInput`](crate::input::AttachDiskInput)
    pub fn builder() -> crate::input::attach_disk_input::Builder {
        crate::input::attach_disk_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachDisk {
    type Output =
        std::result::Result<crate::output::AttachDiskOutput, crate::error::AttachDiskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_disk_error(response)
        } else {
            crate::operation_deser::parse_attach_disk_response(response)
        }
    }
}

/// <p>Attaches one or more Lightsail instances to a load balancer.</p>
/// <p>After some time, the instances are attached to the load balancer and the health check
/// status is available.</p>
/// <p>The <code>attach instances to load balancer</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by <code>load balancer
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachInstancesToLoadBalancer {
    _private: (),
}
impl AttachInstancesToLoadBalancer {
    /// Creates a new builder-style object to manufacture [`AttachInstancesToLoadBalancerInput`](crate::input::AttachInstancesToLoadBalancerInput)
    pub fn builder() -> crate::input::attach_instances_to_load_balancer_input::Builder {
        crate::input::attach_instances_to_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachInstancesToLoadBalancer {
    type Output = std::result::Result<
        crate::output::AttachInstancesToLoadBalancerOutput,
        crate::error::AttachInstancesToLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_instances_to_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_attach_instances_to_load_balancer_response(response)
        }
    }
}

/// <p>Attaches a Transport Layer Security (TLS) certificate to your load balancer. TLS is just
/// an updated, more secure version of Secure Socket Layer (SSL).</p>
/// <p>Once you create and validate your certificate, you can attach it to your load balancer.
/// You can also use this API to rotate the certificates on your account. Use the
/// <code>AttachLoadBalancerTlsCertificate</code> action with the non-attached certificate, and
/// it will replace the existing one and become the attached certificate.</p>
/// <p>The <code>AttachLoadBalancerTlsCertificate</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by <code>load balancer
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachLoadBalancerTlsCertificate {
    _private: (),
}
impl AttachLoadBalancerTlsCertificate {
    /// Creates a new builder-style object to manufacture [`AttachLoadBalancerTlsCertificateInput`](crate::input::AttachLoadBalancerTlsCertificateInput)
    pub fn builder() -> crate::input::attach_load_balancer_tls_certificate_input::Builder {
        crate::input::attach_load_balancer_tls_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachLoadBalancerTlsCertificate {
    type Output = std::result::Result<
        crate::output::AttachLoadBalancerTlsCertificateOutput,
        crate::error::AttachLoadBalancerTlsCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_load_balancer_tls_certificate_error(response)
        } else {
            crate::operation_deser::parse_attach_load_balancer_tls_certificate_response(response)
        }
    }
}

/// <p>Attaches a static IP address to a specific Amazon Lightsail instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachStaticIp {
    _private: (),
}
impl AttachStaticIp {
    /// Creates a new builder-style object to manufacture [`AttachStaticIpInput`](crate::input::AttachStaticIpInput)
    pub fn builder() -> crate::input::attach_static_ip_input::Builder {
        crate::input::attach_static_ip_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachStaticIp {
    type Output =
        std::result::Result<crate::output::AttachStaticIpOutput, crate::error::AttachStaticIpError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_static_ip_error(response)
        } else {
            crate::operation_deser::parse_attach_static_ip_response(response)
        }
    }
}

/// <p>Closes ports for a specific Amazon Lightsail instance.</p>
/// <p>The <code>CloseInstancePublicPorts</code> action supports tag-based access control via
/// resource tags applied to the resource identified by <code>instanceName</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CloseInstancePublicPorts {
    _private: (),
}
impl CloseInstancePublicPorts {
    /// Creates a new builder-style object to manufacture [`CloseInstancePublicPortsInput`](crate::input::CloseInstancePublicPortsInput)
    pub fn builder() -> crate::input::close_instance_public_ports_input::Builder {
        crate::input::close_instance_public_ports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CloseInstancePublicPorts {
    type Output = std::result::Result<
        crate::output::CloseInstancePublicPortsOutput,
        crate::error::CloseInstancePublicPortsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_close_instance_public_ports_error(response)
        } else {
            crate::operation_deser::parse_close_instance_public_ports_response(response)
        }
    }
}

/// <p>Copies a manual snapshot of an instance or disk as another manual snapshot, or copies an
/// automatic snapshot of an instance or disk as a manual snapshot. This operation can also be
/// used to copy a manual or automatic snapshot of an instance or a disk from one AWS Region to
/// another in Amazon Lightsail.</p>
/// <p>When copying a <i>manual snapshot</i>, be sure to define the <code>source
/// region</code>, <code>source snapshot name</code>, and <code>target snapshot name</code>
/// parameters.</p>
/// <p>When copying an <i>automatic snapshot</i>, be sure to define the
/// <code>source region</code>, <code>source resource name</code>, <code>target snapshot
/// name</code>, and either the <code>restore date</code> or the <code>use latest restorable
/// auto snapshot</code> parameters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CopySnapshot {
    _private: (),
}
impl CopySnapshot {
    /// Creates a new builder-style object to manufacture [`CopySnapshotInput`](crate::input::CopySnapshotInput)
    pub fn builder() -> crate::input::copy_snapshot_input::Builder {
        crate::input::copy_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CopySnapshot {
    type Output =
        std::result::Result<crate::output::CopySnapshotOutput, crate::error::CopySnapshotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_copy_snapshot_error(response)
        } else {
            crate::operation_deser::parse_copy_snapshot_response(response)
        }
    }
}

/// <p>Creates an Amazon Lightsail bucket.</p>
/// <p>A bucket is a cloud storage resource available in the Lightsail object storage service.
/// Use buckets to store objects such as data and its descriptive metadata. For more information
/// about buckets, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/buckets-in-amazon-lightsail">Buckets in Amazon Lightsail</a> in the <i>Amazon Lightsail Developer
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBucket {
    _private: (),
}
impl CreateBucket {
    /// Creates a new builder-style object to manufacture [`CreateBucketInput`](crate::input::CreateBucketInput)
    pub fn builder() -> crate::input::create_bucket_input::Builder {
        crate::input::create_bucket_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBucket {
    type Output =
        std::result::Result<crate::output::CreateBucketOutput, crate::error::CreateBucketError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_bucket_error(response)
        } else {
            crate::operation_deser::parse_create_bucket_response(response)
        }
    }
}

/// <p>Creates a new access key for the specified Amazon Lightsail bucket. Access keys consist of
/// an access key ID and corresponding secret access key.</p>
/// <p>Access keys grant full programmatic access to the specified bucket and its objects. You
/// can have a maximum of two access keys per bucket. Use the <a>GetBucketAccessKeys</a> action to get a list of current access keys for a specific bucket. For more information
/// about access keys, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-creating-bucket-access-keys">Creating access keys for a bucket in Amazon Lightsail</a> in the
/// <i>Amazon Lightsail Developer Guide</i>.</p>
/// <important>
/// <p>The <code>secretAccessKey</code> value is returned only in response to the
/// <code>CreateBucketAccessKey</code> action. You can get a secret access key only when you
/// first create an access key; you cannot get the secret access key later. If you lose the
/// secret access key, you must create a new access key.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBucketAccessKey {
    _private: (),
}
impl CreateBucketAccessKey {
    /// Creates a new builder-style object to manufacture [`CreateBucketAccessKeyInput`](crate::input::CreateBucketAccessKeyInput)
    pub fn builder() -> crate::input::create_bucket_access_key_input::Builder {
        crate::input::create_bucket_access_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBucketAccessKey {
    type Output = std::result::Result<
        crate::output::CreateBucketAccessKeyOutput,
        crate::error::CreateBucketAccessKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_bucket_access_key_error(response)
        } else {
            crate::operation_deser::parse_create_bucket_access_key_response(response)
        }
    }
}

/// <p>Creates an SSL/TLS certificate for an Amazon Lightsail content delivery network (CDN)
/// distribution and a container service.</p>
/// <p>After the certificate is valid, use the <code>AttachCertificateToDistribution</code>
/// action to use the certificate and its domains with your distribution. Or use the
/// <code>UpdateContainerService</code> action to use the certificate and its domains with your
/// container service.</p>
/// <important>
/// <p>Only certificates created in the <code>us-east-1</code> AWS Region can be attached to
/// Lightsail distributions. Lightsail distributions are global resources that can reference
/// an origin in any AWS Region, and distribute its content globally. However, all
/// distributions are located in the <code>us-east-1</code> Region.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCertificate {
    _private: (),
}
impl CreateCertificate {
    /// Creates a new builder-style object to manufacture [`CreateCertificateInput`](crate::input::CreateCertificateInput)
    pub fn builder() -> crate::input::create_certificate_input::Builder {
        crate::input::create_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCertificate {
    type Output = std::result::Result<
        crate::output::CreateCertificateOutput,
        crate::error::CreateCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_certificate_error(response)
        } else {
            crate::operation_deser::parse_create_certificate_response(response)
        }
    }
}

/// <p>Creates an AWS CloudFormation stack, which creates a new Amazon EC2 instance from an exported
/// Amazon Lightsail snapshot. This operation results in a CloudFormation stack record that can be
/// used to track the AWS CloudFormation stack created. Use the <code>get cloud formation stack
/// records</code> operation to get a list of the CloudFormation stacks created.</p>
/// <important>
/// <p>Wait until after your new Amazon EC2 instance is created before running the <code>create
/// cloud formation stack</code> operation again with the same export snapshot record.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCloudFormationStack {
    _private: (),
}
impl CreateCloudFormationStack {
    /// Creates a new builder-style object to manufacture [`CreateCloudFormationStackInput`](crate::input::CreateCloudFormationStackInput)
    pub fn builder() -> crate::input::create_cloud_formation_stack_input::Builder {
        crate::input::create_cloud_formation_stack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCloudFormationStack {
    type Output = std::result::Result<
        crate::output::CreateCloudFormationStackOutput,
        crate::error::CreateCloudFormationStackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_cloud_formation_stack_error(response)
        } else {
            crate::operation_deser::parse_create_cloud_formation_stack_response(response)
        }
    }
}

/// <p>Creates an email or SMS text message contact method.</p>
/// <p>A contact method is used to send you notifications about your Amazon Lightsail resources.
/// You can add one email address and one mobile phone number contact method in each AWS Region.
/// However, SMS text messaging is not supported in some AWS Regions, and SMS text messages
/// cannot be sent to some countries/regions. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContactMethod {
    _private: (),
}
impl CreateContactMethod {
    /// Creates a new builder-style object to manufacture [`CreateContactMethodInput`](crate::input::CreateContactMethodInput)
    pub fn builder() -> crate::input::create_contact_method_input::Builder {
        crate::input::create_contact_method_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContactMethod {
    type Output = std::result::Result<
        crate::output::CreateContactMethodOutput,
        crate::error::CreateContactMethodError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_contact_method_error(response)
        } else {
            crate::operation_deser::parse_create_contact_method_response(response)
        }
    }
}

/// <p>Creates an Amazon Lightsail container service.</p>
/// <p>A Lightsail container service is a compute resource to which you can deploy containers.
/// For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-container-services">Container services in Amazon Lightsail</a> in the <i>Lightsail Dev
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContainerService {
    _private: (),
}
impl CreateContainerService {
    /// Creates a new builder-style object to manufacture [`CreateContainerServiceInput`](crate::input::CreateContainerServiceInput)
    pub fn builder() -> crate::input::create_container_service_input::Builder {
        crate::input::create_container_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContainerService {
    type Output = std::result::Result<
        crate::output::CreateContainerServiceOutput,
        crate::error::CreateContainerServiceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_container_service_error(response)
        } else {
            crate::operation_deser::parse_create_container_service_response(response)
        }
    }
}

/// <p>Creates a deployment for your Amazon Lightsail container service.</p>
/// <p>A deployment specifies the containers that will be launched on the container service and
/// their settings, such as the ports to open, the environment variables to apply, and the launch
/// command to run. It also specifies the container that will serve as the public endpoint of the
/// deployment and its settings, such as the HTTP or HTTPS port to use, and the health check
/// configuration.</p>
/// <p>You can deploy containers to your container service using container images from a public
/// registry like Docker Hub, or from your local machine. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-creating-container-images">Creating container images for your Amazon Lightsail container services</a> in the
/// <i>Amazon Lightsail Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContainerServiceDeployment {
    _private: (),
}
impl CreateContainerServiceDeployment {
    /// Creates a new builder-style object to manufacture [`CreateContainerServiceDeploymentInput`](crate::input::CreateContainerServiceDeploymentInput)
    pub fn builder() -> crate::input::create_container_service_deployment_input::Builder {
        crate::input::create_container_service_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContainerServiceDeployment {
    type Output = std::result::Result<
        crate::output::CreateContainerServiceDeploymentOutput,
        crate::error::CreateContainerServiceDeploymentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_container_service_deployment_error(response)
        } else {
            crate::operation_deser::parse_create_container_service_deployment_response(response)
        }
    }
}

/// <p>Creates a temporary set of log in credentials that you can use to log in to the Docker
/// process on your local machine. After you're logged in, you can use the native Docker commands
/// to push your local container images to the container image registry of your Amazon Lightsail
/// account so that you can use them with your Lightsail container service. The log in
/// credentials expire 12 hours after they are created, at which point you will need to create a
/// new set of log in credentials.</p>
/// <note>
/// <p>You can only push container images to the container service registry of your Lightsail
/// account. You cannot pull container images or perform any other container image management
/// actions on the container service registry.</p>
/// </note>
/// <p>After you push your container images to the container image registry of your Lightsail
/// account, use the <code>RegisterContainerImage</code> action to register the pushed images to a
/// specific Lightsail container service.</p>
/// <note>
/// <p>This action is not required if you install and use the Lightsail Control
/// (lightsailctl) plugin to push container images to your Lightsail container service. For
/// more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-pushing-container-images">Pushing and managing container images on your Amazon Lightsail container services</a>
/// in the <i>Amazon Lightsail Developer Guide</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContainerServiceRegistryLogin {
    _private: (),
}
impl CreateContainerServiceRegistryLogin {
    /// Creates a new builder-style object to manufacture [`CreateContainerServiceRegistryLoginInput`](crate::input::CreateContainerServiceRegistryLoginInput)
    pub fn builder() -> crate::input::create_container_service_registry_login_input::Builder {
        crate::input::create_container_service_registry_login_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContainerServiceRegistryLogin {
    type Output = std::result::Result<
        crate::output::CreateContainerServiceRegistryLoginOutput,
        crate::error::CreateContainerServiceRegistryLoginError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_container_service_registry_login_error(response)
        } else {
            crate::operation_deser::parse_create_container_service_registry_login_response(response)
        }
    }
}

/// <p>Creates a block storage disk that can be attached to an Amazon Lightsail instance in the
/// same Availability Zone (e.g., <code>us-east-2a</code>).</p>
/// <p>The <code>create disk</code> operation supports tag-based access control via request tags.
/// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDisk {
    _private: (),
}
impl CreateDisk {
    /// Creates a new builder-style object to manufacture [`CreateDiskInput`](crate::input::CreateDiskInput)
    pub fn builder() -> crate::input::create_disk_input::Builder {
        crate::input::create_disk_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDisk {
    type Output =
        std::result::Result<crate::output::CreateDiskOutput, crate::error::CreateDiskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_disk_error(response)
        } else {
            crate::operation_deser::parse_create_disk_response(response)
        }
    }
}

/// <p>Creates a block storage disk from a manual or automatic snapshot of a disk. The resulting
/// disk can be attached to an Amazon Lightsail instance in the same Availability Zone (e.g.,
/// <code>us-east-2a</code>).</p>
/// <p>The <code>create disk from snapshot</code> operation supports tag-based access control via
/// request tags and resource tags applied to the resource identified by <code>disk snapshot
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDiskFromSnapshot {
    _private: (),
}
impl CreateDiskFromSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateDiskFromSnapshotInput`](crate::input::CreateDiskFromSnapshotInput)
    pub fn builder() -> crate::input::create_disk_from_snapshot_input::Builder {
        crate::input::create_disk_from_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDiskFromSnapshot {
    type Output = std::result::Result<
        crate::output::CreateDiskFromSnapshotOutput,
        crate::error::CreateDiskFromSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_disk_from_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_disk_from_snapshot_response(response)
        }
    }
}

/// <p>Creates a snapshot of a block storage disk. You can use snapshots for backups, to make
/// copies of disks, and to save data before shutting down a Lightsail instance.</p>
/// <p>You can take a snapshot of an attached disk that is in use; however, snapshots only
/// capture data that has been written to your disk at the time the snapshot command is issued.
/// This may exclude any data that has been cached by any applications or the operating system. If
/// you can pause any file systems on the disk long enough to take a snapshot, your snapshot
/// should be complete. Nevertheless, if you cannot pause all file writes to the disk, you should
/// unmount the disk from within the Lightsail instance, issue the create disk snapshot command,
/// and then remount the disk to ensure a consistent and complete snapshot. You may remount and
/// use your disk while the snapshot status is pending.</p>
/// <p>You can also use this operation to create a snapshot of an instance's system volume. You
/// might want to do this, for example, to recover data from the system volume of a botched
/// instance or to create a backup of the system volume like you would for a block storage disk.
/// To create a snapshot of a system volume, just define the <code>instance name</code> parameter
/// when issuing the snapshot command, and a snapshot of the defined instance's system volume will
/// be created. After the snapshot is available, you can create a block storage disk from the
/// snapshot and attach it to a running instance to access the data on the disk.</p>
/// <p>The <code>create disk snapshot</code> operation supports tag-based access control via
/// request tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDiskSnapshot {
    _private: (),
}
impl CreateDiskSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateDiskSnapshotInput`](crate::input::CreateDiskSnapshotInput)
    pub fn builder() -> crate::input::create_disk_snapshot_input::Builder {
        crate::input::create_disk_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDiskSnapshot {
    type Output = std::result::Result<
        crate::output::CreateDiskSnapshotOutput,
        crate::error::CreateDiskSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_disk_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_disk_snapshot_response(response)
        }
    }
}

/// <p>Creates an Amazon Lightsail content delivery network (CDN) distribution.</p>
/// <p>A distribution is a globally distributed network of caching servers that improve the
/// performance of your website or web application hosted on a Lightsail instance. For more
/// information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-content-delivery-network-distributions">Content delivery networks in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDistribution {
    _private: (),
}
impl CreateDistribution {
    /// Creates a new builder-style object to manufacture [`CreateDistributionInput`](crate::input::CreateDistributionInput)
    pub fn builder() -> crate::input::create_distribution_input::Builder {
        crate::input::create_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDistribution {
    type Output = std::result::Result<
        crate::output::CreateDistributionOutput,
        crate::error::CreateDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_distribution_error(response)
        } else {
            crate::operation_deser::parse_create_distribution_response(response)
        }
    }
}

/// <p>Creates a domain resource for the specified domain (e.g., example.com).</p>
/// <p>The <code>create domain</code> operation supports tag-based access control via request
/// tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDomain {
    _private: (),
}
impl CreateDomain {
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput)
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDomain {
    type Output =
        std::result::Result<crate::output::CreateDomainOutput, crate::error::CreateDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_domain_error(response)
        } else {
            crate::operation_deser::parse_create_domain_response(response)
        }
    }
}

/// <p>Creates one of the following domain name system (DNS) records in a domain DNS zone:
/// Address (A), canonical name (CNAME), mail exchanger (MX), name server (NS), start of authority
/// (SOA), service locator (SRV), or text (TXT).</p>
/// <p>The <code>create domain entry</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by <code>domain name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDomainEntry {
    _private: (),
}
impl CreateDomainEntry {
    /// Creates a new builder-style object to manufacture [`CreateDomainEntryInput`](crate::input::CreateDomainEntryInput)
    pub fn builder() -> crate::input::create_domain_entry_input::Builder {
        crate::input::create_domain_entry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDomainEntry {
    type Output = std::result::Result<
        crate::output::CreateDomainEntryOutput,
        crate::error::CreateDomainEntryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_domain_entry_error(response)
        } else {
            crate::operation_deser::parse_create_domain_entry_response(response)
        }
    }
}

/// <p>Creates one or more Amazon Lightsail instances.</p>
/// <p>The <code>create instances</code> operation supports tag-based access control via request
/// tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateInstances {
    _private: (),
}
impl CreateInstances {
    /// Creates a new builder-style object to manufacture [`CreateInstancesInput`](crate::input::CreateInstancesInput)
    pub fn builder() -> crate::input::create_instances_input::Builder {
        crate::input::create_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateInstances {
    type Output = std::result::Result<
        crate::output::CreateInstancesOutput,
        crate::error::CreateInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_instances_error(response)
        } else {
            crate::operation_deser::parse_create_instances_response(response)
        }
    }
}

/// <p>Creates one or more new instances from a manual or automatic snapshot of an
/// instance.</p>
/// <p>The <code>create instances from snapshot</code> operation supports tag-based access
/// control via request tags and resource tags applied to the resource identified by
/// <code>instance snapshot name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateInstancesFromSnapshot {
    _private: (),
}
impl CreateInstancesFromSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateInstancesFromSnapshotInput`](crate::input::CreateInstancesFromSnapshotInput)
    pub fn builder() -> crate::input::create_instances_from_snapshot_input::Builder {
        crate::input::create_instances_from_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateInstancesFromSnapshot {
    type Output = std::result::Result<
        crate::output::CreateInstancesFromSnapshotOutput,
        crate::error::CreateInstancesFromSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_instances_from_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_instances_from_snapshot_response(response)
        }
    }
}

/// <p>Creates a snapshot of a specific virtual private server, or <i>instance</i>.
/// You can use a snapshot to create a new instance that is based on that snapshot.</p>
/// <p>The <code>create instance snapshot</code> operation supports tag-based access control via
/// request tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateInstanceSnapshot {
    _private: (),
}
impl CreateInstanceSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateInstanceSnapshotInput`](crate::input::CreateInstanceSnapshotInput)
    pub fn builder() -> crate::input::create_instance_snapshot_input::Builder {
        crate::input::create_instance_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateInstanceSnapshot {
    type Output = std::result::Result<
        crate::output::CreateInstanceSnapshotOutput,
        crate::error::CreateInstanceSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_instance_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_instance_snapshot_response(response)
        }
    }
}

/// <p>Creates an SSH key pair.</p>
/// <p>The <code>create key pair</code> operation supports tag-based access control via request
/// tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateKeyPair {
    _private: (),
}
impl CreateKeyPair {
    /// Creates a new builder-style object to manufacture [`CreateKeyPairInput`](crate::input::CreateKeyPairInput)
    pub fn builder() -> crate::input::create_key_pair_input::Builder {
        crate::input::create_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateKeyPair {
    type Output =
        std::result::Result<crate::output::CreateKeyPairOutput, crate::error::CreateKeyPairError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_key_pair_error(response)
        } else {
            crate::operation_deser::parse_create_key_pair_response(response)
        }
    }
}

/// <p>Creates a Lightsail load balancer. To learn more about deciding whether to load balance
/// your application, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/configure-lightsail-instances-for-load-balancing">Configure your Lightsail instances for load balancing</a>. You can create up to 5
/// load balancers per AWS Region in your account.</p>
/// <p>When you create a load balancer, you can specify a unique name and port settings. To
/// change additional load balancer settings, use the <code>UpdateLoadBalancerAttribute</code>
/// operation.</p>
/// <p>The <code>create load balancer</code> operation supports tag-based access control via
/// request tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLoadBalancer {
    _private: (),
}
impl CreateLoadBalancer {
    /// Creates a new builder-style object to manufacture [`CreateLoadBalancerInput`](crate::input::CreateLoadBalancerInput)
    pub fn builder() -> crate::input::create_load_balancer_input::Builder {
        crate::input::create_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLoadBalancer {
    type Output = std::result::Result<
        crate::output::CreateLoadBalancerOutput,
        crate::error::CreateLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_create_load_balancer_response(response)
        }
    }
}

/// <p>Creates an SSL/TLS certificate for an Amazon Lightsail load balancer.</p>
/// <p>TLS is just an updated, more secure version of Secure Socket Layer (SSL).</p>
/// <p>The <code>CreateLoadBalancerTlsCertificate</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by <code>load balancer
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLoadBalancerTlsCertificate {
    _private: (),
}
impl CreateLoadBalancerTlsCertificate {
    /// Creates a new builder-style object to manufacture [`CreateLoadBalancerTlsCertificateInput`](crate::input::CreateLoadBalancerTlsCertificateInput)
    pub fn builder() -> crate::input::create_load_balancer_tls_certificate_input::Builder {
        crate::input::create_load_balancer_tls_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLoadBalancerTlsCertificate {
    type Output = std::result::Result<
        crate::output::CreateLoadBalancerTlsCertificateOutput,
        crate::error::CreateLoadBalancerTlsCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_load_balancer_tls_certificate_error(response)
        } else {
            crate::operation_deser::parse_create_load_balancer_tls_certificate_response(response)
        }
    }
}

/// <p>Creates a new database in Amazon Lightsail.</p>
/// <p>The <code>create relational database</code> operation supports tag-based access control
/// via request tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRelationalDatabase {
    _private: (),
}
impl CreateRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`CreateRelationalDatabaseInput`](crate::input::CreateRelationalDatabaseInput)
    pub fn builder() -> crate::input::create_relational_database_input::Builder {
        crate::input::create_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRelationalDatabase {
    type Output = std::result::Result<
        crate::output::CreateRelationalDatabaseOutput,
        crate::error::CreateRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_relational_database_error(response)
        } else {
            crate::operation_deser::parse_create_relational_database_response(response)
        }
    }
}

/// <p>Creates a new database from an existing database snapshot in Amazon Lightsail.</p>
/// <p>You can create a new database from a snapshot in if something goes wrong with your
/// original database, or to change it to a different plan, such as a high availability or
/// standard plan.</p>
/// <p>The <code>create relational database from snapshot</code> operation supports tag-based
/// access control via request tags and resource tags applied to the resource identified by
/// relationalDatabaseSnapshotName. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRelationalDatabaseFromSnapshot {
    _private: (),
}
impl CreateRelationalDatabaseFromSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateRelationalDatabaseFromSnapshotInput`](crate::input::CreateRelationalDatabaseFromSnapshotInput)
    pub fn builder() -> crate::input::create_relational_database_from_snapshot_input::Builder {
        crate::input::create_relational_database_from_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRelationalDatabaseFromSnapshot {
    type Output = std::result::Result<
        crate::output::CreateRelationalDatabaseFromSnapshotOutput,
        crate::error::CreateRelationalDatabaseFromSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_relational_database_from_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_relational_database_from_snapshot_response(
                response,
            )
        }
    }
}

/// <p>Creates a snapshot of your database in Amazon Lightsail. You can use snapshots for backups,
/// to make copies of a database, and to save data before deleting a database.</p>
/// <p>The <code>create relational database snapshot</code> operation supports tag-based access
/// control via request tags. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRelationalDatabaseSnapshot {
    _private: (),
}
impl CreateRelationalDatabaseSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateRelationalDatabaseSnapshotInput`](crate::input::CreateRelationalDatabaseSnapshotInput)
    pub fn builder() -> crate::input::create_relational_database_snapshot_input::Builder {
        crate::input::create_relational_database_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRelationalDatabaseSnapshot {
    type Output = std::result::Result<
        crate::output::CreateRelationalDatabaseSnapshotOutput,
        crate::error::CreateRelationalDatabaseSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_relational_database_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_relational_database_snapshot_response(response)
        }
    }
}

/// <p>Deletes an alarm.</p>
/// <p>An alarm is used to monitor a single metric for one of your resources. When a metric
/// condition is met, the alarm can notify you by email, SMS text message, and a banner displayed
/// on the Amazon Lightsail console. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-alarms">Alarms
/// in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAlarm {
    _private: (),
}
impl DeleteAlarm {
    /// Creates a new builder-style object to manufacture [`DeleteAlarmInput`](crate::input::DeleteAlarmInput)
    pub fn builder() -> crate::input::delete_alarm_input::Builder {
        crate::input::delete_alarm_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAlarm {
    type Output =
        std::result::Result<crate::output::DeleteAlarmOutput, crate::error::DeleteAlarmError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_alarm_error(response)
        } else {
            crate::operation_deser::parse_delete_alarm_response(response)
        }
    }
}

/// <p>Deletes an automatic snapshot of an instance or disk. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAutoSnapshot {
    _private: (),
}
impl DeleteAutoSnapshot {
    /// Creates a new builder-style object to manufacture [`DeleteAutoSnapshotInput`](crate::input::DeleteAutoSnapshotInput)
    pub fn builder() -> crate::input::delete_auto_snapshot_input::Builder {
        crate::input::delete_auto_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAutoSnapshot {
    type Output = std::result::Result<
        crate::output::DeleteAutoSnapshotOutput,
        crate::error::DeleteAutoSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_auto_snapshot_error(response)
        } else {
            crate::operation_deser::parse_delete_auto_snapshot_response(response)
        }
    }
}

/// <p>Deletes a Amazon Lightsail bucket.</p>
/// <note>
/// <p>When you delete your bucket, the bucket name is released and can be reused for a new
/// bucket in your account or another AWS account.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBucket {
    _private: (),
}
impl DeleteBucket {
    /// Creates a new builder-style object to manufacture [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    pub fn builder() -> crate::input::delete_bucket_input::Builder {
        crate::input::delete_bucket_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBucket {
    type Output =
        std::result::Result<crate::output::DeleteBucketOutput, crate::error::DeleteBucketError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_bucket_error(response)
        } else {
            crate::operation_deser::parse_delete_bucket_response(response)
        }
    }
}

/// <p>Deletes an access key for the specified Amazon Lightsail bucket.</p>
/// <p>We recommend that you delete an access key if the secret access key is compromised.</p>
/// <p>For more information about access keys, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-creating-bucket-access-keys">Creating access keys for a bucket in Amazon Lightsail</a> in the
/// <i>Amazon Lightsail Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBucketAccessKey {
    _private: (),
}
impl DeleteBucketAccessKey {
    /// Creates a new builder-style object to manufacture [`DeleteBucketAccessKeyInput`](crate::input::DeleteBucketAccessKeyInput)
    pub fn builder() -> crate::input::delete_bucket_access_key_input::Builder {
        crate::input::delete_bucket_access_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBucketAccessKey {
    type Output = std::result::Result<
        crate::output::DeleteBucketAccessKeyOutput,
        crate::error::DeleteBucketAccessKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_bucket_access_key_error(response)
        } else {
            crate::operation_deser::parse_delete_bucket_access_key_response(response)
        }
    }
}

/// <p>Deletes an SSL/TLS certificate for your Amazon Lightsail content delivery network (CDN)
/// distribution.</p>
/// <p>Certificates that are currently attached to a distribution cannot be deleted. Use the
/// <code>DetachCertificateFromDistribution</code> action to detach a certificate from a
/// distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCertificate {
    _private: (),
}
impl DeleteCertificate {
    /// Creates a new builder-style object to manufacture [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
    pub fn builder() -> crate::input::delete_certificate_input::Builder {
        crate::input::delete_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCertificate {
    type Output = std::result::Result<
        crate::output::DeleteCertificateOutput,
        crate::error::DeleteCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_certificate_error(response)
        } else {
            crate::operation_deser::parse_delete_certificate_response(response)
        }
    }
}

/// <p>Deletes a contact method.</p>
/// <p>A contact method is used to send you notifications about your Amazon Lightsail resources.
/// You can add one email address and one mobile phone number contact method in each AWS Region.
/// However, SMS text messaging is not supported in some AWS Regions, and SMS text messages
/// cannot be sent to some countries/regions. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContactMethod {
    _private: (),
}
impl DeleteContactMethod {
    /// Creates a new builder-style object to manufacture [`DeleteContactMethodInput`](crate::input::DeleteContactMethodInput)
    pub fn builder() -> crate::input::delete_contact_method_input::Builder {
        crate::input::delete_contact_method_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContactMethod {
    type Output = std::result::Result<
        crate::output::DeleteContactMethodOutput,
        crate::error::DeleteContactMethodError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_contact_method_error(response)
        } else {
            crate::operation_deser::parse_delete_contact_method_response(response)
        }
    }
}

/// <p>Deletes a container image that is registered to your Amazon Lightsail container
/// service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContainerImage {
    _private: (),
}
impl DeleteContainerImage {
    /// Creates a new builder-style object to manufacture [`DeleteContainerImageInput`](crate::input::DeleteContainerImageInput)
    pub fn builder() -> crate::input::delete_container_image_input::Builder {
        crate::input::delete_container_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContainerImage {
    type Output = std::result::Result<
        crate::output::DeleteContainerImageOutput,
        crate::error::DeleteContainerImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_container_image_error(response)
        } else {
            crate::operation_deser::parse_delete_container_image_response(response)
        }
    }
}

/// <p>Deletes your Amazon Lightsail container service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContainerService {
    _private: (),
}
impl DeleteContainerService {
    /// Creates a new builder-style object to manufacture [`DeleteContainerServiceInput`](crate::input::DeleteContainerServiceInput)
    pub fn builder() -> crate::input::delete_container_service_input::Builder {
        crate::input::delete_container_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContainerService {
    type Output = std::result::Result<
        crate::output::DeleteContainerServiceOutput,
        crate::error::DeleteContainerServiceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_container_service_error(response)
        } else {
            crate::operation_deser::parse_delete_container_service_response(response)
        }
    }
}

/// <p>Deletes the specified block storage disk. The disk must be in the <code>available</code>
/// state (not attached to a Lightsail instance).</p>
/// <note>
/// <p>The disk may remain in the <code>deleting</code> state for several minutes.</p>
/// </note>
/// <p>The <code>delete disk</code> operation supports tag-based access control via resource tags
/// applied to the resource identified by <code>disk name</code>. For more information, see the
/// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDisk {
    _private: (),
}
impl DeleteDisk {
    /// Creates a new builder-style object to manufacture [`DeleteDiskInput`](crate::input::DeleteDiskInput)
    pub fn builder() -> crate::input::delete_disk_input::Builder {
        crate::input::delete_disk_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDisk {
    type Output =
        std::result::Result<crate::output::DeleteDiskOutput, crate::error::DeleteDiskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_disk_error(response)
        } else {
            crate::operation_deser::parse_delete_disk_response(response)
        }
    }
}

/// <p>Deletes the specified disk snapshot.</p>
/// <p>When you make periodic snapshots of a disk, the snapshots are incremental, and only the
/// blocks on the device that have changed since your last snapshot are saved in the new snapshot.
/// When you delete a snapshot, only the data not needed for any other snapshot is removed. So
/// regardless of which prior snapshots have been deleted, all active snapshots will have access
/// to all the information needed to restore the disk.</p>
/// <p>The <code>delete disk snapshot</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by <code>disk snapshot name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDiskSnapshot {
    _private: (),
}
impl DeleteDiskSnapshot {
    /// Creates a new builder-style object to manufacture [`DeleteDiskSnapshotInput`](crate::input::DeleteDiskSnapshotInput)
    pub fn builder() -> crate::input::delete_disk_snapshot_input::Builder {
        crate::input::delete_disk_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDiskSnapshot {
    type Output = std::result::Result<
        crate::output::DeleteDiskSnapshotOutput,
        crate::error::DeleteDiskSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_disk_snapshot_error(response)
        } else {
            crate::operation_deser::parse_delete_disk_snapshot_response(response)
        }
    }
}

/// <p>Deletes your Amazon Lightsail content delivery network (CDN) distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDistribution {
    _private: (),
}
impl DeleteDistribution {
    /// Creates a new builder-style object to manufacture [`DeleteDistributionInput`](crate::input::DeleteDistributionInput)
    pub fn builder() -> crate::input::delete_distribution_input::Builder {
        crate::input::delete_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDistribution {
    type Output = std::result::Result<
        crate::output::DeleteDistributionOutput,
        crate::error::DeleteDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_distribution_error(response)
        } else {
            crate::operation_deser::parse_delete_distribution_response(response)
        }
    }
}

/// <p>Deletes the specified domain recordset and all of its domain records.</p>
/// <p>The <code>delete domain</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>domain name</code>. For more information, see
/// the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDomain {
    _private: (),
}
impl DeleteDomain {
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDomain {
    type Output =
        std::result::Result<crate::output::DeleteDomainOutput, crate::error::DeleteDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_domain_error(response)
        } else {
            crate::operation_deser::parse_delete_domain_response(response)
        }
    }
}

/// <p>Deletes a specific domain entry.</p>
/// <p>The <code>delete domain entry</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by <code>domain name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDomainEntry {
    _private: (),
}
impl DeleteDomainEntry {
    /// Creates a new builder-style object to manufacture [`DeleteDomainEntryInput`](crate::input::DeleteDomainEntryInput)
    pub fn builder() -> crate::input::delete_domain_entry_input::Builder {
        crate::input::delete_domain_entry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDomainEntry {
    type Output = std::result::Result<
        crate::output::DeleteDomainEntryOutput,
        crate::error::DeleteDomainEntryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_domain_entry_error(response)
        } else {
            crate::operation_deser::parse_delete_domain_entry_response(response)
        }
    }
}

/// <p>Deletes an Amazon Lightsail instance.</p>
/// <p>The <code>delete instance</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>instance name</code>. For more information,
/// see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteInstance {
    _private: (),
}
impl DeleteInstance {
    /// Creates a new builder-style object to manufacture [`DeleteInstanceInput`](crate::input::DeleteInstanceInput)
    pub fn builder() -> crate::input::delete_instance_input::Builder {
        crate::input::delete_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteInstance {
    type Output =
        std::result::Result<crate::output::DeleteInstanceOutput, crate::error::DeleteInstanceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_instance_error(response)
        } else {
            crate::operation_deser::parse_delete_instance_response(response)
        }
    }
}

/// <p>Deletes a specific snapshot of a virtual private server (or
/// <i>instance</i>).</p>
/// <p>The <code>delete instance snapshot</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by <code>instance snapshot name</code>. For
/// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteInstanceSnapshot {
    _private: (),
}
impl DeleteInstanceSnapshot {
    /// Creates a new builder-style object to manufacture [`DeleteInstanceSnapshotInput`](crate::input::DeleteInstanceSnapshotInput)
    pub fn builder() -> crate::input::delete_instance_snapshot_input::Builder {
        crate::input::delete_instance_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteInstanceSnapshot {
    type Output = std::result::Result<
        crate::output::DeleteInstanceSnapshotOutput,
        crate::error::DeleteInstanceSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_instance_snapshot_error(response)
        } else {
            crate::operation_deser::parse_delete_instance_snapshot_response(response)
        }
    }
}

/// <p>Deletes a specific SSH key pair.</p>
/// <p>The <code>delete key pair</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>key pair name</code>. For more information,
/// see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteKeyPair {
    _private: (),
}
impl DeleteKeyPair {
    /// Creates a new builder-style object to manufacture [`DeleteKeyPairInput`](crate::input::DeleteKeyPairInput)
    pub fn builder() -> crate::input::delete_key_pair_input::Builder {
        crate::input::delete_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteKeyPair {
    type Output =
        std::result::Result<crate::output::DeleteKeyPairOutput, crate::error::DeleteKeyPairError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_key_pair_error(response)
        } else {
            crate::operation_deser::parse_delete_key_pair_response(response)
        }
    }
}

/// <p>Deletes the known host key or certificate used by the Amazon Lightsail browser-based SSH or
/// RDP clients to authenticate an instance. This operation enables the Lightsail browser-based
/// SSH or RDP clients to connect to the instance after a host key mismatch.</p>
/// <important>
/// <p>Perform this operation only if you were expecting the host key or certificate mismatch
/// or if you are familiar with the new host key or certificate on the instance. For more
/// information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-troubleshooting-browser-based-ssh-rdp-client-connection">Troubleshooting connection issues when using the Amazon Lightsail browser-based SSH or RDP
/// client</a>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteKnownHostKeys {
    _private: (),
}
impl DeleteKnownHostKeys {
    /// Creates a new builder-style object to manufacture [`DeleteKnownHostKeysInput`](crate::input::DeleteKnownHostKeysInput)
    pub fn builder() -> crate::input::delete_known_host_keys_input::Builder {
        crate::input::delete_known_host_keys_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteKnownHostKeys {
    type Output = std::result::Result<
        crate::output::DeleteKnownHostKeysOutput,
        crate::error::DeleteKnownHostKeysError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_known_host_keys_error(response)
        } else {
            crate::operation_deser::parse_delete_known_host_keys_response(response)
        }
    }
}

/// <p>Deletes a Lightsail load balancer and all its associated SSL/TLS certificates. Once the
/// load balancer is deleted, you will need to create a new load balancer, create a new
/// certificate, and verify domain ownership again.</p>
/// <p>The <code>delete load balancer</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by <code>load balancer name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLoadBalancer {
    _private: (),
}
impl DeleteLoadBalancer {
    /// Creates a new builder-style object to manufacture [`DeleteLoadBalancerInput`](crate::input::DeleteLoadBalancerInput)
    pub fn builder() -> crate::input::delete_load_balancer_input::Builder {
        crate::input::delete_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLoadBalancer {
    type Output = std::result::Result<
        crate::output::DeleteLoadBalancerOutput,
        crate::error::DeleteLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_delete_load_balancer_response(response)
        }
    }
}

/// <p>Deletes an SSL/TLS certificate associated with a Lightsail load balancer.</p>
/// <p>The <code>DeleteLoadBalancerTlsCertificate</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by <code>load balancer
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLoadBalancerTlsCertificate {
    _private: (),
}
impl DeleteLoadBalancerTlsCertificate {
    /// Creates a new builder-style object to manufacture [`DeleteLoadBalancerTlsCertificateInput`](crate::input::DeleteLoadBalancerTlsCertificateInput)
    pub fn builder() -> crate::input::delete_load_balancer_tls_certificate_input::Builder {
        crate::input::delete_load_balancer_tls_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLoadBalancerTlsCertificate {
    type Output = std::result::Result<
        crate::output::DeleteLoadBalancerTlsCertificateOutput,
        crate::error::DeleteLoadBalancerTlsCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_load_balancer_tls_certificate_error(response)
        } else {
            crate::operation_deser::parse_delete_load_balancer_tls_certificate_response(response)
        }
    }
}

/// <p>Deletes a database in Amazon Lightsail.</p>
/// <p>The <code>delete relational database</code> operation supports tag-based access control
/// via resource tags applied to the resource identified by relationalDatabaseName. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRelationalDatabase {
    _private: (),
}
impl DeleteRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`DeleteRelationalDatabaseInput`](crate::input::DeleteRelationalDatabaseInput)
    pub fn builder() -> crate::input::delete_relational_database_input::Builder {
        crate::input::delete_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRelationalDatabase {
    type Output = std::result::Result<
        crate::output::DeleteRelationalDatabaseOutput,
        crate::error::DeleteRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_relational_database_error(response)
        } else {
            crate::operation_deser::parse_delete_relational_database_response(response)
        }
    }
}

/// <p>Deletes a database snapshot in Amazon Lightsail.</p>
/// <p>The <code>delete relational database snapshot</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by relationalDatabaseName. For
/// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRelationalDatabaseSnapshot {
    _private: (),
}
impl DeleteRelationalDatabaseSnapshot {
    /// Creates a new builder-style object to manufacture [`DeleteRelationalDatabaseSnapshotInput`](crate::input::DeleteRelationalDatabaseSnapshotInput)
    pub fn builder() -> crate::input::delete_relational_database_snapshot_input::Builder {
        crate::input::delete_relational_database_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRelationalDatabaseSnapshot {
    type Output = std::result::Result<
        crate::output::DeleteRelationalDatabaseSnapshotOutput,
        crate::error::DeleteRelationalDatabaseSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_relational_database_snapshot_error(response)
        } else {
            crate::operation_deser::parse_delete_relational_database_snapshot_response(response)
        }
    }
}

/// <p>Detaches an SSL/TLS certificate from your Amazon Lightsail content delivery network (CDN)
/// distribution.</p>
/// <p>After the certificate is detached, your distribution stops accepting traffic for all of
/// the domains that are associated with the certificate.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachCertificateFromDistribution {
    _private: (),
}
impl DetachCertificateFromDistribution {
    /// Creates a new builder-style object to manufacture [`DetachCertificateFromDistributionInput`](crate::input::DetachCertificateFromDistributionInput)
    pub fn builder() -> crate::input::detach_certificate_from_distribution_input::Builder {
        crate::input::detach_certificate_from_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachCertificateFromDistribution {
    type Output = std::result::Result<
        crate::output::DetachCertificateFromDistributionOutput,
        crate::error::DetachCertificateFromDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_certificate_from_distribution_error(response)
        } else {
            crate::operation_deser::parse_detach_certificate_from_distribution_response(response)
        }
    }
}

/// <p>Detaches a stopped block storage disk from a Lightsail instance. Make sure to unmount
/// any file systems on the device within your operating system before stopping the instance and
/// detaching the disk.</p>
/// <p>The <code>detach disk</code> operation supports tag-based access control via resource tags
/// applied to the resource identified by <code>disk name</code>. For more information, see the
/// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachDisk {
    _private: (),
}
impl DetachDisk {
    /// Creates a new builder-style object to manufacture [`DetachDiskInput`](crate::input::DetachDiskInput)
    pub fn builder() -> crate::input::detach_disk_input::Builder {
        crate::input::detach_disk_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachDisk {
    type Output =
        std::result::Result<crate::output::DetachDiskOutput, crate::error::DetachDiskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_disk_error(response)
        } else {
            crate::operation_deser::parse_detach_disk_response(response)
        }
    }
}

/// <p>Detaches the specified instances from a Lightsail load balancer.</p>
/// <p>This operation waits until the instances are no longer needed before they are detached
/// from the load balancer.</p>
/// <p>The <code>detach instances from load balancer</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by <code>load balancer
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachInstancesFromLoadBalancer {
    _private: (),
}
impl DetachInstancesFromLoadBalancer {
    /// Creates a new builder-style object to manufacture [`DetachInstancesFromLoadBalancerInput`](crate::input::DetachInstancesFromLoadBalancerInput)
    pub fn builder() -> crate::input::detach_instances_from_load_balancer_input::Builder {
        crate::input::detach_instances_from_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachInstancesFromLoadBalancer {
    type Output = std::result::Result<
        crate::output::DetachInstancesFromLoadBalancerOutput,
        crate::error::DetachInstancesFromLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_instances_from_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_detach_instances_from_load_balancer_response(response)
        }
    }
}

/// <p>Detaches a static IP from the Amazon Lightsail instance to which it is attached.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachStaticIp {
    _private: (),
}
impl DetachStaticIp {
    /// Creates a new builder-style object to manufacture [`DetachStaticIpInput`](crate::input::DetachStaticIpInput)
    pub fn builder() -> crate::input::detach_static_ip_input::Builder {
        crate::input::detach_static_ip_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachStaticIp {
    type Output =
        std::result::Result<crate::output::DetachStaticIpOutput, crate::error::DetachStaticIpError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_static_ip_error(response)
        } else {
            crate::operation_deser::parse_detach_static_ip_response(response)
        }
    }
}

/// <p>Disables an add-on for an Amazon Lightsail resource. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableAddOn {
    _private: (),
}
impl DisableAddOn {
    /// Creates a new builder-style object to manufacture [`DisableAddOnInput`](crate::input::DisableAddOnInput)
    pub fn builder() -> crate::input::disable_add_on_input::Builder {
        crate::input::disable_add_on_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableAddOn {
    type Output =
        std::result::Result<crate::output::DisableAddOnOutput, crate::error::DisableAddOnError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_add_on_error(response)
        } else {
            crate::operation_deser::parse_disable_add_on_response(response)
        }
    }
}

/// <p>Downloads the default SSH key pair from the user's account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DownloadDefaultKeyPair {
    _private: (),
}
impl DownloadDefaultKeyPair {
    /// Creates a new builder-style object to manufacture [`DownloadDefaultKeyPairInput`](crate::input::DownloadDefaultKeyPairInput)
    pub fn builder() -> crate::input::download_default_key_pair_input::Builder {
        crate::input::download_default_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DownloadDefaultKeyPair {
    type Output = std::result::Result<
        crate::output::DownloadDefaultKeyPairOutput,
        crate::error::DownloadDefaultKeyPairError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_download_default_key_pair_error(response)
        } else {
            crate::operation_deser::parse_download_default_key_pair_response(response)
        }
    }
}

/// <p>Enables or modifies an add-on for an Amazon Lightsail resource. For more information, see
/// the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableAddOn {
    _private: (),
}
impl EnableAddOn {
    /// Creates a new builder-style object to manufacture [`EnableAddOnInput`](crate::input::EnableAddOnInput)
    pub fn builder() -> crate::input::enable_add_on_input::Builder {
        crate::input::enable_add_on_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableAddOn {
    type Output =
        std::result::Result<crate::output::EnableAddOnOutput, crate::error::EnableAddOnError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_add_on_error(response)
        } else {
            crate::operation_deser::parse_enable_add_on_response(response)
        }
    }
}

/// <p>Exports an Amazon Lightsail instance or block storage disk snapshot to Amazon Elastic Compute Cloud (Amazon EC2).
/// This operation results in an export snapshot record that can be used with the <code>create
/// cloud formation stack</code> operation to create new Amazon EC2 instances.</p>
/// <p>Exported instance snapshots appear in Amazon EC2 as Amazon Machine Images (AMIs), and the
/// instance system disk appears as an Amazon Elastic Block Store (Amazon EBS) volume. Exported disk snapshots appear in
/// Amazon EC2 as Amazon EBS volumes. Snapshots are exported to the same Amazon Web Services Region in Amazon EC2 as the
/// source Lightsail snapshot.</p>
/// <p></p>
/// <p>The <code>export snapshot</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>source snapshot name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
/// <note>
/// <p>Use the <code>get instance snapshots</code> or <code>get disk snapshots</code>
/// operations to get a list of snapshots that you can export to Amazon EC2.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ExportSnapshot {
    _private: (),
}
impl ExportSnapshot {
    /// Creates a new builder-style object to manufacture [`ExportSnapshotInput`](crate::input::ExportSnapshotInput)
    pub fn builder() -> crate::input::export_snapshot_input::Builder {
        crate::input::export_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ExportSnapshot {
    type Output =
        std::result::Result<crate::output::ExportSnapshotOutput, crate::error::ExportSnapshotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_export_snapshot_error(response)
        } else {
            crate::operation_deser::parse_export_snapshot_response(response)
        }
    }
}

/// <p>Returns the names of all active (not deleted) resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetActiveNames {
    _private: (),
}
impl GetActiveNames {
    /// Creates a new builder-style object to manufacture [`GetActiveNamesInput`](crate::input::GetActiveNamesInput)
    pub fn builder() -> crate::input::get_active_names_input::Builder {
        crate::input::get_active_names_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetActiveNames {
    type Output =
        std::result::Result<crate::output::GetActiveNamesOutput, crate::error::GetActiveNamesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_active_names_error(response)
        } else {
            crate::operation_deser::parse_get_active_names_response(response)
        }
    }
}

/// <p>Returns information about the configured alarms. Specify an alarm name in your request to
/// return information about a specific alarm, or specify a monitored resource name to return
/// information about all alarms for a specific resource.</p>
/// <p>An alarm is used to monitor a single metric for one of your resources. When a metric
/// condition is met, the alarm can notify you by email, SMS text message, and a banner displayed
/// on the Amazon Lightsail console. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-alarms">Alarms
/// in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAlarms {
    _private: (),
}
impl GetAlarms {
    /// Creates a new builder-style object to manufacture [`GetAlarmsInput`](crate::input::GetAlarmsInput)
    pub fn builder() -> crate::input::get_alarms_input::Builder {
        crate::input::get_alarms_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAlarms {
    type Output = std::result::Result<crate::output::GetAlarmsOutput, crate::error::GetAlarmsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_alarms_error(response)
        } else {
            crate::operation_deser::parse_get_alarms_response(response)
        }
    }
}

/// <p>Returns the available automatic snapshots for an instance or disk. For more information,
/// see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAutoSnapshots {
    _private: (),
}
impl GetAutoSnapshots {
    /// Creates a new builder-style object to manufacture [`GetAutoSnapshotsInput`](crate::input::GetAutoSnapshotsInput)
    pub fn builder() -> crate::input::get_auto_snapshots_input::Builder {
        crate::input::get_auto_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAutoSnapshots {
    type Output = std::result::Result<
        crate::output::GetAutoSnapshotsOutput,
        crate::error::GetAutoSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_auto_snapshots_error(response)
        } else {
            crate::operation_deser::parse_get_auto_snapshots_response(response)
        }
    }
}

/// <p>Returns the list of available instance images, or <i>blueprints</i>. You can
/// use a blueprint to create a new instance already running a specific operating system, as well
/// as a preinstalled app or development stack. The software each instance is running depends on
/// the blueprint image you choose.</p>
/// <note>
/// <p>Use active blueprints when creating new instances. Inactive blueprints are listed to
/// support customers with existing instances and are not necessarily available to create new
/// instances. Blueprints are marked inactive when they become outdated due to operating system
/// updates or new application releases.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBlueprints {
    _private: (),
}
impl GetBlueprints {
    /// Creates a new builder-style object to manufacture [`GetBlueprintsInput`](crate::input::GetBlueprintsInput)
    pub fn builder() -> crate::input::get_blueprints_input::Builder {
        crate::input::get_blueprints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBlueprints {
    type Output =
        std::result::Result<crate::output::GetBlueprintsOutput, crate::error::GetBlueprintsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_blueprints_error(response)
        } else {
            crate::operation_deser::parse_get_blueprints_response(response)
        }
    }
}

/// <p>Returns the existing access key IDs for the specified Amazon Lightsail bucket.</p>
/// <important>
/// <p>This action does not return the secret access key value of an access key. You can get a
/// secret access key only when you create it from the response of the <a>CreateBucketAccessKey</a> action. If you lose the secret access key, you must
/// create a new access key.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBucketAccessKeys {
    _private: (),
}
impl GetBucketAccessKeys {
    /// Creates a new builder-style object to manufacture [`GetBucketAccessKeysInput`](crate::input::GetBucketAccessKeysInput)
    pub fn builder() -> crate::input::get_bucket_access_keys_input::Builder {
        crate::input::get_bucket_access_keys_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBucketAccessKeys {
    type Output = std::result::Result<
        crate::output::GetBucketAccessKeysOutput,
        crate::error::GetBucketAccessKeysError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bucket_access_keys_error(response)
        } else {
            crate::operation_deser::parse_get_bucket_access_keys_response(response)
        }
    }
}

/// <p>Returns the bundles that you can apply to a Amazon Lightsail bucket.</p>
/// <p>The bucket bundle specifies the monthly cost, storage quota, and data transfer quota for a
/// bucket.</p>
/// <p>Use the <a>UpdateBucketBundle</a> action to update the bundle for a
/// bucket.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBucketBundles {
    _private: (),
}
impl GetBucketBundles {
    /// Creates a new builder-style object to manufacture [`GetBucketBundlesInput`](crate::input::GetBucketBundlesInput)
    pub fn builder() -> crate::input::get_bucket_bundles_input::Builder {
        crate::input::get_bucket_bundles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBucketBundles {
    type Output = std::result::Result<
        crate::output::GetBucketBundlesOutput,
        crate::error::GetBucketBundlesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bucket_bundles_error(response)
        } else {
            crate::operation_deser::parse_get_bucket_bundles_response(response)
        }
    }
}

/// <p>Returns the data points of a specific metric for an Amazon Lightsail bucket.</p>
/// <p>Metrics report the utilization of a bucket. View and collect metric data regularly to
/// monitor the number of objects stored in a bucket (including object versions) and the storage
/// space used by those objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBucketMetricData {
    _private: (),
}
impl GetBucketMetricData {
    /// Creates a new builder-style object to manufacture [`GetBucketMetricDataInput`](crate::input::GetBucketMetricDataInput)
    pub fn builder() -> crate::input::get_bucket_metric_data_input::Builder {
        crate::input::get_bucket_metric_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBucketMetricData {
    type Output = std::result::Result<
        crate::output::GetBucketMetricDataOutput,
        crate::error::GetBucketMetricDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bucket_metric_data_error(response)
        } else {
            crate::operation_deser::parse_get_bucket_metric_data_response(response)
        }
    }
}

/// <p>Returns information about one or more Amazon Lightsail buckets.</p>
/// <p>For more information about buckets, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/buckets-in-amazon-lightsail">Buckets in Amazon Lightsail</a> in the <i>Amazon Lightsail Developer
/// Guide</i>..</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBuckets {
    _private: (),
}
impl GetBuckets {
    /// Creates a new builder-style object to manufacture [`GetBucketsInput`](crate::input::GetBucketsInput)
    pub fn builder() -> crate::input::get_buckets_input::Builder {
        crate::input::get_buckets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBuckets {
    type Output =
        std::result::Result<crate::output::GetBucketsOutput, crate::error::GetBucketsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_buckets_error(response)
        } else {
            crate::operation_deser::parse_get_buckets_response(response)
        }
    }
}

/// <p>Returns the list of bundles that are available for purchase. A bundle describes the specs
/// for your virtual private server (or <i>instance</i>).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBundles {
    _private: (),
}
impl GetBundles {
    /// Creates a new builder-style object to manufacture [`GetBundlesInput`](crate::input::GetBundlesInput)
    pub fn builder() -> crate::input::get_bundles_input::Builder {
        crate::input::get_bundles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBundles {
    type Output =
        std::result::Result<crate::output::GetBundlesOutput, crate::error::GetBundlesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_bundles_error(response)
        } else {
            crate::operation_deser::parse_get_bundles_response(response)
        }
    }
}

/// <p>Returns information about one or more Amazon Lightsail SSL/TLS certificates.</p>
/// <note>
/// <p>To get a summary of a certificate, ommit <code>includeCertificateDetails</code> from
/// your request. The response will include only the certificate Amazon Resource Name (ARN),
/// certificate name, domain name, and tags.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCertificates {
    _private: (),
}
impl GetCertificates {
    /// Creates a new builder-style object to manufacture [`GetCertificatesInput`](crate::input::GetCertificatesInput)
    pub fn builder() -> crate::input::get_certificates_input::Builder {
        crate::input::get_certificates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCertificates {
    type Output = std::result::Result<
        crate::output::GetCertificatesOutput,
        crate::error::GetCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_certificates_error(response)
        } else {
            crate::operation_deser::parse_get_certificates_response(response)
        }
    }
}

/// <p>Returns the CloudFormation stack record created as a result of the <code>create cloud
/// formation stack</code> operation.</p>
/// <p>An AWS CloudFormation stack is used to create a new Amazon EC2 instance from an exported Lightsail
/// snapshot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCloudFormationStackRecords {
    _private: (),
}
impl GetCloudFormationStackRecords {
    /// Creates a new builder-style object to manufacture [`GetCloudFormationStackRecordsInput`](crate::input::GetCloudFormationStackRecordsInput)
    pub fn builder() -> crate::input::get_cloud_formation_stack_records_input::Builder {
        crate::input::get_cloud_formation_stack_records_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCloudFormationStackRecords {
    type Output = std::result::Result<
        crate::output::GetCloudFormationStackRecordsOutput,
        crate::error::GetCloudFormationStackRecordsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_cloud_formation_stack_records_error(response)
        } else {
            crate::operation_deser::parse_get_cloud_formation_stack_records_response(response)
        }
    }
}

/// <p>Returns information about the configured contact methods. Specify a protocol in your
/// request to return information about a specific contact method.</p>
/// <p>A contact method is used to send you notifications about your Amazon Lightsail resources.
/// You can add one email address and one mobile phone number contact method in each AWS Region.
/// However, SMS text messaging is not supported in some AWS Regions, and SMS text messages
/// cannot be sent to some countries/regions. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContactMethods {
    _private: (),
}
impl GetContactMethods {
    /// Creates a new builder-style object to manufacture [`GetContactMethodsInput`](crate::input::GetContactMethodsInput)
    pub fn builder() -> crate::input::get_contact_methods_input::Builder {
        crate::input::get_contact_methods_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContactMethods {
    type Output = std::result::Result<
        crate::output::GetContactMethodsOutput,
        crate::error::GetContactMethodsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_contact_methods_error(response)
        } else {
            crate::operation_deser::parse_get_contact_methods_response(response)
        }
    }
}

/// <p>Returns information about Amazon Lightsail containers, such as the current version of the
/// Lightsail Control (lightsailctl) plugin.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerAPIMetadata {
    _private: (),
}
impl GetContainerAPIMetadata {
    /// Creates a new builder-style object to manufacture [`GetContainerApiMetadataInput`](crate::input::GetContainerApiMetadataInput)
    pub fn builder() -> crate::input::get_container_api_metadata_input::Builder {
        crate::input::get_container_api_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerAPIMetadata {
    type Output = std::result::Result<
        crate::output::GetContainerApiMetadataOutput,
        crate::error::GetContainerAPIMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_api_metadata_error(response)
        } else {
            crate::operation_deser::parse_get_container_api_metadata_response(response)
        }
    }
}

/// <p>Returns the container images that are registered to your Amazon Lightsail container
/// service.</p>
/// <note>
/// <p>If you created a deployment on your Lightsail container service that uses container
/// images from a public registry like Docker Hub, those images are not returned as part of this
/// action. Those images are not registered to your Lightsail container service.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerImages {
    _private: (),
}
impl GetContainerImages {
    /// Creates a new builder-style object to manufacture [`GetContainerImagesInput`](crate::input::GetContainerImagesInput)
    pub fn builder() -> crate::input::get_container_images_input::Builder {
        crate::input::get_container_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerImages {
    type Output = std::result::Result<
        crate::output::GetContainerImagesOutput,
        crate::error::GetContainerImagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_images_error(response)
        } else {
            crate::operation_deser::parse_get_container_images_response(response)
        }
    }
}

/// <p>Returns the log events of a container of your Amazon Lightsail container service.</p>
/// <p>If your container service has more than one node (i.e., a scale greater than 1), then the
/// log events that are returned for the specified container are merged from all nodes on your
/// container service.</p>
/// <note>
/// <p>Container logs are retained for a certain amount of time. For more information, see
/// <a href="https://docs.aws.amazon.com/general/latest/gr/lightsail.html">Amazon Lightsail
/// endpoints and quotas</a> in the <i>AWS General Reference</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerLog {
    _private: (),
}
impl GetContainerLog {
    /// Creates a new builder-style object to manufacture [`GetContainerLogInput`](crate::input::GetContainerLogInput)
    pub fn builder() -> crate::input::get_container_log_input::Builder {
        crate::input::get_container_log_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerLog {
    type Output = std::result::Result<
        crate::output::GetContainerLogOutput,
        crate::error::GetContainerLogError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_log_error(response)
        } else {
            crate::operation_deser::parse_get_container_log_response(response)
        }
    }
}

/// <p>Returns the deployments for your Amazon Lightsail container service</p>
/// <p>A deployment specifies the settings, such as the ports and launch command, of containers
/// that are deployed to your container service.</p>
/// <p>The deployments are ordered by version in ascending order. The newest version is listed at
/// the top of the response.</p>
/// <note>
/// <p>A set number of deployments are kept before the oldest one is replaced with the newest
/// one. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/lightsail.html">Amazon Lightsail
/// endpoints and quotas</a> in the <i>AWS General Reference</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerServiceDeployments {
    _private: (),
}
impl GetContainerServiceDeployments {
    /// Creates a new builder-style object to manufacture [`GetContainerServiceDeploymentsInput`](crate::input::GetContainerServiceDeploymentsInput)
    pub fn builder() -> crate::input::get_container_service_deployments_input::Builder {
        crate::input::get_container_service_deployments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerServiceDeployments {
    type Output = std::result::Result<
        crate::output::GetContainerServiceDeploymentsOutput,
        crate::error::GetContainerServiceDeploymentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_service_deployments_error(response)
        } else {
            crate::operation_deser::parse_get_container_service_deployments_response(response)
        }
    }
}

/// <p>Returns the data points of a specific metric of your Amazon Lightsail container
/// service.</p>
/// <p>Metrics report the utilization of your resources. Monitor and collect metric data
/// regularly to maintain the reliability, availability, and performance of your resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerServiceMetricData {
    _private: (),
}
impl GetContainerServiceMetricData {
    /// Creates a new builder-style object to manufacture [`GetContainerServiceMetricDataInput`](crate::input::GetContainerServiceMetricDataInput)
    pub fn builder() -> crate::input::get_container_service_metric_data_input::Builder {
        crate::input::get_container_service_metric_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerServiceMetricData {
    type Output = std::result::Result<
        crate::output::GetContainerServiceMetricDataOutput,
        crate::error::GetContainerServiceMetricDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_service_metric_data_error(response)
        } else {
            crate::operation_deser::parse_get_container_service_metric_data_response(response)
        }
    }
}

/// <p>Returns the list of powers that can be specified for your Amazon Lightsail container
/// services.</p>
/// <p>The power specifies the amount of memory, the number of vCPUs, and the base price of the
/// container service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerServicePowers {
    _private: (),
}
impl GetContainerServicePowers {
    /// Creates a new builder-style object to manufacture [`GetContainerServicePowersInput`](crate::input::GetContainerServicePowersInput)
    pub fn builder() -> crate::input::get_container_service_powers_input::Builder {
        crate::input::get_container_service_powers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerServicePowers {
    type Output = std::result::Result<
        crate::output::GetContainerServicePowersOutput,
        crate::error::GetContainerServicePowersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_service_powers_error(response)
        } else {
            crate::operation_deser::parse_get_container_service_powers_response(response)
        }
    }
}

/// <p>Returns information about one or more of your Amazon Lightsail container services.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContainerServices {
    _private: (),
}
impl GetContainerServices {
    /// Creates a new builder-style object to manufacture [`GetContainerServicesInput`](crate::input::GetContainerServicesInput)
    pub fn builder() -> crate::input::get_container_services_input::Builder {
        crate::input::get_container_services_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContainerServices {
    type Output = std::result::Result<
        crate::output::GetContainerServicesOutput,
        crate::error::GetContainerServicesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_container_services_error(response)
        } else {
            crate::operation_deser::parse_get_container_services_response(response)
        }
    }
}

/// <p>Returns information about a specific block storage disk.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDisk {
    _private: (),
}
impl GetDisk {
    /// Creates a new builder-style object to manufacture [`GetDiskInput`](crate::input::GetDiskInput)
    pub fn builder() -> crate::input::get_disk_input::Builder {
        crate::input::get_disk_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDisk {
    type Output = std::result::Result<crate::output::GetDiskOutput, crate::error::GetDiskError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_disk_error(response)
        } else {
            crate::operation_deser::parse_get_disk_response(response)
        }
    }
}

/// <p>Returns information about all block storage disks in your AWS account and region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDisks {
    _private: (),
}
impl GetDisks {
    /// Creates a new builder-style object to manufacture [`GetDisksInput`](crate::input::GetDisksInput)
    pub fn builder() -> crate::input::get_disks_input::Builder {
        crate::input::get_disks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDisks {
    type Output = std::result::Result<crate::output::GetDisksOutput, crate::error::GetDisksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_disks_error(response)
        } else {
            crate::operation_deser::parse_get_disks_response(response)
        }
    }
}

/// <p>Returns information about a specific block storage disk snapshot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDiskSnapshot {
    _private: (),
}
impl GetDiskSnapshot {
    /// Creates a new builder-style object to manufacture [`GetDiskSnapshotInput`](crate::input::GetDiskSnapshotInput)
    pub fn builder() -> crate::input::get_disk_snapshot_input::Builder {
        crate::input::get_disk_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDiskSnapshot {
    type Output = std::result::Result<
        crate::output::GetDiskSnapshotOutput,
        crate::error::GetDiskSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_disk_snapshot_error(response)
        } else {
            crate::operation_deser::parse_get_disk_snapshot_response(response)
        }
    }
}

/// <p>Returns information about all block storage disk snapshots in your AWS account and
/// region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDiskSnapshots {
    _private: (),
}
impl GetDiskSnapshots {
    /// Creates a new builder-style object to manufacture [`GetDiskSnapshotsInput`](crate::input::GetDiskSnapshotsInput)
    pub fn builder() -> crate::input::get_disk_snapshots_input::Builder {
        crate::input::get_disk_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDiskSnapshots {
    type Output = std::result::Result<
        crate::output::GetDiskSnapshotsOutput,
        crate::error::GetDiskSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_disk_snapshots_error(response)
        } else {
            crate::operation_deser::parse_get_disk_snapshots_response(response)
        }
    }
}

/// <p>Returns the bundles that can be applied to your Amazon Lightsail content delivery network
/// (CDN) distributions.</p>
/// <p>A distribution bundle specifies the monthly network transfer quota and monthly cost of
/// your dsitribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistributionBundles {
    _private: (),
}
impl GetDistributionBundles {
    /// Creates a new builder-style object to manufacture [`GetDistributionBundlesInput`](crate::input::GetDistributionBundlesInput)
    pub fn builder() -> crate::input::get_distribution_bundles_input::Builder {
        crate::input::get_distribution_bundles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistributionBundles {
    type Output = std::result::Result<
        crate::output::GetDistributionBundlesOutput,
        crate::error::GetDistributionBundlesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distribution_bundles_error(response)
        } else {
            crate::operation_deser::parse_get_distribution_bundles_response(response)
        }
    }
}

/// <p>Returns the timestamp and status of the last cache reset of a specific Amazon Lightsail
/// content delivery network (CDN) distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistributionLatestCacheReset {
    _private: (),
}
impl GetDistributionLatestCacheReset {
    /// Creates a new builder-style object to manufacture [`GetDistributionLatestCacheResetInput`](crate::input::GetDistributionLatestCacheResetInput)
    pub fn builder() -> crate::input::get_distribution_latest_cache_reset_input::Builder {
        crate::input::get_distribution_latest_cache_reset_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistributionLatestCacheReset {
    type Output = std::result::Result<
        crate::output::GetDistributionLatestCacheResetOutput,
        crate::error::GetDistributionLatestCacheResetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distribution_latest_cache_reset_error(response)
        } else {
            crate::operation_deser::parse_get_distribution_latest_cache_reset_response(response)
        }
    }
}

/// <p>Returns the data points of a specific metric for an Amazon Lightsail content delivery
/// network (CDN) distribution.</p>
/// <p>Metrics report the utilization of your resources, and the error counts generated by them.
/// Monitor and collect metric data regularly to maintain the reliability, availability, and
/// performance of your resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistributionMetricData {
    _private: (),
}
impl GetDistributionMetricData {
    /// Creates a new builder-style object to manufacture [`GetDistributionMetricDataInput`](crate::input::GetDistributionMetricDataInput)
    pub fn builder() -> crate::input::get_distribution_metric_data_input::Builder {
        crate::input::get_distribution_metric_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistributionMetricData {
    type Output = std::result::Result<
        crate::output::GetDistributionMetricDataOutput,
        crate::error::GetDistributionMetricDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distribution_metric_data_error(response)
        } else {
            crate::operation_deser::parse_get_distribution_metric_data_response(response)
        }
    }
}

/// <p>Returns information about one or more of your Amazon Lightsail content delivery network
/// (CDN) distributions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistributions {
    _private: (),
}
impl GetDistributions {
    /// Creates a new builder-style object to manufacture [`GetDistributionsInput`](crate::input::GetDistributionsInput)
    pub fn builder() -> crate::input::get_distributions_input::Builder {
        crate::input::get_distributions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistributions {
    type Output = std::result::Result<
        crate::output::GetDistributionsOutput,
        crate::error::GetDistributionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distributions_error(response)
        } else {
            crate::operation_deser::parse_get_distributions_response(response)
        }
    }
}

/// <p>Returns information about a specific domain recordset.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomain {
    _private: (),
}
impl GetDomain {
    /// Creates a new builder-style object to manufacture [`GetDomainInput`](crate::input::GetDomainInput)
    pub fn builder() -> crate::input::get_domain_input::Builder {
        crate::input::get_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomain {
    type Output = std::result::Result<crate::output::GetDomainOutput, crate::error::GetDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_error(response)
        } else {
            crate::operation_deser::parse_get_domain_response(response)
        }
    }
}

/// <p>Returns a list of all domains in the user's account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomains {
    _private: (),
}
impl GetDomains {
    /// Creates a new builder-style object to manufacture [`GetDomainsInput`](crate::input::GetDomainsInput)
    pub fn builder() -> crate::input::get_domains_input::Builder {
        crate::input::get_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomains {
    type Output =
        std::result::Result<crate::output::GetDomainsOutput, crate::error::GetDomainsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domains_error(response)
        } else {
            crate::operation_deser::parse_get_domains_response(response)
        }
    }
}

/// <p>Returns all export snapshot records created as a result of the <code>export
/// snapshot</code> operation.</p>
/// <p>An export snapshot record can be used to create a new Amazon EC2 instance and its related
/// resources with the <a>CreateCloudFormationStack</a> action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetExportSnapshotRecords {
    _private: (),
}
impl GetExportSnapshotRecords {
    /// Creates a new builder-style object to manufacture [`GetExportSnapshotRecordsInput`](crate::input::GetExportSnapshotRecordsInput)
    pub fn builder() -> crate::input::get_export_snapshot_records_input::Builder {
        crate::input::get_export_snapshot_records_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetExportSnapshotRecords {
    type Output = std::result::Result<
        crate::output::GetExportSnapshotRecordsOutput,
        crate::error::GetExportSnapshotRecordsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_export_snapshot_records_error(response)
        } else {
            crate::operation_deser::parse_get_export_snapshot_records_response(response)
        }
    }
}

/// <p>Returns information about a specific Amazon Lightsail instance, which is a virtual private
/// server.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstance {
    _private: (),
}
impl GetInstance {
    /// Creates a new builder-style object to manufacture [`GetInstanceInput`](crate::input::GetInstanceInput)
    pub fn builder() -> crate::input::get_instance_input::Builder {
        crate::input::get_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstance {
    type Output =
        std::result::Result<crate::output::GetInstanceOutput, crate::error::GetInstanceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_error(response)
        } else {
            crate::operation_deser::parse_get_instance_response(response)
        }
    }
}

/// <p>Returns temporary SSH keys you can use to connect to a specific virtual private server, or
/// <i>instance</i>.</p>
/// <p>The <code>get instance access details</code> operation supports tag-based access control
/// via resource tags applied to the resource identified by <code>instance name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstanceAccessDetails {
    _private: (),
}
impl GetInstanceAccessDetails {
    /// Creates a new builder-style object to manufacture [`GetInstanceAccessDetailsInput`](crate::input::GetInstanceAccessDetailsInput)
    pub fn builder() -> crate::input::get_instance_access_details_input::Builder {
        crate::input::get_instance_access_details_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstanceAccessDetails {
    type Output = std::result::Result<
        crate::output::GetInstanceAccessDetailsOutput,
        crate::error::GetInstanceAccessDetailsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_access_details_error(response)
        } else {
            crate::operation_deser::parse_get_instance_access_details_response(response)
        }
    }
}

/// <p>Returns the data points for the specified Amazon Lightsail instance metric, given an
/// instance name.</p>
/// <p>Metrics report the utilization of your resources, and the error counts generated by them.
/// Monitor and collect metric data regularly to maintain the reliability, availability, and
/// performance of your resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstanceMetricData {
    _private: (),
}
impl GetInstanceMetricData {
    /// Creates a new builder-style object to manufacture [`GetInstanceMetricDataInput`](crate::input::GetInstanceMetricDataInput)
    pub fn builder() -> crate::input::get_instance_metric_data_input::Builder {
        crate::input::get_instance_metric_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstanceMetricData {
    type Output = std::result::Result<
        crate::output::GetInstanceMetricDataOutput,
        crate::error::GetInstanceMetricDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_metric_data_error(response)
        } else {
            crate::operation_deser::parse_get_instance_metric_data_response(response)
        }
    }
}

/// <p>Returns the firewall port states for a specific Amazon Lightsail instance, the IP addresses
/// allowed to connect to the instance through the ports, and the protocol.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstancePortStates {
    _private: (),
}
impl GetInstancePortStates {
    /// Creates a new builder-style object to manufacture [`GetInstancePortStatesInput`](crate::input::GetInstancePortStatesInput)
    pub fn builder() -> crate::input::get_instance_port_states_input::Builder {
        crate::input::get_instance_port_states_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstancePortStates {
    type Output = std::result::Result<
        crate::output::GetInstancePortStatesOutput,
        crate::error::GetInstancePortStatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_port_states_error(response)
        } else {
            crate::operation_deser::parse_get_instance_port_states_response(response)
        }
    }
}

/// <p>Returns information about all Amazon Lightsail virtual private servers, or
/// <i>instances</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstances {
    _private: (),
}
impl GetInstances {
    /// Creates a new builder-style object to manufacture [`GetInstancesInput`](crate::input::GetInstancesInput)
    pub fn builder() -> crate::input::get_instances_input::Builder {
        crate::input::get_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstances {
    type Output =
        std::result::Result<crate::output::GetInstancesOutput, crate::error::GetInstancesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instances_error(response)
        } else {
            crate::operation_deser::parse_get_instances_response(response)
        }
    }
}

/// <p>Returns information about a specific instance snapshot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstanceSnapshot {
    _private: (),
}
impl GetInstanceSnapshot {
    /// Creates a new builder-style object to manufacture [`GetInstanceSnapshotInput`](crate::input::GetInstanceSnapshotInput)
    pub fn builder() -> crate::input::get_instance_snapshot_input::Builder {
        crate::input::get_instance_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstanceSnapshot {
    type Output = std::result::Result<
        crate::output::GetInstanceSnapshotOutput,
        crate::error::GetInstanceSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_snapshot_error(response)
        } else {
            crate::operation_deser::parse_get_instance_snapshot_response(response)
        }
    }
}

/// <p>Returns all instance snapshots for the user's account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstanceSnapshots {
    _private: (),
}
impl GetInstanceSnapshots {
    /// Creates a new builder-style object to manufacture [`GetInstanceSnapshotsInput`](crate::input::GetInstanceSnapshotsInput)
    pub fn builder() -> crate::input::get_instance_snapshots_input::Builder {
        crate::input::get_instance_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstanceSnapshots {
    type Output = std::result::Result<
        crate::output::GetInstanceSnapshotsOutput,
        crate::error::GetInstanceSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_snapshots_error(response)
        } else {
            crate::operation_deser::parse_get_instance_snapshots_response(response)
        }
    }
}

/// <p>Returns the state of a specific instance. Works on one instance at a time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstanceState {
    _private: (),
}
impl GetInstanceState {
    /// Creates a new builder-style object to manufacture [`GetInstanceStateInput`](crate::input::GetInstanceStateInput)
    pub fn builder() -> crate::input::get_instance_state_input::Builder {
        crate::input::get_instance_state_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstanceState {
    type Output = std::result::Result<
        crate::output::GetInstanceStateOutput,
        crate::error::GetInstanceStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_state_error(response)
        } else {
            crate::operation_deser::parse_get_instance_state_response(response)
        }
    }
}

/// <p>Returns information about a specific key pair.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetKeyPair {
    _private: (),
}
impl GetKeyPair {
    /// Creates a new builder-style object to manufacture [`GetKeyPairInput`](crate::input::GetKeyPairInput)
    pub fn builder() -> crate::input::get_key_pair_input::Builder {
        crate::input::get_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetKeyPair {
    type Output =
        std::result::Result<crate::output::GetKeyPairOutput, crate::error::GetKeyPairError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_key_pair_error(response)
        } else {
            crate::operation_deser::parse_get_key_pair_response(response)
        }
    }
}

/// <p>Returns information about all key pairs in the user's account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetKeyPairs {
    _private: (),
}
impl GetKeyPairs {
    /// Creates a new builder-style object to manufacture [`GetKeyPairsInput`](crate::input::GetKeyPairsInput)
    pub fn builder() -> crate::input::get_key_pairs_input::Builder {
        crate::input::get_key_pairs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetKeyPairs {
    type Output =
        std::result::Result<crate::output::GetKeyPairsOutput, crate::error::GetKeyPairsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_key_pairs_error(response)
        } else {
            crate::operation_deser::parse_get_key_pairs_response(response)
        }
    }
}

/// <p>Returns information about the specified Lightsail load balancer.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLoadBalancer {
    _private: (),
}
impl GetLoadBalancer {
    /// Creates a new builder-style object to manufacture [`GetLoadBalancerInput`](crate::input::GetLoadBalancerInput)
    pub fn builder() -> crate::input::get_load_balancer_input::Builder {
        crate::input::get_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLoadBalancer {
    type Output = std::result::Result<
        crate::output::GetLoadBalancerOutput,
        crate::error::GetLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_get_load_balancer_response(response)
        }
    }
}

/// <p>Returns information about health metrics for your Lightsail load balancer.</p>
/// <p>Metrics report the utilization of your resources, and the error counts generated by them.
/// Monitor and collect metric data regularly to maintain the reliability, availability, and
/// performance of your resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLoadBalancerMetricData {
    _private: (),
}
impl GetLoadBalancerMetricData {
    /// Creates a new builder-style object to manufacture [`GetLoadBalancerMetricDataInput`](crate::input::GetLoadBalancerMetricDataInput)
    pub fn builder() -> crate::input::get_load_balancer_metric_data_input::Builder {
        crate::input::get_load_balancer_metric_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLoadBalancerMetricData {
    type Output = std::result::Result<
        crate::output::GetLoadBalancerMetricDataOutput,
        crate::error::GetLoadBalancerMetricDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_load_balancer_metric_data_error(response)
        } else {
            crate::operation_deser::parse_get_load_balancer_metric_data_response(response)
        }
    }
}

/// <p>Returns information about all load balancers in an account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLoadBalancers {
    _private: (),
}
impl GetLoadBalancers {
    /// Creates a new builder-style object to manufacture [`GetLoadBalancersInput`](crate::input::GetLoadBalancersInput)
    pub fn builder() -> crate::input::get_load_balancers_input::Builder {
        crate::input::get_load_balancers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLoadBalancers {
    type Output = std::result::Result<
        crate::output::GetLoadBalancersOutput,
        crate::error::GetLoadBalancersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_load_balancers_error(response)
        } else {
            crate::operation_deser::parse_get_load_balancers_response(response)
        }
    }
}

/// <p>Returns information about the TLS certificates that are associated with the specified
/// Lightsail load balancer.</p>
/// <p>TLS is just an updated, more secure version of Secure Socket Layer (SSL).</p>
/// <p>You can have a maximum of 2 certificates associated with a Lightsail load balancer. One
/// is active and the other is inactive.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLoadBalancerTlsCertificates {
    _private: (),
}
impl GetLoadBalancerTlsCertificates {
    /// Creates a new builder-style object to manufacture [`GetLoadBalancerTlsCertificatesInput`](crate::input::GetLoadBalancerTlsCertificatesInput)
    pub fn builder() -> crate::input::get_load_balancer_tls_certificates_input::Builder {
        crate::input::get_load_balancer_tls_certificates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLoadBalancerTlsCertificates {
    type Output = std::result::Result<
        crate::output::GetLoadBalancerTlsCertificatesOutput,
        crate::error::GetLoadBalancerTlsCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_load_balancer_tls_certificates_error(response)
        } else {
            crate::operation_deser::parse_get_load_balancer_tls_certificates_response(response)
        }
    }
}

/// <p>Returns information about a specific operation. Operations include events such as when you
/// create an instance, allocate a static IP, attach a static IP, and so on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOperation {
    _private: (),
}
impl GetOperation {
    /// Creates a new builder-style object to manufacture [`GetOperationInput`](crate::input::GetOperationInput)
    pub fn builder() -> crate::input::get_operation_input::Builder {
        crate::input::get_operation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOperation {
    type Output =
        std::result::Result<crate::output::GetOperationOutput, crate::error::GetOperationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_operation_error(response)
        } else {
            crate::operation_deser::parse_get_operation_response(response)
        }
    }
}

/// <p>Returns information about all operations.</p>
/// <p>Results are returned from oldest to newest, up to a maximum of 200. Results can be paged
/// by making each subsequent call to <code>GetOperations</code> use the maximum (last)
/// <code>statusChangedAt</code> value from the previous request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOperations {
    _private: (),
}
impl GetOperations {
    /// Creates a new builder-style object to manufacture [`GetOperationsInput`](crate::input::GetOperationsInput)
    pub fn builder() -> crate::input::get_operations_input::Builder {
        crate::input::get_operations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOperations {
    type Output =
        std::result::Result<crate::output::GetOperationsOutput, crate::error::GetOperationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_operations_error(response)
        } else {
            crate::operation_deser::parse_get_operations_response(response)
        }
    }
}

/// <p>Gets operations for a specific resource (e.g., an instance or a static IP).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOperationsForResource {
    _private: (),
}
impl GetOperationsForResource {
    /// Creates a new builder-style object to manufacture [`GetOperationsForResourceInput`](crate::input::GetOperationsForResourceInput)
    pub fn builder() -> crate::input::get_operations_for_resource_input::Builder {
        crate::input::get_operations_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOperationsForResource {
    type Output = std::result::Result<
        crate::output::GetOperationsForResourceOutput,
        crate::error::GetOperationsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_operations_for_resource_error(response)
        } else {
            crate::operation_deser::parse_get_operations_for_resource_response(response)
        }
    }
}

/// <p>Returns a list of all valid regions for Amazon Lightsail. Use the <code>include
/// availability zones</code> parameter to also return the Availability Zones in a
/// region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRegions {
    _private: (),
}
impl GetRegions {
    /// Creates a new builder-style object to manufacture [`GetRegionsInput`](crate::input::GetRegionsInput)
    pub fn builder() -> crate::input::get_regions_input::Builder {
        crate::input::get_regions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRegions {
    type Output =
        std::result::Result<crate::output::GetRegionsOutput, crate::error::GetRegionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_regions_error(response)
        } else {
            crate::operation_deser::parse_get_regions_response(response)
        }
    }
}

/// <p>Returns information about a specific database in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabase {
    _private: (),
}
impl GetRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseInput`](crate::input::GetRelationalDatabaseInput)
    pub fn builder() -> crate::input::get_relational_database_input::Builder {
        crate::input::get_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabase {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseOutput,
        crate::error::GetRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_response(response)
        }
    }
}

/// <p>Returns a list of available database blueprints in Amazon Lightsail. A blueprint describes
/// the major engine version of a database.</p>
/// <p>You can use a blueprint ID to create a new database that runs a specific database
/// engine.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseBlueprints {
    _private: (),
}
impl GetRelationalDatabaseBlueprints {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseBlueprintsInput`](crate::input::GetRelationalDatabaseBlueprintsInput)
    pub fn builder() -> crate::input::get_relational_database_blueprints_input::Builder {
        crate::input::get_relational_database_blueprints_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseBlueprints {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseBlueprintsOutput,
        crate::error::GetRelationalDatabaseBlueprintsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_blueprints_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_blueprints_response(response)
        }
    }
}

/// <p>Returns the list of bundles that are available in Amazon Lightsail. A bundle describes the
/// performance specifications for a database.</p>
/// <p>You can use a bundle ID to create a new database with explicit performance
/// specifications.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseBundles {
    _private: (),
}
impl GetRelationalDatabaseBundles {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseBundlesInput`](crate::input::GetRelationalDatabaseBundlesInput)
    pub fn builder() -> crate::input::get_relational_database_bundles_input::Builder {
        crate::input::get_relational_database_bundles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseBundles {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseBundlesOutput,
        crate::error::GetRelationalDatabaseBundlesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_bundles_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_bundles_response(response)
        }
    }
}

/// <p>Returns a list of events for a specific database in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseEvents {
    _private: (),
}
impl GetRelationalDatabaseEvents {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseEventsInput`](crate::input::GetRelationalDatabaseEventsInput)
    pub fn builder() -> crate::input::get_relational_database_events_input::Builder {
        crate::input::get_relational_database_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseEvents {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseEventsOutput,
        crate::error::GetRelationalDatabaseEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_events_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_events_response(response)
        }
    }
}

/// <p>Returns a list of log events for a database in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseLogEvents {
    _private: (),
}
impl GetRelationalDatabaseLogEvents {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseLogEventsInput`](crate::input::GetRelationalDatabaseLogEventsInput)
    pub fn builder() -> crate::input::get_relational_database_log_events_input::Builder {
        crate::input::get_relational_database_log_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseLogEvents {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseLogEventsOutput,
        crate::error::GetRelationalDatabaseLogEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_log_events_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_log_events_response(response)
        }
    }
}

/// <p>Returns a list of available log streams for a specific database in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseLogStreams {
    _private: (),
}
impl GetRelationalDatabaseLogStreams {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseLogStreamsInput`](crate::input::GetRelationalDatabaseLogStreamsInput)
    pub fn builder() -> crate::input::get_relational_database_log_streams_input::Builder {
        crate::input::get_relational_database_log_streams_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseLogStreams {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseLogStreamsOutput,
        crate::error::GetRelationalDatabaseLogStreamsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_log_streams_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_log_streams_response(response)
        }
    }
}

/// <p>Returns the current, previous, or pending versions of the master user password for a
/// Lightsail database.</p>
/// <p>The <code>GetRelationalDatabaseMasterUserPassword</code> operation supports tag-based
/// access control via resource tags applied to the resource identified by
/// relationalDatabaseName.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseMasterUserPassword {
    _private: (),
}
impl GetRelationalDatabaseMasterUserPassword {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseMasterUserPasswordInput`](crate::input::GetRelationalDatabaseMasterUserPasswordInput)
    pub fn builder() -> crate::input::get_relational_database_master_user_password_input::Builder {
        crate::input::get_relational_database_master_user_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseMasterUserPassword {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseMasterUserPasswordOutput,
        crate::error::GetRelationalDatabaseMasterUserPasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_master_user_password_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_relational_database_master_user_password_response(
                response,
            )
        }
    }
}

/// <p>Returns the data points of the specified metric for a database in Amazon Lightsail.</p>
/// <p>Metrics report the utilization of your resources, and the error counts generated by them.
/// Monitor and collect metric data regularly to maintain the reliability, availability, and
/// performance of your resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseMetricData {
    _private: (),
}
impl GetRelationalDatabaseMetricData {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseMetricDataInput`](crate::input::GetRelationalDatabaseMetricDataInput)
    pub fn builder() -> crate::input::get_relational_database_metric_data_input::Builder {
        crate::input::get_relational_database_metric_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseMetricData {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseMetricDataOutput,
        crate::error::GetRelationalDatabaseMetricDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_metric_data_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_metric_data_response(response)
        }
    }
}

/// <p>Returns all of the runtime parameters offered by the underlying database software, or
/// engine, for a specific database in Amazon Lightsail.</p>
/// <p>In addition to the parameter names and values, this operation returns other information
/// about each parameter. This information includes whether changes require a reboot, whether the
/// parameter is modifiable, the allowed values, and the data types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseParameters {
    _private: (),
}
impl GetRelationalDatabaseParameters {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseParametersInput`](crate::input::GetRelationalDatabaseParametersInput)
    pub fn builder() -> crate::input::get_relational_database_parameters_input::Builder {
        crate::input::get_relational_database_parameters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseParameters {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseParametersOutput,
        crate::error::GetRelationalDatabaseParametersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_parameters_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_parameters_response(response)
        }
    }
}

/// <p>Returns information about all of your databases in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabases {
    _private: (),
}
impl GetRelationalDatabases {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabasesInput`](crate::input::GetRelationalDatabasesInput)
    pub fn builder() -> crate::input::get_relational_databases_input::Builder {
        crate::input::get_relational_databases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabases {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabasesOutput,
        crate::error::GetRelationalDatabasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_databases_error(response)
        } else {
            crate::operation_deser::parse_get_relational_databases_response(response)
        }
    }
}

/// <p>Returns information about a specific database snapshot in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseSnapshot {
    _private: (),
}
impl GetRelationalDatabaseSnapshot {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseSnapshotInput`](crate::input::GetRelationalDatabaseSnapshotInput)
    pub fn builder() -> crate::input::get_relational_database_snapshot_input::Builder {
        crate::input::get_relational_database_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseSnapshot {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseSnapshotOutput,
        crate::error::GetRelationalDatabaseSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_snapshot_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_snapshot_response(response)
        }
    }
}

/// <p>Returns information about all of your database snapshots in Amazon Lightsail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRelationalDatabaseSnapshots {
    _private: (),
}
impl GetRelationalDatabaseSnapshots {
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseSnapshotsInput`](crate::input::GetRelationalDatabaseSnapshotsInput)
    pub fn builder() -> crate::input::get_relational_database_snapshots_input::Builder {
        crate::input::get_relational_database_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRelationalDatabaseSnapshots {
    type Output = std::result::Result<
        crate::output::GetRelationalDatabaseSnapshotsOutput,
        crate::error::GetRelationalDatabaseSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_relational_database_snapshots_error(response)
        } else {
            crate::operation_deser::parse_get_relational_database_snapshots_response(response)
        }
    }
}

/// <p>Returns information about an Amazon Lightsail static IP.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStaticIp {
    _private: (),
}
impl GetStaticIp {
    /// Creates a new builder-style object to manufacture [`GetStaticIpInput`](crate::input::GetStaticIpInput)
    pub fn builder() -> crate::input::get_static_ip_input::Builder {
        crate::input::get_static_ip_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStaticIp {
    type Output =
        std::result::Result<crate::output::GetStaticIpOutput, crate::error::GetStaticIpError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_static_ip_error(response)
        } else {
            crate::operation_deser::parse_get_static_ip_response(response)
        }
    }
}

/// <p>Returns information about all static IPs in the user's account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStaticIps {
    _private: (),
}
impl GetStaticIps {
    /// Creates a new builder-style object to manufacture [`GetStaticIpsInput`](crate::input::GetStaticIpsInput)
    pub fn builder() -> crate::input::get_static_ips_input::Builder {
        crate::input::get_static_ips_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStaticIps {
    type Output =
        std::result::Result<crate::output::GetStaticIpsOutput, crate::error::GetStaticIpsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_static_ips_error(response)
        } else {
            crate::operation_deser::parse_get_static_ips_response(response)
        }
    }
}

/// <p>Imports a public SSH key from a specific key pair.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportKeyPair {
    _private: (),
}
impl ImportKeyPair {
    /// Creates a new builder-style object to manufacture [`ImportKeyPairInput`](crate::input::ImportKeyPairInput)
    pub fn builder() -> crate::input::import_key_pair_input::Builder {
        crate::input::import_key_pair_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportKeyPair {
    type Output =
        std::result::Result<crate::output::ImportKeyPairOutput, crate::error::ImportKeyPairError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_key_pair_error(response)
        } else {
            crate::operation_deser::parse_import_key_pair_response(response)
        }
    }
}

/// <p>Returns a Boolean value indicating whether your Lightsail VPC is peered.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct IsVpcPeered {
    _private: (),
}
impl IsVpcPeered {
    /// Creates a new builder-style object to manufacture [`IsVpcPeeredInput`](crate::input::IsVpcPeeredInput)
    pub fn builder() -> crate::input::is_vpc_peered_input::Builder {
        crate::input::is_vpc_peered_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for IsVpcPeered {
    type Output =
        std::result::Result<crate::output::IsVpcPeeredOutput, crate::error::IsVpcPeeredError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_is_vpc_peered_error(response)
        } else {
            crate::operation_deser::parse_is_vpc_peered_response(response)
        }
    }
}

/// <p>Opens ports for a specific Amazon Lightsail instance, and specifies the IP addresses
/// allowed to connect to the instance through the ports, and the protocol.</p>
/// <p>The <code>OpenInstancePublicPorts</code> action supports tag-based access control via
/// resource tags applied to the resource identified by <code>instanceName</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct OpenInstancePublicPorts {
    _private: (),
}
impl OpenInstancePublicPorts {
    /// Creates a new builder-style object to manufacture [`OpenInstancePublicPortsInput`](crate::input::OpenInstancePublicPortsInput)
    pub fn builder() -> crate::input::open_instance_public_ports_input::Builder {
        crate::input::open_instance_public_ports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for OpenInstancePublicPorts {
    type Output = std::result::Result<
        crate::output::OpenInstancePublicPortsOutput,
        crate::error::OpenInstancePublicPortsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_open_instance_public_ports_error(response)
        } else {
            crate::operation_deser::parse_open_instance_public_ports_response(response)
        }
    }
}

/// <p>Peers the Lightsail VPC with the user's default VPC.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PeerVpc {
    _private: (),
}
impl PeerVpc {
    /// Creates a new builder-style object to manufacture [`PeerVpcInput`](crate::input::PeerVpcInput)
    pub fn builder() -> crate::input::peer_vpc_input::Builder {
        crate::input::peer_vpc_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PeerVpc {
    type Output = std::result::Result<crate::output::PeerVpcOutput, crate::error::PeerVpcError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_peer_vpc_error(response)
        } else {
            crate::operation_deser::parse_peer_vpc_response(response)
        }
    }
}

/// <p>Creates or updates an alarm, and associates it with the specified metric.</p>
/// <p>An alarm is used to monitor a single metric for one of your resources. When a metric
/// condition is met, the alarm can notify you by email, SMS text message, and a banner displayed
/// on the Amazon Lightsail console. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-alarms">Alarms
/// in Amazon Lightsail</a>.</p>
/// <p>When this action creates an alarm, the alarm state is immediately set to
/// <code>INSUFFICIENT_DATA</code>. The alarm is then evaluated and its state is set
/// appropriately. Any actions associated with the new state are then executed.</p>
/// <p>When you update an existing alarm, its state is left unchanged, but the update completely
/// overwrites the previous configuration of the alarm. The alarm is then evaluated with the
/// updated configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAlarm {
    _private: (),
}
impl PutAlarm {
    /// Creates a new builder-style object to manufacture [`PutAlarmInput`](crate::input::PutAlarmInput)
    pub fn builder() -> crate::input::put_alarm_input::Builder {
        crate::input::put_alarm_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAlarm {
    type Output = std::result::Result<crate::output::PutAlarmOutput, crate::error::PutAlarmError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_alarm_error(response)
        } else {
            crate::operation_deser::parse_put_alarm_response(response)
        }
    }
}

/// <p>Opens ports for a specific Amazon Lightsail instance, and specifies the IP addresses
/// allowed to connect to the instance through the ports, and the protocol. This action also
/// closes all currently open ports that are not included in the request. Include all of the ports
/// and the protocols you want to open in your <code>PutInstancePublicPorts</code>request. Or use
/// the <code>OpenInstancePublicPorts</code> action to open ports without closing currently open
/// ports.</p>
/// <p>The <code>PutInstancePublicPorts</code> action supports tag-based access control via
/// resource tags applied to the resource identified by <code>instanceName</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutInstancePublicPorts {
    _private: (),
}
impl PutInstancePublicPorts {
    /// Creates a new builder-style object to manufacture [`PutInstancePublicPortsInput`](crate::input::PutInstancePublicPortsInput)
    pub fn builder() -> crate::input::put_instance_public_ports_input::Builder {
        crate::input::put_instance_public_ports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutInstancePublicPorts {
    type Output = std::result::Result<
        crate::output::PutInstancePublicPortsOutput,
        crate::error::PutInstancePublicPortsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_instance_public_ports_error(response)
        } else {
            crate::operation_deser::parse_put_instance_public_ports_response(response)
        }
    }
}

/// <p>Restarts a specific instance.</p>
/// <p>The <code>reboot instance</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>instance name</code>. For more information,
/// see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RebootInstance {
    _private: (),
}
impl RebootInstance {
    /// Creates a new builder-style object to manufacture [`RebootInstanceInput`](crate::input::RebootInstanceInput)
    pub fn builder() -> crate::input::reboot_instance_input::Builder {
        crate::input::reboot_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RebootInstance {
    type Output =
        std::result::Result<crate::output::RebootInstanceOutput, crate::error::RebootInstanceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reboot_instance_error(response)
        } else {
            crate::operation_deser::parse_reboot_instance_response(response)
        }
    }
}

/// <p>Restarts a specific database in Amazon Lightsail.</p>
/// <p>The <code>reboot relational database</code> operation supports tag-based access control
/// via resource tags applied to the resource identified by relationalDatabaseName. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RebootRelationalDatabase {
    _private: (),
}
impl RebootRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`RebootRelationalDatabaseInput`](crate::input::RebootRelationalDatabaseInput)
    pub fn builder() -> crate::input::reboot_relational_database_input::Builder {
        crate::input::reboot_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RebootRelationalDatabase {
    type Output = std::result::Result<
        crate::output::RebootRelationalDatabaseOutput,
        crate::error::RebootRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reboot_relational_database_error(response)
        } else {
            crate::operation_deser::parse_reboot_relational_database_response(response)
        }
    }
}

/// <p>Registers a container image to your Amazon Lightsail container service.</p>
/// <note>
/// <p>This action is not required if you install and use the Lightsail Control
/// (lightsailctl) plugin to push container images to your Lightsail container service. For
/// more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-pushing-container-images">Pushing and managing container images on your Amazon Lightsail container services</a>
/// in the <i>Amazon Lightsail Developer Guide</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterContainerImage {
    _private: (),
}
impl RegisterContainerImage {
    /// Creates a new builder-style object to manufacture [`RegisterContainerImageInput`](crate::input::RegisterContainerImageInput)
    pub fn builder() -> crate::input::register_container_image_input::Builder {
        crate::input::register_container_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterContainerImage {
    type Output = std::result::Result<
        crate::output::RegisterContainerImageOutput,
        crate::error::RegisterContainerImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_container_image_error(response)
        } else {
            crate::operation_deser::parse_register_container_image_response(response)
        }
    }
}

/// <p>Deletes a specific static IP from your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ReleaseStaticIp {
    _private: (),
}
impl ReleaseStaticIp {
    /// Creates a new builder-style object to manufacture [`ReleaseStaticIpInput`](crate::input::ReleaseStaticIpInput)
    pub fn builder() -> crate::input::release_static_ip_input::Builder {
        crate::input::release_static_ip_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ReleaseStaticIp {
    type Output = std::result::Result<
        crate::output::ReleaseStaticIpOutput,
        crate::error::ReleaseStaticIpError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_release_static_ip_error(response)
        } else {
            crate::operation_deser::parse_release_static_ip_response(response)
        }
    }
}

/// <p>Deletes currently cached content from your Amazon Lightsail content delivery network (CDN)
/// distribution.</p>
/// <p>After resetting the cache, the next time a content request is made, your distribution
/// pulls, serves, and caches it from the origin.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResetDistributionCache {
    _private: (),
}
impl ResetDistributionCache {
    /// Creates a new builder-style object to manufacture [`ResetDistributionCacheInput`](crate::input::ResetDistributionCacheInput)
    pub fn builder() -> crate::input::reset_distribution_cache_input::Builder {
        crate::input::reset_distribution_cache_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResetDistributionCache {
    type Output = std::result::Result<
        crate::output::ResetDistributionCacheOutput,
        crate::error::ResetDistributionCacheError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reset_distribution_cache_error(response)
        } else {
            crate::operation_deser::parse_reset_distribution_cache_response(response)
        }
    }
}

/// <p>Sends a verification request to an email contact method to ensure it's owned by the
/// requester. SMS contact methods don't need to be verified.</p>
/// <p>A contact method is used to send you notifications about your Amazon Lightsail resources.
/// You can add one email address and one mobile phone number contact method in each AWS Region.
/// However, SMS text messaging is not supported in some AWS Regions, and SMS text messages
/// cannot be sent to some countries/regions. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
/// <p>A verification request is sent to the contact method when you initially create it. Use
/// this action to send another verification request if a previous verification request was
/// deleted, or has expired.</p>
/// <important>
/// <p>Notifications are not sent to an email contact method until after it is verified, and
/// confirmed as valid.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendContactMethodVerification {
    _private: (),
}
impl SendContactMethodVerification {
    /// Creates a new builder-style object to manufacture [`SendContactMethodVerificationInput`](crate::input::SendContactMethodVerificationInput)
    pub fn builder() -> crate::input::send_contact_method_verification_input::Builder {
        crate::input::send_contact_method_verification_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendContactMethodVerification {
    type Output = std::result::Result<
        crate::output::SendContactMethodVerificationOutput,
        crate::error::SendContactMethodVerificationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_send_contact_method_verification_error(response)
        } else {
            crate::operation_deser::parse_send_contact_method_verification_response(response)
        }
    }
}

/// <p>Sets the IP address type for an Amazon Lightsail resource.</p>
/// <p>Use this action to enable dual-stack for a resource, which enables IPv4 and IPv6 for the
/// specified resource. Alternately, you can use this action to disable dual-stack, and enable
/// IPv4 only.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIpAddressType {
    _private: (),
}
impl SetIpAddressType {
    /// Creates a new builder-style object to manufacture [`SetIpAddressTypeInput`](crate::input::SetIpAddressTypeInput)
    pub fn builder() -> crate::input::set_ip_address_type_input::Builder {
        crate::input::set_ip_address_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIpAddressType {
    type Output = std::result::Result<
        crate::output::SetIpAddressTypeOutput,
        crate::error::SetIpAddressTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_ip_address_type_error(response)
        } else {
            crate::operation_deser::parse_set_ip_address_type_response(response)
        }
    }
}

/// <p>Sets the Amazon Lightsail resources that can access the specified Lightsail
/// bucket.</p>
/// <p>Lightsail buckets currently support setting access for Lightsail instances in the same
/// AWS Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetResourceAccessForBucket {
    _private: (),
}
impl SetResourceAccessForBucket {
    /// Creates a new builder-style object to manufacture [`SetResourceAccessForBucketInput`](crate::input::SetResourceAccessForBucketInput)
    pub fn builder() -> crate::input::set_resource_access_for_bucket_input::Builder {
        crate::input::set_resource_access_for_bucket_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetResourceAccessForBucket {
    type Output = std::result::Result<
        crate::output::SetResourceAccessForBucketOutput,
        crate::error::SetResourceAccessForBucketError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_resource_access_for_bucket_error(response)
        } else {
            crate::operation_deser::parse_set_resource_access_for_bucket_response(response)
        }
    }
}

/// <p>Starts a specific Amazon Lightsail instance from a stopped state. To restart an instance,
/// use the <code>reboot instance</code> operation.</p>
/// <note>
/// <p>When you start a stopped instance, Lightsail assigns a new public IP address to the
/// instance. To use the same IP address after stopping and starting an instance, create a
/// static IP address and attach it to the instance. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/lightsail-create-static-ip">Amazon Lightsail Developer Guide</a>.</p>
/// </note>
/// <p>The <code>start instance</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>instance name</code>. For more information,
/// see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartInstance {
    _private: (),
}
impl StartInstance {
    /// Creates a new builder-style object to manufacture [`StartInstanceInput`](crate::input::StartInstanceInput)
    pub fn builder() -> crate::input::start_instance_input::Builder {
        crate::input::start_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartInstance {
    type Output =
        std::result::Result<crate::output::StartInstanceOutput, crate::error::StartInstanceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_instance_error(response)
        } else {
            crate::operation_deser::parse_start_instance_response(response)
        }
    }
}

/// <p>Starts a specific database from a stopped state in Amazon Lightsail. To restart a database,
/// use the <code>reboot relational database</code> operation.</p>
/// <p>The <code>start relational database</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by relationalDatabaseName. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartRelationalDatabase {
    _private: (),
}
impl StartRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`StartRelationalDatabaseInput`](crate::input::StartRelationalDatabaseInput)
    pub fn builder() -> crate::input::start_relational_database_input::Builder {
        crate::input::start_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartRelationalDatabase {
    type Output = std::result::Result<
        crate::output::StartRelationalDatabaseOutput,
        crate::error::StartRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_relational_database_error(response)
        } else {
            crate::operation_deser::parse_start_relational_database_response(response)
        }
    }
}

/// <p>Stops a specific Amazon Lightsail instance that is currently running.</p>
/// <note>
/// <p>When you start a stopped instance, Lightsail assigns a new public IP address to the
/// instance. To use the same IP address after stopping and starting an instance, create a
/// static IP address and attach it to the instance. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/lightsail-create-static-ip">Amazon Lightsail Developer Guide</a>.</p>
/// </note>
/// <p>The <code>stop instance</code> operation supports tag-based access control via resource
/// tags applied to the resource identified by <code>instance name</code>. For more information,
/// see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopInstance {
    _private: (),
}
impl StopInstance {
    /// Creates a new builder-style object to manufacture [`StopInstanceInput`](crate::input::StopInstanceInput)
    pub fn builder() -> crate::input::stop_instance_input::Builder {
        crate::input::stop_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopInstance {
    type Output =
        std::result::Result<crate::output::StopInstanceOutput, crate::error::StopInstanceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_instance_error(response)
        } else {
            crate::operation_deser::parse_stop_instance_response(response)
        }
    }
}

/// <p>Stops a specific database that is currently running in Amazon Lightsail.</p>
/// <p>The <code>stop relational database</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by relationalDatabaseName. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopRelationalDatabase {
    _private: (),
}
impl StopRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`StopRelationalDatabaseInput`](crate::input::StopRelationalDatabaseInput)
    pub fn builder() -> crate::input::stop_relational_database_input::Builder {
        crate::input::stop_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopRelationalDatabase {
    type Output = std::result::Result<
        crate::output::StopRelationalDatabaseOutput,
        crate::error::StopRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_relational_database_error(response)
        } else {
            crate::operation_deser::parse_stop_relational_database_response(response)
        }
    }
}

/// <p>Adds one or more tags to the specified Amazon Lightsail resource. Each resource can have a
/// maximum of 50 tags. Each tag consists of a key and an optional value. Tag keys must be unique
/// per resource. For more information about tags, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
/// <p>The <code>tag resource</code> operation supports tag-based access control via request tags
/// and resource tags applied to the resource identified by <code>resource name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Tests an alarm by displaying a banner on the Amazon Lightsail console. If a notification
/// trigger is configured for the specified alarm, the test also sends a notification to the
/// notification protocol (<code>Email</code> and/or <code>SMS</code>) configured for the
/// alarm.</p>
/// <p>An alarm is used to monitor a single metric for one of your resources. When a metric
/// condition is met, the alarm can notify you by email, SMS text message, and a banner displayed
/// on the Amazon Lightsail console. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-alarms">Alarms
/// in Amazon Lightsail</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestAlarm {
    _private: (),
}
impl TestAlarm {
    /// Creates a new builder-style object to manufacture [`TestAlarmInput`](crate::input::TestAlarmInput)
    pub fn builder() -> crate::input::test_alarm_input::Builder {
        crate::input::test_alarm_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestAlarm {
    type Output = std::result::Result<crate::output::TestAlarmOutput, crate::error::TestAlarmError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_alarm_error(response)
        } else {
            crate::operation_deser::parse_test_alarm_response(response)
        }
    }
}

/// <p>Unpeers the Lightsail VPC from the user's default VPC.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UnpeerVpc {
    _private: (),
}
impl UnpeerVpc {
    /// Creates a new builder-style object to manufacture [`UnpeerVpcInput`](crate::input::UnpeerVpcInput)
    pub fn builder() -> crate::input::unpeer_vpc_input::Builder {
        crate::input::unpeer_vpc_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UnpeerVpc {
    type Output = std::result::Result<crate::output::UnpeerVpcOutput, crate::error::UnpeerVpcError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_unpeer_vpc_error(response)
        } else {
            crate::operation_deser::parse_unpeer_vpc_response(response)
        }
    }
}

/// <p>Deletes the specified set of tag keys and their values from the specified Amazon Lightsail
/// resource.</p>
/// <p>The <code>untag resource</code> operation supports tag-based access control via request
/// tags and resource tags applied to the resource identified by <code>resource name</code>. For
/// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an existing Amazon Lightsail bucket.</p>
/// <p>Use this action to update the configuration of an existing bucket, such as versioning,
/// public accessibility, and the AWS accounts that can access the bucket.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBucket {
    _private: (),
}
impl UpdateBucket {
    /// Creates a new builder-style object to manufacture [`UpdateBucketInput`](crate::input::UpdateBucketInput)
    pub fn builder() -> crate::input::update_bucket_input::Builder {
        crate::input::update_bucket_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBucket {
    type Output =
        std::result::Result<crate::output::UpdateBucketOutput, crate::error::UpdateBucketError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_bucket_error(response)
        } else {
            crate::operation_deser::parse_update_bucket_response(response)
        }
    }
}

/// <p>Updates the bundle, or storage plan, of an existing Amazon Lightsail bucket.</p>
/// <p>A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a
/// bucket. You can update a bucket's bundle only one time within a monthly AWS billing cycle. To
/// determine if you can update a bucket's bundle, use the <a>GetBuckets</a> action.
/// The <code>ableToUpdateBundle</code> parameter in the response will indicate whether you can
/// currently update a bucket's bundle.</p>
/// <p>Update a bucket's bundle if it's consistently going over its storage space or data
/// transfer quota, or if a bucket's usage is consistently in the lower range of its storage space
/// or data transfer quota. Due to the unpredictable usage fluctuations that a bucket might
/// experience, we strongly recommend that you update a bucket's bundle only as a long-term
/// strategy, instead of as a short-term, monthly cost-cutting measure. Choose a bucket bundle
/// that will provide the bucket with ample storage space and data transfer for a long time to
/// come.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBucketBundle {
    _private: (),
}
impl UpdateBucketBundle {
    /// Creates a new builder-style object to manufacture [`UpdateBucketBundleInput`](crate::input::UpdateBucketBundleInput)
    pub fn builder() -> crate::input::update_bucket_bundle_input::Builder {
        crate::input::update_bucket_bundle_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBucketBundle {
    type Output = std::result::Result<
        crate::output::UpdateBucketBundleOutput,
        crate::error::UpdateBucketBundleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_bucket_bundle_error(response)
        } else {
            crate::operation_deser::parse_update_bucket_bundle_response(response)
        }
    }
}

/// <p>Updates the configuration of your Amazon Lightsail container service, such as its power,
/// scale, and public domain names.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateContainerService {
    _private: (),
}
impl UpdateContainerService {
    /// Creates a new builder-style object to manufacture [`UpdateContainerServiceInput`](crate::input::UpdateContainerServiceInput)
    pub fn builder() -> crate::input::update_container_service_input::Builder {
        crate::input::update_container_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateContainerService {
    type Output = std::result::Result<
        crate::output::UpdateContainerServiceOutput,
        crate::error::UpdateContainerServiceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_container_service_error(response)
        } else {
            crate::operation_deser::parse_update_container_service_response(response)
        }
    }
}

/// <p>Updates an existing Amazon Lightsail content delivery network (CDN) distribution.</p>
/// <p>Use this action to update the configuration of your existing distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDistribution {
    _private: (),
}
impl UpdateDistribution {
    /// Creates a new builder-style object to manufacture [`UpdateDistributionInput`](crate::input::UpdateDistributionInput)
    pub fn builder() -> crate::input::update_distribution_input::Builder {
        crate::input::update_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDistribution {
    type Output = std::result::Result<
        crate::output::UpdateDistributionOutput,
        crate::error::UpdateDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_distribution_error(response)
        } else {
            crate::operation_deser::parse_update_distribution_response(response)
        }
    }
}

/// <p>Updates the bundle of your Amazon Lightsail content delivery network (CDN)
/// distribution.</p>
/// <p>A distribution bundle specifies the monthly network transfer quota and monthly cost of
/// your dsitribution.</p>
/// <p>Update your distribution's bundle if your distribution is going over its monthly network
/// transfer quota and is incurring an overage fee.</p>
/// <p>You can update your distribution's bundle only one time within your monthly AWS billing
/// cycle. To determine if you can update your distribution's bundle, use the
/// <code>GetDistributions</code> action. The <code>ableToUpdateBundle</code> parameter in the
/// result will indicate whether you can currently update your distribution's bundle.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDistributionBundle {
    _private: (),
}
impl UpdateDistributionBundle {
    /// Creates a new builder-style object to manufacture [`UpdateDistributionBundleInput`](crate::input::UpdateDistributionBundleInput)
    pub fn builder() -> crate::input::update_distribution_bundle_input::Builder {
        crate::input::update_distribution_bundle_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDistributionBundle {
    type Output = std::result::Result<
        crate::output::UpdateDistributionBundleOutput,
        crate::error::UpdateDistributionBundleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_distribution_bundle_error(response)
        } else {
            crate::operation_deser::parse_update_distribution_bundle_response(response)
        }
    }
}

/// <p>Updates a domain recordset after it is created.</p>
/// <p>The <code>update domain entry</code> operation supports tag-based access control via
/// resource tags applied to the resource identified by <code>domain name</code>. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDomainEntry {
    _private: (),
}
impl UpdateDomainEntry {
    /// Creates a new builder-style object to manufacture [`UpdateDomainEntryInput`](crate::input::UpdateDomainEntryInput)
    pub fn builder() -> crate::input::update_domain_entry_input::Builder {
        crate::input::update_domain_entry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDomainEntry {
    type Output = std::result::Result<
        crate::output::UpdateDomainEntryOutput,
        crate::error::UpdateDomainEntryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_domain_entry_error(response)
        } else {
            crate::operation_deser::parse_update_domain_entry_response(response)
        }
    }
}

/// <p>Updates the specified attribute for a load balancer. You can only update one attribute at
/// a time.</p>
/// <p>The <code>update load balancer attribute</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by <code>load balancer
/// name</code>. For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLoadBalancerAttribute {
    _private: (),
}
impl UpdateLoadBalancerAttribute {
    /// Creates a new builder-style object to manufacture [`UpdateLoadBalancerAttributeInput`](crate::input::UpdateLoadBalancerAttributeInput)
    pub fn builder() -> crate::input::update_load_balancer_attribute_input::Builder {
        crate::input::update_load_balancer_attribute_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateLoadBalancerAttribute {
    type Output = std::result::Result<
        crate::output::UpdateLoadBalancerAttributeOutput,
        crate::error::UpdateLoadBalancerAttributeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_load_balancer_attribute_error(response)
        } else {
            crate::operation_deser::parse_update_load_balancer_attribute_response(response)
        }
    }
}

/// <p>Allows the update of one or more attributes of a database in Amazon Lightsail.</p>
/// <p>Updates are applied immediately, or in cases where the updates could result in an outage,
/// are applied during the database's predefined maintenance window.</p>
/// <p>The <code>update relational database</code> operation supports tag-based access control
/// via resource tags applied to the resource identified by relationalDatabaseName. For more
/// information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRelationalDatabase {
    _private: (),
}
impl UpdateRelationalDatabase {
    /// Creates a new builder-style object to manufacture [`UpdateRelationalDatabaseInput`](crate::input::UpdateRelationalDatabaseInput)
    pub fn builder() -> crate::input::update_relational_database_input::Builder {
        crate::input::update_relational_database_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRelationalDatabase {
    type Output = std::result::Result<
        crate::output::UpdateRelationalDatabaseOutput,
        crate::error::UpdateRelationalDatabaseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_relational_database_error(response)
        } else {
            crate::operation_deser::parse_update_relational_database_response(response)
        }
    }
}

/// <p>Allows the update of one or more parameters of a database in Amazon Lightsail.</p>
/// <p>Parameter updates don't cause outages; therefore, their application is not subject to the
/// preferred maintenance window. However, there are two ways in which parameter updates are
/// applied: <code>dynamic</code> or <code>pending-reboot</code>. Parameters marked with a
/// <code>dynamic</code> apply type are applied immediately. Parameters marked with a
/// <code>pending-reboot</code> apply type are applied only after the database is rebooted using
/// the <code>reboot relational database</code> operation.</p>
/// <p>The <code>update relational database parameters</code> operation supports tag-based access
/// control via resource tags applied to the resource identified by relationalDatabaseName. For
/// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-controlling-access-using-tags">Amazon Lightsail Developer Guide</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRelationalDatabaseParameters {
    _private: (),
}
impl UpdateRelationalDatabaseParameters {
    /// Creates a new builder-style object to manufacture [`UpdateRelationalDatabaseParametersInput`](crate::input::UpdateRelationalDatabaseParametersInput)
    pub fn builder() -> crate::input::update_relational_database_parameters_input::Builder {
        crate::input::update_relational_database_parameters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRelationalDatabaseParameters {
    type Output = std::result::Result<
        crate::output::UpdateRelationalDatabaseParametersOutput,
        crate::error::UpdateRelationalDatabaseParametersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_relational_database_parameters_error(response)
        } else {
            crate::operation_deser::parse_update_relational_database_parameters_response(response)
        }
    }
}
