// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AllocateStaticIpInput`](crate::input::AllocateStaticIpInput)
pub mod allocate_static_ip_input {
    /// A builder for [`AllocateStaticIpInput`](crate::input::AllocateStaticIpInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_ip_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the static IP address.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.static_ip_name = Some(input.into());
            self
        }
        /// <p>The name of the static IP address.</p>
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.static_ip_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AllocateStaticIpInput`](crate::input::AllocateStaticIpInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AllocateStaticIpInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AllocateStaticIpInput {
                static_ip_name: self.static_ip_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AllocateStaticIpInputOperationOutputAlias = crate::operation::AllocateStaticIp;
#[doc(hidden)]
pub type AllocateStaticIpInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AllocateStaticIpInput {
    /// Consumes the builder and constructs an Operation<[`AllocateStaticIp`](crate::operation::AllocateStaticIp)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AllocateStaticIp,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AllocateStaticIpInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AllocateStaticIpInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AllocateStaticIpInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.AllocateStaticIp",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_allocate_static_ip(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AllocateStaticIp::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AllocateStaticIp",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AllocateStaticIpInput`](crate::input::AllocateStaticIpInput)
    pub fn builder() -> crate::input::allocate_static_ip_input::Builder {
        crate::input::allocate_static_ip_input::Builder::default()
    }
}

/// See [`AttachCertificateToDistributionInput`](crate::input::AttachCertificateToDistributionInput)
pub mod attach_certificate_to_distribution_input {
    /// A builder for [`AttachCertificateToDistributionInput`](crate::input::AttachCertificateToDistributionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
        pub(crate) certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution that the certificate will be attached to.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution that the certificate will be attached to.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// <p>The name of the certificate to attach to a distribution.</p>
        /// <p>Only certificates with a status of <code>ISSUED</code> can be attached to a
        /// distribution.</p>
        /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
        /// can specify.</p>
        /// <note>
        /// <p>This is the name of the certificate resource type and is used only to reference the
        /// certificate in other API actions. It can be different than the domain name of the
        /// certificate. For example, your certificate name might be
        /// <code>WordPress-Blog-Certificate</code> and the domain name of the certificate might be
        /// <code>example.com</code>.</p>
        /// </note>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The name of the certificate to attach to a distribution.</p>
        /// <p>Only certificates with a status of <code>ISSUED</code> can be attached to a
        /// distribution.</p>
        /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
        /// can specify.</p>
        /// <note>
        /// <p>This is the name of the certificate resource type and is used only to reference the
        /// certificate in other API actions. It can be different than the domain name of the
        /// certificate. For example, your certificate name might be
        /// <code>WordPress-Blog-Certificate</code> and the domain name of the certificate might be
        /// <code>example.com</code>.</p>
        /// </note>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachCertificateToDistributionInput`](crate::input::AttachCertificateToDistributionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachCertificateToDistributionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachCertificateToDistributionInput {
                distribution_name: self.distribution_name,
                certificate_name: self.certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachCertificateToDistributionInputOperationOutputAlias =
    crate::operation::AttachCertificateToDistribution;
#[doc(hidden)]
pub type AttachCertificateToDistributionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachCertificateToDistributionInput {
    /// Consumes the builder and constructs an Operation<[`AttachCertificateToDistribution`](crate::operation::AttachCertificateToDistribution)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachCertificateToDistribution,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AttachCertificateToDistributionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AttachCertificateToDistributionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AttachCertificateToDistributionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.AttachCertificateToDistribution",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_attach_certificate_to_distribution(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachCertificateToDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachCertificateToDistribution",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachCertificateToDistributionInput`](crate::input::AttachCertificateToDistributionInput)
    pub fn builder() -> crate::input::attach_certificate_to_distribution_input::Builder {
        crate::input::attach_certificate_to_distribution_input::Builder::default()
    }
}

/// See [`AttachDiskInput`](crate::input::AttachDiskInput)
pub mod attach_disk_input {
    /// A builder for [`AttachDiskInput`](crate::input::AttachDiskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) disk_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// <p>The name of the Lightsail instance where you want to utilize the storage disk.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the Lightsail instance where you want to utilize the storage disk.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// <p>The disk path to expose to the instance (e.g., <code>/dev/xvdf</code>).</p>
        pub fn disk_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_path = Some(input.into());
            self
        }
        /// <p>The disk path to expose to the instance (e.g., <code>/dev/xvdf</code>).</p>
        pub fn set_disk_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_path = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachDiskInput`](crate::input::AttachDiskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachDiskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachDiskInput {
                disk_name: self.disk_name,
                instance_name: self.instance_name,
                disk_path: self.disk_path,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachDiskInputOperationOutputAlias = crate::operation::AttachDisk;
#[doc(hidden)]
pub type AttachDiskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachDiskInput {
    /// Consumes the builder and constructs an Operation<[`AttachDisk`](crate::operation::AttachDisk)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachDisk,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AttachDiskInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AttachDiskInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AttachDiskInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.AttachDisk",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_attach_disk(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachDisk::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachDisk",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachDiskInput`](crate::input::AttachDiskInput)
    pub fn builder() -> crate::input::attach_disk_input::Builder {
        crate::input::attach_disk_input::Builder::default()
    }
}

/// See [`AttachInstancesToLoadBalancerInput`](crate::input::AttachInstancesToLoadBalancerInput)
pub mod attach_instances_to_load_balancer_input {
    /// A builder for [`AttachInstancesToLoadBalancerInput`](crate::input::AttachInstancesToLoadBalancerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// Appends an item to `instance_names`.
        ///
        /// To override the contents of this collection use [`set_instance_names`](Self::set_instance_names).
        ///
        /// <p>An array of strings representing the instance name(s) you want to attach to your load
        /// balancer.</p>
        /// <p>An instance must be <code>running</code> before you can attach it to your load
        /// balancer.</p>
        /// <p>There are no additional limits on the number of instances you can attach to your load
        /// balancer, aside from the limit of Lightsail instances you can create in your account
        /// (20).</p>
        pub fn instance_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_names.unwrap_or_default();
            v.push(input.into());
            self.instance_names = Some(v);
            self
        }
        /// <p>An array of strings representing the instance name(s) you want to attach to your load
        /// balancer.</p>
        /// <p>An instance must be <code>running</code> before you can attach it to your load
        /// balancer.</p>
        /// <p>There are no additional limits on the number of instances you can attach to your load
        /// balancer, aside from the limit of Lightsail instances you can create in your account
        /// (20).</p>
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_names = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachInstancesToLoadBalancerInput`](crate::input::AttachInstancesToLoadBalancerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachInstancesToLoadBalancerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachInstancesToLoadBalancerInput {
                load_balancer_name: self.load_balancer_name,
                instance_names: self.instance_names,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachInstancesToLoadBalancerInputOperationOutputAlias =
    crate::operation::AttachInstancesToLoadBalancer;
#[doc(hidden)]
pub type AttachInstancesToLoadBalancerInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachInstancesToLoadBalancerInput {
    /// Consumes the builder and constructs an Operation<[`AttachInstancesToLoadBalancer`](crate::operation::AttachInstancesToLoadBalancer)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachInstancesToLoadBalancer,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AttachInstancesToLoadBalancerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AttachInstancesToLoadBalancerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AttachInstancesToLoadBalancerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.AttachInstancesToLoadBalancer",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_attach_instances_to_load_balancer(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachInstancesToLoadBalancer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachInstancesToLoadBalancer",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachInstancesToLoadBalancerInput`](crate::input::AttachInstancesToLoadBalancerInput)
    pub fn builder() -> crate::input::attach_instances_to_load_balancer_input::Builder {
        crate::input::attach_instances_to_load_balancer_input::Builder::default()
    }
}

/// See [`AttachLoadBalancerTlsCertificateInput`](crate::input::AttachLoadBalancerTlsCertificateInput)
pub mod attach_load_balancer_tls_certificate_input {
    /// A builder for [`AttachLoadBalancerTlsCertificateInput`](crate::input::AttachLoadBalancerTlsCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer to which you want to associate the SSL/TLS
        /// certificate.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer to which you want to associate the SSL/TLS
        /// certificate.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The name of your SSL/TLS certificate.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The name of your SSL/TLS certificate.</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachLoadBalancerTlsCertificateInput`](crate::input::AttachLoadBalancerTlsCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachLoadBalancerTlsCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachLoadBalancerTlsCertificateInput {
                load_balancer_name: self.load_balancer_name,
                certificate_name: self.certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachLoadBalancerTlsCertificateInputOperationOutputAlias =
    crate::operation::AttachLoadBalancerTlsCertificate;
#[doc(hidden)]
pub type AttachLoadBalancerTlsCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachLoadBalancerTlsCertificateInput {
    /// Consumes the builder and constructs an Operation<[`AttachLoadBalancerTlsCertificate`](crate::operation::AttachLoadBalancerTlsCertificate)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachLoadBalancerTlsCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AttachLoadBalancerTlsCertificateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AttachLoadBalancerTlsCertificateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AttachLoadBalancerTlsCertificateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.AttachLoadBalancerTlsCertificate",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_attach_load_balancer_tls_certificate(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachLoadBalancerTlsCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachLoadBalancerTlsCertificate",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachLoadBalancerTlsCertificateInput`](crate::input::AttachLoadBalancerTlsCertificateInput)
    pub fn builder() -> crate::input::attach_load_balancer_tls_certificate_input::Builder {
        crate::input::attach_load_balancer_tls_certificate_input::Builder::default()
    }
}

/// See [`AttachStaticIpInput`](crate::input::AttachStaticIpInput)
pub mod attach_static_ip_input {
    /// A builder for [`AttachStaticIpInput`](crate::input::AttachStaticIpInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_ip_name: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the static IP.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.static_ip_name = Some(input.into());
            self
        }
        /// <p>The name of the static IP.</p>
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.static_ip_name = input;
            self
        }
        /// <p>The instance name to which you want to attach the static IP address.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The instance name to which you want to attach the static IP address.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachStaticIpInput`](crate::input::AttachStaticIpInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AttachStaticIpInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AttachStaticIpInput {
                static_ip_name: self.static_ip_name,
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type AttachStaticIpInputOperationOutputAlias = crate::operation::AttachStaticIp;
#[doc(hidden)]
pub type AttachStaticIpInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AttachStaticIpInput {
    /// Consumes the builder and constructs an Operation<[`AttachStaticIp`](crate::operation::AttachStaticIp)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AttachStaticIp,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AttachStaticIpInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AttachStaticIpInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AttachStaticIpInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.AttachStaticIp",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_attach_static_ip(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AttachStaticIp::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AttachStaticIp",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AttachStaticIpInput`](crate::input::AttachStaticIpInput)
    pub fn builder() -> crate::input::attach_static_ip_input::Builder {
        crate::input::attach_static_ip_input::Builder::default()
    }
}

/// See [`CloseInstancePublicPortsInput`](crate::input::CloseInstancePublicPortsInput)
pub mod close_instance_public_ports_input {
    /// A builder for [`CloseInstancePublicPortsInput`](crate::input::CloseInstancePublicPortsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port_info: std::option::Option<crate::model::PortInfo>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object to describe the ports to close for the specified instance.</p>
        pub fn port_info(mut self, input: crate::model::PortInfo) -> Self {
            self.port_info = Some(input);
            self
        }
        /// <p>An object to describe the ports to close for the specified instance.</p>
        pub fn set_port_info(mut self, input: std::option::Option<crate::model::PortInfo>) -> Self {
            self.port_info = input;
            self
        }
        /// <p>The name of the instance for which to close ports.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance for which to close ports.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CloseInstancePublicPortsInput`](crate::input::CloseInstancePublicPortsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CloseInstancePublicPortsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CloseInstancePublicPortsInput {
                port_info: self.port_info,
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CloseInstancePublicPortsInputOperationOutputAlias =
    crate::operation::CloseInstancePublicPorts;
#[doc(hidden)]
pub type CloseInstancePublicPortsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CloseInstancePublicPortsInput {
    /// Consumes the builder and constructs an Operation<[`CloseInstancePublicPorts`](crate::operation::CloseInstancePublicPorts)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CloseInstancePublicPorts,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CloseInstancePublicPortsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CloseInstancePublicPortsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CloseInstancePublicPortsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CloseInstancePublicPorts",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_close_instance_public_ports(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CloseInstancePublicPorts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CloseInstancePublicPorts",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CloseInstancePublicPortsInput`](crate::input::CloseInstancePublicPortsInput)
    pub fn builder() -> crate::input::close_instance_public_ports_input::Builder {
        crate::input::close_instance_public_ports_input::Builder::default()
    }
}

/// See [`CopySnapshotInput`](crate::input::CopySnapshotInput)
pub mod copy_snapshot_input {
    /// A builder for [`CopySnapshotInput`](crate::input::CopySnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) source_resource_name: std::option::Option<std::string::String>,
        pub(crate) restore_date: std::option::Option<std::string::String>,
        pub(crate) use_latest_restorable_auto_snapshot: std::option::Option<bool>,
        pub(crate) target_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) source_region: std::option::Option<crate::model::RegionName>,
    }
    impl Builder {
        /// <p>The name of the source manual snapshot to copy.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>Define this parameter only when copying a manual snapshot as another manual
        /// snapshot.</p>
        /// </li>
        /// </ul>
        pub fn source_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the source manual snapshot to copy.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>Define this parameter only when copying a manual snapshot as another manual
        /// snapshot.</p>
        /// </li>
        /// </ul>
        pub fn set_source_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_snapshot_name = input;
            self
        }
        /// <p>The name of the source instance or disk from which the source automatic snapshot was
        /// created.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn source_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_resource_name = Some(input.into());
            self
        }
        /// <p>The name of the source instance or disk from which the source automatic snapshot was
        /// created.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_source_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_resource_name = input;
            self
        }
        /// <p>The date of the source automatic snapshot to copy. Use the <code>get auto snapshots</code>
        /// operation to identify the dates of the available automatic snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn restore_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore_date = Some(input.into());
            self
        }
        /// <p>The date of the source automatic snapshot to copy. Use the <code>get auto snapshots</code>
        /// operation to identify the dates of the available automatic snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_restore_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.restore_date = input;
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot of the
        /// specified source instance or disk.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn use_latest_restorable_auto_snapshot(mut self, input: bool) -> Self {
            self.use_latest_restorable_auto_snapshot = Some(input);
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot of the
        /// specified source instance or disk.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_use_latest_restorable_auto_snapshot(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_latest_restorable_auto_snapshot = input;
            self
        }
        /// <p>The name of the new manual snapshot to be created as a copy.</p>
        pub fn target_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the new manual snapshot to be created as a copy.</p>
        pub fn set_target_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_snapshot_name = input;
            self
        }
        /// <p>The AWS Region where the source manual or automatic snapshot is located.</p>
        pub fn source_region(mut self, input: crate::model::RegionName) -> Self {
            self.source_region = Some(input);
            self
        }
        /// <p>The AWS Region where the source manual or automatic snapshot is located.</p>
        pub fn set_source_region(
            mut self,
            input: std::option::Option<crate::model::RegionName>,
        ) -> Self {
            self.source_region = input;
            self
        }
        /// Consumes the builder and constructs a [`CopySnapshotInput`](crate::input::CopySnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CopySnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CopySnapshotInput {
                source_snapshot_name: self.source_snapshot_name,
                source_resource_name: self.source_resource_name,
                restore_date: self.restore_date,
                use_latest_restorable_auto_snapshot: self.use_latest_restorable_auto_snapshot,
                target_snapshot_name: self.target_snapshot_name,
                source_region: self.source_region,
            })
        }
    }
}
#[doc(hidden)]
pub type CopySnapshotInputOperationOutputAlias = crate::operation::CopySnapshot;
#[doc(hidden)]
pub type CopySnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CopySnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CopySnapshot`](crate::operation::CopySnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CopySnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CopySnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CopySnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CopySnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CopySnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_copy_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CopySnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CopySnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CopySnapshotInput`](crate::input::CopySnapshotInput)
    pub fn builder() -> crate::input::copy_snapshot_input::Builder {
        crate::input::copy_snapshot_input::Builder::default()
    }
}

/// See [`CreateBucketInput`](crate::input::CreateBucketInput)
pub mod create_bucket_input {
    /// A builder for [`CreateBucketInput`](crate::input::CreateBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) enable_object_versioning: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name for the bucket.</p>
        ///
        /// <p>For more information about bucket names, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/bucket-naming-rules-in-amazon-lightsail">Bucket naming rules in Amazon Lightsail</a> in the <i>Amazon Lightsail Developer
        /// Guide</i>.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name for the bucket.</p>
        ///
        /// <p>For more information about bucket names, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/bucket-naming-rules-in-amazon-lightsail">Bucket naming rules in Amazon Lightsail</a> in the <i>Amazon Lightsail Developer
        /// Guide</i>.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The ID of the bundle to use for the bucket.</p>
        ///
        /// <p>A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a
        /// bucket.</p>
        ///
        /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
        /// specify.</p>
        ///
        /// <p>Use the <a>UpdateBucketBundle</a> action to change the bundle after the bucket
        /// is created.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The ID of the bundle to use for the bucket.</p>
        ///
        /// <p>A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a
        /// bucket.</p>
        ///
        /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
        /// specify.</p>
        ///
        /// <p>Use the <a>UpdateBucketBundle</a> action to change the bundle after the bucket
        /// is created.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the bucket during creation.</p>
        ///
        /// <p>Use the <a>TagResource</a> action to tag the bucket after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the bucket during creation.</p>
        ///
        /// <p>Use the <a>TagResource</a> action to tag the bucket after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A Boolean value that indicates whether to enable versioning of objects in the
        /// bucket.</p>
        ///
        /// <p>For more information about versioning, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-managing-bucket-object-versioning">Enabling and suspending object versioning in a bucket in Amazon Lightsail</a> in the
        /// <i>Amazon Lightsail Developer Guide</i>.</p>
        pub fn enable_object_versioning(mut self, input: bool) -> Self {
            self.enable_object_versioning = Some(input);
            self
        }
        /// <p>A Boolean value that indicates whether to enable versioning of objects in the
        /// bucket.</p>
        ///
        /// <p>For more information about versioning, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-managing-bucket-object-versioning">Enabling and suspending object versioning in a bucket in Amazon Lightsail</a> in the
        /// <i>Amazon Lightsail Developer Guide</i>.</p>
        pub fn set_enable_object_versioning(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_object_versioning = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBucketInput`](crate::input::CreateBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateBucketInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateBucketInput {
                bucket_name: self.bucket_name,
                bundle_id: self.bundle_id,
                tags: self.tags,
                enable_object_versioning: self.enable_object_versioning,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBucketInputOperationOutputAlias = crate::operation::CreateBucket;
#[doc(hidden)]
pub type CreateBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBucketInput {
    /// Consumes the builder and constructs an Operation<[`CreateBucket`](crate::operation::CreateBucket)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateBucketInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateBucketInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateBucket",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_bucket(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateBucket::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateBucket",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBucketInput`](crate::input::CreateBucketInput)
    pub fn builder() -> crate::input::create_bucket_input::Builder {
        crate::input::create_bucket_input::Builder::default()
    }
}

/// See [`CreateBucketAccessKeyInput`](crate::input::CreateBucketAccessKeyInput)
pub mod create_bucket_access_key_input {
    /// A builder for [`CreateBucketAccessKeyInput`](crate::input::CreateBucketAccessKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket that the new access key will belong to, and grant access to.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket that the new access key will belong to, and grant access to.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateBucketAccessKeyInput`](crate::input::CreateBucketAccessKeyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateBucketAccessKeyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateBucketAccessKeyInput {
                bucket_name: self.bucket_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateBucketAccessKeyInputOperationOutputAlias = crate::operation::CreateBucketAccessKey;
#[doc(hidden)]
pub type CreateBucketAccessKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateBucketAccessKeyInput {
    /// Consumes the builder and constructs an Operation<[`CreateBucketAccessKey`](crate::operation::CreateBucketAccessKey)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateBucketAccessKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateBucketAccessKeyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateBucketAccessKeyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateBucketAccessKeyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateBucketAccessKey",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_bucket_access_key(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateBucketAccessKey::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateBucketAccessKey",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateBucketAccessKeyInput`](crate::input::CreateBucketAccessKeyInput)
    pub fn builder() -> crate::input::create_bucket_access_key_input::Builder {
        crate::input::create_bucket_access_key_input::Builder::default()
    }
}

/// See [`CreateCertificateInput`](crate::input::CreateCertificateInput)
pub mod create_certificate_input {
    /// A builder for [`CreateCertificateInput`](crate::input::CreateCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_name: std::option::Option<std::string::String>,
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) subject_alternative_names:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name for the certificate.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The name for the certificate.</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for the certificate.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for the certificate.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Appends an item to `subject_alternative_names`.
        ///
        /// To override the contents of this collection use [`set_subject_alternative_names`](Self::set_subject_alternative_names).
        ///
        /// <p>An array of strings that specify the alternate domains (e.g., <code>example2.com</code>)
        /// and subdomains (e.g., <code>blog.example.com</code>) for the certificate.</p>
        /// <p>You can specify a maximum of nine alternate domains (in addition to the primary domain
        /// name).</p>
        /// <p>Wildcard domain entries (e.g., <code>*.example.com</code>) are not supported.</p>
        pub fn subject_alternative_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subject_alternative_names.unwrap_or_default();
            v.push(input.into());
            self.subject_alternative_names = Some(v);
            self
        }
        /// <p>An array of strings that specify the alternate domains (e.g., <code>example2.com</code>)
        /// and subdomains (e.g., <code>blog.example.com</code>) for the certificate.</p>
        /// <p>You can specify a maximum of nine alternate domains (in addition to the primary domain
        /// name).</p>
        /// <p>Wildcard domain entries (e.g., <code>*.example.com</code>) are not supported.</p>
        pub fn set_subject_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subject_alternative_names = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the certificate during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the certificate during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCertificateInput`](crate::input::CreateCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCertificateInput {
                certificate_name: self.certificate_name,
                domain_name: self.domain_name,
                subject_alternative_names: self.subject_alternative_names,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCertificateInputOperationOutputAlias = crate::operation::CreateCertificate;
#[doc(hidden)]
pub type CreateCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateCertificateInput {
    /// Consumes the builder and constructs an Operation<[`CreateCertificate`](crate::operation::CreateCertificate)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateCertificateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateCertificateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateCertificateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateCertificate",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_certificate(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCertificate",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateCertificateInput`](crate::input::CreateCertificateInput)
    pub fn builder() -> crate::input::create_certificate_input::Builder {
        crate::input::create_certificate_input::Builder::default()
    }
}

/// See [`CreateCloudFormationStackInput`](crate::input::CreateCloudFormationStackInput)
pub mod create_cloud_formation_stack_input {
    /// A builder for [`CreateCloudFormationStackInput`](crate::input::CreateCloudFormationStackInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instances: std::option::Option<std::vec::Vec<crate::model::InstanceEntry>>,
    }
    impl Builder {
        /// Appends an item to `instances`.
        ///
        /// To override the contents of this collection use [`set_instances`](Self::set_instances).
        ///
        /// <p>An array of parameters that will be used to create the new Amazon EC2 instance. You can only
        /// pass one instance entry at a time in this array. You will get an invalid parameter error if
        /// you pass more than one instance entry in this array.</p>
        pub fn instances(mut self, input: impl Into<crate::model::InstanceEntry>) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input.into());
            self.instances = Some(v);
            self
        }
        /// <p>An array of parameters that will be used to create the new Amazon EC2 instance. You can only
        /// pass one instance entry at a time in this array. You will get an invalid parameter error if
        /// you pass more than one instance entry in this array.</p>
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceEntry>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCloudFormationStackInput`](crate::input::CreateCloudFormationStackInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCloudFormationStackInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCloudFormationStackInput {
                instances: self.instances,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCloudFormationStackInputOperationOutputAlias =
    crate::operation::CreateCloudFormationStack;
#[doc(hidden)]
pub type CreateCloudFormationStackInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateCloudFormationStackInput {
    /// Consumes the builder and constructs an Operation<[`CreateCloudFormationStack`](crate::operation::CreateCloudFormationStack)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCloudFormationStack,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateCloudFormationStackInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateCloudFormationStackInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateCloudFormationStackInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateCloudFormationStack",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_cloud_formation_stack(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCloudFormationStack::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCloudFormationStack",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateCloudFormationStackInput`](crate::input::CreateCloudFormationStackInput)
    pub fn builder() -> crate::input::create_cloud_formation_stack_input::Builder {
        crate::input::create_cloud_formation_stack_input::Builder::default()
    }
}

/// See [`CreateContactMethodInput`](crate::input::CreateContactMethodInput)
pub mod create_contact_method_input {
    /// A builder for [`CreateContactMethodInput`](crate::input::CreateContactMethodInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::ContactProtocol>,
        pub(crate) contact_endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The protocol of the contact method, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        /// <p>The <code>SMS</code> protocol is supported only in the following AWS Regions.</p>
        /// <ul>
        /// <li>
        /// <p>US East (N. Virginia) (<code>us-east-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>US West (Oregon) (<code>us-west-2</code>)</p>
        /// </li>
        /// <li>
        /// <p>Europe (Ireland) (<code>eu-west-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Tokyo) (<code>ap-northeast-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Singapore) (<code>ap-southeast-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Sydney) (<code>ap-southeast-2</code>)</p>
        /// </li>
        /// </ul>
        /// <p>For a list of countries/regions where SMS text messages can be sent, and the latest AWS
        /// Regions where SMS text messaging is supported, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-supported-regions-countries.html">Supported Regions and Countries</a> in the <i>Amazon SNS Developer
        /// Guide</i>.</p>
        /// <p>For more information about notifications in Amazon Lightsail, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
        pub fn protocol(mut self, input: crate::model::ContactProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol of the contact method, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        /// <p>The <code>SMS</code> protocol is supported only in the following AWS Regions.</p>
        /// <ul>
        /// <li>
        /// <p>US East (N. Virginia) (<code>us-east-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>US West (Oregon) (<code>us-west-2</code>)</p>
        /// </li>
        /// <li>
        /// <p>Europe (Ireland) (<code>eu-west-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Tokyo) (<code>ap-northeast-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Singapore) (<code>ap-southeast-1</code>)</p>
        /// </li>
        /// <li>
        /// <p>Asia Pacific (Sydney) (<code>ap-southeast-2</code>)</p>
        /// </li>
        /// </ul>
        /// <p>For a list of countries/regions where SMS text messages can be sent, and the latest AWS
        /// Regions where SMS text messaging is supported, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-supported-regions-countries.html">Supported Regions and Countries</a> in the <i>Amazon SNS Developer
        /// Guide</i>.</p>
        /// <p>For more information about notifications in Amazon Lightsail, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ContactProtocol>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// <p>The destination of the contact method, such as an email address or a mobile phone
        /// number.</p>
        /// <p>Use the E.164 format when specifying a mobile phone number. E.164 is a standard for the
        /// phone number structure used for international telecommunication. Phone numbers that follow
        /// this format can have a maximum of 15 digits, and they are prefixed with the plus character (+)
        /// and the country code. For example, a U.S. phone number in E.164 format would be specified as
        /// +1XXX5550100. For more information, see <a href="https://en.wikipedia.org/wiki/E.164">E.164</a> on <i>Wikipedia</i>.</p>
        pub fn contact_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_endpoint = Some(input.into());
            self
        }
        /// <p>The destination of the contact method, such as an email address or a mobile phone
        /// number.</p>
        /// <p>Use the E.164 format when specifying a mobile phone number. E.164 is a standard for the
        /// phone number structure used for international telecommunication. Phone numbers that follow
        /// this format can have a maximum of 15 digits, and they are prefixed with the plus character (+)
        /// and the country code. For example, a U.S. phone number in E.164 format would be specified as
        /// +1XXX5550100. For more information, see <a href="https://en.wikipedia.org/wiki/E.164">E.164</a> on <i>Wikipedia</i>.</p>
        pub fn set_contact_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.contact_endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateContactMethodInput`](crate::input::CreateContactMethodInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateContactMethodInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateContactMethodInput {
                protocol: self.protocol,
                contact_endpoint: self.contact_endpoint,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateContactMethodInputOperationOutputAlias = crate::operation::CreateContactMethod;
#[doc(hidden)]
pub type CreateContactMethodInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateContactMethodInput {
    /// Consumes the builder and constructs an Operation<[`CreateContactMethod`](crate::operation::CreateContactMethod)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateContactMethod,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateContactMethodInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateContactMethodInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateContactMethodInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateContactMethod",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_contact_method(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateContactMethod::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateContactMethod",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateContactMethodInput`](crate::input::CreateContactMethodInput)
    pub fn builder() -> crate::input::create_contact_method_input::Builder {
        crate::input::create_contact_method_input::Builder::default()
    }
}

/// See [`CreateContainerServiceInput`](crate::input::CreateContainerServiceInput)
pub mod create_container_service_input {
    /// A builder for [`CreateContainerServiceInput`](crate::input::CreateContainerServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) power: std::option::Option<crate::model::ContainerServicePowerName>,
        pub(crate) scale: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) public_domain_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) deployment: std::option::Option<crate::model::ContainerServiceDeploymentRequest>,
    }
    impl Builder {
        /// <p>The name for the container service.</p>
        ///
        /// <p>The name that you specify for your container service will make up part of its default
        /// domain. The default domain of a container service is typically
        /// <code>https://<ServiceName>.<RandomGUID>.<AWSRegion>.cs.amazonlightsail.com</code>.
        /// If the name of your container service is <code>container-service-1</code>, and it's located in
        /// the US East (Ohio) AWS region (<code>us-east-2</code>), then the domain for your container
        /// service will be like the following example:
        /// <code>https://container-service-1.ur4EXAMPLE2uq.us-east-2.cs.amazonlightsail.com</code>
        /// </p>
        ///
        /// <p>The following are the requirements for container service names:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Must be unique within each AWS Region in your Lightsail account.</p>
        /// </li>
        /// <li>
        /// <p>Must contain 1 to 63 characters.</p>
        /// </li>
        /// <li>
        /// <p>Must contain only alphanumeric characters and hyphens.</p>
        /// </li>
        /// <li>
        /// <p>A hyphen (-) can separate words but cannot be at the start or end of the name.</p>
        /// </li>
        /// </ul>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name for the container service.</p>
        ///
        /// <p>The name that you specify for your container service will make up part of its default
        /// domain. The default domain of a container service is typically
        /// <code>https://<ServiceName>.<RandomGUID>.<AWSRegion>.cs.amazonlightsail.com</code>.
        /// If the name of your container service is <code>container-service-1</code>, and it's located in
        /// the US East (Ohio) AWS region (<code>us-east-2</code>), then the domain for your container
        /// service will be like the following example:
        /// <code>https://container-service-1.ur4EXAMPLE2uq.us-east-2.cs.amazonlightsail.com</code>
        /// </p>
        ///
        /// <p>The following are the requirements for container service names:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Must be unique within each AWS Region in your Lightsail account.</p>
        /// </li>
        /// <li>
        /// <p>Must contain 1 to 63 characters.</p>
        /// </li>
        /// <li>
        /// <p>Must contain only alphanumeric characters and hyphens.</p>
        /// </li>
        /// <li>
        /// <p>A hyphen (-) can separate words but cannot be at the start or end of the name.</p>
        /// </li>
        /// </ul>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The power specification for the container service.</p>
        ///
        /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
        /// container service. The <code>power</code> and <code>scale</code> of a container service makes
        /// up its configured capacity. To determine the monthly price of your container service, multiply
        /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
        /// the service.</p>
        ///
        /// <p>Use the <code>GetContainerServicePowers</code> action to get a list of power options that
        /// you can specify using this parameter, and their base monthly cost.</p>
        pub fn power(mut self, input: crate::model::ContainerServicePowerName) -> Self {
            self.power = Some(input);
            self
        }
        /// <p>The power specification for the container service.</p>
        ///
        /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
        /// container service. The <code>power</code> and <code>scale</code> of a container service makes
        /// up its configured capacity. To determine the monthly price of your container service, multiply
        /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
        /// the service.</p>
        ///
        /// <p>Use the <code>GetContainerServicePowers</code> action to get a list of power options that
        /// you can specify using this parameter, and their base monthly cost.</p>
        pub fn set_power(
            mut self,
            input: std::option::Option<crate::model::ContainerServicePowerName>,
        ) -> Self {
            self.power = input;
            self
        }
        /// <p>The scale specification for the container service.</p>
        ///
        /// <p>The scale specifies the allocated compute nodes of the container service. The
        /// <code>power</code> and <code>scale</code> of a container service makes up its configured
        /// capacity. To determine the monthly price of your container service, multiply the base price of
        /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
        /// service.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.scale = Some(input);
            self
        }
        /// <p>The scale specification for the container service.</p>
        ///
        /// <p>The scale specifies the allocated compute nodes of the container service. The
        /// <code>power</code> and <code>scale</code> of a container service makes up its configured
        /// capacity. To determine the monthly price of your container service, multiply the base price of
        /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
        /// service.</p>
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.scale = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the container service during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        /// <p>For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the container service during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        /// <p>For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Adds a key-value pair to `public_domain_names`.
        ///
        /// To override the contents of this collection use [`set_public_domain_names`](Self::set_public_domain_names).
        ///
        /// <p>The public domain names to use with the container service, such as
        /// <code>example.com</code> and <code>www.example.com</code>.</p>
        ///
        /// <p>You can specify up to four public domain names for a container service. The domain names
        /// that you specify are used when you create a deployment with a container configured as the
        /// public endpoint of your container service.</p>
        ///
        /// <p>If you don't specify public domain names, then you can use the default domain of the
        /// container service.</p>
        ///
        /// <important>
        /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
        /// names with your container service. Use the <code>CreateCertificate</code> action to create a
        /// certificate for the public domain names you want to use with your container service.</p>
        /// </important>
        ///
        /// <p>You can specify public domain names using a string to array map as shown in the example
        /// later on this page.</p>
        pub fn public_domain_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.public_domain_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.public_domain_names = Some(hash_map);
            self
        }
        /// <p>The public domain names to use with the container service, such as
        /// <code>example.com</code> and <code>www.example.com</code>.</p>
        ///
        /// <p>You can specify up to four public domain names for a container service. The domain names
        /// that you specify are used when you create a deployment with a container configured as the
        /// public endpoint of your container service.</p>
        ///
        /// <p>If you don't specify public domain names, then you can use the default domain of the
        /// container service.</p>
        ///
        /// <important>
        /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
        /// names with your container service. Use the <code>CreateCertificate</code> action to create a
        /// certificate for the public domain names you want to use with your container service.</p>
        /// </important>
        ///
        /// <p>You can specify public domain names using a string to array map as shown in the example
        /// later on this page.</p>
        pub fn set_public_domain_names(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.public_domain_names = input;
            self
        }
        /// <p>An object that describes a deployment for the container service.</p>
        ///
        /// <p>A deployment specifies the containers that will be launched on the container service and
        /// their settings, such as the ports to open, the environment variables to apply, and the launch
        /// command to run. It also specifies the container that will serve as the public endpoint of the
        /// deployment and its settings, such as the HTTP or HTTPS port to use, and the health check
        /// configuration.</p>
        pub fn deployment(
            mut self,
            input: crate::model::ContainerServiceDeploymentRequest,
        ) -> Self {
            self.deployment = Some(input);
            self
        }
        /// <p>An object that describes a deployment for the container service.</p>
        ///
        /// <p>A deployment specifies the containers that will be launched on the container service and
        /// their settings, such as the ports to open, the environment variables to apply, and the launch
        /// command to run. It also specifies the container that will serve as the public endpoint of the
        /// deployment and its settings, such as the HTTP or HTTPS port to use, and the health check
        /// configuration.</p>
        pub fn set_deployment(
            mut self,
            input: std::option::Option<crate::model::ContainerServiceDeploymentRequest>,
        ) -> Self {
            self.deployment = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateContainerServiceInput`](crate::input::CreateContainerServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateContainerServiceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateContainerServiceInput {
                service_name: self.service_name,
                power: self.power,
                scale: self.scale,
                tags: self.tags,
                public_domain_names: self.public_domain_names,
                deployment: self.deployment,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateContainerServiceInputOperationOutputAlias = crate::operation::CreateContainerService;
#[doc(hidden)]
pub type CreateContainerServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateContainerServiceInput {
    /// Consumes the builder and constructs an Operation<[`CreateContainerService`](crate::operation::CreateContainerService)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateContainerService,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateContainerServiceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateContainerServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateContainerServiceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateContainerService",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_container_service(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateContainerService::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateContainerService",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateContainerServiceInput`](crate::input::CreateContainerServiceInput)
    pub fn builder() -> crate::input::create_container_service_input::Builder {
        crate::input::create_container_service_input::Builder::default()
    }
}

/// See [`CreateContainerServiceDeploymentInput`](crate::input::CreateContainerServiceDeploymentInput)
pub mod create_container_service_deployment_input {
    /// A builder for [`CreateContainerServiceDeploymentInput`](crate::input::CreateContainerServiceDeploymentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) containers: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Container>,
        >,
        pub(crate) public_endpoint: std::option::Option<crate::model::EndpointRequest>,
    }
    impl Builder {
        /// <p>The name of the container service for which to create the deployment.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to create the deployment.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// Adds a key-value pair to `containers`.
        ///
        /// To override the contents of this collection use [`set_containers`](Self::set_containers).
        ///
        /// <p>An object that describes the settings of the containers that will be launched on the
        /// container service.</p>
        pub fn containers(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Container>,
        ) -> Self {
            let mut hash_map = self.containers.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.containers = Some(hash_map);
            self
        }
        /// <p>An object that describes the settings of the containers that will be launched on the
        /// container service.</p>
        pub fn set_containers(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Container>,
            >,
        ) -> Self {
            self.containers = input;
            self
        }
        /// <p>An object that describes the settings of the public endpoint for the container
        /// service.</p>
        pub fn public_endpoint(mut self, input: crate::model::EndpointRequest) -> Self {
            self.public_endpoint = Some(input);
            self
        }
        /// <p>An object that describes the settings of the public endpoint for the container
        /// service.</p>
        pub fn set_public_endpoint(
            mut self,
            input: std::option::Option<crate::model::EndpointRequest>,
        ) -> Self {
            self.public_endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateContainerServiceDeploymentInput`](crate::input::CreateContainerServiceDeploymentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateContainerServiceDeploymentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateContainerServiceDeploymentInput {
                service_name: self.service_name,
                containers: self.containers,
                public_endpoint: self.public_endpoint,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateContainerServiceDeploymentInputOperationOutputAlias =
    crate::operation::CreateContainerServiceDeployment;
#[doc(hidden)]
pub type CreateContainerServiceDeploymentInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateContainerServiceDeploymentInput {
    /// Consumes the builder and constructs an Operation<[`CreateContainerServiceDeployment`](crate::operation::CreateContainerServiceDeployment)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateContainerServiceDeployment,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateContainerServiceDeploymentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateContainerServiceDeploymentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateContainerServiceDeploymentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateContainerServiceDeployment",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_container_service_deployment(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateContainerServiceDeployment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateContainerServiceDeployment",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateContainerServiceDeploymentInput`](crate::input::CreateContainerServiceDeploymentInput)
    pub fn builder() -> crate::input::create_container_service_deployment_input::Builder {
        crate::input::create_container_service_deployment_input::Builder::default()
    }
}

/// See [`CreateContainerServiceRegistryLoginInput`](crate::input::CreateContainerServiceRegistryLoginInput)
pub mod create_container_service_registry_login_input {
    /// A builder for [`CreateContainerServiceRegistryLoginInput`](crate::input::CreateContainerServiceRegistryLoginInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CreateContainerServiceRegistryLoginInput`](crate::input::CreateContainerServiceRegistryLoginInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateContainerServiceRegistryLoginInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateContainerServiceRegistryLoginInput {})
        }
    }
}
#[doc(hidden)]
pub type CreateContainerServiceRegistryLoginInputOperationOutputAlias =
    crate::operation::CreateContainerServiceRegistryLogin;
#[doc(hidden)]
pub type CreateContainerServiceRegistryLoginInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl CreateContainerServiceRegistryLoginInput {
    /// Consumes the builder and constructs an Operation<[`CreateContainerServiceRegistryLogin`](crate::operation::CreateContainerServiceRegistryLogin)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateContainerServiceRegistryLogin,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateContainerServiceRegistryLoginInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateContainerServiceRegistryLoginInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateContainerServiceRegistryLoginInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateContainerServiceRegistryLogin",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_container_service_registry_login(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateContainerServiceRegistryLogin::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateContainerServiceRegistryLogin",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateContainerServiceRegistryLoginInput`](crate::input::CreateContainerServiceRegistryLoginInput)
    pub fn builder() -> crate::input::create_container_service_registry_login_input::Builder {
        crate::input::create_container_service_registry_login_input::Builder::default()
    }
}

/// See [`CreateDiskInput`](crate::input::CreateDiskInput)
pub mod create_disk_input {
    /// A builder for [`CreateDiskInput`](crate::input::CreateDiskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) size_in_gb: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
    }
    impl Builder {
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
        /// Use the same Availability Zone as the Lightsail instance to which you want to attach the
        /// disk.</p>
        /// <p>Use the <code>get regions</code> operation to list the Availability Zones where
        /// Lightsail is currently available.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
        /// Use the same Availability Zone as the Lightsail instance to which you want to attach the
        /// disk.</p>
        /// <p>Use the <code>get regions</code> operation to list the Availability Zones where
        /// Lightsail is currently available.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
        pub fn size_in_gb(mut self, input: i32) -> Self {
            self.size_in_gb = Some(input);
            self
        }
        /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
        pub fn set_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.size_in_gb = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `add_ons`.
        ///
        /// To override the contents of this collection use [`set_add_ons`](Self::set_add_ons).
        ///
        /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
        pub fn add_ons(mut self, input: impl Into<crate::model::AddOnRequest>) -> Self {
            let mut v = self.add_ons.unwrap_or_default();
            v.push(input.into());
            self.add_ons = Some(v);
            self
        }
        /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.add_ons = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDiskInput`](crate::input::CreateDiskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDiskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDiskInput {
                disk_name: self.disk_name,
                availability_zone: self.availability_zone,
                size_in_gb: self.size_in_gb,
                tags: self.tags,
                add_ons: self.add_ons,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDiskInputOperationOutputAlias = crate::operation::CreateDisk;
#[doc(hidden)]
pub type CreateDiskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDiskInput {
    /// Consumes the builder and constructs an Operation<[`CreateDisk`](crate::operation::CreateDisk)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDisk,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDiskInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDiskInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDiskInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateDisk",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_disk(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDisk::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDisk",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDiskInput`](crate::input::CreateDiskInput)
    pub fn builder() -> crate::input::create_disk_input::Builder {
        crate::input::create_disk_input::Builder::default()
    }
}

/// See [`CreateDiskFromSnapshotInput`](crate::input::CreateDiskFromSnapshotInput)
pub mod create_disk_from_snapshot_input {
    /// A builder for [`CreateDiskFromSnapshotInput`](crate::input::CreateDiskFromSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
        pub(crate) disk_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) size_in_gb: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        pub(crate) source_disk_name: std::option::Option<std::string::String>,
        pub(crate) restore_date: std::option::Option<std::string::String>,
        pub(crate) use_latest_restorable_auto_snapshot: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// <p>The name of the disk snapshot (e.g., <code>my-snapshot</code>) from which to create the
        /// new storage disk.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>source disk name</code>
        /// parameter. The <code>disk snapshot name</code> and <code>source disk name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// </ul>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the disk snapshot (e.g., <code>my-snapshot</code>) from which to create the
        /// new storage disk.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>source disk name</code>
        /// parameter. The <code>disk snapshot name</code> and <code>source disk name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// </ul>
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_snapshot_name = input;
            self
        }
        /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
        /// Choose the same Availability Zone as the Lightsail instance where you want to create the
        /// disk.</p>
        /// <p>Use the GetRegions operation to list the Availability Zones where Lightsail is currently
        /// available.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
        /// Choose the same Availability Zone as the Lightsail instance where you want to create the
        /// disk.</p>
        /// <p>Use the GetRegions operation to list the Availability Zones where Lightsail is currently
        /// available.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
        pub fn size_in_gb(mut self, input: i32) -> Self {
            self.size_in_gb = Some(input);
            self
        }
        /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
        pub fn set_size_in_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.size_in_gb = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `add_ons`.
        ///
        /// To override the contents of this collection use [`set_add_ons`](Self::set_add_ons).
        ///
        /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
        pub fn add_ons(mut self, input: impl Into<crate::model::AddOnRequest>) -> Self {
            let mut v = self.add_ons.unwrap_or_default();
            v.push(input.into());
            self.add_ons = Some(v);
            self
        }
        /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.add_ons = input;
            self
        }
        /// <p>The name of the source disk from which the source automatic snapshot was created.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>disk snapshot name</code>
        /// parameter. The <code>source disk name</code> and <code>disk snapshot name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn source_disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_disk_name = Some(input.into());
            self
        }
        /// <p>The name of the source disk from which the source automatic snapshot was created.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>disk snapshot name</code>
        /// parameter. The <code>source disk name</code> and <code>disk snapshot name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_source_disk_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_disk_name = input;
            self
        }
        /// <p>The date of the automatic snapshot to use for the new disk. Use the <code>get auto
        /// snapshots</code> operation to identify the dates of the available automatic
        /// snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn restore_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore_date = Some(input.into());
            self
        }
        /// <p>The date of the automatic snapshot to use for the new disk. Use the <code>get auto
        /// snapshots</code> operation to identify the dates of the available automatic
        /// snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_restore_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.restore_date = input;
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn use_latest_restorable_auto_snapshot(mut self, input: bool) -> Self {
            self.use_latest_restorable_auto_snapshot = Some(input);
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
        /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_use_latest_restorable_auto_snapshot(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_latest_restorable_auto_snapshot = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDiskFromSnapshotInput`](crate::input::CreateDiskFromSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDiskFromSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDiskFromSnapshotInput {
                disk_name: self.disk_name,
                disk_snapshot_name: self.disk_snapshot_name,
                availability_zone: self.availability_zone,
                size_in_gb: self.size_in_gb,
                tags: self.tags,
                add_ons: self.add_ons,
                source_disk_name: self.source_disk_name,
                restore_date: self.restore_date,
                use_latest_restorable_auto_snapshot: self.use_latest_restorable_auto_snapshot,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDiskFromSnapshotInputOperationOutputAlias = crate::operation::CreateDiskFromSnapshot;
#[doc(hidden)]
pub type CreateDiskFromSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDiskFromSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateDiskFromSnapshot`](crate::operation::CreateDiskFromSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDiskFromSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDiskFromSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDiskFromSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDiskFromSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateDiskFromSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_disk_from_snapshot(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDiskFromSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDiskFromSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDiskFromSnapshotInput`](crate::input::CreateDiskFromSnapshotInput)
    pub fn builder() -> crate::input::create_disk_from_snapshot_input::Builder {
        crate::input::create_disk_from_snapshot_input::Builder::default()
    }
}

/// See [`CreateDiskSnapshotInput`](crate::input::CreateDiskSnapshotInput)
pub mod create_disk_snapshot_input {
    /// A builder for [`CreateDiskSnapshotInput`](crate::input::CreateDiskSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
        pub(crate) disk_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The unique name of the source disk (e.g., <code>Disk-Virginia-1</code>).</p>
        /// <note>
        /// <p>This parameter cannot be defined together with the <code>instance name</code> parameter.
        /// The <code>disk name</code> and <code>instance name</code> parameters are mutually
        /// exclusive.</p>
        /// </note>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The unique name of the source disk (e.g., <code>Disk-Virginia-1</code>).</p>
        /// <note>
        /// <p>This parameter cannot be defined together with the <code>instance name</code> parameter.
        /// The <code>disk name</code> and <code>instance name</code> parameters are mutually
        /// exclusive.</p>
        /// </note>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// <p>The name of the destination disk snapshot (e.g., <code>my-disk-snapshot</code>) based on
        /// the source disk.</p>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the destination disk snapshot (e.g., <code>my-disk-snapshot</code>) based on
        /// the source disk.</p>
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_snapshot_name = input;
            self
        }
        /// <p>The unique name of the source instance (e.g., <code>Amazon_Linux-512MB-Virginia-1</code>).
        /// When this is defined, a snapshot of the instance's system volume is created.</p>
        /// <note>
        /// <p>This parameter cannot be defined together with the <code>disk name</code> parameter. The
        /// <code>instance name</code> and <code>disk name</code> parameters are mutually
        /// exclusive.</p>
        /// </note>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The unique name of the source instance (e.g., <code>Amazon_Linux-512MB-Virginia-1</code>).
        /// When this is defined, a snapshot of the instance's system volume is created.</p>
        /// <note>
        /// <p>This parameter cannot be defined together with the <code>disk name</code> parameter. The
        /// <code>instance name</code> and <code>disk name</code> parameters are mutually
        /// exclusive.</p>
        /// </note>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDiskSnapshotInput`](crate::input::CreateDiskSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDiskSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDiskSnapshotInput {
                disk_name: self.disk_name,
                disk_snapshot_name: self.disk_snapshot_name,
                instance_name: self.instance_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDiskSnapshotInputOperationOutputAlias = crate::operation::CreateDiskSnapshot;
#[doc(hidden)]
pub type CreateDiskSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDiskSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateDiskSnapshot`](crate::operation::CreateDiskSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDiskSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDiskSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDiskSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDiskSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateDiskSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_disk_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDiskSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDiskSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDiskSnapshotInput`](crate::input::CreateDiskSnapshotInput)
    pub fn builder() -> crate::input::create_disk_snapshot_input::Builder {
        crate::input::create_disk_snapshot_input::Builder::default()
    }
}

/// See [`CreateDistributionInput`](crate::input::CreateDistributionInput)
pub mod create_distribution_input {
    /// A builder for [`CreateDistributionInput`](crate::input::CreateDistributionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<crate::model::InputOrigin>,
        pub(crate) default_cache_behavior: std::option::Option<crate::model::CacheBehavior>,
        pub(crate) cache_behavior_settings: std::option::Option<crate::model::CacheSettings>,
        pub(crate) cache_behaviors:
            std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) ip_address_type: std::option::Option<crate::model::IpAddressType>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name for the distribution.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name for the distribution.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
        /// instance or load balancer.</p>
        /// <p>The distribution pulls, caches, and serves content from the origin.</p>
        pub fn origin(mut self, input: crate::model::InputOrigin) -> Self {
            self.origin = Some(input);
            self
        }
        /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
        /// instance or load balancer.</p>
        /// <p>The distribution pulls, caches, and serves content from the origin.</p>
        pub fn set_origin(mut self, input: std::option::Option<crate::model::InputOrigin>) -> Self {
            self.origin = input;
            self
        }
        /// <p>An object that describes the default cache behavior for the distribution.</p>
        pub fn default_cache_behavior(mut self, input: crate::model::CacheBehavior) -> Self {
            self.default_cache_behavior = Some(input);
            self
        }
        /// <p>An object that describes the default cache behavior for the distribution.</p>
        pub fn set_default_cache_behavior(
            mut self,
            input: std::option::Option<crate::model::CacheBehavior>,
        ) -> Self {
            self.default_cache_behavior = input;
            self
        }
        /// <p>An object that describes the cache behavior settings for the distribution.</p>
        pub fn cache_behavior_settings(mut self, input: crate::model::CacheSettings) -> Self {
            self.cache_behavior_settings = Some(input);
            self
        }
        /// <p>An object that describes the cache behavior settings for the distribution.</p>
        pub fn set_cache_behavior_settings(
            mut self,
            input: std::option::Option<crate::model::CacheSettings>,
        ) -> Self {
            self.cache_behavior_settings = input;
            self
        }
        /// Appends an item to `cache_behaviors`.
        ///
        /// To override the contents of this collection use [`set_cache_behaviors`](Self::set_cache_behaviors).
        ///
        /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
        pub fn cache_behaviors(
            mut self,
            input: impl Into<crate::model::CacheBehaviorPerPath>,
        ) -> Self {
            let mut v = self.cache_behaviors.unwrap_or_default();
            v.push(input.into());
            self.cache_behaviors = Some(v);
            self
        }
        /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
        pub fn set_cache_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
        ) -> Self {
            self.cache_behaviors = input;
            self
        }
        /// <p>The bundle ID to use for the distribution.</p>
        /// <p>A distribution bundle describes the specifications of your distribution, such as the
        /// monthly cost and monthly network transfer quota.</p>
        /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
        /// IDs that you can specify.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle ID to use for the distribution.</p>
        /// <p>A distribution bundle describes the specifications of your distribution, such as the
        /// monthly cost and monthly network transfer quota.</p>
        /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
        /// IDs that you can specify.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The IP address type for the distribution.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.ip_address_type = Some(input);
            self
        }
        /// <p>The IP address type for the distribution.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.ip_address_type = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the distribution during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the distribution during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDistributionInput`](crate::input::CreateDistributionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDistributionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDistributionInput {
                distribution_name: self.distribution_name,
                origin: self.origin,
                default_cache_behavior: self.default_cache_behavior,
                cache_behavior_settings: self.cache_behavior_settings,
                cache_behaviors: self.cache_behaviors,
                bundle_id: self.bundle_id,
                ip_address_type: self.ip_address_type,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDistributionInputOperationOutputAlias = crate::operation::CreateDistribution;
#[doc(hidden)]
pub type CreateDistributionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDistributionInput {
    /// Consumes the builder and constructs an Operation<[`CreateDistribution`](crate::operation::CreateDistribution)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDistribution,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDistributionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDistributionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDistributionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateDistribution",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_distribution(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDistribution",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDistributionInput`](crate::input::CreateDistributionInput)
    pub fn builder() -> crate::input::create_distribution_input::Builder {
        crate::input::create_distribution_input::Builder::default()
    }
}

/// See [`CreateDomainInput`](crate::input::CreateDomainInput)
pub mod create_domain_input {
    /// A builder for [`CreateDomainInput`](crate::input::CreateDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The domain name to manage (e.g., <code>example.com</code>).</p>
        /// <note>
        /// <p>You cannot register a new domain name using Lightsail. You must register a domain name
        /// using Amazon Route 53 or another domain name registrar. If you have already registered your
        /// domain, you can enter its name in this parameter to manage the DNS records for that domain
        /// using Lightsail.</p>
        /// </note>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name to manage (e.g., <code>example.com</code>).</p>
        /// <note>
        /// <p>You cannot register a new domain name using Lightsail. You must register a domain name
        /// using Amazon Route 53 or another domain name registrar. If you have already registered your
        /// domain, you can enter its name in this parameter to manage the DNS records for that domain
        /// using Lightsail.</p>
        /// </note>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDomainInput`](crate::input::CreateDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDomainInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDomainInput {
                domain_name: self.domain_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDomainInputOperationOutputAlias = crate::operation::CreateDomain;
#[doc(hidden)]
pub type CreateDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDomainInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomain`](crate::operation::CreateDomain)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDomainInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDomainInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDomainInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateDomain",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_domain(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDomain",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput)
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
}

/// See [`CreateDomainEntryInput`](crate::input::CreateDomainEntryInput)
pub mod create_domain_entry_input {
    /// A builder for [`CreateDomainEntryInput`](crate::input::CreateDomainEntryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) domain_entry: std::option::Option<crate::model::DomainEntry>,
    }
    impl Builder {
        /// <p>The domain name (e.g., <code>example.com</code>) for which you want to create the domain
        /// entry.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for which you want to create the domain
        /// entry.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>An array of key-value pairs containing information about the domain entry request.</p>
        pub fn domain_entry(mut self, input: crate::model::DomainEntry) -> Self {
            self.domain_entry = Some(input);
            self
        }
        /// <p>An array of key-value pairs containing information about the domain entry request.</p>
        pub fn set_domain_entry(
            mut self,
            input: std::option::Option<crate::model::DomainEntry>,
        ) -> Self {
            self.domain_entry = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDomainEntryInput`](crate::input::CreateDomainEntryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDomainEntryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDomainEntryInput {
                domain_name: self.domain_name,
                domain_entry: self.domain_entry,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDomainEntryInputOperationOutputAlias = crate::operation::CreateDomainEntry;
#[doc(hidden)]
pub type CreateDomainEntryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateDomainEntryInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomainEntry`](crate::operation::CreateDomainEntry)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDomainEntry,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDomainEntryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDomainEntryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDomainEntryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateDomainEntry",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_domain_entry(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDomainEntry::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDomainEntry",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDomainEntryInput`](crate::input::CreateDomainEntryInput)
    pub fn builder() -> crate::input::create_domain_entry_input::Builder {
        crate::input::create_domain_entry_input::Builder::default()
    }
}

/// See [`CreateInstancesInput`](crate::input::CreateInstancesInput)
pub mod create_instances_input {
    /// A builder for [`CreateInstancesInput`](crate::input::CreateInstancesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) custom_image_name: std::option::Option<std::string::String>,
        pub(crate) blueprint_id: std::option::Option<std::string::String>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) key_pair_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        pub(crate) ip_address_type: std::option::Option<crate::model::IpAddressType>,
    }
    impl Builder {
        /// Appends an item to `instance_names`.
        ///
        /// To override the contents of this collection use [`set_instance_names`](Self::set_instance_names).
        ///
        /// <p>The names to use for your new Lightsail instances. Separate multiple values using
        /// quotation marks and commas, for example:
        /// <code>["MyFirstInstance","MySecondInstance"]</code>
        /// </p>
        pub fn instance_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_names.unwrap_or_default();
            v.push(input.into());
            self.instance_names = Some(v);
            self
        }
        /// <p>The names to use for your new Lightsail instances. Separate multiple values using
        /// quotation marks and commas, for example:
        /// <code>["MyFirstInstance","MySecondInstance"]</code>
        /// </p>
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_names = input;
            self
        }
        /// <p>The Availability Zone in which to create your instance. Use the following format:
        /// <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones by using
        /// the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
        /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
        /// parameter to your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone in which to create your instance. Use the following format:
        /// <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones by using
        /// the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
        /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
        /// parameter to your request.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>(Deprecated) The name for your custom image.</p>
        /// <note>
        /// <p>In releases prior to June 12, 2017, this parameter was ignored by the API. It is now
        /// deprecated.</p>
        /// </note>
        pub fn custom_image_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_image_name = Some(input.into());
            self
        }
        /// <p>(Deprecated) The name for your custom image.</p>
        /// <note>
        /// <p>In releases prior to June 12, 2017, this parameter was ignored by the API. It is now
        /// deprecated.</p>
        /// </note>
        pub fn set_custom_image_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_image_name = input;
            self
        }
        /// <p>The ID for a virtual private server image (e.g., <code>app_wordpress_4_4</code> or
        /// <code>app_lamp_7_0</code>). Use the <code>get blueprints</code> operation to return a list
        /// of available images (or <i>blueprints</i>).</p>
        /// <note>
        /// <p>Use active blueprints when creating new instances. Inactive blueprints are listed to
        /// support customers with existing instances and are not necessarily available to create new
        /// instances. Blueprints are marked inactive when they become outdated due to operating system
        /// updates or new application releases.</p>
        /// </note>
        pub fn blueprint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.blueprint_id = Some(input.into());
            self
        }
        /// <p>The ID for a virtual private server image (e.g., <code>app_wordpress_4_4</code> or
        /// <code>app_lamp_7_0</code>). Use the <code>get blueprints</code> operation to return a list
        /// of available images (or <i>blueprints</i>).</p>
        /// <note>
        /// <p>Use active blueprints when creating new instances. Inactive blueprints are listed to
        /// support customers with existing instances and are not necessarily available to create new
        /// instances. Blueprints are marked inactive when they become outdated due to operating system
        /// updates or new application releases.</p>
        /// </note>
        pub fn set_blueprint_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.blueprint_id = input;
            self
        }
        /// <p>The bundle of specification information for your virtual private server (or
        /// <i>instance</i>), including the pricing plan (e.g.,
        /// <code>micro_1_0</code>).</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle of specification information for your virtual private server (or
        /// <i>instance</i>), including the pricing plan (e.g.,
        /// <code>micro_1_0</code>).</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>A launch script you can create that configures a server with additional user data. For
        /// example, you might want to run <code>apt-get -y update</code>.</p>
        /// <note>
        /// <p>Depending on the machine image you choose, the command to get software on your instance
        /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
        /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
        /// </note>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        /// <p>A launch script you can create that configures a server with additional user data. For
        /// example, you might want to run <code>apt-get -y update</code>.</p>
        /// <note>
        /// <p>Depending on the machine image you choose, the command to get software on your instance
        /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
        /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
        /// </note>
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// <p>The name of your key pair.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_name = Some(input.into());
            self
        }
        /// <p>The name of your key pair.</p>
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_pair_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `add_ons`.
        ///
        /// To override the contents of this collection use [`set_add_ons`](Self::set_add_ons).
        ///
        /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
        pub fn add_ons(mut self, input: impl Into<crate::model::AddOnRequest>) -> Self {
            let mut v = self.add_ons.unwrap_or_default();
            v.push(input.into());
            self.add_ons = Some(v);
            self
        }
        /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.add_ons = input;
            self
        }
        /// <p>The IP address type for the instance.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.ip_address_type = Some(input);
            self
        }
        /// <p>The IP address type for the instance.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.ip_address_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateInstancesInput`](crate::input::CreateInstancesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateInstancesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateInstancesInput {
                instance_names: self.instance_names,
                availability_zone: self.availability_zone,
                custom_image_name: self.custom_image_name,
                blueprint_id: self.blueprint_id,
                bundle_id: self.bundle_id,
                user_data: self.user_data,
                key_pair_name: self.key_pair_name,
                tags: self.tags,
                add_ons: self.add_ons,
                ip_address_type: self.ip_address_type,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateInstancesInputOperationOutputAlias = crate::operation::CreateInstances;
#[doc(hidden)]
pub type CreateInstancesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateInstancesInput {
    /// Consumes the builder and constructs an Operation<[`CreateInstances`](crate::operation::CreateInstances)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateInstances,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateInstancesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateInstancesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateInstancesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateInstances",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_instances(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateInstances::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateInstances",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateInstancesInput`](crate::input::CreateInstancesInput)
    pub fn builder() -> crate::input::create_instances_input::Builder {
        crate::input::create_instances_input::Builder::default()
    }
}

/// See [`CreateInstancesFromSnapshotInput`](crate::input::CreateInstancesFromSnapshotInput)
pub mod create_instances_from_snapshot_input {
    /// A builder for [`CreateInstancesFromSnapshotInput`](crate::input::CreateInstancesFromSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) attached_disk_mapping: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::DiskMap>>,
        >,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) instance_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) key_pair_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        pub(crate) ip_address_type: std::option::Option<crate::model::IpAddressType>,
        pub(crate) source_instance_name: std::option::Option<std::string::String>,
        pub(crate) restore_date: std::option::Option<std::string::String>,
        pub(crate) use_latest_restorable_auto_snapshot: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `instance_names`.
        ///
        /// To override the contents of this collection use [`set_instance_names`](Self::set_instance_names).
        ///
        /// <p>The names for your new instances.</p>
        pub fn instance_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_names.unwrap_or_default();
            v.push(input.into());
            self.instance_names = Some(v);
            self
        }
        /// <p>The names for your new instances.</p>
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_names = input;
            self
        }
        /// Adds a key-value pair to `attached_disk_mapping`.
        ///
        /// To override the contents of this collection use [`set_attached_disk_mapping`](Self::set_attached_disk_mapping).
        ///
        /// <p>An object containing information about one or more disk mappings.</p>
        pub fn attached_disk_mapping(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<crate::model::DiskMap>>,
        ) -> Self {
            let mut hash_map = self.attached_disk_mapping.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attached_disk_mapping = Some(hash_map);
            self
        }
        /// <p>An object containing information about one or more disk mappings.</p>
        pub fn set_attached_disk_mapping(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::vec::Vec<crate::model::DiskMap>,
                >,
            >,
        ) -> Self {
            self.attached_disk_mapping = input;
            self
        }
        /// <p>The Availability Zone where you want to create your instances. Use the following
        /// formatting: <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones
        /// by using the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
        /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
        /// parameter to your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone where you want to create your instances. Use the following
        /// formatting: <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones
        /// by using the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
        /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
        /// parameter to your request.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The name of the instance snapshot on which you are basing your new instances. Use the get
        /// instance snapshots operation to return information about your existing snapshots.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>source instance name</code>
        /// parameter. The <code>instance snapshot name</code> and <code>source instance name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// </ul>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the instance snapshot on which you are basing your new instances. Use the get
        /// instance snapshots operation to return information about your existing snapshots.</p>
        /// <p>Constraint:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>source instance name</code>
        /// parameter. The <code>instance snapshot name</code> and <code>source instance name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// </ul>
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_snapshot_name = input;
            self
        }
        /// <p>The bundle of specification information for your virtual private server (or
        /// <i>instance</i>), including the pricing plan (e.g.,
        /// <code>micro_1_0</code>).</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle of specification information for your virtual private server (or
        /// <i>instance</i>), including the pricing plan (e.g.,
        /// <code>micro_1_0</code>).</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>You can create a launch script that configures a server with additional user data. For
        /// example, <code>apt-get -y update</code>.</p>
        /// <note>
        /// <p>Depending on the machine image you choose, the command to get software on your instance
        /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
        /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
        /// </note>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        /// <p>You can create a launch script that configures a server with additional user data. For
        /// example, <code>apt-get -y update</code>.</p>
        /// <note>
        /// <p>Depending on the machine image you choose, the command to get software on your instance
        /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
        /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
        /// </note>
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// <p>The name for your key pair.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_name = Some(input.into());
            self
        }
        /// <p>The name for your key pair.</p>
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_pair_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `add_ons`.
        ///
        /// To override the contents of this collection use [`set_add_ons`](Self::set_add_ons).
        ///
        /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
        pub fn add_ons(mut self, input: impl Into<crate::model::AddOnRequest>) -> Self {
            let mut v = self.add_ons.unwrap_or_default();
            v.push(input.into());
            self.add_ons = Some(v);
            self
        }
        /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
        pub fn set_add_ons(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
        ) -> Self {
            self.add_ons = input;
            self
        }
        /// <p>The IP address type for the instance.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.ip_address_type = Some(input);
            self
        }
        /// <p>The IP address type for the instance.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.ip_address_type = input;
            self
        }
        /// <p>The name of the source instance from which the source automatic snapshot was
        /// created.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>instance snapshot name</code>
        /// parameter. The <code>source instance name</code> and <code>instance snapshot name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn source_instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_instance_name = Some(input.into());
            self
        }
        /// <p>The name of the source instance from which the source automatic snapshot was
        /// created.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>instance snapshot name</code>
        /// parameter. The <code>source instance name</code> and <code>instance snapshot name</code>
        /// parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_source_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_instance_name = input;
            self
        }
        /// <p>The date of the automatic snapshot to use for the new instance. Use the <code>get auto
        /// snapshots</code> operation to identify the dates of the available automatic
        /// snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn restore_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.restore_date = Some(input.into());
            self
        }
        /// <p>The date of the automatic snapshot to use for the new instance. Use the <code>get auto
        /// snapshots</code> operation to identify the dates of the available automatic
        /// snapshots.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
        /// </li>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
        /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
        /// auto snapshot</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_restore_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.restore_date = input;
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn use_latest_restorable_auto_snapshot(mut self, input: bool) -> Self {
            self.use_latest_restorable_auto_snapshot = Some(input);
            self
        }
        /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>This parameter cannot be defined together with the <code>restore date</code>
        /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
        /// date</code> parameters are mutually exclusive.</p>
        /// </li>
        /// <li>
        /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
        /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_use_latest_restorable_auto_snapshot(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_latest_restorable_auto_snapshot = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateInstancesFromSnapshotInput`](crate::input::CreateInstancesFromSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateInstancesFromSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateInstancesFromSnapshotInput {
                instance_names: self.instance_names,
                attached_disk_mapping: self.attached_disk_mapping,
                availability_zone: self.availability_zone,
                instance_snapshot_name: self.instance_snapshot_name,
                bundle_id: self.bundle_id,
                user_data: self.user_data,
                key_pair_name: self.key_pair_name,
                tags: self.tags,
                add_ons: self.add_ons,
                ip_address_type: self.ip_address_type,
                source_instance_name: self.source_instance_name,
                restore_date: self.restore_date,
                use_latest_restorable_auto_snapshot: self.use_latest_restorable_auto_snapshot,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateInstancesFromSnapshotInputOperationOutputAlias =
    crate::operation::CreateInstancesFromSnapshot;
#[doc(hidden)]
pub type CreateInstancesFromSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateInstancesFromSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateInstancesFromSnapshot`](crate::operation::CreateInstancesFromSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateInstancesFromSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateInstancesFromSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateInstancesFromSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateInstancesFromSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateInstancesFromSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_instances_from_snapshot(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateInstancesFromSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateInstancesFromSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateInstancesFromSnapshotInput`](crate::input::CreateInstancesFromSnapshotInput)
    pub fn builder() -> crate::input::create_instances_from_snapshot_input::Builder {
        crate::input::create_instances_from_snapshot_input::Builder::default()
    }
}

/// See [`CreateInstanceSnapshotInput`](crate::input::CreateInstanceSnapshotInput)
pub mod create_instance_snapshot_input {
    /// A builder for [`CreateInstanceSnapshotInput`](crate::input::CreateInstanceSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name for your new snapshot.</p>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name for your new snapshot.</p>
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_snapshot_name = input;
            self
        }
        /// <p>The Lightsail instance on which to base your snapshot.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The Lightsail instance on which to base your snapshot.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateInstanceSnapshotInput`](crate::input::CreateInstanceSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateInstanceSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateInstanceSnapshotInput {
                instance_snapshot_name: self.instance_snapshot_name,
                instance_name: self.instance_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateInstanceSnapshotInputOperationOutputAlias = crate::operation::CreateInstanceSnapshot;
#[doc(hidden)]
pub type CreateInstanceSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateInstanceSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateInstanceSnapshot`](crate::operation::CreateInstanceSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateInstanceSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateInstanceSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateInstanceSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateInstanceSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateInstanceSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_instance_snapshot(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateInstanceSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateInstanceSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateInstanceSnapshotInput`](crate::input::CreateInstanceSnapshotInput)
    pub fn builder() -> crate::input::create_instance_snapshot_input::Builder {
        crate::input::create_instance_snapshot_input::Builder::default()
    }
}

/// See [`CreateKeyPairInput`](crate::input::CreateKeyPairInput)
pub mod create_key_pair_input {
    /// A builder for [`CreateKeyPairInput`](crate::input::CreateKeyPairInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_pair_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name for your new key pair.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_name = Some(input.into());
            self
        }
        /// <p>The name for your new key pair.</p>
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_pair_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateKeyPairInput`](crate::input::CreateKeyPairInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateKeyPairInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateKeyPairInput {
                key_pair_name: self.key_pair_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateKeyPairInputOperationOutputAlias = crate::operation::CreateKeyPair;
#[doc(hidden)]
pub type CreateKeyPairInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateKeyPairInput {
    /// Consumes the builder and constructs an Operation<[`CreateKeyPair`](crate::operation::CreateKeyPair)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateKeyPair,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateKeyPairInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateKeyPairInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateKeyPairInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateKeyPair",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_key_pair(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateKeyPair::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateKeyPair",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateKeyPairInput`](crate::input::CreateKeyPairInput)
    pub fn builder() -> crate::input::create_key_pair_input::Builder {
        crate::input::create_key_pair_input::Builder::default()
    }
}

/// See [`CreateLoadBalancerInput`](crate::input::CreateLoadBalancerInput)
pub mod create_load_balancer_input {
    /// A builder for [`CreateLoadBalancerInput`](crate::input::CreateLoadBalancerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) instance_port: std::option::Option<i32>,
        pub(crate) health_check_path: std::option::Option<std::string::String>,
        pub(crate) certificate_name: std::option::Option<std::string::String>,
        pub(crate) certificate_domain_name: std::option::Option<std::string::String>,
        pub(crate) certificate_alternative_names:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) ip_address_type: std::option::Option<crate::model::IpAddressType>,
    }
    impl Builder {
        /// <p>The name of your load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of your load balancer.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The instance port where you're creating your load balancer.</p>
        pub fn instance_port(mut self, input: i32) -> Self {
            self.instance_port = Some(input);
            self
        }
        /// <p>The instance port where you're creating your load balancer.</p>
        pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_port = input;
            self
        }
        /// <p>The path you provided to perform the load balancer health check. If you didn't specify a
        /// health check path, Lightsail uses the root path of your website (e.g.,
        /// <code>"/"</code>).</p>
        /// <p>You may want to specify a custom health check path other than the root of your application
        /// if your home page loads slowly or has a lot of media or scripting on it.</p>
        pub fn health_check_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_check_path = Some(input.into());
            self
        }
        /// <p>The path you provided to perform the load balancer health check. If you didn't specify a
        /// health check path, Lightsail uses the root path of your website (e.g.,
        /// <code>"/"</code>).</p>
        /// <p>You may want to specify a custom health check path other than the root of your application
        /// if your home page loads slowly or has a lot of media or scripting on it.</p>
        pub fn set_health_check_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_check_path = input;
            self
        }
        /// <p>The name of the SSL/TLS certificate.</p>
        /// <p>If you specify <code>certificateName</code>, then <code>certificateDomainName</code> is
        /// required (and vice-versa).</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The name of the SSL/TLS certificate.</p>
        /// <p>If you specify <code>certificateName</code>, then <code>certificateDomainName</code> is
        /// required (and vice-versa).</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// <p>The domain name with which your certificate is associated (e.g.,
        /// <code>example.com</code>).</p>
        /// <p>If you specify <code>certificateDomainName</code>, then <code>certificateName</code> is
        /// required (and vice-versa).</p>
        pub fn certificate_domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_domain_name = Some(input.into());
            self
        }
        /// <p>The domain name with which your certificate is associated (e.g.,
        /// <code>example.com</code>).</p>
        /// <p>If you specify <code>certificateDomainName</code>, then <code>certificateName</code> is
        /// required (and vice-versa).</p>
        pub fn set_certificate_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_domain_name = input;
            self
        }
        /// Appends an item to `certificate_alternative_names`.
        ///
        /// To override the contents of this collection use [`set_certificate_alternative_names`](Self::set_certificate_alternative_names).
        ///
        /// <p>The optional alternative domains and subdomains to use with your SSL/TLS certificate
        /// (e.g., <code>www.example.com</code>, <code>example.com</code>, <code>m.example.com</code>,
        /// <code>blog.example.com</code>).</p>
        pub fn certificate_alternative_names(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.certificate_alternative_names.unwrap_or_default();
            v.push(input.into());
            self.certificate_alternative_names = Some(v);
            self
        }
        /// <p>The optional alternative domains and subdomains to use with your SSL/TLS certificate
        /// (e.g., <code>www.example.com</code>, <code>example.com</code>, <code>m.example.com</code>,
        /// <code>blog.example.com</code>).</p>
        pub fn set_certificate_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.certificate_alternative_names = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The IP address type for the load balancer.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.ip_address_type = Some(input);
            self
        }
        /// <p>The IP address type for the load balancer.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        ///
        /// <p>The default value is <code>dualstack</code>.</p>
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.ip_address_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLoadBalancerInput`](crate::input::CreateLoadBalancerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLoadBalancerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLoadBalancerInput {
                load_balancer_name: self.load_balancer_name,
                instance_port: self.instance_port.unwrap_or_default(),
                health_check_path: self.health_check_path,
                certificate_name: self.certificate_name,
                certificate_domain_name: self.certificate_domain_name,
                certificate_alternative_names: self.certificate_alternative_names,
                tags: self.tags,
                ip_address_type: self.ip_address_type,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLoadBalancerInputOperationOutputAlias = crate::operation::CreateLoadBalancer;
#[doc(hidden)]
pub type CreateLoadBalancerInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateLoadBalancerInput {
    /// Consumes the builder and constructs an Operation<[`CreateLoadBalancer`](crate::operation::CreateLoadBalancer)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLoadBalancer,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateLoadBalancerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateLoadBalancerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateLoadBalancerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateLoadBalancer",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_load_balancer(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLoadBalancer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLoadBalancer",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLoadBalancerInput`](crate::input::CreateLoadBalancerInput)
    pub fn builder() -> crate::input::create_load_balancer_input::Builder {
        crate::input::create_load_balancer_input::Builder::default()
    }
}

/// See [`CreateLoadBalancerTlsCertificateInput`](crate::input::CreateLoadBalancerTlsCertificateInput)
pub mod create_load_balancer_tls_certificate_input {
    /// A builder for [`CreateLoadBalancerTlsCertificateInput`](crate::input::CreateLoadBalancerTlsCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) certificate_name: std::option::Option<std::string::String>,
        pub(crate) certificate_domain_name: std::option::Option<std::string::String>,
        pub(crate) certificate_alternative_names:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The load balancer name where you want to create the SSL/TLS certificate.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The load balancer name where you want to create the SSL/TLS certificate.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The SSL/TLS certificate name.</p>
        /// <p>You can have up to 10 certificates in your account at one time. Each Lightsail load
        /// balancer can have up to 2 certificates associated with it at one time. There is also an
        /// overall limit to the number of certificates that can be issue in a 365-day period. For more
        /// information, see <a href="http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Limits</a>.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The SSL/TLS certificate name.</p>
        /// <p>You can have up to 10 certificates in your account at one time. Each Lightsail load
        /// balancer can have up to 2 certificates associated with it at one time. There is also an
        /// overall limit to the number of certificates that can be issue in a 365-day period. For more
        /// information, see <a href="http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Limits</a>.</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for your SSL/TLS certificate.</p>
        pub fn certificate_domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_domain_name = Some(input.into());
            self
        }
        /// <p>The domain name (e.g., <code>example.com</code>) for your SSL/TLS certificate.</p>
        pub fn set_certificate_domain_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_domain_name = input;
            self
        }
        /// Appends an item to `certificate_alternative_names`.
        ///
        /// To override the contents of this collection use [`set_certificate_alternative_names`](Self::set_certificate_alternative_names).
        ///
        /// <p>An array of strings listing alternative domains and subdomains for your SSL/TLS
        /// certificate. Lightsail will de-dupe the names for you. You can have a maximum of 9
        /// alternative names (in addition to the 1 primary domain). We do not support wildcards (e.g.,
        /// <code>*.example.com</code>).</p>
        pub fn certificate_alternative_names(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.certificate_alternative_names.unwrap_or_default();
            v.push(input.into());
            self.certificate_alternative_names = Some(v);
            self
        }
        /// <p>An array of strings listing alternative domains and subdomains for your SSL/TLS
        /// certificate. Lightsail will de-dupe the names for you. You can have a maximum of 9
        /// alternative names (in addition to the 1 primary domain). We do not support wildcards (e.g.,
        /// <code>*.example.com</code>).</p>
        pub fn set_certificate_alternative_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.certificate_alternative_names = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLoadBalancerTlsCertificateInput`](crate::input::CreateLoadBalancerTlsCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLoadBalancerTlsCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLoadBalancerTlsCertificateInput {
                load_balancer_name: self.load_balancer_name,
                certificate_name: self.certificate_name,
                certificate_domain_name: self.certificate_domain_name,
                certificate_alternative_names: self.certificate_alternative_names,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLoadBalancerTlsCertificateInputOperationOutputAlias =
    crate::operation::CreateLoadBalancerTlsCertificate;
#[doc(hidden)]
pub type CreateLoadBalancerTlsCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateLoadBalancerTlsCertificateInput {
    /// Consumes the builder and constructs an Operation<[`CreateLoadBalancerTlsCertificate`](crate::operation::CreateLoadBalancerTlsCertificate)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLoadBalancerTlsCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateLoadBalancerTlsCertificateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateLoadBalancerTlsCertificateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateLoadBalancerTlsCertificateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateLoadBalancerTlsCertificate",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_load_balancer_tls_certificate(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLoadBalancerTlsCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLoadBalancerTlsCertificate",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLoadBalancerTlsCertificateInput`](crate::input::CreateLoadBalancerTlsCertificateInput)
    pub fn builder() -> crate::input::create_load_balancer_tls_certificate_input::Builder {
        crate::input::create_load_balancer_tls_certificate_input::Builder::default()
    }
}

/// See [`CreateRelationalDatabaseInput`](crate::input::CreateRelationalDatabaseInput)
pub mod create_relational_database_input {
    /// A builder for [`CreateRelationalDatabaseInput`](crate::input::CreateRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) relational_database_blueprint_id: std::option::Option<std::string::String>,
        pub(crate) relational_database_bundle_id: std::option::Option<std::string::String>,
        pub(crate) master_database_name: std::option::Option<std::string::String>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
        pub(crate) preferred_backup_window: std::option::Option<std::string::String>,
        pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name to use for your new Lightsail database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name to use for your new Lightsail database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The Availability Zone in which to create your new database. Use the
        /// <code>us-east-2a</code> case-sensitive format.</p>
        /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
        /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
        /// your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone in which to create your new database. Use the
        /// <code>us-east-2a</code> case-sensitive format.</p>
        /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
        /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
        /// your request.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The blueprint ID for your new database. A blueprint describes the major engine version of
        /// a database.</p>
        /// <p>You can get a list of database blueprints IDs by using the <code>get relational database
        /// blueprints</code> operation.</p>
        pub fn relational_database_blueprint_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_blueprint_id = Some(input.into());
            self
        }
        /// <p>The blueprint ID for your new database. A blueprint describes the major engine version of
        /// a database.</p>
        /// <p>You can get a list of database blueprints IDs by using the <code>get relational database
        /// blueprints</code> operation.</p>
        pub fn set_relational_database_blueprint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_blueprint_id = input;
            self
        }
        /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
        /// your database.</p>
        /// <p>You can get a list of database bundle IDs by using the <code>get relational database
        /// bundles</code> operation.</p>
        pub fn relational_database_bundle_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
        /// your database.</p>
        /// <p>You can get a list of database bundle IDs by using the <code>get relational database
        /// bundles</code> operation.</p>
        pub fn set_relational_database_bundle_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_bundle_id = input;
            self
        }
        /// <p>The meaning of this parameter differs according to the database engine you use.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>The name of the database to create when the Lightsail database resource is created. If
        /// this parameter isn't specified, no database is created in the database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1 to 64 letters or numbers.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
        /// (0- 9).</p>
        /// </li>
        /// <li>
        /// <p>Can't be a word reserved by the specified database engine.</p>
        /// <p>For more information about reserved words in MySQL, see the Keywords and Reserved
        /// Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>The name of the database to create when the Lightsail database resource is created. If
        /// this parameter isn't specified, a database named <code>postgres</code> is created in the
        /// database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1 to 63 letters or numbers.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
        /// (0- 9).</p>
        /// </li>
        /// <li>
        /// <p>Can't be a word reserved by the specified database engine.</p>
        /// <p>For more information about reserved words in PostgreSQL, see the SQL Key Words
        /// articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL
        /// 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
        /// 12</a>.</p>
        /// </li>
        /// </ul>
        pub fn master_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_database_name = Some(input.into());
            self
        }
        /// <p>The meaning of this parameter differs according to the database engine you use.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>The name of the database to create when the Lightsail database resource is created. If
        /// this parameter isn't specified, no database is created in the database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1 to 64 letters or numbers.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
        /// (0- 9).</p>
        /// </li>
        /// <li>
        /// <p>Can't be a word reserved by the specified database engine.</p>
        /// <p>For more information about reserved words in MySQL, see the Keywords and Reserved
        /// Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>The name of the database to create when the Lightsail database resource is created. If
        /// this parameter isn't specified, a database named <code>postgres</code> is created in the
        /// database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain 1 to 63 letters or numbers.</p>
        /// </li>
        /// <li>
        /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
        /// (0- 9).</p>
        /// </li>
        /// <li>
        /// <p>Can't be a word reserved by the specified database engine.</p>
        /// <p>For more information about reserved words in PostgreSQL, see the SQL Key Words
        /// articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL
        /// 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
        /// 12</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_master_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_database_name = input;
            self
        }
        /// <p>The name for the master user.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Required for MySQL.</p>
        /// </li>
        /// <li>
        /// <p>Must be 1 to 16 letters or numbers. Can contain underscores.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't be a reserved word for the chosen database engine.</p>
        /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
        /// Reserved Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Required for PostgreSQL.</p>
        /// </li>
        /// <li>
        /// <p>Must be 1 to 63 letters or numbers. Can contain underscores.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't be a reserved word for the chosen database engine.</p>
        /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
        /// Reserved Words articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL
        /// 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL
        /// 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
        /// 12</a>.</p>
        /// </li>
        /// </ul>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The name for the master user.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Required for MySQL.</p>
        /// </li>
        /// <li>
        /// <p>Must be 1 to 16 letters or numbers. Can contain underscores.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't be a reserved word for the chosen database engine.</p>
        /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
        /// Reserved Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Required for PostgreSQL.</p>
        /// </li>
        /// <li>
        /// <p>Must be 1 to 63 letters or numbers. Can contain underscores.</p>
        /// </li>
        /// <li>
        /// <p>First character must be a letter.</p>
        /// </li>
        /// <li>
        /// <p>Can't be a reserved word for the chosen database engine.</p>
        /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
        /// Reserved Words articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL
        /// 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL
        /// 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
        /// 12</a>.</p>
        /// </li>
        /// </ul>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The password for the master user. The password can include any printable ASCII character
        /// except "/", """, or "@". It cannot contain spaces.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 41 characters.</p>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 128 characters.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The password for the master user. The password can include any printable ASCII character
        /// except "/", """, or "@". It cannot contain spaces.</p>
        /// <p>
        /// <b>MySQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 41 characters.</p>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 128 characters.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// <p>The daily time range during which automated backups are created for your new database if
        /// automated backups are enabled.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region. For more information about the preferred backup window time blocks for each
        /// region, see the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Working With Backups</a> guide in the Amazon Relational Database Service (Amazon RDS) documentation.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
        /// <p>Example: <code>16:00-16:30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Must not conflict with the preferred maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// </ul>
        pub fn preferred_backup_window(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_backup_window = Some(input.into());
            self
        }
        /// <p>The daily time range during which automated backups are created for your new database if
        /// automated backups are enabled.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region. For more information about the preferred backup window time blocks for each
        /// region, see the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Working With Backups</a> guide in the Amazon Relational Database Service (Amazon RDS) documentation.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
        /// <p>Example: <code>16:00-16:30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Must not conflict with the preferred maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// </ul>
        pub fn set_preferred_backup_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_backup_window = input;
            self
        }
        /// <p>The weekly time range during which system maintenance can occur on your new
        /// database.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region, occurring on a random day of the week.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
        /// </li>
        /// <li>
        /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = Some(input.into());
            self
        }
        /// <p>The weekly time range during which system maintenance can occur on your new
        /// database.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region, occurring on a random day of the week.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
        /// </li>
        /// <li>
        /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = input;
            self
        }
        /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRelationalDatabaseInput`](crate::input::CreateRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
                availability_zone: self.availability_zone,
                relational_database_blueprint_id: self.relational_database_blueprint_id,
                relational_database_bundle_id: self.relational_database_bundle_id,
                master_database_name: self.master_database_name,
                master_username: self.master_username,
                master_user_password: self.master_user_password,
                preferred_backup_window: self.preferred_backup_window,
                preferred_maintenance_window: self.preferred_maintenance_window,
                publicly_accessible: self.publicly_accessible,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRelationalDatabaseInputOperationOutputAlias =
    crate::operation::CreateRelationalDatabase;
#[doc(hidden)]
pub type CreateRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`CreateRelationalDatabase`](crate::operation::CreateRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateRelationalDatabaseInput`](crate::input::CreateRelationalDatabaseInput)
    pub fn builder() -> crate::input::create_relational_database_input::Builder {
        crate::input::create_relational_database_input::Builder::default()
    }
}

/// See [`CreateRelationalDatabaseFromSnapshotInput`](crate::input::CreateRelationalDatabaseFromSnapshotInput)
pub mod create_relational_database_from_snapshot_input {
    /// A builder for [`CreateRelationalDatabaseFromSnapshotInput`](crate::input::CreateRelationalDatabaseFromSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) relational_database_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) relational_database_bundle_id: std::option::Option<std::string::String>,
        pub(crate) source_relational_database_name: std::option::Option<std::string::String>,
        pub(crate) restore_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) use_latest_restorable_time: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name to use for your new Lightsail database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name to use for your new Lightsail database resource.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The Availability Zone in which to create your new database. Use the
        /// <code>us-east-2a</code> case-sensitive format.</p>
        /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
        /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
        /// your request.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone in which to create your new database. Use the
        /// <code>us-east-2a</code> case-sensitive format.</p>
        /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
        /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
        /// your request.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>The name of the database snapshot from which to create your new database.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the database snapshot from which to create your new database.</p>
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = input;
            self
        }
        /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
        /// your database.</p>
        /// <p>You can get a list of database bundle IDs by using the <code>get relational database
        /// bundles</code> operation.</p>
        /// <p>When creating a new database from a snapshot, you cannot choose a bundle that is smaller
        /// than the bundle of the source database.</p>
        pub fn relational_database_bundle_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
        /// your database.</p>
        /// <p>You can get a list of database bundle IDs by using the <code>get relational database
        /// bundles</code> operation.</p>
        /// <p>When creating a new database from a snapshot, you cannot choose a bundle that is smaller
        /// than the bundle of the source database.</p>
        pub fn set_relational_database_bundle_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_bundle_id = input;
            self
        }
        /// <p>The name of the source database.</p>
        pub fn source_relational_database_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.source_relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of the source database.</p>
        pub fn set_source_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_relational_database_name = input;
            self
        }
        /// <p>The date and time to restore your database from.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be before the latest restorable time for the database.</p>
        /// </li>
        /// <li>
        /// <p>Cannot be specified if the <code>use latest restorable time</code> parameter is
        /// <code>true</code>.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a restore time of October 1, 2018, at 8 PM UTC, then
        /// you input <code>1538424000</code> as the restore time.</p>
        /// </li>
        /// </ul>
        pub fn restore_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.restore_time = Some(input);
            self
        }
        /// <p>The date and time to restore your database from.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be before the latest restorable time for the database.</p>
        /// </li>
        /// <li>
        /// <p>Cannot be specified if the <code>use latest restorable time</code> parameter is
        /// <code>true</code>.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a restore time of October 1, 2018, at 8 PM UTC, then
        /// you input <code>1538424000</code> as the restore time.</p>
        /// </li>
        /// </ul>
        pub fn set_restore_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.restore_time = input;
            self
        }
        /// <p>Specifies whether your database is restored from the latest backup time. A value of
        /// <code>true</code> restores from the latest backup time. </p>
        /// <p>Default: <code>false</code>
        /// </p>
        /// <p>Constraints: Cannot be specified if the <code>restore time</code> parameter is
        /// provided.</p>
        pub fn use_latest_restorable_time(mut self, input: bool) -> Self {
            self.use_latest_restorable_time = Some(input);
            self
        }
        /// <p>Specifies whether your database is restored from the latest backup time. A value of
        /// <code>true</code> restores from the latest backup time. </p>
        /// <p>Default: <code>false</code>
        /// </p>
        /// <p>Constraints: Cannot be specified if the <code>restore time</code> parameter is
        /// provided.</p>
        pub fn set_use_latest_restorable_time(mut self, input: std::option::Option<bool>) -> Self {
            self.use_latest_restorable_time = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRelationalDatabaseFromSnapshotInput`](crate::input::CreateRelationalDatabaseFromSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRelationalDatabaseFromSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRelationalDatabaseFromSnapshotInput {
                relational_database_name: self.relational_database_name,
                availability_zone: self.availability_zone,
                publicly_accessible: self.publicly_accessible,
                relational_database_snapshot_name: self.relational_database_snapshot_name,
                relational_database_bundle_id: self.relational_database_bundle_id,
                source_relational_database_name: self.source_relational_database_name,
                restore_time: self.restore_time,
                use_latest_restorable_time: self.use_latest_restorable_time,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRelationalDatabaseFromSnapshotInputOperationOutputAlias =
    crate::operation::CreateRelationalDatabaseFromSnapshot;
#[doc(hidden)]
pub type CreateRelationalDatabaseFromSnapshotInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl CreateRelationalDatabaseFromSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateRelationalDatabaseFromSnapshot`](crate::operation::CreateRelationalDatabaseFromSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRelationalDatabaseFromSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateRelationalDatabaseFromSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateRelationalDatabaseFromSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateRelationalDatabaseFromSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateRelationalDatabaseFromSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_relational_database_from_snapshot(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRelationalDatabaseFromSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRelationalDatabaseFromSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateRelationalDatabaseFromSnapshotInput`](crate::input::CreateRelationalDatabaseFromSnapshotInput)
    pub fn builder() -> crate::input::create_relational_database_from_snapshot_input::Builder {
        crate::input::create_relational_database_from_snapshot_input::Builder::default()
    }
}

/// See [`CreateRelationalDatabaseSnapshotInput`](crate::input::CreateRelationalDatabaseSnapshotInput)
pub mod create_relational_database_snapshot_input {
    /// A builder for [`CreateRelationalDatabaseSnapshotInput`](crate::input::CreateRelationalDatabaseSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) relational_database_snapshot_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the database on which to base your new snapshot.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of the database on which to base your new snapshot.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The name for your new database snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name for your new database snapshot.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag keys and optional values to add to the resource during create.</p>
        /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRelationalDatabaseSnapshotInput`](crate::input::CreateRelationalDatabaseSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateRelationalDatabaseSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateRelationalDatabaseSnapshotInput {
                relational_database_name: self.relational_database_name,
                relational_database_snapshot_name: self.relational_database_snapshot_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateRelationalDatabaseSnapshotInputOperationOutputAlias =
    crate::operation::CreateRelationalDatabaseSnapshot;
#[doc(hidden)]
pub type CreateRelationalDatabaseSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateRelationalDatabaseSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`CreateRelationalDatabaseSnapshot`](crate::operation::CreateRelationalDatabaseSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRelationalDatabaseSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateRelationalDatabaseSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateRelationalDatabaseSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateRelationalDatabaseSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.CreateRelationalDatabaseSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_relational_database_snapshot(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRelationalDatabaseSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRelationalDatabaseSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateRelationalDatabaseSnapshotInput`](crate::input::CreateRelationalDatabaseSnapshotInput)
    pub fn builder() -> crate::input::create_relational_database_snapshot_input::Builder {
        crate::input::create_relational_database_snapshot_input::Builder::default()
    }
}

/// See [`DeleteAlarmInput`](crate::input::DeleteAlarmInput)
pub mod delete_alarm_input {
    /// A builder for [`DeleteAlarmInput`](crate::input::DeleteAlarmInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the alarm to delete.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of the alarm to delete.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAlarmInput`](crate::input::DeleteAlarmInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAlarmInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAlarmInput {
                alarm_name: self.alarm_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAlarmInputOperationOutputAlias = crate::operation::DeleteAlarm;
#[doc(hidden)]
pub type DeleteAlarmInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAlarmInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAlarm`](crate::operation::DeleteAlarm)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAlarm,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteAlarmInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteAlarmInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteAlarmInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteAlarm",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_alarm(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAlarm::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAlarm",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAlarmInput`](crate::input::DeleteAlarmInput)
    pub fn builder() -> crate::input::delete_alarm_input::Builder {
        crate::input::delete_alarm_input::Builder::default()
    }
}

/// See [`DeleteAutoSnapshotInput`](crate::input::DeleteAutoSnapshotInput)
pub mod delete_auto_snapshot_input {
    /// A builder for [`DeleteAutoSnapshotInput`](crate::input::DeleteAutoSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the source instance or disk from which to delete the automatic
        /// snapshot.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the source instance or disk from which to delete the automatic
        /// snapshot.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The date of the automatic snapshot to delete in <code>YYYY-MM-DD</code> format. Use the
        /// <code>get auto snapshots</code> operation to get the available automatic snapshots for a
        /// resource.</p>
        pub fn date(mut self, input: impl Into<std::string::String>) -> Self {
            self.date = Some(input.into());
            self
        }
        /// <p>The date of the automatic snapshot to delete in <code>YYYY-MM-DD</code> format. Use the
        /// <code>get auto snapshots</code> operation to get the available automatic snapshots for a
        /// resource.</p>
        pub fn set_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.date = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAutoSnapshotInput`](crate::input::DeleteAutoSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAutoSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAutoSnapshotInput {
                resource_name: self.resource_name,
                date: self.date,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAutoSnapshotInputOperationOutputAlias = crate::operation::DeleteAutoSnapshot;
#[doc(hidden)]
pub type DeleteAutoSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAutoSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAutoSnapshot`](crate::operation::DeleteAutoSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAutoSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteAutoSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteAutoSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteAutoSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteAutoSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_auto_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAutoSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAutoSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAutoSnapshotInput`](crate::input::DeleteAutoSnapshotInput)
    pub fn builder() -> crate::input::delete_auto_snapshot_input::Builder {
        crate::input::delete_auto_snapshot_input::Builder::default()
    }
}

/// See [`DeleteBucketInput`](crate::input::DeleteBucketInput)
pub mod delete_bucket_input {
    /// A builder for [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) force_delete: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the bucket to delete.</p>
        ///
        /// <p>Use the <a>GetBuckets</a> action to get a list of bucket names that you can
        /// specify.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket to delete.</p>
        ///
        /// <p>Use the <a>GetBuckets</a> action to get a list of bucket names that you can
        /// specify.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>A Boolean value that indicates whether to force delete the bucket.</p>
        ///
        /// <p>You must force delete the bucket if it has one of the following conditions:</p>
        /// <ul>
        /// <li>
        /// <p>The bucket is the origin of a distribution.</p>
        /// </li>
        /// <li>
        /// <p>The bucket has instances that were granted access to it using the <a>SetResourceAccessForBucket</a> action.</p>
        /// </li>
        /// <li>
        /// <p>The bucket has objects.</p>
        /// </li>
        /// <li>
        /// <p>The bucket has access keys.</p>
        /// </li>
        /// </ul>
        ///
        /// <important>
        /// <p>Force deleting a bucket might impact other resources that rely on the bucket, such as
        /// instances, distributions, or software that use the issued access keys.</p>
        /// </important>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.force_delete = Some(input);
            self
        }
        /// <p>A Boolean value that indicates whether to force delete the bucket.</p>
        ///
        /// <p>You must force delete the bucket if it has one of the following conditions:</p>
        /// <ul>
        /// <li>
        /// <p>The bucket is the origin of a distribution.</p>
        /// </li>
        /// <li>
        /// <p>The bucket has instances that were granted access to it using the <a>SetResourceAccessForBucket</a> action.</p>
        /// </li>
        /// <li>
        /// <p>The bucket has objects.</p>
        /// </li>
        /// <li>
        /// <p>The bucket has access keys.</p>
        /// </li>
        /// </ul>
        ///
        /// <important>
        /// <p>Force deleting a bucket might impact other resources that rely on the bucket, such as
        /// instances, distributions, or software that use the issued access keys.</p>
        /// </important>
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.force_delete = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketInput`](crate::input::DeleteBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketInput {
                bucket_name: self.bucket_name,
                force_delete: self.force_delete,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketInputOperationOutputAlias = crate::operation::DeleteBucket;
#[doc(hidden)]
pub type DeleteBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucket`](crate::operation::DeleteBucket)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteBucket",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_bucket(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucket::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteBucket",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketInput`](crate::input::DeleteBucketInput)
    pub fn builder() -> crate::input::delete_bucket_input::Builder {
        crate::input::delete_bucket_input::Builder::default()
    }
}

/// See [`DeleteBucketAccessKeyInput`](crate::input::DeleteBucketAccessKeyInput)
pub mod delete_bucket_access_key_input {
    /// A builder for [`DeleteBucketAccessKeyInput`](crate::input::DeleteBucketAccessKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) access_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket that the access key belongs to.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket that the access key belongs to.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The ID of the access key to delete.</p>
        ///
        /// <p>Use the <a>GetBucketAccessKeys</a> action to get a list of access key IDs that
        /// you can specify.</p>
        pub fn access_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(input.into());
            self
        }
        /// <p>The ID of the access key to delete.</p>
        ///
        /// <p>Use the <a>GetBucketAccessKeys</a> action to get a list of access key IDs that
        /// you can specify.</p>
        pub fn set_access_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteBucketAccessKeyInput`](crate::input::DeleteBucketAccessKeyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteBucketAccessKeyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteBucketAccessKeyInput {
                bucket_name: self.bucket_name,
                access_key_id: self.access_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteBucketAccessKeyInputOperationOutputAlias = crate::operation::DeleteBucketAccessKey;
#[doc(hidden)]
pub type DeleteBucketAccessKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteBucketAccessKeyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBucketAccessKey`](crate::operation::DeleteBucketAccessKey)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteBucketAccessKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteBucketAccessKeyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteBucketAccessKeyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteBucketAccessKeyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteBucketAccessKey",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_bucket_access_key(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteBucketAccessKey::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteBucketAccessKey",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteBucketAccessKeyInput`](crate::input::DeleteBucketAccessKeyInput)
    pub fn builder() -> crate::input::delete_bucket_access_key_input::Builder {
        crate::input::delete_bucket_access_key_input::Builder::default()
    }
}

/// See [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
pub mod delete_certificate_input {
    /// A builder for [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the certificate to delete.</p>
        /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
        /// can specify.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The name of the certificate to delete.</p>
        /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
        /// can specify.</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCertificateInput {
                certificate_name: self.certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCertificateInputOperationOutputAlias = crate::operation::DeleteCertificate;
#[doc(hidden)]
pub type DeleteCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCertificate`](crate::operation::DeleteCertificate)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteCertificateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteCertificateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteCertificateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteCertificate",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_certificate(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCertificate",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteCertificateInput`](crate::input::DeleteCertificateInput)
    pub fn builder() -> crate::input::delete_certificate_input::Builder {
        crate::input::delete_certificate_input::Builder::default()
    }
}

/// See [`DeleteContactMethodInput`](crate::input::DeleteContactMethodInput)
pub mod delete_contact_method_input {
    /// A builder for [`DeleteContactMethodInput`](crate::input::DeleteContactMethodInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::ContactProtocol>,
    }
    impl Builder {
        /// <p>The protocol that will be deleted, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        /// <note>
        /// <p>To delete an <code>Email</code> and an <code>SMS</code> contact method if you added
        /// both, you must run separate <code>DeleteContactMethod</code> actions to delete each
        /// protocol.</p>
        /// </note>
        pub fn protocol(mut self, input: crate::model::ContactProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol that will be deleted, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        /// <note>
        /// <p>To delete an <code>Email</code> and an <code>SMS</code> contact method if you added
        /// both, you must run separate <code>DeleteContactMethod</code> actions to delete each
        /// protocol.</p>
        /// </note>
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ContactProtocol>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteContactMethodInput`](crate::input::DeleteContactMethodInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteContactMethodInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteContactMethodInput {
                protocol: self.protocol,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteContactMethodInputOperationOutputAlias = crate::operation::DeleteContactMethod;
#[doc(hidden)]
pub type DeleteContactMethodInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteContactMethodInput {
    /// Consumes the builder and constructs an Operation<[`DeleteContactMethod`](crate::operation::DeleteContactMethod)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteContactMethod,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteContactMethodInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteContactMethodInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteContactMethodInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteContactMethod",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_contact_method(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteContactMethod::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteContactMethod",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteContactMethodInput`](crate::input::DeleteContactMethodInput)
    pub fn builder() -> crate::input::delete_contact_method_input::Builder {
        crate::input::delete_contact_method_input::Builder::default()
    }
}

/// See [`DeleteContainerImageInput`](crate::input::DeleteContainerImageInput)
pub mod delete_container_image_input {
    /// A builder for [`DeleteContainerImageInput`](crate::input::DeleteContainerImageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) image: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service for which to delete a registered container image.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to delete a registered container image.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The name of the container image to delete from the container service.</p>
        ///
        /// <p>Use the <code>GetContainerImages</code> action to get the name of the container images
        /// that are registered to a container service.</p>
        ///
        /// <note>
        /// <p>Container images sourced from your Lightsail container service, that are registered
        /// and stored on your service, start with a colon (<code>:</code>). For example,
        /// <code>:container-service-1.mystaticwebsite.1</code>. Container images sourced from a
        /// public registry like Docker Hub don't start with a colon. For example,
        /// <code>nginx:latest</code> or <code>nginx</code>.</p>
        /// </note>
        pub fn image(mut self, input: impl Into<std::string::String>) -> Self {
            self.image = Some(input.into());
            self
        }
        /// <p>The name of the container image to delete from the container service.</p>
        ///
        /// <p>Use the <code>GetContainerImages</code> action to get the name of the container images
        /// that are registered to a container service.</p>
        ///
        /// <note>
        /// <p>Container images sourced from your Lightsail container service, that are registered
        /// and stored on your service, start with a colon (<code>:</code>). For example,
        /// <code>:container-service-1.mystaticwebsite.1</code>. Container images sourced from a
        /// public registry like Docker Hub don't start with a colon. For example,
        /// <code>nginx:latest</code> or <code>nginx</code>.</p>
        /// </note>
        pub fn set_image(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteContainerImageInput`](crate::input::DeleteContainerImageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteContainerImageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteContainerImageInput {
                service_name: self.service_name,
                image: self.image,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteContainerImageInputOperationOutputAlias = crate::operation::DeleteContainerImage;
#[doc(hidden)]
pub type DeleteContainerImageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteContainerImageInput {
    /// Consumes the builder and constructs an Operation<[`DeleteContainerImage`](crate::operation::DeleteContainerImage)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteContainerImage,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteContainerImageInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteContainerImageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteContainerImageInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteContainerImage",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_container_image(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteContainerImage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteContainerImage",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteContainerImageInput`](crate::input::DeleteContainerImageInput)
    pub fn builder() -> crate::input::delete_container_image_input::Builder {
        crate::input::delete_container_image_input::Builder::default()
    }
}

/// See [`DeleteContainerServiceInput`](crate::input::DeleteContainerServiceInput)
pub mod delete_container_service_input {
    /// A builder for [`DeleteContainerServiceInput`](crate::input::DeleteContainerServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service to delete.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service to delete.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteContainerServiceInput`](crate::input::DeleteContainerServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteContainerServiceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteContainerServiceInput {
                service_name: self.service_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteContainerServiceInputOperationOutputAlias = crate::operation::DeleteContainerService;
#[doc(hidden)]
pub type DeleteContainerServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteContainerServiceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteContainerService`](crate::operation::DeleteContainerService)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteContainerService,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteContainerServiceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteContainerServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteContainerServiceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteContainerService",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_container_service(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteContainerService::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteContainerService",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteContainerServiceInput`](crate::input::DeleteContainerServiceInput)
    pub fn builder() -> crate::input::delete_container_service_input::Builder {
        crate::input::delete_container_service_input::Builder::default()
    }
}

/// See [`DeleteDiskInput`](crate::input::DeleteDiskInput)
pub mod delete_disk_input {
    /// A builder for [`DeleteDiskInput`](crate::input::DeleteDiskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
        pub(crate) force_delete_add_ons: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The unique name of the disk you want to delete (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The unique name of the disk you want to delete (e.g., <code>my-disk</code>).</p>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
        pub fn force_delete_add_ons(mut self, input: bool) -> Self {
            self.force_delete_add_ons = Some(input);
            self
        }
        /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
        pub fn set_force_delete_add_ons(mut self, input: std::option::Option<bool>) -> Self {
            self.force_delete_add_ons = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDiskInput`](crate::input::DeleteDiskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDiskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDiskInput {
                disk_name: self.disk_name,
                force_delete_add_ons: self.force_delete_add_ons,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDiskInputOperationOutputAlias = crate::operation::DeleteDisk;
#[doc(hidden)]
pub type DeleteDiskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDiskInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDisk`](crate::operation::DeleteDisk)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDisk,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDiskInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDiskInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDiskInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteDisk",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_disk(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDisk::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDisk",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDiskInput`](crate::input::DeleteDiskInput)
    pub fn builder() -> crate::input::delete_disk_input::Builder {
        crate::input::delete_disk_input::Builder::default()
    }
}

/// See [`DeleteDiskSnapshotInput`](crate::input::DeleteDiskSnapshotInput)
pub mod delete_disk_snapshot_input {
    /// A builder for [`DeleteDiskSnapshotInput`](crate::input::DeleteDiskSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the disk snapshot you want to delete (e.g.,
        /// <code>my-disk-snapshot</code>).</p>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the disk snapshot you want to delete (e.g.,
        /// <code>my-disk-snapshot</code>).</p>
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDiskSnapshotInput`](crate::input::DeleteDiskSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDiskSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDiskSnapshotInput {
                disk_snapshot_name: self.disk_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDiskSnapshotInputOperationOutputAlias = crate::operation::DeleteDiskSnapshot;
#[doc(hidden)]
pub type DeleteDiskSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDiskSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDiskSnapshot`](crate::operation::DeleteDiskSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDiskSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDiskSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDiskSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDiskSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteDiskSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_disk_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDiskSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDiskSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDiskSnapshotInput`](crate::input::DeleteDiskSnapshotInput)
    pub fn builder() -> crate::input::delete_disk_snapshot_input::Builder {
        crate::input::delete_disk_snapshot_input::Builder::default()
    }
}

/// See [`DeleteDistributionInput`](crate::input::DeleteDistributionInput)
pub mod delete_distribution_input {
    /// A builder for [`DeleteDistributionInput`](crate::input::DeleteDistributionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution to delete.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution to delete.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDistributionInput`](crate::input::DeleteDistributionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDistributionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDistributionInput {
                distribution_name: self.distribution_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDistributionInputOperationOutputAlias = crate::operation::DeleteDistribution;
#[doc(hidden)]
pub type DeleteDistributionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDistributionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDistribution`](crate::operation::DeleteDistribution)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDistribution,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDistributionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDistributionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDistributionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteDistribution",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_distribution(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDistribution",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDistributionInput`](crate::input::DeleteDistributionInput)
    pub fn builder() -> crate::input::delete_distribution_input::Builder {
        crate::input::delete_distribution_input::Builder::default()
    }
}

/// See [`DeleteDomainInput`](crate::input::DeleteDomainInput)
pub mod delete_domain_input {
    /// A builder for [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The specific domain name to delete.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The specific domain name to delete.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDomainInput`](crate::input::DeleteDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDomainInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDomainInput {
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDomainInputOperationOutputAlias = crate::operation::DeleteDomain;
#[doc(hidden)]
pub type DeleteDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDomainInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDomain`](crate::operation::DeleteDomain)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDomainInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDomainInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDomainInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteDomain",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_domain(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDomain",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDomainInput`](crate::input::DeleteDomainInput)
    pub fn builder() -> crate::input::delete_domain_input::Builder {
        crate::input::delete_domain_input::Builder::default()
    }
}

/// See [`DeleteDomainEntryInput`](crate::input::DeleteDomainEntryInput)
pub mod delete_domain_entry_input {
    /// A builder for [`DeleteDomainEntryInput`](crate::input::DeleteDomainEntryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) domain_entry: std::option::Option<crate::model::DomainEntry>,
    }
    impl Builder {
        /// <p>The name of the domain entry to delete.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of the domain entry to delete.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>An array of key-value pairs containing information about your domain entries.</p>
        pub fn domain_entry(mut self, input: crate::model::DomainEntry) -> Self {
            self.domain_entry = Some(input);
            self
        }
        /// <p>An array of key-value pairs containing information about your domain entries.</p>
        pub fn set_domain_entry(
            mut self,
            input: std::option::Option<crate::model::DomainEntry>,
        ) -> Self {
            self.domain_entry = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDomainEntryInput`](crate::input::DeleteDomainEntryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDomainEntryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDomainEntryInput {
                domain_name: self.domain_name,
                domain_entry: self.domain_entry,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDomainEntryInputOperationOutputAlias = crate::operation::DeleteDomainEntry;
#[doc(hidden)]
pub type DeleteDomainEntryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDomainEntryInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDomainEntry`](crate::operation::DeleteDomainEntry)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDomainEntry,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDomainEntryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDomainEntryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDomainEntryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteDomainEntry",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_domain_entry(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDomainEntry::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDomainEntry",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDomainEntryInput`](crate::input::DeleteDomainEntryInput)
    pub fn builder() -> crate::input::delete_domain_entry_input::Builder {
        crate::input::delete_domain_entry_input::Builder::default()
    }
}

/// See [`DeleteInstanceInput`](crate::input::DeleteInstanceInput)
pub mod delete_instance_input {
    /// A builder for [`DeleteInstanceInput`](crate::input::DeleteInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) force_delete_add_ons: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the instance to delete.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance to delete.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
        pub fn force_delete_add_ons(mut self, input: bool) -> Self {
            self.force_delete_add_ons = Some(input);
            self
        }
        /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
        pub fn set_force_delete_add_ons(mut self, input: std::option::Option<bool>) -> Self {
            self.force_delete_add_ons = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteInstanceInput`](crate::input::DeleteInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteInstanceInput {
                instance_name: self.instance_name,
                force_delete_add_ons: self.force_delete_add_ons,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteInstanceInputOperationOutputAlias = crate::operation::DeleteInstance;
#[doc(hidden)]
pub type DeleteInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteInstanceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteInstance`](crate::operation::DeleteInstance)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteInstanceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteInstanceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteInstance",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_instance(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteInstance",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteInstanceInput`](crate::input::DeleteInstanceInput)
    pub fn builder() -> crate::input::delete_instance_input::Builder {
        crate::input::delete_instance_input::Builder::default()
    }
}

/// See [`DeleteInstanceSnapshotInput`](crate::input::DeleteInstanceSnapshotInput)
pub mod delete_instance_snapshot_input {
    /// A builder for [`DeleteInstanceSnapshotInput`](crate::input::DeleteInstanceSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the snapshot to delete.</p>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot to delete.</p>
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteInstanceSnapshotInput`](crate::input::DeleteInstanceSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteInstanceSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteInstanceSnapshotInput {
                instance_snapshot_name: self.instance_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteInstanceSnapshotInputOperationOutputAlias = crate::operation::DeleteInstanceSnapshot;
#[doc(hidden)]
pub type DeleteInstanceSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteInstanceSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`DeleteInstanceSnapshot`](crate::operation::DeleteInstanceSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteInstanceSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteInstanceSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteInstanceSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteInstanceSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteInstanceSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_instance_snapshot(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteInstanceSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteInstanceSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteInstanceSnapshotInput`](crate::input::DeleteInstanceSnapshotInput)
    pub fn builder() -> crate::input::delete_instance_snapshot_input::Builder {
        crate::input::delete_instance_snapshot_input::Builder::default()
    }
}

/// See [`DeleteKeyPairInput`](crate::input::DeleteKeyPairInput)
pub mod delete_key_pair_input {
    /// A builder for [`DeleteKeyPairInput`](crate::input::DeleteKeyPairInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_pair_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the key pair to delete.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_name = Some(input.into());
            self
        }
        /// <p>The name of the key pair to delete.</p>
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_pair_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteKeyPairInput`](crate::input::DeleteKeyPairInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteKeyPairInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteKeyPairInput {
                key_pair_name: self.key_pair_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteKeyPairInputOperationOutputAlias = crate::operation::DeleteKeyPair;
#[doc(hidden)]
pub type DeleteKeyPairInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteKeyPairInput {
    /// Consumes the builder and constructs an Operation<[`DeleteKeyPair`](crate::operation::DeleteKeyPair)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteKeyPair,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteKeyPairInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteKeyPairInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteKeyPairInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteKeyPair",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_key_pair(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteKeyPair::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteKeyPair",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteKeyPairInput`](crate::input::DeleteKeyPairInput)
    pub fn builder() -> crate::input::delete_key_pair_input::Builder {
        crate::input::delete_key_pair_input::Builder::default()
    }
}

/// See [`DeleteKnownHostKeysInput`](crate::input::DeleteKnownHostKeysInput)
pub mod delete_known_host_keys_input {
    /// A builder for [`DeleteKnownHostKeysInput`](crate::input::DeleteKnownHostKeysInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance for which you want to reset the host key or certificate.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance for which you want to reset the host key or certificate.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteKnownHostKeysInput`](crate::input::DeleteKnownHostKeysInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteKnownHostKeysInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteKnownHostKeysInput {
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteKnownHostKeysInputOperationOutputAlias = crate::operation::DeleteKnownHostKeys;
#[doc(hidden)]
pub type DeleteKnownHostKeysInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteKnownHostKeysInput {
    /// Consumes the builder and constructs an Operation<[`DeleteKnownHostKeys`](crate::operation::DeleteKnownHostKeys)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteKnownHostKeys,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteKnownHostKeysInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteKnownHostKeysInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteKnownHostKeysInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteKnownHostKeys",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_known_host_keys(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteKnownHostKeys::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteKnownHostKeys",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteKnownHostKeysInput`](crate::input::DeleteKnownHostKeysInput)
    pub fn builder() -> crate::input::delete_known_host_keys_input::Builder {
        crate::input::delete_known_host_keys_input::Builder::default()
    }
}

/// See [`DeleteLoadBalancerInput`](crate::input::DeleteLoadBalancerInput)
pub mod delete_load_balancer_input {
    /// A builder for [`DeleteLoadBalancerInput`](crate::input::DeleteLoadBalancerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer you want to delete.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer you want to delete.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLoadBalancerInput`](crate::input::DeleteLoadBalancerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLoadBalancerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLoadBalancerInput {
                load_balancer_name: self.load_balancer_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLoadBalancerInputOperationOutputAlias = crate::operation::DeleteLoadBalancer;
#[doc(hidden)]
pub type DeleteLoadBalancerInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLoadBalancerInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLoadBalancer`](crate::operation::DeleteLoadBalancer)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLoadBalancer,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteLoadBalancerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteLoadBalancerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteLoadBalancerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteLoadBalancer",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_load_balancer(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLoadBalancer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLoadBalancer",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLoadBalancerInput`](crate::input::DeleteLoadBalancerInput)
    pub fn builder() -> crate::input::delete_load_balancer_input::Builder {
        crate::input::delete_load_balancer_input::Builder::default()
    }
}

/// See [`DeleteLoadBalancerTlsCertificateInput`](crate::input::DeleteLoadBalancerTlsCertificateInput)
pub mod delete_load_balancer_tls_certificate_input {
    /// A builder for [`DeleteLoadBalancerTlsCertificateInput`](crate::input::DeleteLoadBalancerTlsCertificateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) certificate_name: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The load balancer name.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The load balancer name.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The SSL/TLS certificate name.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The SSL/TLS certificate name.</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// <p>When <code>true</code>, forces the deletion of an SSL/TLS certificate.</p>
        /// <p>There can be two certificates associated with a Lightsail load balancer: the primary and
        /// the backup. The <code>force</code> parameter is required when the primary SSL/TLS certificate
        /// is in use by an instance attached to the load balancer.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>When <code>true</code>, forces the deletion of an SSL/TLS certificate.</p>
        /// <p>There can be two certificates associated with a Lightsail load balancer: the primary and
        /// the backup. The <code>force</code> parameter is required when the primary SSL/TLS certificate
        /// is in use by an instance attached to the load balancer.</p>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLoadBalancerTlsCertificateInput`](crate::input::DeleteLoadBalancerTlsCertificateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLoadBalancerTlsCertificateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLoadBalancerTlsCertificateInput {
                load_balancer_name: self.load_balancer_name,
                certificate_name: self.certificate_name,
                force: self.force,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLoadBalancerTlsCertificateInputOperationOutputAlias =
    crate::operation::DeleteLoadBalancerTlsCertificate;
#[doc(hidden)]
pub type DeleteLoadBalancerTlsCertificateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLoadBalancerTlsCertificateInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLoadBalancerTlsCertificate`](crate::operation::DeleteLoadBalancerTlsCertificate)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLoadBalancerTlsCertificate,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteLoadBalancerTlsCertificateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteLoadBalancerTlsCertificateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteLoadBalancerTlsCertificateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteLoadBalancerTlsCertificate",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_load_balancer_tls_certificate(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLoadBalancerTlsCertificate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLoadBalancerTlsCertificate",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLoadBalancerTlsCertificateInput`](crate::input::DeleteLoadBalancerTlsCertificateInput)
    pub fn builder() -> crate::input::delete_load_balancer_tls_certificate_input::Builder {
        crate::input::delete_load_balancer_tls_certificate_input::Builder::default()
    }
}

/// See [`DeleteRelationalDatabaseInput`](crate::input::DeleteRelationalDatabaseInput)
pub mod delete_relational_database_input {
    /// A builder for [`DeleteRelationalDatabaseInput`](crate::input::DeleteRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) skip_final_snapshot: std::option::Option<bool>,
        pub(crate) final_relational_database_snapshot_name:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database that you are deleting.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of the database that you are deleting.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>Determines whether a final database snapshot is created before your database is deleted.
        /// If <code>true</code> is specified, no database snapshot is created. If <code>false</code> is
        /// specified, a database snapshot is created before your database is deleted.</p>
        /// <p>You must specify the <code>final relational database snapshot name</code> parameter if the
        /// <code>skip final snapshot</code> parameter is <code>false</code>.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn skip_final_snapshot(mut self, input: bool) -> Self {
            self.skip_final_snapshot = Some(input);
            self
        }
        /// <p>Determines whether a final database snapshot is created before your database is deleted.
        /// If <code>true</code> is specified, no database snapshot is created. If <code>false</code> is
        /// specified, a database snapshot is created before your database is deleted.</p>
        /// <p>You must specify the <code>final relational database snapshot name</code> parameter if the
        /// <code>skip final snapshot</code> parameter is <code>false</code>.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn set_skip_final_snapshot(mut self, input: std::option::Option<bool>) -> Self {
            self.skip_final_snapshot = input;
            self
        }
        /// <p>The name of the database snapshot created if <code>skip final snapshot</code> is
        /// <code>false</code>, which is the default value for that parameter.</p>
        /// <note>
        /// <p>Specifying this parameter and also specifying the <code>skip final snapshot</code>
        /// parameter to <code>true</code> results in an error.</p>
        /// </note>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn final_relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.final_relational_database_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the database snapshot created if <code>skip final snapshot</code> is
        /// <code>false</code>, which is the default value for that parameter.</p>
        /// <note>
        /// <p>Specifying this parameter and also specifying the <code>skip final snapshot</code>
        /// parameter to <code>true</code> results in an error.</p>
        /// </note>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
        /// </li>
        /// <li>
        /// <p>The first and last character must be a letter or number.</p>
        /// </li>
        /// </ul>
        pub fn set_final_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.final_relational_database_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRelationalDatabaseInput`](crate::input::DeleteRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
                skip_final_snapshot: self.skip_final_snapshot,
                final_relational_database_snapshot_name: self
                    .final_relational_database_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRelationalDatabaseInputOperationOutputAlias =
    crate::operation::DeleteRelationalDatabase;
#[doc(hidden)]
pub type DeleteRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRelationalDatabase`](crate::operation::DeleteRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRelationalDatabaseInput`](crate::input::DeleteRelationalDatabaseInput)
    pub fn builder() -> crate::input::delete_relational_database_input::Builder {
        crate::input::delete_relational_database_input::Builder::default()
    }
}

/// See [`DeleteRelationalDatabaseSnapshotInput`](crate::input::DeleteRelationalDatabaseSnapshotInput)
pub mod delete_relational_database_snapshot_input {
    /// A builder for [`DeleteRelationalDatabaseSnapshotInput`](crate::input::DeleteRelationalDatabaseSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database snapshot that you are deleting.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the database snapshot that you are deleting.</p>
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRelationalDatabaseSnapshotInput`](crate::input::DeleteRelationalDatabaseSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRelationalDatabaseSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRelationalDatabaseSnapshotInput {
                relational_database_snapshot_name: self.relational_database_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRelationalDatabaseSnapshotInputOperationOutputAlias =
    crate::operation::DeleteRelationalDatabaseSnapshot;
#[doc(hidden)]
pub type DeleteRelationalDatabaseSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRelationalDatabaseSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRelationalDatabaseSnapshot`](crate::operation::DeleteRelationalDatabaseSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteRelationalDatabaseSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteRelationalDatabaseSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteRelationalDatabaseSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteRelationalDatabaseSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DeleteRelationalDatabaseSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_relational_database_snapshot(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteRelationalDatabaseSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteRelationalDatabaseSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRelationalDatabaseSnapshotInput`](crate::input::DeleteRelationalDatabaseSnapshotInput)
    pub fn builder() -> crate::input::delete_relational_database_snapshot_input::Builder {
        crate::input::delete_relational_database_snapshot_input::Builder::default()
    }
}

/// See [`DetachCertificateFromDistributionInput`](crate::input::DetachCertificateFromDistributionInput)
pub mod detach_certificate_from_distribution_input {
    /// A builder for [`DetachCertificateFromDistributionInput`](crate::input::DetachCertificateFromDistributionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution from which to detach the certificate.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution from which to detach the certificate.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachCertificateFromDistributionInput`](crate::input::DetachCertificateFromDistributionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachCertificateFromDistributionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachCertificateFromDistributionInput {
                distribution_name: self.distribution_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachCertificateFromDistributionInputOperationOutputAlias =
    crate::operation::DetachCertificateFromDistribution;
#[doc(hidden)]
pub type DetachCertificateFromDistributionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachCertificateFromDistributionInput {
    /// Consumes the builder and constructs an Operation<[`DetachCertificateFromDistribution`](crate::operation::DetachCertificateFromDistribution)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachCertificateFromDistribution,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetachCertificateFromDistributionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetachCertificateFromDistributionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetachCertificateFromDistributionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DetachCertificateFromDistribution",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_detach_certificate_from_distribution(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachCertificateFromDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachCertificateFromDistribution",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachCertificateFromDistributionInput`](crate::input::DetachCertificateFromDistributionInput)
    pub fn builder() -> crate::input::detach_certificate_from_distribution_input::Builder {
        crate::input::detach_certificate_from_distribution_input::Builder::default()
    }
}

/// See [`DetachDiskInput`](crate::input::DetachDiskInput)
pub mod detach_disk_input {
    /// A builder for [`DetachDiskInput`](crate::input::DetachDiskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the disk you want to detach from your instance (e.g.,
        /// <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The unique name of the disk you want to detach from your instance (e.g.,
        /// <code>my-disk</code>).</p>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachDiskInput`](crate::input::DetachDiskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachDiskInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachDiskInput {
                disk_name: self.disk_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachDiskInputOperationOutputAlias = crate::operation::DetachDisk;
#[doc(hidden)]
pub type DetachDiskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachDiskInput {
    /// Consumes the builder and constructs an Operation<[`DetachDisk`](crate::operation::DetachDisk)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachDisk,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetachDiskInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetachDiskInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetachDiskInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DetachDisk",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_detach_disk(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachDisk::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachDisk",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachDiskInput`](crate::input::DetachDiskInput)
    pub fn builder() -> crate::input::detach_disk_input::Builder {
        crate::input::detach_disk_input::Builder::default()
    }
}

/// See [`DetachInstancesFromLoadBalancerInput`](crate::input::DetachInstancesFromLoadBalancerInput)
pub mod detach_instances_from_load_balancer_input {
    /// A builder for [`DetachInstancesFromLoadBalancerInput`](crate::input::DetachInstancesFromLoadBalancerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the Lightsail load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the Lightsail load balancer.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// Appends an item to `instance_names`.
        ///
        /// To override the contents of this collection use [`set_instance_names`](Self::set_instance_names).
        ///
        /// <p>An array of strings containing the names of the instances you want to detach from the load
        /// balancer.</p>
        pub fn instance_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instance_names.unwrap_or_default();
            v.push(input.into());
            self.instance_names = Some(v);
            self
        }
        /// <p>An array of strings containing the names of the instances you want to detach from the load
        /// balancer.</p>
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instance_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachInstancesFromLoadBalancerInput`](crate::input::DetachInstancesFromLoadBalancerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachInstancesFromLoadBalancerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachInstancesFromLoadBalancerInput {
                load_balancer_name: self.load_balancer_name,
                instance_names: self.instance_names,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachInstancesFromLoadBalancerInputOperationOutputAlias =
    crate::operation::DetachInstancesFromLoadBalancer;
#[doc(hidden)]
pub type DetachInstancesFromLoadBalancerInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachInstancesFromLoadBalancerInput {
    /// Consumes the builder and constructs an Operation<[`DetachInstancesFromLoadBalancer`](crate::operation::DetachInstancesFromLoadBalancer)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachInstancesFromLoadBalancer,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetachInstancesFromLoadBalancerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetachInstancesFromLoadBalancerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetachInstancesFromLoadBalancerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DetachInstancesFromLoadBalancer",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_detach_instances_from_load_balancer(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachInstancesFromLoadBalancer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachInstancesFromLoadBalancer",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachInstancesFromLoadBalancerInput`](crate::input::DetachInstancesFromLoadBalancerInput)
    pub fn builder() -> crate::input::detach_instances_from_load_balancer_input::Builder {
        crate::input::detach_instances_from_load_balancer_input::Builder::default()
    }
}

/// See [`DetachStaticIpInput`](crate::input::DetachStaticIpInput)
pub mod detach_static_ip_input {
    /// A builder for [`DetachStaticIpInput`](crate::input::DetachStaticIpInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_ip_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the static IP to detach from the instance.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.static_ip_name = Some(input.into());
            self
        }
        /// <p>The name of the static IP to detach from the instance.</p>
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.static_ip_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DetachStaticIpInput`](crate::input::DetachStaticIpInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DetachStaticIpInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DetachStaticIpInput {
                static_ip_name: self.static_ip_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DetachStaticIpInputOperationOutputAlias = crate::operation::DetachStaticIp;
#[doc(hidden)]
pub type DetachStaticIpInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DetachStaticIpInput {
    /// Consumes the builder and constructs an Operation<[`DetachStaticIp`](crate::operation::DetachStaticIp)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DetachStaticIp,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DetachStaticIpInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DetachStaticIpInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DetachStaticIpInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DetachStaticIp",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_detach_static_ip(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DetachStaticIp::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DetachStaticIp",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DetachStaticIpInput`](crate::input::DetachStaticIpInput)
    pub fn builder() -> crate::input::detach_static_ip_input::Builder {
        crate::input::detach_static_ip_input::Builder::default()
    }
}

/// See [`DisableAddOnInput`](crate::input::DisableAddOnInput)
pub mod disable_add_on_input {
    /// A builder for [`DisableAddOnInput`](crate::input::DisableAddOnInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add_on_type: std::option::Option<crate::model::AddOnType>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The add-on type to disable.</p>
        pub fn add_on_type(mut self, input: crate::model::AddOnType) -> Self {
            self.add_on_type = Some(input);
            self
        }
        /// <p>The add-on type to disable.</p>
        pub fn set_add_on_type(
            mut self,
            input: std::option::Option<crate::model::AddOnType>,
        ) -> Self {
            self.add_on_type = input;
            self
        }
        /// <p>The name of the source resource for which to disable the add-on.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the source resource for which to disable the add-on.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableAddOnInput`](crate::input::DisableAddOnInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisableAddOnInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisableAddOnInput {
                add_on_type: self.add_on_type,
                resource_name: self.resource_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DisableAddOnInputOperationOutputAlias = crate::operation::DisableAddOn;
#[doc(hidden)]
pub type DisableAddOnInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisableAddOnInput {
    /// Consumes the builder and constructs an Operation<[`DisableAddOn`](crate::operation::DisableAddOn)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisableAddOn,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisableAddOnInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisableAddOnInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisableAddOnInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DisableAddOn",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_disable_add_on(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisableAddOn::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisableAddOn",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisableAddOnInput`](crate::input::DisableAddOnInput)
    pub fn builder() -> crate::input::disable_add_on_input::Builder {
        crate::input::disable_add_on_input::Builder::default()
    }
}

/// See [`DownloadDefaultKeyPairInput`](crate::input::DownloadDefaultKeyPairInput)
pub mod download_default_key_pair_input {
    /// A builder for [`DownloadDefaultKeyPairInput`](crate::input::DownloadDefaultKeyPairInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DownloadDefaultKeyPairInput`](crate::input::DownloadDefaultKeyPairInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DownloadDefaultKeyPairInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DownloadDefaultKeyPairInput {})
        }
    }
}
#[doc(hidden)]
pub type DownloadDefaultKeyPairInputOperationOutputAlias = crate::operation::DownloadDefaultKeyPair;
#[doc(hidden)]
pub type DownloadDefaultKeyPairInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DownloadDefaultKeyPairInput {
    /// Consumes the builder and constructs an Operation<[`DownloadDefaultKeyPair`](crate::operation::DownloadDefaultKeyPair)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DownloadDefaultKeyPair,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DownloadDefaultKeyPairInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DownloadDefaultKeyPairInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DownloadDefaultKeyPairInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.DownloadDefaultKeyPair",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_download_default_key_pair(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DownloadDefaultKeyPair::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DownloadDefaultKeyPair",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DownloadDefaultKeyPairInput`](crate::input::DownloadDefaultKeyPairInput)
    pub fn builder() -> crate::input::download_default_key_pair_input::Builder {
        crate::input::download_default_key_pair_input::Builder::default()
    }
}

/// See [`EnableAddOnInput`](crate::input::EnableAddOnInput)
pub mod enable_add_on_input {
    /// A builder for [`EnableAddOnInput`](crate::input::EnableAddOnInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) add_on_request: std::option::Option<crate::model::AddOnRequest>,
    }
    impl Builder {
        /// <p>The name of the source resource for which to enable or modify the add-on.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the source resource for which to enable or modify the add-on.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>An array of strings representing the add-on to enable or modify.</p>
        pub fn add_on_request(mut self, input: crate::model::AddOnRequest) -> Self {
            self.add_on_request = Some(input);
            self
        }
        /// <p>An array of strings representing the add-on to enable or modify.</p>
        pub fn set_add_on_request(
            mut self,
            input: std::option::Option<crate::model::AddOnRequest>,
        ) -> Self {
            self.add_on_request = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableAddOnInput`](crate::input::EnableAddOnInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::EnableAddOnInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::EnableAddOnInput {
                resource_name: self.resource_name,
                add_on_request: self.add_on_request,
            })
        }
    }
}
#[doc(hidden)]
pub type EnableAddOnInputOperationOutputAlias = crate::operation::EnableAddOn;
#[doc(hidden)]
pub type EnableAddOnInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl EnableAddOnInput {
    /// Consumes the builder and constructs an Operation<[`EnableAddOn`](crate::operation::EnableAddOn)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::EnableAddOn,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::EnableAddOnInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::EnableAddOnInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::EnableAddOnInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.EnableAddOn",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_enable_add_on(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::EnableAddOn::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "EnableAddOn",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`EnableAddOnInput`](crate::input::EnableAddOnInput)
    pub fn builder() -> crate::input::enable_add_on_input::Builder {
        crate::input::enable_add_on_input::Builder::default()
    }
}

/// See [`ExportSnapshotInput`](crate::input::ExportSnapshotInput)
pub mod export_snapshot_input {
    /// A builder for [`ExportSnapshotInput`](crate::input::ExportSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance or disk snapshot to be exported to Amazon EC2.</p>
        pub fn source_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the instance or disk snapshot to be exported to Amazon EC2.</p>
        pub fn set_source_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportSnapshotInput`](crate::input::ExportSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ExportSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ExportSnapshotInput {
                source_snapshot_name: self.source_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ExportSnapshotInputOperationOutputAlias = crate::operation::ExportSnapshot;
#[doc(hidden)]
pub type ExportSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ExportSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`ExportSnapshot`](crate::operation::ExportSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ExportSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ExportSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ExportSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ExportSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.ExportSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_export_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ExportSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ExportSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ExportSnapshotInput`](crate::input::ExportSnapshotInput)
    pub fn builder() -> crate::input::export_snapshot_input::Builder {
        crate::input::export_snapshot_input::Builder::default()
    }
}

/// See [`GetActiveNamesInput`](crate::input::GetActiveNamesInput)
pub mod get_active_names_input {
    /// A builder for [`GetActiveNamesInput`](crate::input::GetActiveNamesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetActiveNames</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetActiveNames</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetActiveNamesInput`](crate::input::GetActiveNamesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetActiveNamesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetActiveNamesInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetActiveNamesInputOperationOutputAlias = crate::operation::GetActiveNames;
#[doc(hidden)]
pub type GetActiveNamesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetActiveNamesInput {
    /// Consumes the builder and constructs an Operation<[`GetActiveNames`](crate::operation::GetActiveNames)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetActiveNames,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetActiveNamesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetActiveNamesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetActiveNamesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetActiveNames",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_active_names(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetActiveNames::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetActiveNames",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetActiveNamesInput`](crate::input::GetActiveNamesInput)
    pub fn builder() -> crate::input::get_active_names_input::Builder {
        crate::input::get_active_names_input::Builder::default()
    }
}

/// See [`GetAlarmsInput`](crate::input::GetAlarmsInput)
pub mod get_alarms_input {
    /// A builder for [`GetAlarmsInput`](crate::input::GetAlarmsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
        pub(crate) monitored_resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the alarm.</p>
        /// <p>Specify an alarm name to return information about a specific alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of the alarm.</p>
        /// <p>Specify an alarm name to return information about a specific alarm.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetAlarms</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetAlarms</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// <p>The name of the Lightsail resource being monitored by the alarm.</p>
        /// <p>Specify a monitored resource name to return information about all alarms for a specific
        /// resource.</p>
        pub fn monitored_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitored_resource_name = Some(input.into());
            self
        }
        /// <p>The name of the Lightsail resource being monitored by the alarm.</p>
        /// <p>Specify a monitored resource name to return information about all alarms for a specific
        /// resource.</p>
        pub fn set_monitored_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitored_resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAlarmsInput`](crate::input::GetAlarmsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetAlarmsInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetAlarmsInput {
                alarm_name: self.alarm_name,
                page_token: self.page_token,
                monitored_resource_name: self.monitored_resource_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAlarmsInputOperationOutputAlias = crate::operation::GetAlarms;
#[doc(hidden)]
pub type GetAlarmsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAlarmsInput {
    /// Consumes the builder and constructs an Operation<[`GetAlarms`](crate::operation::GetAlarms)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAlarms,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetAlarmsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetAlarmsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetAlarmsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetAlarms",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_alarms(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetAlarms::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetAlarms",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAlarmsInput`](crate::input::GetAlarmsInput)
    pub fn builder() -> crate::input::get_alarms_input::Builder {
        crate::input::get_alarms_input::Builder::default()
    }
}

/// See [`GetAutoSnapshotsInput`](crate::input::GetAutoSnapshotsInput)
pub mod get_auto_snapshots_input {
    /// A builder for [`GetAutoSnapshotsInput`](crate::input::GetAutoSnapshotsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the source instance or disk from which to get automatic snapshot
        /// information.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the source instance or disk from which to get automatic snapshot
        /// information.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAutoSnapshotsInput`](crate::input::GetAutoSnapshotsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAutoSnapshotsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAutoSnapshotsInput {
                resource_name: self.resource_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAutoSnapshotsInputOperationOutputAlias = crate::operation::GetAutoSnapshots;
#[doc(hidden)]
pub type GetAutoSnapshotsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAutoSnapshotsInput {
    /// Consumes the builder and constructs an Operation<[`GetAutoSnapshots`](crate::operation::GetAutoSnapshots)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAutoSnapshots,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetAutoSnapshotsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetAutoSnapshotsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetAutoSnapshotsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetAutoSnapshots",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_auto_snapshots(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAutoSnapshots::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAutoSnapshots",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAutoSnapshotsInput`](crate::input::GetAutoSnapshotsInput)
    pub fn builder() -> crate::input::get_auto_snapshots_input::Builder {
        crate::input::get_auto_snapshots_input::Builder::default()
    }
}

/// See [`GetBlueprintsInput`](crate::input::GetBlueprintsInput)
pub mod get_blueprints_input {
    /// A builder for [`GetBlueprintsInput`](crate::input::GetBlueprintsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_inactive: std::option::Option<bool>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A Boolean value indicating whether to include inactive results in your request.</p>
        pub fn include_inactive(mut self, input: bool) -> Self {
            self.include_inactive = Some(input);
            self
        }
        /// <p>A Boolean value indicating whether to include inactive results in your request.</p>
        pub fn set_include_inactive(mut self, input: std::option::Option<bool>) -> Self {
            self.include_inactive = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetBlueprints</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetBlueprints</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBlueprintsInput`](crate::input::GetBlueprintsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBlueprintsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBlueprintsInput {
                include_inactive: self.include_inactive,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBlueprintsInputOperationOutputAlias = crate::operation::GetBlueprints;
#[doc(hidden)]
pub type GetBlueprintsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBlueprintsInput {
    /// Consumes the builder and constructs an Operation<[`GetBlueprints`](crate::operation::GetBlueprints)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBlueprints,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBlueprintsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBlueprintsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBlueprintsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetBlueprints",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_blueprints(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBlueprints::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBlueprints",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBlueprintsInput`](crate::input::GetBlueprintsInput)
    pub fn builder() -> crate::input::get_blueprints_input::Builder {
        crate::input::get_blueprints_input::Builder::default()
    }
}

/// See [`GetBucketAccessKeysInput`](crate::input::GetBucketAccessKeysInput)
pub mod get_bucket_access_keys_input {
    /// A builder for [`GetBucketAccessKeysInput`](crate::input::GetBucketAccessKeysInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to return access keys.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket for which to return access keys.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketAccessKeysInput`](crate::input::GetBucketAccessKeysInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketAccessKeysInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketAccessKeysInput {
                bucket_name: self.bucket_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketAccessKeysInputOperationOutputAlias = crate::operation::GetBucketAccessKeys;
#[doc(hidden)]
pub type GetBucketAccessKeysInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketAccessKeysInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketAccessKeys`](crate::operation::GetBucketAccessKeys)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBucketAccessKeys,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketAccessKeysInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketAccessKeysInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketAccessKeysInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetBucketAccessKeys",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_access_keys(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketAccessKeys::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBucketAccessKeys",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketAccessKeysInput`](crate::input::GetBucketAccessKeysInput)
    pub fn builder() -> crate::input::get_bucket_access_keys_input::Builder {
        crate::input::get_bucket_access_keys_input::Builder::default()
    }
}

/// See [`GetBucketBundlesInput`](crate::input::GetBucketBundlesInput)
pub mod get_bucket_bundles_input {
    /// A builder for [`GetBucketBundlesInput`](crate::input::GetBucketBundlesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_inactive: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A Boolean value that indicates whether to include inactive (unavailable) bundles in the
        /// response.</p>
        pub fn include_inactive(mut self, input: bool) -> Self {
            self.include_inactive = Some(input);
            self
        }
        /// <p>A Boolean value that indicates whether to include inactive (unavailable) bundles in the
        /// response.</p>
        pub fn set_include_inactive(mut self, input: std::option::Option<bool>) -> Self {
            self.include_inactive = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketBundlesInput`](crate::input::GetBucketBundlesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketBundlesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketBundlesInput {
                include_inactive: self.include_inactive,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketBundlesInputOperationOutputAlias = crate::operation::GetBucketBundles;
#[doc(hidden)]
pub type GetBucketBundlesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketBundlesInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketBundles`](crate::operation::GetBucketBundles)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBucketBundles,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketBundlesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketBundlesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketBundlesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetBucketBundles",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_bundles(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketBundles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBucketBundles",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketBundlesInput`](crate::input::GetBucketBundlesInput)
    pub fn builder() -> crate::input::get_bucket_bundles_input::Builder {
        crate::input::get_bucket_bundles_input::Builder::default()
    }
}

/// See [`GetBucketMetricDataInput`](crate::input::GetBucketMetricDataInput)
pub mod get_bucket_metric_data_input {
    /// A builder for [`GetBucketMetricDataInput`](crate::input::GetBucketMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::BucketMetricName>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        pub(crate) unit: std::option::Option<crate::model::MetricUnit>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to get metric data.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket for which to get metric data.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The metric for which you want to return information.</p>
        ///
        /// <p>Valid bucket metric names are listed below, along with the most useful statistics to
        /// include in your request, and the published unit value.</p>
        ///
        /// <note>
        /// <p>These bucket metrics are reported once per day.</p>
        /// </note>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BucketSizeBytes</code>
        /// </b> - The amount of data in
        /// bytes stored in a bucket. This value is calculated by summing the size of all objects in
        /// the bucket (including object versions), including the size of all parts for all incomplete
        /// multipart uploads to the bucket.</p>
        /// <p>Statistics: The most useful statistic is <code>Maximum</code>.</p>
        /// <p>Unit: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NumberOfObjects</code>
        /// </b> - The total number of
        /// objects stored in a bucket. This value is calculated by counting all objects in the bucket
        /// (including object versions) and the total number of parts for all incomplete multipart
        /// uploads to the bucket.</p>
        /// <p>Statistics: The most useful statistic is <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::BucketMetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        ///
        /// <p>Valid bucket metric names are listed below, along with the most useful statistics to
        /// include in your request, and the published unit value.</p>
        ///
        /// <note>
        /// <p>These bucket metrics are reported once per day.</p>
        /// </note>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BucketSizeBytes</code>
        /// </b> - The amount of data in
        /// bytes stored in a bucket. This value is calculated by summing the size of all objects in
        /// the bucket (including object versions), including the size of all parts for all incomplete
        /// multipart uploads to the bucket.</p>
        /// <p>Statistics: The most useful statistic is <code>Maximum</code>.</p>
        /// <p>Unit: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NumberOfObjects</code>
        /// </b> - The total number of
        /// objects stored in a bucket. This value is calculated by counting all objects in the bucket
        /// (including object versions) and the total number of parts for all incomplete multipart
        /// uploads to the bucket.</p>
        /// <p>Statistics: The most useful statistic is <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::BucketMetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The timestamp indicating the earliest data to be returned.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The timestamp indicating the earliest data to be returned.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The timestamp indicating the latest data to be returned.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The timestamp indicating the latest data to be returned.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <note>
        /// <p>Bucket storage metrics are reported once per day. Therefore, you should specify a period
        /// of 86400 seconds, which is the number of seconds in a day.</p>
        /// </note>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <note>
        /// <p>Bucket storage metrics are reported once per day. Therefore, you should specify a period
        /// of 86400 seconds, which is the number of seconds in a day.</p>
        /// </note>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The statistic for the metric.</p>
        ///
        /// <p>The following statistics are available:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - The sum of all values submitted for the matching metric. You can
        /// use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
        /// the specified period. By comparing this statistic with the <code>Minimum</code> and
        /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
        /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, input: impl Into<crate::model::MetricStatistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The statistic for the metric.</p>
        ///
        /// <p>The following statistics are available:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - The sum of all values submitted for the matching metric. You can
        /// use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
        /// the specified period. By comparing this statistic with the <code>Minimum</code> and
        /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
        /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// <p>The unit for the metric data request.</p>
        /// <p>Valid units depend on the metric data being requested. For the valid units with each
        /// available metric, see the <code>metricName</code> parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric data request.</p>
        /// <p>Valid units depend on the metric data being requested. For the valid units with each
        /// available metric, see the <code>metricName</code> parameter.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketMetricDataInput`](crate::input::GetBucketMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketMetricDataInput {
                bucket_name: self.bucket_name,
                metric_name: self.metric_name,
                start_time: self.start_time,
                end_time: self.end_time,
                period: self.period.unwrap_or_default(),
                statistics: self.statistics,
                unit: self.unit,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketMetricDataInputOperationOutputAlias = crate::operation::GetBucketMetricData;
#[doc(hidden)]
pub type GetBucketMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetBucketMetricData`](crate::operation::GetBucketMetricData)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBucketMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetBucketMetricData",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_bucket_metric_data(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBucketMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBucketMetricData",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketMetricDataInput`](crate::input::GetBucketMetricDataInput)
    pub fn builder() -> crate::input::get_bucket_metric_data_input::Builder {
        crate::input::get_bucket_metric_data_input::Builder::default()
    }
}

/// See [`GetBucketsInput`](crate::input::GetBucketsInput)
pub mod get_buckets_input {
    /// A builder for [`GetBucketsInput`](crate::input::GetBucketsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
        pub(crate) include_connected_resources: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to return information.</p>
        ///
        /// <p>When omitted, the response includes all of your buckets in the AWS Region where the
        /// request is made.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket for which to return information.</p>
        ///
        /// <p>When omitted, the response includes all of your buckets in the AWS Region where the
        /// request is made.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        ///
        /// <p>To get a page token, perform an initial <code>GetBuckets</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        ///
        /// <p>To get a page token, perform an initial <code>GetBuckets</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// <p>A Boolean value that indicates whether to include Lightsail instances that were given
        /// access to the bucket using the <a>SetResourceAccessForBucket</a> action.</p>
        pub fn include_connected_resources(mut self, input: bool) -> Self {
            self.include_connected_resources = Some(input);
            self
        }
        /// <p>A Boolean value that indicates whether to include Lightsail instances that were given
        /// access to the bucket using the <a>SetResourceAccessForBucket</a> action.</p>
        pub fn set_include_connected_resources(mut self, input: std::option::Option<bool>) -> Self {
            self.include_connected_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBucketsInput`](crate::input::GetBucketsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBucketsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBucketsInput {
                bucket_name: self.bucket_name,
                page_token: self.page_token,
                include_connected_resources: self.include_connected_resources,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBucketsInputOperationOutputAlias = crate::operation::GetBuckets;
#[doc(hidden)]
pub type GetBucketsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBucketsInput {
    /// Consumes the builder and constructs an Operation<[`GetBuckets`](crate::operation::GetBuckets)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBuckets,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBucketsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBucketsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBucketsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetBuckets",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_buckets(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBuckets::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBuckets",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBucketsInput`](crate::input::GetBucketsInput)
    pub fn builder() -> crate::input::get_buckets_input::Builder {
        crate::input::get_buckets_input::Builder::default()
    }
}

/// See [`GetBundlesInput`](crate::input::GetBundlesInput)
pub mod get_bundles_input {
    /// A builder for [`GetBundlesInput`](crate::input::GetBundlesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_inactive: std::option::Option<bool>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A Boolean value that indicates whether to include inactive bundle results in your
        /// request.</p>
        pub fn include_inactive(mut self, input: bool) -> Self {
            self.include_inactive = Some(input);
            self
        }
        /// <p>A Boolean value that indicates whether to include inactive bundle results in your
        /// request.</p>
        pub fn set_include_inactive(mut self, input: std::option::Option<bool>) -> Self {
            self.include_inactive = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetBundles</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetBundles</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetBundlesInput`](crate::input::GetBundlesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetBundlesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetBundlesInput {
                include_inactive: self.include_inactive,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetBundlesInputOperationOutputAlias = crate::operation::GetBundles;
#[doc(hidden)]
pub type GetBundlesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetBundlesInput {
    /// Consumes the builder and constructs an Operation<[`GetBundles`](crate::operation::GetBundles)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetBundles,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetBundlesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetBundlesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetBundlesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetBundles",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_bundles(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetBundles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetBundles",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetBundlesInput`](crate::input::GetBundlesInput)
    pub fn builder() -> crate::input::get_bundles_input::Builder {
        crate::input::get_bundles_input::Builder::default()
    }
}

/// See [`GetCertificatesInput`](crate::input::GetCertificatesInput)
pub mod get_certificates_input {
    /// A builder for [`GetCertificatesInput`](crate::input::GetCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_statuses:
            std::option::Option<std::vec::Vec<crate::model::CertificateStatus>>,
        pub(crate) include_certificate_details: std::option::Option<bool>,
        pub(crate) certificate_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `certificate_statuses`.
        ///
        /// To override the contents of this collection use [`set_certificate_statuses`](Self::set_certificate_statuses).
        ///
        /// <p>The status of the certificates for which to return information.</p>
        /// <p>For example, specify <code>ISSUED</code> to return only certificates with an
        /// <code>ISSUED</code> status.</p>
        /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
        /// request is made, regardless of their current status.</p>
        pub fn certificate_statuses(
            mut self,
            input: impl Into<crate::model::CertificateStatus>,
        ) -> Self {
            let mut v = self.certificate_statuses.unwrap_or_default();
            v.push(input.into());
            self.certificate_statuses = Some(v);
            self
        }
        /// <p>The status of the certificates for which to return information.</p>
        /// <p>For example, specify <code>ISSUED</code> to return only certificates with an
        /// <code>ISSUED</code> status.</p>
        /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
        /// request is made, regardless of their current status.</p>
        pub fn set_certificate_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CertificateStatus>>,
        ) -> Self {
            self.certificate_statuses = input;
            self
        }
        /// <p>Indicates whether to include detailed information about the certificates in the
        /// response.</p>
        /// <p>When omitted, the response includes only the certificate names, Amazon Resource Names
        /// (ARNs), domain names, and tags.</p>
        pub fn include_certificate_details(mut self, input: bool) -> Self {
            self.include_certificate_details = Some(input);
            self
        }
        /// <p>Indicates whether to include detailed information about the certificates in the
        /// response.</p>
        /// <p>When omitted, the response includes only the certificate names, Amazon Resource Names
        /// (ARNs), domain names, and tags.</p>
        pub fn set_include_certificate_details(mut self, input: std::option::Option<bool>) -> Self {
            self.include_certificate_details = input;
            self
        }
        /// <p>The name for the certificate for which to return information.</p>
        /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
        /// request is made.</p>
        pub fn certificate_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_name = Some(input.into());
            self
        }
        /// <p>The name for the certificate for which to return information.</p>
        /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
        /// request is made.</p>
        pub fn set_certificate_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCertificatesInput`](crate::input::GetCertificatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCertificatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCertificatesInput {
                certificate_statuses: self.certificate_statuses,
                include_certificate_details: self.include_certificate_details.unwrap_or_default(),
                certificate_name: self.certificate_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCertificatesInputOperationOutputAlias = crate::operation::GetCertificates;
#[doc(hidden)]
pub type GetCertificatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`GetCertificates`](crate::operation::GetCertificates)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCertificates,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCertificatesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCertificatesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCertificatesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetCertificates",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_certificates(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCertificates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCertificates",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCertificatesInput`](crate::input::GetCertificatesInput)
    pub fn builder() -> crate::input::get_certificates_input::Builder {
        crate::input::get_certificates_input::Builder::default()
    }
}

/// See [`GetCloudFormationStackRecordsInput`](crate::input::GetCloudFormationStackRecordsInput)
pub mod get_cloud_formation_stack_records_input {
    /// A builder for [`GetCloudFormationStackRecordsInput`](crate::input::GetCloudFormationStackRecordsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetClouFormationStackRecords</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetClouFormationStackRecords</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCloudFormationStackRecordsInput`](crate::input::GetCloudFormationStackRecordsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCloudFormationStackRecordsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCloudFormationStackRecordsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCloudFormationStackRecordsInputOperationOutputAlias =
    crate::operation::GetCloudFormationStackRecords;
#[doc(hidden)]
pub type GetCloudFormationStackRecordsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCloudFormationStackRecordsInput {
    /// Consumes the builder and constructs an Operation<[`GetCloudFormationStackRecords`](crate::operation::GetCloudFormationStackRecords)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCloudFormationStackRecords,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCloudFormationStackRecordsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCloudFormationStackRecordsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCloudFormationStackRecordsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetCloudFormationStackRecords",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_cloud_formation_stack_records(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCloudFormationStackRecords::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCloudFormationStackRecords",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCloudFormationStackRecordsInput`](crate::input::GetCloudFormationStackRecordsInput)
    pub fn builder() -> crate::input::get_cloud_formation_stack_records_input::Builder {
        crate::input::get_cloud_formation_stack_records_input::Builder::default()
    }
}

/// See [`GetContactMethodsInput`](crate::input::GetContactMethodsInput)
pub mod get_contact_methods_input {
    /// A builder for [`GetContactMethodsInput`](crate::input::GetContactMethodsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocols: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
    }
    impl Builder {
        /// Appends an item to `protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>The protocols used to send notifications, such as <code>Email</code>, or <code>SMS</code>
        /// (text messaging).</p>
        /// <p>Specify a protocol in your request to return information about a specific contact method
        /// protocol.</p>
        pub fn protocols(mut self, input: impl Into<crate::model::ContactProtocol>) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input.into());
            self.protocols = Some(v);
            self
        }
        /// <p>The protocols used to send notifications, such as <code>Email</code>, or <code>SMS</code>
        /// (text messaging).</p>
        /// <p>Specify a protocol in your request to return information about a specific contact method
        /// protocol.</p>
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
        ) -> Self {
            self.protocols = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContactMethodsInput`](crate::input::GetContactMethodsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContactMethodsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContactMethodsInput {
                protocols: self.protocols,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContactMethodsInputOperationOutputAlias = crate::operation::GetContactMethods;
#[doc(hidden)]
pub type GetContactMethodsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContactMethodsInput {
    /// Consumes the builder and constructs an Operation<[`GetContactMethods`](crate::operation::GetContactMethods)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContactMethods,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContactMethodsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContactMethodsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContactMethodsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContactMethods",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_contact_methods(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContactMethods::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContactMethods",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContactMethodsInput`](crate::input::GetContactMethodsInput)
    pub fn builder() -> crate::input::get_contact_methods_input::Builder {
        crate::input::get_contact_methods_input::Builder::default()
    }
}

/// See [`GetContainerApiMetadataInput`](crate::input::GetContainerApiMetadataInput)
pub mod get_container_api_metadata_input {
    /// A builder for [`GetContainerApiMetadataInput`](crate::input::GetContainerApiMetadataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetContainerApiMetadataInput`](crate::input::GetContainerApiMetadataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerApiMetadataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerApiMetadataInput {})
        }
    }
}
#[doc(hidden)]
pub type GetContainerApiMetadataInputOperationOutputAlias =
    crate::operation::GetContainerAPIMetadata;
#[doc(hidden)]
pub type GetContainerApiMetadataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerApiMetadataInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerAPIMetadata`](crate::operation::GetContainerAPIMetadata)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerAPIMetadata,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerApiMetadataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerApiMetadataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerApiMetadataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerAPIMetadata",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_api_metadata(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerAPIMetadata::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerAPIMetadata",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerApiMetadataInput`](crate::input::GetContainerApiMetadataInput)
    pub fn builder() -> crate::input::get_container_api_metadata_input::Builder {
        crate::input::get_container_api_metadata_input::Builder::default()
    }
}

/// See [`GetContainerImagesInput`](crate::input::GetContainerImagesInput)
pub mod get_container_images_input {
    /// A builder for [`GetContainerImagesInput`](crate::input::GetContainerImagesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service for which to return registered container images.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to return registered container images.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContainerImagesInput`](crate::input::GetContainerImagesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerImagesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerImagesInput {
                service_name: self.service_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContainerImagesInputOperationOutputAlias = crate::operation::GetContainerImages;
#[doc(hidden)]
pub type GetContainerImagesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerImagesInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerImages`](crate::operation::GetContainerImages)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerImages,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerImagesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerImagesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerImagesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerImages",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_images(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerImages::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerImages",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerImagesInput`](crate::input::GetContainerImagesInput)
    pub fn builder() -> crate::input::get_container_images_input::Builder {
        crate::input::get_container_images_input::Builder::default()
    }
}

/// See [`GetContainerLogInput`](crate::input::GetContainerLogInput)
pub mod get_container_log_input {
    /// A builder for [`GetContainerLogInput`](crate::input::GetContainerLogInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) container_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service for which to get a container log.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to get a container log.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The name of the container that is either running or previously ran on the container
        /// service for which to return a log.</p>
        pub fn container_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.container_name = Some(input.into());
            self
        }
        /// <p>The name of the container that is either running or previously ran on the container
        /// service for which to return a log.</p>
        pub fn set_container_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.container_name = input;
            self
        }
        /// <p>The start of the time interval for which to get log data.</p>
        ///
        /// <p>Constraints:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        ///
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
        /// <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        ///
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start of the time interval for which to get log data.</p>
        ///
        /// <p>Constraints:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        ///
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
        /// <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        ///
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time interval for which to get log data.</p>
        ///
        /// <p>Constraints:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        ///
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
        /// <code>1538427600</code> as the end time.</p>
        /// </li>
        /// </ul>
        ///
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time interval for which to get log data.</p>
        ///
        /// <p>Constraints:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        ///
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
        /// <code>1538427600</code> as the end time.</p>
        /// </li>
        /// </ul>
        ///
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The pattern to use to filter the returned log events to a specific term.</p>
        ///
        /// <p>The following are a few examples of filter patterns that you can specify:</p>
        /// <ul>
        /// <li>
        /// <p>To return all log events, specify a filter pattern of <code>""</code>.</p>
        /// </li>
        /// <li>
        /// <p>To exclude log events that contain the <code>ERROR</code> term, and return all other
        /// log events, specify a filter pattern of <code>"-ERROR"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain the <code>ERROR</code> term, specify a filter
        /// pattern of <code>"ERROR"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain both the <code>ERROR</code> and
        /// <code>Exception</code> terms, specify a filter pattern of <code>"ERROR
        /// Exception"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain the <code>ERROR</code>
        /// <i>or</i> the <code>Exception</code> term, specify a filter pattern of
        /// <code>"?ERROR ?Exception"</code>.</p>
        /// </li>
        /// </ul>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        /// <p>The pattern to use to filter the returned log events to a specific term.</p>
        ///
        /// <p>The following are a few examples of filter patterns that you can specify:</p>
        /// <ul>
        /// <li>
        /// <p>To return all log events, specify a filter pattern of <code>""</code>.</p>
        /// </li>
        /// <li>
        /// <p>To exclude log events that contain the <code>ERROR</code> term, and return all other
        /// log events, specify a filter pattern of <code>"-ERROR"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain the <code>ERROR</code> term, specify a filter
        /// pattern of <code>"ERROR"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain both the <code>ERROR</code> and
        /// <code>Exception</code> terms, specify a filter pattern of <code>"ERROR
        /// Exception"</code>.</p>
        /// </li>
        /// <li>
        /// <p>To return log events that contain the <code>ERROR</code>
        /// <i>or</i> the <code>Exception</code> term, specify a filter pattern of
        /// <code>"?ERROR ?Exception"</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        ///
        /// <p>To get a page token, perform an initial <code>GetContainerLog</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        ///
        /// <p>To get a page token, perform an initial <code>GetContainerLog</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContainerLogInput`](crate::input::GetContainerLogInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerLogInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerLogInput {
                service_name: self.service_name,
                container_name: self.container_name,
                start_time: self.start_time,
                end_time: self.end_time,
                filter_pattern: self.filter_pattern,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContainerLogInputOperationOutputAlias = crate::operation::GetContainerLog;
#[doc(hidden)]
pub type GetContainerLogInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerLogInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerLog`](crate::operation::GetContainerLog)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerLog,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerLogInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::GetContainerLogInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_1) = &_input.start_time {
                query.push_kv(
                    "startTime",
                    &aws_smithy_http::query::fmt_timestamp(
                        inner_1,
                        aws_smithy_types::instant::Format::DateTime,
                    ),
                );
            }
            if let Some(inner_2) = &_input.end_time {
                query.push_kv(
                    "endTime",
                    &aws_smithy_http::query::fmt_timestamp(
                        inner_2,
                        aws_smithy_types::instant::Format::DateTime,
                    ),
                );
            }
            if let Some(inner_3) = &_input.filter_pattern {
                query.push_kv(
                    "filterPattern",
                    &aws_smithy_http::query::fmt_string(&inner_3),
                );
            }
            if let Some(inner_4) = &_input.page_token {
                query.push_kv("pageToken", &aws_smithy_http::query::fmt_string(&inner_4));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerLogInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerLogInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerLog",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_log(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerLog::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerLog",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerLogInput`](crate::input::GetContainerLogInput)
    pub fn builder() -> crate::input::get_container_log_input::Builder {
        crate::input::get_container_log_input::Builder::default()
    }
}

/// See [`GetContainerServiceDeploymentsInput`](crate::input::GetContainerServiceDeploymentsInput)
pub mod get_container_service_deployments_input {
    /// A builder for [`GetContainerServiceDeploymentsInput`](crate::input::GetContainerServiceDeploymentsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service for which to return deployments.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to return deployments.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContainerServiceDeploymentsInput`](crate::input::GetContainerServiceDeploymentsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerServiceDeploymentsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerServiceDeploymentsInput {
                service_name: self.service_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContainerServiceDeploymentsInputOperationOutputAlias =
    crate::operation::GetContainerServiceDeployments;
#[doc(hidden)]
pub type GetContainerServiceDeploymentsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerServiceDeploymentsInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerServiceDeployments`](crate::operation::GetContainerServiceDeployments)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerServiceDeployments,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerServiceDeploymentsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerServiceDeploymentsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerServiceDeploymentsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerServiceDeployments",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_service_deployments(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerServiceDeployments::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerServiceDeployments",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerServiceDeploymentsInput`](crate::input::GetContainerServiceDeploymentsInput)
    pub fn builder() -> crate::input::get_container_service_deployments_input::Builder {
        crate::input::get_container_service_deployments_input::Builder::default()
    }
}

/// See [`GetContainerServiceMetricDataInput`](crate::input::GetContainerServiceMetricDataInput)
pub mod get_container_service_metric_data_input {
    /// A builder for [`GetContainerServiceMetricDataInput`](crate::input::GetContainerServiceMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::ContainerServiceMetricName>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
    }
    impl Builder {
        /// <p>The name of the container service for which to get metric data.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to get metric data.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The metric for which you want to return information.</p>
        ///
        /// <p>Valid container service metric names are listed below, along with the most useful
        /// statistics to include in your request, and the published unit value.</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CPUUtilization</code> - The average percentage of compute units that are
        /// currently in use across all nodes of the container service. This metric identifies the
        /// processing power required to run containers on each node of the container service.</p>
        /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MemoryUtilization</code> - The average percentage of available memory that is
        /// currently in use across all nodes of the container service. This metric identifies the
        /// memory required to run containers on each node of the container service.</p>
        /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::ContainerServiceMetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        ///
        /// <p>Valid container service metric names are listed below, along with the most useful
        /// statistics to include in your request, and the published unit value.</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CPUUtilization</code> - The average percentage of compute units that are
        /// currently in use across all nodes of the container service. This metric identifies the
        /// processing power required to run containers on each node of the container service.</p>
        /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MemoryUtilization</code> - The average percentage of available memory that is
        /// currently in use across all nodes of the container service. This metric identifies the
        /// memory required to run containers on each node of the container service.</p>
        /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>Unit: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::ContainerServiceMetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The start time of the time period.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the time period.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time of the time period.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time of the time period.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        ///
        /// <p>All container service metric data is available in 5-minute (300 seconds)
        /// granularity.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        ///
        /// <p>All container service metric data is available in 5-minute (300 seconds)
        /// granularity.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The statistic for the metric.</p>
        ///
        /// <p>The following statistics are available:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
        /// the specified period. By comparing this statistic with the <code>Minimum</code> and
        /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
        /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, input: impl Into<crate::model::MetricStatistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The statistic for the metric.</p>
        ///
        /// <p>The following statistics are available:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
        /// the specified period. By comparing this statistic with the <code>Minimum</code> and
        /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
        /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContainerServiceMetricDataInput`](crate::input::GetContainerServiceMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerServiceMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerServiceMetricDataInput {
                service_name: self.service_name,
                metric_name: self.metric_name,
                start_time: self.start_time,
                end_time: self.end_time,
                period: self.period.unwrap_or_default(),
                statistics: self.statistics,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContainerServiceMetricDataInputOperationOutputAlias =
    crate::operation::GetContainerServiceMetricData;
#[doc(hidden)]
pub type GetContainerServiceMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerServiceMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerServiceMetricData`](crate::operation::GetContainerServiceMetricData)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerServiceMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerServiceMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetContainerServiceMetricDataInput,
            mut output: &mut String,
        ) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_5) = &_input.metric_name {
                query.push_kv("metricName", &aws_smithy_http::query::fmt_string(&inner_5));
            }
            if let Some(inner_6) = &_input.start_time {
                query.push_kv(
                    "startTime",
                    &aws_smithy_http::query::fmt_timestamp(
                        inner_6,
                        aws_smithy_types::instant::Format::DateTime,
                    ),
                );
            }
            if let Some(inner_7) = &_input.end_time {
                query.push_kv(
                    "endTime",
                    &aws_smithy_http::query::fmt_timestamp(
                        inner_7,
                        aws_smithy_types::instant::Format::DateTime,
                    ),
                );
            }
            if _input.period != 0 {
                query.push_kv(
                    "period",
                    &aws_smithy_types::primitive::Encoder::from(_input.period).encode(),
                );
            }
            if let Some(inner_8) = &_input.statistics {
                for inner_9 in inner_8 {
                    query.push_kv("statistics", &aws_smithy_http::query::fmt_string(&inner_9));
                }
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerServiceMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerServiceMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerServiceMetricData",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_service_metric_data(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerServiceMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerServiceMetricData",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerServiceMetricDataInput`](crate::input::GetContainerServiceMetricDataInput)
    pub fn builder() -> crate::input::get_container_service_metric_data_input::Builder {
        crate::input::get_container_service_metric_data_input::Builder::default()
    }
}

/// See [`GetContainerServicePowersInput`](crate::input::GetContainerServicePowersInput)
pub mod get_container_service_powers_input {
    /// A builder for [`GetContainerServicePowersInput`](crate::input::GetContainerServicePowersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetContainerServicePowersInput`](crate::input::GetContainerServicePowersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerServicePowersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerServicePowersInput {})
        }
    }
}
#[doc(hidden)]
pub type GetContainerServicePowersInputOperationOutputAlias =
    crate::operation::GetContainerServicePowers;
#[doc(hidden)]
pub type GetContainerServicePowersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerServicePowersInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerServicePowers`](crate::operation::GetContainerServicePowers)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerServicePowers,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerServicePowersInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerServicePowersInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerServicePowersInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerServicePowers",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_service_powers(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerServicePowers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerServicePowers",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerServicePowersInput`](crate::input::GetContainerServicePowersInput)
    pub fn builder() -> crate::input::get_container_service_powers_input::Builder {
        crate::input::get_container_service_powers_input::Builder::default()
    }
}

/// See [`GetContainerServicesInput`](crate::input::GetContainerServicesInput)
pub mod get_container_services_input {
    /// A builder for [`GetContainerServicesInput`](crate::input::GetContainerServicesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service for which to return information.</p>
        ///
        /// <p>When omitted, the response includes all of your container services in the AWS Region
        /// where the request is made.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to return information.</p>
        ///
        /// <p>When omitted, the response includes all of your container services in the AWS Region
        /// where the request is made.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetContainerServicesInput`](crate::input::GetContainerServicesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetContainerServicesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetContainerServicesInput {
                service_name: self.service_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetContainerServicesInputOperationOutputAlias = crate::operation::GetContainerServices;
#[doc(hidden)]
pub type GetContainerServicesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetContainerServicesInput {
    /// Consumes the builder and constructs an Operation<[`GetContainerServices`](crate::operation::GetContainerServices)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetContainerServices,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetContainerServicesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(_input: &crate::input::GetContainerServicesInput, mut output: &mut String) {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_10) = &_input.service_name {
                query.push_kv(
                    "serviceName",
                    &aws_smithy_http::query::fmt_string(&inner_10),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetContainerServicesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetContainerServicesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetContainerServices",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_container_services(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetContainerServices::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetContainerServices",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetContainerServicesInput`](crate::input::GetContainerServicesInput)
    pub fn builder() -> crate::input::get_container_services_input::Builder {
        crate::input::get_container_services_input::Builder::default()
    }
}

/// See [`GetDiskInput`](crate::input::GetDiskInput)
pub mod get_disk_input {
    /// A builder for [`GetDiskInput`](crate::input::GetDiskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the disk (e.g., <code>my-disk</code>).</p>
        pub fn disk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_name = Some(input.into());
            self
        }
        /// <p>The name of the disk (e.g., <code>my-disk</code>).</p>
        pub fn set_disk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDiskInput`](crate::input::GetDiskInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetDiskInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetDiskInput {
                disk_name: self.disk_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDiskInputOperationOutputAlias = crate::operation::GetDisk;
#[doc(hidden)]
pub type GetDiskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDiskInput {
    /// Consumes the builder and constructs an Operation<[`GetDisk`](crate::operation::GetDisk)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDisk,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDiskInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDiskInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDiskInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDisk",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_disk(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetDisk::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetDisk",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDiskInput`](crate::input::GetDiskInput)
    pub fn builder() -> crate::input::get_disk_input::Builder {
        crate::input::get_disk_input::Builder::default()
    }
}

/// See [`GetDisksInput`](crate::input::GetDisksInput)
pub mod get_disks_input {
    /// A builder for [`GetDisksInput`](crate::input::GetDisksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDisks</code> request. If your results are
        /// paginated, the response will return a next page token that you can specify as the page token
        /// in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDisks</code> request. If your results are
        /// paginated, the response will return a next page token that you can specify as the page token
        /// in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDisksInput`](crate::input::GetDisksInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetDisksInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetDisksInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDisksInputOperationOutputAlias = crate::operation::GetDisks;
#[doc(hidden)]
pub type GetDisksInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDisksInput {
    /// Consumes the builder and constructs an Operation<[`GetDisks`](crate::operation::GetDisks)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDisks,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDisksInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDisksInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDisksInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDisks",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_disks(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetDisks::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetDisks",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDisksInput`](crate::input::GetDisksInput)
    pub fn builder() -> crate::input::get_disks_input::Builder {
        crate::input::get_disks_input::Builder::default()
    }
}

/// See [`GetDiskSnapshotInput`](crate::input::GetDiskSnapshotInput)
pub mod get_disk_snapshot_input {
    /// A builder for [`GetDiskSnapshotInput`](crate::input::GetDiskSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the disk snapshot (e.g., <code>my-disk-snapshot</code>).</p>
        pub fn disk_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the disk snapshot (e.g., <code>my-disk-snapshot</code>).</p>
        pub fn set_disk_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDiskSnapshotInput`](crate::input::GetDiskSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDiskSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDiskSnapshotInput {
                disk_snapshot_name: self.disk_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDiskSnapshotInputOperationOutputAlias = crate::operation::GetDiskSnapshot;
#[doc(hidden)]
pub type GetDiskSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDiskSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`GetDiskSnapshot`](crate::operation::GetDiskSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDiskSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDiskSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDiskSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDiskSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDiskSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_disk_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDiskSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDiskSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDiskSnapshotInput`](crate::input::GetDiskSnapshotInput)
    pub fn builder() -> crate::input::get_disk_snapshot_input::Builder {
        crate::input::get_disk_snapshot_input::Builder::default()
    }
}

/// See [`GetDiskSnapshotsInput`](crate::input::GetDiskSnapshotsInput)
pub mod get_disk_snapshots_input {
    /// A builder for [`GetDiskSnapshotsInput`](crate::input::GetDiskSnapshotsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDiskSnapshots</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDiskSnapshots</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDiskSnapshotsInput`](crate::input::GetDiskSnapshotsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDiskSnapshotsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDiskSnapshotsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDiskSnapshotsInputOperationOutputAlias = crate::operation::GetDiskSnapshots;
#[doc(hidden)]
pub type GetDiskSnapshotsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDiskSnapshotsInput {
    /// Consumes the builder and constructs an Operation<[`GetDiskSnapshots`](crate::operation::GetDiskSnapshots)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDiskSnapshots,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDiskSnapshotsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDiskSnapshotsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDiskSnapshotsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDiskSnapshots",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_disk_snapshots(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDiskSnapshots::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDiskSnapshots",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDiskSnapshotsInput`](crate::input::GetDiskSnapshotsInput)
    pub fn builder() -> crate::input::get_disk_snapshots_input::Builder {
        crate::input::get_disk_snapshots_input::Builder::default()
    }
}

/// See [`GetDistributionBundlesInput`](crate::input::GetDistributionBundlesInput)
pub mod get_distribution_bundles_input {
    /// A builder for [`GetDistributionBundlesInput`](crate::input::GetDistributionBundlesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetDistributionBundlesInput`](crate::input::GetDistributionBundlesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDistributionBundlesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDistributionBundlesInput {})
        }
    }
}
#[doc(hidden)]
pub type GetDistributionBundlesInputOperationOutputAlias = crate::operation::GetDistributionBundles;
#[doc(hidden)]
pub type GetDistributionBundlesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDistributionBundlesInput {
    /// Consumes the builder and constructs an Operation<[`GetDistributionBundles`](crate::operation::GetDistributionBundles)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDistributionBundles,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDistributionBundlesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDistributionBundlesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDistributionBundlesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDistributionBundles",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_distribution_bundles(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDistributionBundles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDistributionBundles",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDistributionBundlesInput`](crate::input::GetDistributionBundlesInput)
    pub fn builder() -> crate::input::get_distribution_bundles_input::Builder {
        crate::input::get_distribution_bundles_input::Builder::default()
    }
}

/// See [`GetDistributionLatestCacheResetInput`](crate::input::GetDistributionLatestCacheResetInput)
pub mod get_distribution_latest_cache_reset_input {
    /// A builder for [`GetDistributionLatestCacheResetInput`](crate::input::GetDistributionLatestCacheResetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution for which to return the timestamp of the last cache
        /// reset.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        /// <p>When omitted, the response includes the latest cache reset timestamp of all your
        /// distributions.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution for which to return the timestamp of the last cache
        /// reset.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        /// <p>When omitted, the response includes the latest cache reset timestamp of all your
        /// distributions.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDistributionLatestCacheResetInput`](crate::input::GetDistributionLatestCacheResetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDistributionLatestCacheResetInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDistributionLatestCacheResetInput {
                distribution_name: self.distribution_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDistributionLatestCacheResetInputOperationOutputAlias =
    crate::operation::GetDistributionLatestCacheReset;
#[doc(hidden)]
pub type GetDistributionLatestCacheResetInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDistributionLatestCacheResetInput {
    /// Consumes the builder and constructs an Operation<[`GetDistributionLatestCacheReset`](crate::operation::GetDistributionLatestCacheReset)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDistributionLatestCacheReset,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDistributionLatestCacheResetInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDistributionLatestCacheResetInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDistributionLatestCacheResetInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDistributionLatestCacheReset",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_distribution_latest_cache_reset(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDistributionLatestCacheReset::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDistributionLatestCacheReset",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDistributionLatestCacheResetInput`](crate::input::GetDistributionLatestCacheResetInput)
    pub fn builder() -> crate::input::get_distribution_latest_cache_reset_input::Builder {
        crate::input::get_distribution_latest_cache_reset_input::Builder::default()
    }
}

/// See [`GetDistributionMetricDataInput`](crate::input::GetDistributionMetricDataInput)
pub mod get_distribution_metric_data_input {
    /// A builder for [`GetDistributionMetricDataInput`](crate::input::GetDistributionMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::DistributionMetricName>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) unit: std::option::Option<crate::model::MetricUnit>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
    }
    impl Builder {
        /// <p>The name of the distribution for which to get metric data.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution for which to get metric data.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid distribution metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>Requests</code>
        /// </b> - The total number of viewer
        /// requests received by your Lightsail distribution, for all HTTP methods, and for both
        /// HTTP and HTTPS requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BytesDownloaded</code>
        /// </b> - The number of bytes
        /// downloaded by viewers for GET, HEAD, and OPTIONS requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BytesUploaded </code>
        /// </b> - The number of bytes
        /// uploaded to your origin by your Lightsail distribution, using POST and PUT
        /// requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>TotalErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status code was 4xx or 5xx.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>4xxErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status cod was 4xx. In these cases, the
        /// client or client viewer may have made an error. For example, a status code of 404 (Not
        /// Found) means that the client requested an object that could not be found.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>5xxErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status code was 5xx. In these cases, the
        /// origin server did not satisfy the requests. For example, a status code of 503 (Service
        /// Unavailable) means that the origin server is currently unavailable.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::DistributionMetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid distribution metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>Requests</code>
        /// </b> - The total number of viewer
        /// requests received by your Lightsail distribution, for all HTTP methods, and for both
        /// HTTP and HTTPS requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BytesDownloaded</code>
        /// </b> - The number of bytes
        /// downloaded by viewers for GET, HEAD, and OPTIONS requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BytesUploaded </code>
        /// </b> - The number of bytes
        /// uploaded to your origin by your Lightsail distribution, using POST and PUT
        /// requests.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>None</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>TotalErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status code was 4xx or 5xx.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>4xxErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status cod was 4xx. In these cases, the
        /// client or client viewer may have made an error. For example, a status code of 404 (Not
        /// Found) means that the client requested an object that could not be found.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>5xxErrorRate</code>
        /// </b> - The percentage of all
        /// viewer requests for which the response's HTTP status code was 5xx. In these cases, the
        /// origin server did not satisfy the requests. For example, a status code of 503 (Service
        /// Unavailable) means that the origin server is currently unavailable.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::DistributionMetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The start of the time interval for which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
        /// <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start of the time interval for which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
        /// <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time interval for which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
        /// <code>1538427600</code> as the end time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time interval for which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
        /// <code>1538427600</code> as the end time.</p>
        /// </li>
        /// </ul>
        /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The granularity, in seconds, for the metric data points that will be returned.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, for the metric data points that will be returned.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The unit for the metric data request.</p>
        /// <p>Valid units depend on the metric data being requested. For the valid units with each
        /// available metric, see the <code>metricName</code> parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric data request.</p>
        /// <p>Valid units depend on the metric data being requested. For the valid units with each
        /// available metric, see the <code>metricName</code> parameter.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, input: impl Into<crate::model::MetricStatistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDistributionMetricDataInput`](crate::input::GetDistributionMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDistributionMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDistributionMetricDataInput {
                distribution_name: self.distribution_name,
                metric_name: self.metric_name,
                start_time: self.start_time,
                end_time: self.end_time,
                period: self.period.unwrap_or_default(),
                unit: self.unit,
                statistics: self.statistics,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDistributionMetricDataInputOperationOutputAlias =
    crate::operation::GetDistributionMetricData;
#[doc(hidden)]
pub type GetDistributionMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDistributionMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetDistributionMetricData`](crate::operation::GetDistributionMetricData)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDistributionMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDistributionMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDistributionMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDistributionMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDistributionMetricData",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_distribution_metric_data(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDistributionMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDistributionMetricData",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDistributionMetricDataInput`](crate::input::GetDistributionMetricDataInput)
    pub fn builder() -> crate::input::get_distribution_metric_data_input::Builder {
        crate::input::get_distribution_metric_data_input::Builder::default()
    }
}

/// See [`GetDistributionsInput`](crate::input::GetDistributionsInput)
pub mod get_distributions_input {
    /// A builder for [`GetDistributionsInput`](crate::input::GetDistributionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution for which to return information.</p>
        ///
        /// <p>When omitted, the response includes all of your distributions in the AWS Region where
        /// the request is made.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution for which to return information.</p>
        ///
        /// <p>When omitted, the response includes all of your distributions in the AWS Region where
        /// the request is made.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDistributions</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDistributions</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDistributionsInput`](crate::input::GetDistributionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDistributionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDistributionsInput {
                distribution_name: self.distribution_name,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDistributionsInputOperationOutputAlias = crate::operation::GetDistributions;
#[doc(hidden)]
pub type GetDistributionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDistributionsInput {
    /// Consumes the builder and constructs an Operation<[`GetDistributions`](crate::operation::GetDistributions)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDistributions,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDistributionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDistributionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDistributionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDistributions",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_distributions(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDistributions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDistributions",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDistributionsInput`](crate::input::GetDistributionsInput)
    pub fn builder() -> crate::input::get_distributions_input::Builder {
        crate::input::get_distributions_input::Builder::default()
    }
}

/// See [`GetDomainInput`](crate::input::GetDomainInput)
pub mod get_domain_input {
    /// A builder for [`GetDomainInput`](crate::input::GetDomainInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The domain name for which your want to return information about.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name for which your want to return information about.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDomainInput`](crate::input::GetDomainInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetDomainInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetDomainInput {
                domain_name: self.domain_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDomainInputOperationOutputAlias = crate::operation::GetDomain;
#[doc(hidden)]
pub type GetDomainInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDomainInput {
    /// Consumes the builder and constructs an Operation<[`GetDomain`](crate::operation::GetDomain)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDomain,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDomainInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDomainInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDomainInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDomain",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_domain(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetDomain::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetDomain",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDomainInput`](crate::input::GetDomainInput)
    pub fn builder() -> crate::input::get_domain_input::Builder {
        crate::input::get_domain_input::Builder::default()
    }
}

/// See [`GetDomainsInput`](crate::input::GetDomainsInput)
pub mod get_domains_input {
    /// A builder for [`GetDomainsInput`](crate::input::GetDomainsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDomains</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetDomains</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDomainsInput`](crate::input::GetDomainsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDomainsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDomainsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDomainsInputOperationOutputAlias = crate::operation::GetDomains;
#[doc(hidden)]
pub type GetDomainsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDomainsInput {
    /// Consumes the builder and constructs an Operation<[`GetDomains`](crate::operation::GetDomains)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDomains,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDomainsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDomainsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDomainsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetDomains",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_domains(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDomains::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDomains",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDomainsInput`](crate::input::GetDomainsInput)
    pub fn builder() -> crate::input::get_domains_input::Builder {
        crate::input::get_domains_input::Builder::default()
    }
}

/// See [`GetExportSnapshotRecordsInput`](crate::input::GetExportSnapshotRecordsInput)
pub mod get_export_snapshot_records_input {
    /// A builder for [`GetExportSnapshotRecordsInput`](crate::input::GetExportSnapshotRecordsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetExportSnapshotRecords</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetExportSnapshotRecords</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetExportSnapshotRecordsInput`](crate::input::GetExportSnapshotRecordsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetExportSnapshotRecordsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetExportSnapshotRecordsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetExportSnapshotRecordsInputOperationOutputAlias =
    crate::operation::GetExportSnapshotRecords;
#[doc(hidden)]
pub type GetExportSnapshotRecordsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetExportSnapshotRecordsInput {
    /// Consumes the builder and constructs an Operation<[`GetExportSnapshotRecords`](crate::operation::GetExportSnapshotRecords)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetExportSnapshotRecords,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetExportSnapshotRecordsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetExportSnapshotRecordsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetExportSnapshotRecordsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetExportSnapshotRecords",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_export_snapshot_records(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetExportSnapshotRecords::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetExportSnapshotRecords",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetExportSnapshotRecordsInput`](crate::input::GetExportSnapshotRecordsInput)
    pub fn builder() -> crate::input::get_export_snapshot_records_input::Builder {
        crate::input::get_export_snapshot_records_input::Builder::default()
    }
}

/// See [`GetInstanceInput`](crate::input::GetInstanceInput)
pub mod get_instance_input {
    /// A builder for [`GetInstanceInput`](crate::input::GetInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceInput`](crate::input::GetInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstanceInput {
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceInputOperationOutputAlias = crate::operation::GetInstance;
#[doc(hidden)]
pub type GetInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceInput {
    /// Consumes the builder and constructs an Operation<[`GetInstance`](crate::operation::GetInstance)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstance",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_instance(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstance",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceInput`](crate::input::GetInstanceInput)
    pub fn builder() -> crate::input::get_instance_input::Builder {
        crate::input::get_instance_input::Builder::default()
    }
}

/// See [`GetInstanceAccessDetailsInput`](crate::input::GetInstanceAccessDetailsInput)
pub mod get_instance_access_details_input {
    /// A builder for [`GetInstanceAccessDetailsInput`](crate::input::GetInstanceAccessDetailsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) protocol: std::option::Option<crate::model::InstanceAccessProtocol>,
    }
    impl Builder {
        /// <p>The name of the instance to access.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance to access.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// <p>The protocol to use to connect to your instance. Defaults to <code>ssh</code>.</p>
        pub fn protocol(mut self, input: crate::model::InstanceAccessProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol to use to connect to your instance. Defaults to <code>ssh</code>.</p>
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::InstanceAccessProtocol>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceAccessDetailsInput`](crate::input::GetInstanceAccessDetailsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstanceAccessDetailsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstanceAccessDetailsInput {
                instance_name: self.instance_name,
                protocol: self.protocol,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceAccessDetailsInputOperationOutputAlias =
    crate::operation::GetInstanceAccessDetails;
#[doc(hidden)]
pub type GetInstanceAccessDetailsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceAccessDetailsInput {
    /// Consumes the builder and constructs an Operation<[`GetInstanceAccessDetails`](crate::operation::GetInstanceAccessDetails)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstanceAccessDetails,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceAccessDetailsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceAccessDetailsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceAccessDetailsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstanceAccessDetails",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instance_access_details(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstanceAccessDetails::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstanceAccessDetails",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceAccessDetailsInput`](crate::input::GetInstanceAccessDetailsInput)
    pub fn builder() -> crate::input::get_instance_access_details_input::Builder {
        crate::input::get_instance_access_details_input::Builder::default()
    }
}

/// See [`GetInstanceMetricDataInput`](crate::input::GetInstanceMetricDataInput)
pub mod get_instance_metric_data_input {
    /// A builder for [`GetInstanceMetricDataInput`](crate::input::GetInstanceMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::InstanceMetricName>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) unit: std::option::Option<crate::model::MetricUnit>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
    }
    impl Builder {
        /// <p>The name of the instance for which you want to get metrics data.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance for which you want to get metrics data.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid instance metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BurstCapacityPercentage</code>
        /// </b> - The percentage
        /// of CPU performance available for your instance to burst above its baseline. Your instance
        /// continuously accrues and consumes burst capacity. Burst capacity stops accruing when your
        /// instance's <code>BurstCapacityPercentage</code> reaches 100%. For more information, see
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BurstCapacityTime</code>
        /// </b> - The available amount
        /// of time for your instance to burst at 100% CPU utilization. Your instance continuously
        /// accrues and consumes burst capacity. Burst capacity time stops accruing when your
        /// instance's <code>BurstCapacityPercentage</code> metric reaches 100%.</p>
        /// <p>Burst capacity time is consumed at the full rate only when your instance operates at
        /// 100% CPU utilization. For example, if your instance operates at 50% CPU utilization in the
        /// burstable zone for a 5-minute period, then it consumes CPU burst capacity minutes at a 50%
        /// rate in that period. Your instance consumed 2 minutes and 30 seconds of CPU burst capacity
        /// minutes in the 5-minute period. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>CPUUtilization</code>
        /// </b> - The percentage of
        /// allocated compute units that are currently in use on the instance. This metric identifies
        /// the processing power to run the applications on the instance. Tools in your operating
        /// system can show a lower percentage than Lightsail when the instance is not allocated a
        /// full processor core.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkIn</code>
        /// </b> - The number of bytes received
        /// on all network interfaces by the instance. This metric identifies the volume of incoming
        /// network traffic to the instance. The number reported is the number of bytes received
        /// during the period. Because this metric is reported in 5-minute intervals, divide the
        /// reported number by 300 to find Bytes/second.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkOut</code>
        /// </b> - The number of bytes sent
        /// out on all network interfaces by the instance. This metric identifies the volume of
        /// outgoing network traffic from the instance. The number reported is the number of bytes
        /// sent during the period. Because this metric is reported in 5-minute intervals, divide the
        /// reported number by 300 to find Bytes/second.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed</code>
        /// </b> - Reports whether the
        /// instance passed or failed both the instance status check and the system status check. This
        /// metric can be either 0 (passed) or 1 (failed). This metric data is available in 1-minute
        /// (60 seconds) granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed_Instance</code>
        /// </b> - Reports
        /// whether the instance passed or failed the instance status check. This metric can be either
        /// 0 (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed_System</code>
        /// </b> - Reports
        /// whether the instance passed or failed the system status check. This metric can be either 0
        /// (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::InstanceMetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid instance metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BurstCapacityPercentage</code>
        /// </b> - The percentage
        /// of CPU performance available for your instance to burst above its baseline. Your instance
        /// continuously accrues and consumes burst capacity. Burst capacity stops accruing when your
        /// instance's <code>BurstCapacityPercentage</code> reaches 100%. For more information, see
        /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>BurstCapacityTime</code>
        /// </b> - The available amount
        /// of time for your instance to burst at 100% CPU utilization. Your instance continuously
        /// accrues and consumes burst capacity. Burst capacity time stops accruing when your
        /// instance's <code>BurstCapacityPercentage</code> metric reaches 100%.</p>
        /// <p>Burst capacity time is consumed at the full rate only when your instance operates at
        /// 100% CPU utilization. For example, if your instance operates at 50% CPU utilization in the
        /// burstable zone for a 5-minute period, then it consumes CPU burst capacity minutes at a 50%
        /// rate in that period. Your instance consumed 2 minutes and 30 seconds of CPU burst capacity
        /// minutes in the 5-minute period. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>CPUUtilization</code>
        /// </b> - The percentage of
        /// allocated compute units that are currently in use on the instance. This metric identifies
        /// the processing power to run the applications on the instance. Tools in your operating
        /// system can show a lower percentage than Lightsail when the instance is not allocated a
        /// full processor core.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkIn</code>
        /// </b> - The number of bytes received
        /// on all network interfaces by the instance. This metric identifies the volume of incoming
        /// network traffic to the instance. The number reported is the number of bytes received
        /// during the period. Because this metric is reported in 5-minute intervals, divide the
        /// reported number by 300 to find Bytes/second.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkOut</code>
        /// </b> - The number of bytes sent
        /// out on all network interfaces by the instance. This metric identifies the volume of
        /// outgoing network traffic from the instance. The number reported is the number of bytes
        /// sent during the period. Because this metric is reported in 5-minute intervals, divide the
        /// reported number by 300 to find Bytes/second.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed</code>
        /// </b> - Reports whether the
        /// instance passed or failed both the instance status check and the system status check. This
        /// metric can be either 0 (passed) or 1 (failed). This metric data is available in 1-minute
        /// (60 seconds) granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed_Instance</code>
        /// </b> - Reports
        /// whether the instance passed or failed the instance status check. This metric can be either
        /// 0 (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>StatusCheckFailed_System</code>
        /// </b> - Reports
        /// whether the instance passed or failed the system status check. This metric can be either 0
        /// (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::InstanceMetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>The <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and
        /// <code>StatusCheckFailed_System</code> instance metric data is available in 1-minute (60
        /// seconds) granularity. All other instance metric data is available in 5-minute (300 seconds)
        /// granularity.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>The <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and
        /// <code>StatusCheckFailed_System</code> instance metric data is available in 1-minute (60
        /// seconds) granularity. All other instance metric data is available in 5-minute (300 seconds)
        /// granularity.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The start time of the time period.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the time period.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time of the time period.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time of the time period.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units to specify with each available metric, see the
        /// <code>metricName</code> parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units to specify with each available metric, see the
        /// <code>metricName</code> parameter.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, input: impl Into<crate::model::MetricStatistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceMetricDataInput`](crate::input::GetInstanceMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstanceMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstanceMetricDataInput {
                instance_name: self.instance_name,
                metric_name: self.metric_name,
                period: self.period.unwrap_or_default(),
                start_time: self.start_time,
                end_time: self.end_time,
                unit: self.unit,
                statistics: self.statistics,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceMetricDataInputOperationOutputAlias = crate::operation::GetInstanceMetricData;
#[doc(hidden)]
pub type GetInstanceMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetInstanceMetricData`](crate::operation::GetInstanceMetricData)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstanceMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstanceMetricData",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instance_metric_data(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstanceMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstanceMetricData",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceMetricDataInput`](crate::input::GetInstanceMetricDataInput)
    pub fn builder() -> crate::input::get_instance_metric_data_input::Builder {
        crate::input::get_instance_metric_data_input::Builder::default()
    }
}

/// See [`GetInstancePortStatesInput`](crate::input::GetInstancePortStatesInput)
pub mod get_instance_port_states_input {
    /// A builder for [`GetInstancePortStatesInput`](crate::input::GetInstancePortStatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance for which to return firewall port states.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance for which to return firewall port states.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstancePortStatesInput`](crate::input::GetInstancePortStatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstancePortStatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstancePortStatesInput {
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstancePortStatesInputOperationOutputAlias = crate::operation::GetInstancePortStates;
#[doc(hidden)]
pub type GetInstancePortStatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstancePortStatesInput {
    /// Consumes the builder and constructs an Operation<[`GetInstancePortStates`](crate::operation::GetInstancePortStates)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstancePortStates,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstancePortStatesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstancePortStatesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstancePortStatesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstancePortStates",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instance_port_states(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstancePortStates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstancePortStates",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstancePortStatesInput`](crate::input::GetInstancePortStatesInput)
    pub fn builder() -> crate::input::get_instance_port_states_input::Builder {
        crate::input::get_instance_port_states_input::Builder::default()
    }
}

/// See [`GetInstancesInput`](crate::input::GetInstancesInput)
pub mod get_instances_input {
    /// A builder for [`GetInstancesInput`](crate::input::GetInstancesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetInstances</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetInstances</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstancesInput`](crate::input::GetInstancesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstancesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstancesInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstancesInputOperationOutputAlias = crate::operation::GetInstances;
#[doc(hidden)]
pub type GetInstancesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstancesInput {
    /// Consumes the builder and constructs an Operation<[`GetInstances`](crate::operation::GetInstances)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstances,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstancesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstancesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstancesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstances",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_instances(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstances::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstances",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstancesInput`](crate::input::GetInstancesInput)
    pub fn builder() -> crate::input::get_instances_input::Builder {
        crate::input::get_instances_input::Builder::default()
    }
}

/// See [`GetInstanceSnapshotInput`](crate::input::GetInstanceSnapshotInput)
pub mod get_instance_snapshot_input {
    /// A builder for [`GetInstanceSnapshotInput`](crate::input::GetInstanceSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the snapshot for which you are requesting information.</p>
        pub fn instance_snapshot_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot for which you are requesting information.</p>
        pub fn set_instance_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceSnapshotInput`](crate::input::GetInstanceSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstanceSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstanceSnapshotInput {
                instance_snapshot_name: self.instance_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceSnapshotInputOperationOutputAlias = crate::operation::GetInstanceSnapshot;
#[doc(hidden)]
pub type GetInstanceSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`GetInstanceSnapshot`](crate::operation::GetInstanceSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstanceSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstanceSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instance_snapshot(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstanceSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstanceSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceSnapshotInput`](crate::input::GetInstanceSnapshotInput)
    pub fn builder() -> crate::input::get_instance_snapshot_input::Builder {
        crate::input::get_instance_snapshot_input::Builder::default()
    }
}

/// See [`GetInstanceSnapshotsInput`](crate::input::GetInstanceSnapshotsInput)
pub mod get_instance_snapshots_input {
    /// A builder for [`GetInstanceSnapshotsInput`](crate::input::GetInstanceSnapshotsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetInstanceSnapshots</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetInstanceSnapshots</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceSnapshotsInput`](crate::input::GetInstanceSnapshotsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstanceSnapshotsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstanceSnapshotsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceSnapshotsInputOperationOutputAlias = crate::operation::GetInstanceSnapshots;
#[doc(hidden)]
pub type GetInstanceSnapshotsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceSnapshotsInput {
    /// Consumes the builder and constructs an Operation<[`GetInstanceSnapshots`](crate::operation::GetInstanceSnapshots)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstanceSnapshots,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceSnapshotsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceSnapshotsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceSnapshotsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstanceSnapshots",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instance_snapshots(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstanceSnapshots::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstanceSnapshots",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceSnapshotsInput`](crate::input::GetInstanceSnapshotsInput)
    pub fn builder() -> crate::input::get_instance_snapshots_input::Builder {
        crate::input::get_instance_snapshots_input::Builder::default()
    }
}

/// See [`GetInstanceStateInput`](crate::input::GetInstanceStateInput)
pub mod get_instance_state_input {
    /// A builder for [`GetInstanceStateInput`](crate::input::GetInstanceStateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance to get state information about.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance to get state information about.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceStateInput`](crate::input::GetInstanceStateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstanceStateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstanceStateInput {
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceStateInputOperationOutputAlias = crate::operation::GetInstanceState;
#[doc(hidden)]
pub type GetInstanceStateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceStateInput {
    /// Consumes the builder and constructs an Operation<[`GetInstanceState`](crate::operation::GetInstanceState)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInstanceState,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceStateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceStateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceStateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetInstanceState",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instance_state(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstanceState::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInstanceState",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceStateInput`](crate::input::GetInstanceStateInput)
    pub fn builder() -> crate::input::get_instance_state_input::Builder {
        crate::input::get_instance_state_input::Builder::default()
    }
}

/// See [`GetKeyPairInput`](crate::input::GetKeyPairInput)
pub mod get_key_pair_input {
    /// A builder for [`GetKeyPairInput`](crate::input::GetKeyPairInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_pair_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the key pair for which you are requesting information.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_name = Some(input.into());
            self
        }
        /// <p>The name of the key pair for which you are requesting information.</p>
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_pair_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetKeyPairInput`](crate::input::GetKeyPairInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetKeyPairInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetKeyPairInput {
                key_pair_name: self.key_pair_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetKeyPairInputOperationOutputAlias = crate::operation::GetKeyPair;
#[doc(hidden)]
pub type GetKeyPairInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetKeyPairInput {
    /// Consumes the builder and constructs an Operation<[`GetKeyPair`](crate::operation::GetKeyPair)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetKeyPair,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetKeyPairInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetKeyPairInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetKeyPairInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetKeyPair",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_key_pair(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetKeyPair::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetKeyPair",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetKeyPairInput`](crate::input::GetKeyPairInput)
    pub fn builder() -> crate::input::get_key_pair_input::Builder {
        crate::input::get_key_pair_input::Builder::default()
    }
}

/// See [`GetKeyPairsInput`](crate::input::GetKeyPairsInput)
pub mod get_key_pairs_input {
    /// A builder for [`GetKeyPairsInput`](crate::input::GetKeyPairsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetKeyPairs</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetKeyPairs</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetKeyPairsInput`](crate::input::GetKeyPairsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetKeyPairsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetKeyPairsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetKeyPairsInputOperationOutputAlias = crate::operation::GetKeyPairs;
#[doc(hidden)]
pub type GetKeyPairsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetKeyPairsInput {
    /// Consumes the builder and constructs an Operation<[`GetKeyPairs`](crate::operation::GetKeyPairs)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetKeyPairs,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetKeyPairsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetKeyPairsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetKeyPairsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetKeyPairs",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_key_pairs(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetKeyPairs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetKeyPairs",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetKeyPairsInput`](crate::input::GetKeyPairsInput)
    pub fn builder() -> crate::input::get_key_pairs_input::Builder {
        crate::input::get_key_pairs_input::Builder::default()
    }
}

/// See [`GetLoadBalancerInput`](crate::input::GetLoadBalancerInput)
pub mod get_load_balancer_input {
    /// A builder for [`GetLoadBalancerInput`](crate::input::GetLoadBalancerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLoadBalancerInput`](crate::input::GetLoadBalancerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLoadBalancerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLoadBalancerInput {
                load_balancer_name: self.load_balancer_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLoadBalancerInputOperationOutputAlias = crate::operation::GetLoadBalancer;
#[doc(hidden)]
pub type GetLoadBalancerInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLoadBalancerInput {
    /// Consumes the builder and constructs an Operation<[`GetLoadBalancer`](crate::operation::GetLoadBalancer)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLoadBalancer,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLoadBalancerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLoadBalancerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLoadBalancerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetLoadBalancer",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_load_balancer(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLoadBalancer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLoadBalancer",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLoadBalancerInput`](crate::input::GetLoadBalancerInput)
    pub fn builder() -> crate::input::get_load_balancer_input::Builder {
        crate::input::get_load_balancer_input::Builder::default()
    }
}

/// See [`GetLoadBalancerMetricDataInput`](crate::input::GetLoadBalancerMetricDataInput)
pub mod get_load_balancer_metric_data_input {
    /// A builder for [`GetLoadBalancerMetricDataInput`](crate::input::GetLoadBalancerMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::LoadBalancerMetricName>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) unit: std::option::Option<crate::model::MetricUnit>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
    }
    impl Builder {
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid load balancer metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>ClientTLSNegotiationErrorCount</code>
        /// </b> - The
        /// number of TLS connections initiated by the client that did not establish a session with
        /// the load balancer due to a TLS error generated by the load balancer. Possible causes
        /// include a mismatch of ciphers or protocols.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HealthyHostCount</code>
        /// </b> - The number of target
        /// instances that are considered healthy.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
        /// <code>Minimum</code>, and <code>Maximum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_2XX_Count</code>
        /// </b> - The number
        /// of HTTP 2XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_3XX_Count</code>
        /// </b> - The number
        /// of HTTP 3XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_4XX_Count</code>
        /// </b> - The number
        /// of HTTP 4XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_5XX_Count</code>
        /// </b> - The number
        /// of HTTP 5XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_LB_4XX_Count</code>
        /// </b> - The number of
        /// HTTP 4XX client error codes that originated from the load balancer. Client errors are
        /// generated when requests are malformed or incomplete. These requests were not received by
        /// the target instance. This count does not include response codes generated by the target
        /// instances.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_LB_5XX_Count</code>
        /// </b> - The number of
        /// HTTP 5XX server error codes that originated from the load balancer. This does not include
        /// any response codes generated by the target instance. This metric is reported if there are
        /// no healthy instances attached to the load balancer, or if the request rate exceeds the
        /// capacity of the instances (spillover) or the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>InstanceResponseTime</code>
        /// </b> - The time elapsed,
        /// in seconds, after the request leaves the load balancer until a response from the target
        /// instance is received.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>RejectedConnectionCount</code>
        /// </b> - The number of
        /// connections that were rejected because the load balancer had reached its maximum number of
        /// connections.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>RequestCount</code>
        /// </b> - The number of requests
        /// processed over IPv4. This count includes only the requests with a response generated by a
        /// target instance of the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>UnhealthyHostCount</code>
        /// </b> - The number of
        /// target instances that are considered unhealthy.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
        /// <code>Minimum</code>, and <code>Maximum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::LoadBalancerMetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid load balancer metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>ClientTLSNegotiationErrorCount</code>
        /// </b> - The
        /// number of TLS connections initiated by the client that did not establish a session with
        /// the load balancer due to a TLS error generated by the load balancer. Possible causes
        /// include a mismatch of ciphers or protocols.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HealthyHostCount</code>
        /// </b> - The number of target
        /// instances that are considered healthy.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
        /// <code>Minimum</code>, and <code>Maximum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_2XX_Count</code>
        /// </b> - The number
        /// of HTTP 2XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_3XX_Count</code>
        /// </b> - The number
        /// of HTTP 3XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_4XX_Count</code>
        /// </b> - The number
        /// of HTTP 4XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_Instance_5XX_Count</code>
        /// </b> - The number
        /// of HTTP 5XX response codes generated by the target instances. This does not include any
        /// response codes generated by the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_LB_4XX_Count</code>
        /// </b> - The number of
        /// HTTP 4XX client error codes that originated from the load balancer. Client errors are
        /// generated when requests are malformed or incomplete. These requests were not received by
        /// the target instance. This count does not include response codes generated by the target
        /// instances.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>HTTPCode_LB_5XX_Count</code>
        /// </b> - The number of
        /// HTTP 5XX server error codes that originated from the load balancer. This does not include
        /// any response codes generated by the target instance. This metric is reported if there are
        /// no healthy instances attached to the load balancer, or if the request rate exceeds the
        /// capacity of the instances (spillover) or the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>InstanceResponseTime</code>
        /// </b> - The time elapsed,
        /// in seconds, after the request leaves the load balancer until a response from the target
        /// instance is received.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>RejectedConnectionCount</code>
        /// </b> - The number of
        /// connections that were rejected because the load balancer had reached its maximum number of
        /// connections.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>RequestCount</code>
        /// </b> - The number of requests
        /// processed over IPv4. This count includes only the requests with a response generated by a
        /// target instance of the load balancer.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
        /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
        /// <code>1</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>UnhealthyHostCount</code>
        /// </b> - The number of
        /// target instances that are considered unhealthy.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
        /// <code>Minimum</code>, and <code>Maximum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerMetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The start time of the period.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the period.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time of the period.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time of the period.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units with each available metric, see the <code>metricName</code>
        /// parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units with each available metric, see the <code>metricName</code>
        /// parameter.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, input: impl Into<crate::model::MetricStatistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLoadBalancerMetricDataInput`](crate::input::GetLoadBalancerMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLoadBalancerMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLoadBalancerMetricDataInput {
                load_balancer_name: self.load_balancer_name,
                metric_name: self.metric_name,
                period: self.period.unwrap_or_default(),
                start_time: self.start_time,
                end_time: self.end_time,
                unit: self.unit,
                statistics: self.statistics,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLoadBalancerMetricDataInputOperationOutputAlias =
    crate::operation::GetLoadBalancerMetricData;
#[doc(hidden)]
pub type GetLoadBalancerMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLoadBalancerMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetLoadBalancerMetricData`](crate::operation::GetLoadBalancerMetricData)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLoadBalancerMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLoadBalancerMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLoadBalancerMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLoadBalancerMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetLoadBalancerMetricData",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_load_balancer_metric_data(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLoadBalancerMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLoadBalancerMetricData",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLoadBalancerMetricDataInput`](crate::input::GetLoadBalancerMetricDataInput)
    pub fn builder() -> crate::input::get_load_balancer_metric_data_input::Builder {
        crate::input::get_load_balancer_metric_data_input::Builder::default()
    }
}

/// See [`GetLoadBalancersInput`](crate::input::GetLoadBalancersInput)
pub mod get_load_balancers_input {
    /// A builder for [`GetLoadBalancersInput`](crate::input::GetLoadBalancersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetLoadBalancers</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetLoadBalancers</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLoadBalancersInput`](crate::input::GetLoadBalancersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLoadBalancersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLoadBalancersInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLoadBalancersInputOperationOutputAlias = crate::operation::GetLoadBalancers;
#[doc(hidden)]
pub type GetLoadBalancersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLoadBalancersInput {
    /// Consumes the builder and constructs an Operation<[`GetLoadBalancers`](crate::operation::GetLoadBalancers)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLoadBalancers,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLoadBalancersInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLoadBalancersInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLoadBalancersInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetLoadBalancers",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_load_balancers(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLoadBalancers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLoadBalancers",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLoadBalancersInput`](crate::input::GetLoadBalancersInput)
    pub fn builder() -> crate::input::get_load_balancers_input::Builder {
        crate::input::get_load_balancers_input::Builder::default()
    }
}

/// See [`GetLoadBalancerTlsCertificatesInput`](crate::input::GetLoadBalancerTlsCertificatesInput)
pub mod get_load_balancer_tls_certificates_input {
    /// A builder for [`GetLoadBalancerTlsCertificatesInput`](crate::input::GetLoadBalancerTlsCertificatesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer you associated with your SSL/TLS certificate.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer you associated with your SSL/TLS certificate.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLoadBalancerTlsCertificatesInput`](crate::input::GetLoadBalancerTlsCertificatesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLoadBalancerTlsCertificatesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLoadBalancerTlsCertificatesInput {
                load_balancer_name: self.load_balancer_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLoadBalancerTlsCertificatesInputOperationOutputAlias =
    crate::operation::GetLoadBalancerTlsCertificates;
#[doc(hidden)]
pub type GetLoadBalancerTlsCertificatesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLoadBalancerTlsCertificatesInput {
    /// Consumes the builder and constructs an Operation<[`GetLoadBalancerTlsCertificates`](crate::operation::GetLoadBalancerTlsCertificates)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLoadBalancerTlsCertificates,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLoadBalancerTlsCertificatesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLoadBalancerTlsCertificatesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLoadBalancerTlsCertificatesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetLoadBalancerTlsCertificates",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_load_balancer_tls_certificates(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLoadBalancerTlsCertificates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLoadBalancerTlsCertificates",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLoadBalancerTlsCertificatesInput`](crate::input::GetLoadBalancerTlsCertificatesInput)
    pub fn builder() -> crate::input::get_load_balancer_tls_certificates_input::Builder {
        crate::input::get_load_balancer_tls_certificates_input::Builder::default()
    }
}

/// See [`GetOperationInput`](crate::input::GetOperationInput)
pub mod get_operation_input {
    /// A builder for [`GetOperationInput`](crate::input::GetOperationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A GUID used to identify the operation.</p>
        pub fn operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_id = Some(input.into());
            self
        }
        /// <p>A GUID used to identify the operation.</p>
        pub fn set_operation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetOperationInput`](crate::input::GetOperationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetOperationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetOperationInput {
                operation_id: self.operation_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOperationInputOperationOutputAlias = crate::operation::GetOperation;
#[doc(hidden)]
pub type GetOperationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetOperationInput {
    /// Consumes the builder and constructs an Operation<[`GetOperation`](crate::operation::GetOperation)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetOperation,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetOperationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetOperationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetOperationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetOperation",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_operation(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetOperation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetOperation",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetOperationInput`](crate::input::GetOperationInput)
    pub fn builder() -> crate::input::get_operation_input::Builder {
        crate::input::get_operation_input::Builder::default()
    }
}

/// See [`GetOperationsInput`](crate::input::GetOperationsInput)
pub mod get_operations_input {
    /// A builder for [`GetOperationsInput`](crate::input::GetOperationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetOperations</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetOperations</code> request. If your
        /// results are paginated, the response will return a next page token that you can specify as the
        /// page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetOperationsInput`](crate::input::GetOperationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetOperationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetOperationsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOperationsInputOperationOutputAlias = crate::operation::GetOperations;
#[doc(hidden)]
pub type GetOperationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetOperationsInput {
    /// Consumes the builder and constructs an Operation<[`GetOperations`](crate::operation::GetOperations)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetOperations,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetOperationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetOperationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetOperationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetOperations",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_operations(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetOperations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetOperations",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetOperationsInput`](crate::input::GetOperationsInput)
    pub fn builder() -> crate::input::get_operations_input::Builder {
        crate::input::get_operations_input::Builder::default()
    }
}

/// See [`GetOperationsForResourceInput`](crate::input::GetOperationsForResourceInput)
pub mod get_operations_for_resource_input {
    /// A builder for [`GetOperationsForResourceInput`](crate::input::GetOperationsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the resource for which you are requesting information.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource for which you are requesting information.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetOperationsForResource</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetOperationsForResource</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetOperationsForResourceInput`](crate::input::GetOperationsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetOperationsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetOperationsForResourceInput {
                resource_name: self.resource_name,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOperationsForResourceInputOperationOutputAlias =
    crate::operation::GetOperationsForResource;
#[doc(hidden)]
pub type GetOperationsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetOperationsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`GetOperationsForResource`](crate::operation::GetOperationsForResource)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetOperationsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetOperationsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetOperationsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetOperationsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetOperationsForResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_operations_for_resource(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetOperationsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetOperationsForResource",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetOperationsForResourceInput`](crate::input::GetOperationsForResourceInput)
    pub fn builder() -> crate::input::get_operations_for_resource_input::Builder {
        crate::input::get_operations_for_resource_input::Builder::default()
    }
}

/// See [`GetRegionsInput`](crate::input::GetRegionsInput)
pub mod get_regions_input {
    /// A builder for [`GetRegionsInput`](crate::input::GetRegionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_availability_zones: std::option::Option<bool>,
        pub(crate) include_relational_database_availability_zones: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A Boolean value indicating whether to also include Availability Zones in your get regions
        /// request. Availability Zones are indicated with a letter: e.g., <code>us-east-2a</code>.</p>
        pub fn include_availability_zones(mut self, input: bool) -> Self {
            self.include_availability_zones = Some(input);
            self
        }
        /// <p>A Boolean value indicating whether to also include Availability Zones in your get regions
        /// request. Availability Zones are indicated with a letter: e.g., <code>us-east-2a</code>.</p>
        pub fn set_include_availability_zones(mut self, input: std::option::Option<bool>) -> Self {
            self.include_availability_zones = input;
            self
        }
        /// <p>A Boolean value indicating whether to also include Availability Zones for databases in
        /// your get regions request. Availability Zones are indicated with a letter (e.g.,
        /// <code>us-east-2a</code>).</p>
        pub fn include_relational_database_availability_zones(mut self, input: bool) -> Self {
            self.include_relational_database_availability_zones = Some(input);
            self
        }
        /// <p>A Boolean value indicating whether to also include Availability Zones for databases in
        /// your get regions request. Availability Zones are indicated with a letter (e.g.,
        /// <code>us-east-2a</code>).</p>
        pub fn set_include_relational_database_availability_zones(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.include_relational_database_availability_zones = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRegionsInput`](crate::input::GetRegionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRegionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRegionsInput {
                include_availability_zones: self.include_availability_zones,
                include_relational_database_availability_zones: self
                    .include_relational_database_availability_zones,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRegionsInputOperationOutputAlias = crate::operation::GetRegions;
#[doc(hidden)]
pub type GetRegionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRegionsInput {
    /// Consumes the builder and constructs an Operation<[`GetRegions`](crate::operation::GetRegions)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRegions,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRegionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRegionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRegionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRegions",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_regions(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRegions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRegions",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRegionsInput`](crate::input::GetRegionsInput)
    pub fn builder() -> crate::input::get_regions_input::Builder {
        crate::input::get_regions_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseInput`](crate::input::GetRelationalDatabaseInput)
pub mod get_relational_database_input {
    /// A builder for [`GetRelationalDatabaseInput`](crate::input::GetRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database that you are looking up.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of the database that you are looking up.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseInput`](crate::input::GetRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseInputOperationOutputAlias = crate::operation::GetRelationalDatabase;
#[doc(hidden)]
pub type GetRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabase`](crate::operation::GetRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseInput`](crate::input::GetRelationalDatabaseInput)
    pub fn builder() -> crate::input::get_relational_database_input::Builder {
        crate::input::get_relational_database_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseBlueprintsInput`](crate::input::GetRelationalDatabaseBlueprintsInput)
pub mod get_relational_database_blueprints_input {
    /// A builder for [`GetRelationalDatabaseBlueprintsInput`](crate::input::GetRelationalDatabaseBlueprintsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBlueprints</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBlueprints</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseBlueprintsInput`](crate::input::GetRelationalDatabaseBlueprintsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseBlueprintsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseBlueprintsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseBlueprintsInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseBlueprints;
#[doc(hidden)]
pub type GetRelationalDatabaseBlueprintsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseBlueprintsInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseBlueprints`](crate::operation::GetRelationalDatabaseBlueprints)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseBlueprints,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseBlueprintsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseBlueprintsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseBlueprintsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseBlueprints",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_blueprints(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseBlueprints::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseBlueprints",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseBlueprintsInput`](crate::input::GetRelationalDatabaseBlueprintsInput)
    pub fn builder() -> crate::input::get_relational_database_blueprints_input::Builder {
        crate::input::get_relational_database_blueprints_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseBundlesInput`](crate::input::GetRelationalDatabaseBundlesInput)
pub mod get_relational_database_bundles_input {
    /// A builder for [`GetRelationalDatabaseBundlesInput`](crate::input::GetRelationalDatabaseBundlesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBundles</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBundles</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseBundlesInput`](crate::input::GetRelationalDatabaseBundlesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseBundlesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseBundlesInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseBundlesInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseBundles;
#[doc(hidden)]
pub type GetRelationalDatabaseBundlesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseBundlesInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseBundles`](crate::operation::GetRelationalDatabaseBundles)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseBundles,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseBundlesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseBundlesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseBundlesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseBundles",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_bundles(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseBundles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseBundles",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseBundlesInput`](crate::input::GetRelationalDatabaseBundlesInput)
    pub fn builder() -> crate::input::get_relational_database_bundles_input::Builder {
        crate::input::get_relational_database_bundles_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseEventsInput`](crate::input::GetRelationalDatabaseEventsInput)
pub mod get_relational_database_events_input {
    /// A builder for [`GetRelationalDatabaseEventsInput`](crate::input::GetRelationalDatabaseEventsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) duration_in_minutes: std::option::Option<i32>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database from which to get events.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of the database from which to get events.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The number of minutes in the past from which to retrieve events. For example, to get all
        /// events from the past 2 hours, enter 120.</p>
        /// <p>Default: <code>60</code>
        /// </p>
        /// <p>The minimum is 1 and the maximum is 14 days (20160 minutes).</p>
        pub fn duration_in_minutes(mut self, input: i32) -> Self {
            self.duration_in_minutes = Some(input);
            self
        }
        /// <p>The number of minutes in the past from which to retrieve events. For example, to get all
        /// events from the past 2 hours, enter 120.</p>
        /// <p>Default: <code>60</code>
        /// </p>
        /// <p>The minimum is 1 and the maximum is 14 days (20160 minutes).</p>
        pub fn set_duration_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_in_minutes = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseEvents</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseEvents</code> request.
        /// If your results are paginated, the response will return a next page token that you can specify
        /// as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseEventsInput`](crate::input::GetRelationalDatabaseEventsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseEventsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseEventsInput {
                relational_database_name: self.relational_database_name,
                duration_in_minutes: self.duration_in_minutes,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseEventsInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseEvents;
#[doc(hidden)]
pub type GetRelationalDatabaseEventsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseEventsInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseEvents`](crate::operation::GetRelationalDatabaseEvents)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseEvents,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseEventsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseEventsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseEventsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseEvents",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_events(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseEvents::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseEvents",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseEventsInput`](crate::input::GetRelationalDatabaseEventsInput)
    pub fn builder() -> crate::input::get_relational_database_events_input::Builder {
        crate::input::get_relational_database_events_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseLogEventsInput`](crate::input::GetRelationalDatabaseLogEventsInput)
pub mod get_relational_database_log_events_input {
    /// A builder for [`GetRelationalDatabaseLogEventsInput`](crate::input::GetRelationalDatabaseLogEventsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) start_from_head: std::option::Option<bool>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your database for which to get log events.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database for which to get log events.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The name of the log stream.</p>
        /// <p>Use the <code>get relational database log streams</code> operation to get a list of
        /// available log streams.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        /// <p>The name of the log stream.</p>
        /// <p>Use the <code>get relational database log streams</code> operation to get a list of
        /// available log streams.</p>
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// <p>The start of the time interval from which to get log events.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start of the time interval from which to get log events.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the start time.</p>
        /// </li>
        /// </ul>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time interval from which to get log events.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the end time.</p>
        ///
        /// </li>
        /// </ul>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time interval from which to get log events.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the end time.</p>
        ///
        /// </li>
        /// </ul>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Parameter to specify if the log should start from head or tail. If <code>true</code> is
        /// specified, the log event starts from the head of the log. If <code>false</code> is specified,
        /// the log event starts from the tail of the log.</p>
        /// <note>
        /// <p>For PostgreSQL, the default value of <code>false</code> is the only option
        /// available.</p>
        /// </note>
        pub fn start_from_head(mut self, input: bool) -> Self {
            self.start_from_head = Some(input);
            self
        }
        /// <p>Parameter to specify if the log should start from head or tail. If <code>true</code> is
        /// specified, the log event starts from the head of the log. If <code>false</code> is specified,
        /// the log event starts from the tail of the log.</p>
        /// <note>
        /// <p>For PostgreSQL, the default value of <code>false</code> is the only option
        /// available.</p>
        /// </note>
        pub fn set_start_from_head(mut self, input: std::option::Option<bool>) -> Self {
            self.start_from_head = input;
            self
        }
        /// <p>The token to advance to the next or previous page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseLogEvents</code>
        /// request. If your results are paginated, the response will return a next forward token and/or
        /// next backward token that you can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next or previous page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseLogEvents</code>
        /// request. If your results are paginated, the response will return a next forward token and/or
        /// next backward token that you can specify as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseLogEventsInput`](crate::input::GetRelationalDatabaseLogEventsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseLogEventsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseLogEventsInput {
                relational_database_name: self.relational_database_name,
                log_stream_name: self.log_stream_name,
                start_time: self.start_time,
                end_time: self.end_time,
                start_from_head: self.start_from_head,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseLogEventsInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseLogEvents;
#[doc(hidden)]
pub type GetRelationalDatabaseLogEventsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseLogEventsInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseLogEvents`](crate::operation::GetRelationalDatabaseLogEvents)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseLogEvents,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseLogEventsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseLogEventsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseLogEventsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseLogEvents",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_log_events(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseLogEvents::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseLogEvents",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseLogEventsInput`](crate::input::GetRelationalDatabaseLogEventsInput)
    pub fn builder() -> crate::input::get_relational_database_log_events_input::Builder {
        crate::input::get_relational_database_log_events_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseLogStreamsInput`](crate::input::GetRelationalDatabaseLogStreamsInput)
pub mod get_relational_database_log_streams_input {
    /// A builder for [`GetRelationalDatabaseLogStreamsInput`](crate::input::GetRelationalDatabaseLogStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your database for which to get log streams.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database for which to get log streams.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseLogStreamsInput`](crate::input::GetRelationalDatabaseLogStreamsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseLogStreamsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseLogStreamsInput {
                relational_database_name: self.relational_database_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseLogStreamsInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseLogStreams;
#[doc(hidden)]
pub type GetRelationalDatabaseLogStreamsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseLogStreamsInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseLogStreams`](crate::operation::GetRelationalDatabaseLogStreams)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseLogStreams,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseLogStreamsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseLogStreamsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseLogStreamsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseLogStreams",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_log_streams(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseLogStreams::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseLogStreams",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseLogStreamsInput`](crate::input::GetRelationalDatabaseLogStreamsInput)
    pub fn builder() -> crate::input::get_relational_database_log_streams_input::Builder {
        crate::input::get_relational_database_log_streams_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseMasterUserPasswordInput`](crate::input::GetRelationalDatabaseMasterUserPasswordInput)
pub mod get_relational_database_master_user_password_input {
    /// A builder for [`GetRelationalDatabaseMasterUserPasswordInput`](crate::input::GetRelationalDatabaseMasterUserPasswordInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) password_version:
            std::option::Option<crate::model::RelationalDatabasePasswordVersion>,
    }
    impl Builder {
        /// <p>The name of your database for which to get the master user password.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database for which to get the master user password.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The password version to return.</p>
        /// <p>Specifying <code>CURRENT</code> or <code>PREVIOUS</code> returns the current or previous
        /// passwords respectively. Specifying <code>PENDING</code> returns the newest version of the
        /// password that will rotate to <code>CURRENT</code>. After the <code>PENDING</code> password
        /// rotates to <code>CURRENT</code>, the <code>PENDING</code> password is no longer
        /// available.</p>
        /// <p>Default: <code>CURRENT</code>
        /// </p>
        pub fn password_version(
            mut self,
            input: crate::model::RelationalDatabasePasswordVersion,
        ) -> Self {
            self.password_version = Some(input);
            self
        }
        /// <p>The password version to return.</p>
        /// <p>Specifying <code>CURRENT</code> or <code>PREVIOUS</code> returns the current or previous
        /// passwords respectively. Specifying <code>PENDING</code> returns the newest version of the
        /// password that will rotate to <code>CURRENT</code>. After the <code>PENDING</code> password
        /// rotates to <code>CURRENT</code>, the <code>PENDING</code> password is no longer
        /// available.</p>
        /// <p>Default: <code>CURRENT</code>
        /// </p>
        pub fn set_password_version(
            mut self,
            input: std::option::Option<crate::model::RelationalDatabasePasswordVersion>,
        ) -> Self {
            self.password_version = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseMasterUserPasswordInput`](crate::input::GetRelationalDatabaseMasterUserPasswordInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseMasterUserPasswordInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseMasterUserPasswordInput {
                relational_database_name: self.relational_database_name,
                password_version: self.password_version,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseMasterUserPasswordInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseMasterUserPassword;
#[doc(hidden)]
pub type GetRelationalDatabaseMasterUserPasswordInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseMasterUserPasswordInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseMasterUserPassword`](crate::operation::GetRelationalDatabaseMasterUserPassword)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseMasterUserPassword,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseMasterUserPasswordInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseMasterUserPasswordInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseMasterUserPasswordInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseMasterUserPassword",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_master_user_password(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseMasterUserPassword::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseMasterUserPassword",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseMasterUserPasswordInput`](crate::input::GetRelationalDatabaseMasterUserPasswordInput)
    pub fn builder() -> crate::input::get_relational_database_master_user_password_input::Builder {
        crate::input::get_relational_database_master_user_password_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseMetricDataInput`](crate::input::GetRelationalDatabaseMetricDataInput)
pub mod get_relational_database_metric_data_input {
    /// A builder for [`GetRelationalDatabaseMetricDataInput`](crate::input::GetRelationalDatabaseMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::RelationalDatabaseMetricName>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) unit: std::option::Option<crate::model::MetricUnit>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
    }
    impl Builder {
        /// <p>The name of your database from which to get metric data.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database from which to get metric data.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid relational database metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value. All relational database metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>CPUUtilization</code>
        /// </b> - The percentage of CPU
        /// utilization currently in use on the database.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>DatabaseConnections</code>
        /// </b> - The number of
        /// database connections in use.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>DiskQueueDepth</code>
        /// </b> - The number of
        /// outstanding IOs (read/write requests) that are waiting to access the disk.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>FreeStorageSpace</code>
        /// </b> - The amount of
        /// available storage space.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkReceiveThroughput</code>
        /// </b> - The incoming
        /// (Receive) network traffic on the database, including both customer database traffic and
        /// AWS traffic used for monitoring and replication.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkTransmitThroughput</code>
        /// </b> - The outgoing
        /// (Transmit) network traffic on the database, including both customer database traffic and
        /// AWS traffic used for monitoring and replication.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
        /// </li>
        /// </ul>
        pub fn metric_name(mut self, input: crate::model::RelationalDatabaseMetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The metric for which you want to return information.</p>
        /// <p>Valid relational database metric names are listed below, along with the most useful
        /// <code>statistics</code> to include in your request, and the published <code>unit</code>
        /// value. All relational database metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>CPUUtilization</code>
        /// </b> - The percentage of CPU
        /// utilization currently in use on the database.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>DatabaseConnections</code>
        /// </b> - The number of
        /// database connections in use.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
        /// <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>DiskQueueDepth</code>
        /// </b> - The number of
        /// outstanding IOs (read/write requests) that are waiting to access the disk.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>FreeStorageSpace</code>
        /// </b> - The amount of
        /// available storage space.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkReceiveThroughput</code>
        /// </b> - The incoming
        /// (Receive) network traffic on the database, including both customer database traffic and
        /// AWS traffic used for monitoring and replication.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>NetworkTransmitThroughput</code>
        /// </b> - The outgoing
        /// (Transmit) network traffic on the database, including both customer database traffic and
        /// AWS traffic used for monitoring and replication.</p>
        /// <p>
        /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
        /// <p>
        /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::RelationalDatabaseMetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>All relational database metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points.</p>
        /// <p>All relational database metric data is available in 1-minute (60 seconds)
        /// granularity.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The start of the time interval from which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the start time.</p>
        ///
        /// </li>
        /// </ul>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start of the time interval from which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the start time.</p>
        ///
        /// </li>
        /// </ul>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time interval from which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the end time.</p>
        ///
        /// </li>
        /// </ul>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end of the time interval from which to get metric data.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Specified in the Unix time format.</p>
        /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
        /// input <code>1538424000</code> as the end time.</p>
        ///
        /// </li>
        /// </ul>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units with each available metric, see the <code>metricName</code>
        /// parameter.</p>
        pub fn unit(mut self, input: crate::model::MetricUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric data request. Valid units depend on the metric data being
        /// requested. For the valid units with each available metric, see the <code>metricName</code>
        /// parameter.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::MetricUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn statistics(mut self, input: impl Into<crate::model::MetricStatistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The statistic for the metric.</p>
        /// <p>The following statistics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
        /// value to determine low volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> - The highest value observed during the specified period. Use
        /// this value to determine high volumes of activity for your application.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> - All values submitted for the matching metric added together. You
        /// can use this statistic to determine the total volume of a metric.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
        /// comparing this statistic with the Minimum and Maximum values, you can determine the full
        /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
        /// comparison helps you to know when to increase or decrease your resources.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> - The count, or number, of data points used for the
        /// statistical calculation.</p>
        /// </li>
        /// </ul>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseMetricDataInput`](crate::input::GetRelationalDatabaseMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseMetricDataInput {
                relational_database_name: self.relational_database_name,
                metric_name: self.metric_name,
                period: self.period.unwrap_or_default(),
                start_time: self.start_time,
                end_time: self.end_time,
                unit: self.unit,
                statistics: self.statistics,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseMetricDataInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseMetricData;
#[doc(hidden)]
pub type GetRelationalDatabaseMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseMetricData`](crate::operation::GetRelationalDatabaseMetricData)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseMetricData",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_metric_data(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseMetricData",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseMetricDataInput`](crate::input::GetRelationalDatabaseMetricDataInput)
    pub fn builder() -> crate::input::get_relational_database_metric_data_input::Builder {
        crate::input::get_relational_database_metric_data_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseParametersInput`](crate::input::GetRelationalDatabaseParametersInput)
pub mod get_relational_database_parameters_input {
    /// A builder for [`GetRelationalDatabaseParametersInput`](crate::input::GetRelationalDatabaseParametersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your database for which to get parameters.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database for which to get parameters.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseParameters</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseParameters</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseParametersInput`](crate::input::GetRelationalDatabaseParametersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseParametersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseParametersInput {
                relational_database_name: self.relational_database_name,
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseParametersInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseParameters;
#[doc(hidden)]
pub type GetRelationalDatabaseParametersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseParametersInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseParameters`](crate::operation::GetRelationalDatabaseParameters)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseParameters,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseParametersInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseParametersInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseParametersInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseParameters",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_parameters(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseParameters::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseParameters",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseParametersInput`](crate::input::GetRelationalDatabaseParametersInput)
    pub fn builder() -> crate::input::get_relational_database_parameters_input::Builder {
        crate::input::get_relational_database_parameters_input::Builder::default()
    }
}

/// See [`GetRelationalDatabasesInput`](crate::input::GetRelationalDatabasesInput)
pub mod get_relational_databases_input {
    /// A builder for [`GetRelationalDatabasesInput`](crate::input::GetRelationalDatabasesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabases</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabases</code> request. If
        /// your results are paginated, the response will return a next page token that you can specify as
        /// the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabasesInput`](crate::input::GetRelationalDatabasesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabasesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabasesInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabasesInputOperationOutputAlias = crate::operation::GetRelationalDatabases;
#[doc(hidden)]
pub type GetRelationalDatabasesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabasesInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabases`](crate::operation::GetRelationalDatabases)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabases,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabasesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabasesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabasesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabases",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_databases(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabases::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabases",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabasesInput`](crate::input::GetRelationalDatabasesInput)
    pub fn builder() -> crate::input::get_relational_databases_input::Builder {
        crate::input::get_relational_databases_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseSnapshotInput`](crate::input::GetRelationalDatabaseSnapshotInput)
pub mod get_relational_database_snapshot_input {
    /// A builder for [`GetRelationalDatabaseSnapshotInput`](crate::input::GetRelationalDatabaseSnapshotInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the database snapshot for which to get information.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of the database snapshot for which to get information.</p>
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseSnapshotInput`](crate::input::GetRelationalDatabaseSnapshotInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseSnapshotInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseSnapshotInput {
                relational_database_snapshot_name: self.relational_database_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseSnapshotInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseSnapshot;
#[doc(hidden)]
pub type GetRelationalDatabaseSnapshotInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseSnapshotInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseSnapshot`](crate::operation::GetRelationalDatabaseSnapshot)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseSnapshot,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseSnapshotInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseSnapshotInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseSnapshotInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseSnapshot",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_snapshot(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseSnapshot::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseSnapshot",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseSnapshotInput`](crate::input::GetRelationalDatabaseSnapshotInput)
    pub fn builder() -> crate::input::get_relational_database_snapshot_input::Builder {
        crate::input::get_relational_database_snapshot_input::Builder::default()
    }
}

/// See [`GetRelationalDatabaseSnapshotsInput`](crate::input::GetRelationalDatabaseSnapshotsInput)
pub mod get_relational_database_snapshots_input {
    /// A builder for [`GetRelationalDatabaseSnapshotsInput`](crate::input::GetRelationalDatabaseSnapshotsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseSnapshots</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseSnapshots</code>
        /// request. If your results are paginated, the response will return a next page token that you
        /// can specify as the page token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRelationalDatabaseSnapshotsInput`](crate::input::GetRelationalDatabaseSnapshotsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRelationalDatabaseSnapshotsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRelationalDatabaseSnapshotsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRelationalDatabaseSnapshotsInputOperationOutputAlias =
    crate::operation::GetRelationalDatabaseSnapshots;
#[doc(hidden)]
pub type GetRelationalDatabaseSnapshotsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetRelationalDatabaseSnapshotsInput {
    /// Consumes the builder and constructs an Operation<[`GetRelationalDatabaseSnapshots`](crate::operation::GetRelationalDatabaseSnapshots)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRelationalDatabaseSnapshots,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRelationalDatabaseSnapshotsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRelationalDatabaseSnapshotsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRelationalDatabaseSnapshotsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetRelationalDatabaseSnapshots",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_relational_database_snapshots(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRelationalDatabaseSnapshots::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRelationalDatabaseSnapshots",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRelationalDatabaseSnapshotsInput`](crate::input::GetRelationalDatabaseSnapshotsInput)
    pub fn builder() -> crate::input::get_relational_database_snapshots_input::Builder {
        crate::input::get_relational_database_snapshots_input::Builder::default()
    }
}

/// See [`GetStaticIpInput`](crate::input::GetStaticIpInput)
pub mod get_static_ip_input {
    /// A builder for [`GetStaticIpInput`](crate::input::GetStaticIpInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_ip_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the static IP in Lightsail.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.static_ip_name = Some(input.into());
            self
        }
        /// <p>The name of the static IP in Lightsail.</p>
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.static_ip_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetStaticIpInput`](crate::input::GetStaticIpInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetStaticIpInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetStaticIpInput {
                static_ip_name: self.static_ip_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetStaticIpInputOperationOutputAlias = crate::operation::GetStaticIp;
#[doc(hidden)]
pub type GetStaticIpInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetStaticIpInput {
    /// Consumes the builder and constructs an Operation<[`GetStaticIp`](crate::operation::GetStaticIp)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetStaticIp,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetStaticIpInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetStaticIpInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetStaticIpInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetStaticIp",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_static_ip(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetStaticIp::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetStaticIp",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetStaticIpInput`](crate::input::GetStaticIpInput)
    pub fn builder() -> crate::input::get_static_ip_input::Builder {
        crate::input::get_static_ip_input::Builder::default()
    }
}

/// See [`GetStaticIpsInput`](crate::input::GetStaticIpsInput)
pub mod get_static_ips_input {
    /// A builder for [`GetStaticIpsInput`](crate::input::GetStaticIpsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetStaticIps</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.page_token = Some(input.into());
            self
        }
        /// <p>The token to advance to the next page of results from your request.</p>
        /// <p>To get a page token, perform an initial <code>GetStaticIps</code> request. If your results
        /// are paginated, the response will return a next page token that you can specify as the page
        /// token in a subsequent request.</p>
        pub fn set_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetStaticIpsInput`](crate::input::GetStaticIpsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetStaticIpsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetStaticIpsInput {
                page_token: self.page_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetStaticIpsInputOperationOutputAlias = crate::operation::GetStaticIps;
#[doc(hidden)]
pub type GetStaticIpsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetStaticIpsInput {
    /// Consumes the builder and constructs an Operation<[`GetStaticIps`](crate::operation::GetStaticIps)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetStaticIps,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetStaticIpsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetStaticIpsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetStaticIpsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.GetStaticIps",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_static_ips(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetStaticIps::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetStaticIps",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetStaticIpsInput`](crate::input::GetStaticIpsInput)
    pub fn builder() -> crate::input::get_static_ips_input::Builder {
        crate::input::get_static_ips_input::Builder::default()
    }
}

/// See [`ImportKeyPairInput`](crate::input::ImportKeyPairInput)
pub mod import_key_pair_input {
    /// A builder for [`ImportKeyPairInput`](crate::input::ImportKeyPairInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_pair_name: std::option::Option<std::string::String>,
        pub(crate) public_key_base64: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the key pair for which you want to import the public key.</p>
        pub fn key_pair_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_pair_name = Some(input.into());
            self
        }
        /// <p>The name of the key pair for which you want to import the public key.</p>
        pub fn set_key_pair_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.key_pair_name = input;
            self
        }
        /// <p>A base64-encoded public key of the <code>ssh-rsa</code> type.</p>
        pub fn public_key_base64(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_key_base64 = Some(input.into());
            self
        }
        /// <p>A base64-encoded public key of the <code>ssh-rsa</code> type.</p>
        pub fn set_public_key_base64(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_key_base64 = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportKeyPairInput`](crate::input::ImportKeyPairInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ImportKeyPairInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ImportKeyPairInput {
                key_pair_name: self.key_pair_name,
                public_key_base64: self.public_key_base64,
            })
        }
    }
}
#[doc(hidden)]
pub type ImportKeyPairInputOperationOutputAlias = crate::operation::ImportKeyPair;
#[doc(hidden)]
pub type ImportKeyPairInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ImportKeyPairInput {
    /// Consumes the builder and constructs an Operation<[`ImportKeyPair`](crate::operation::ImportKeyPair)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ImportKeyPair,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ImportKeyPairInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ImportKeyPairInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ImportKeyPairInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.ImportKeyPair",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_import_key_pair(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ImportKeyPair::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ImportKeyPair",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ImportKeyPairInput`](crate::input::ImportKeyPairInput)
    pub fn builder() -> crate::input::import_key_pair_input::Builder {
        crate::input::import_key_pair_input::Builder::default()
    }
}

/// See [`IsVpcPeeredInput`](crate::input::IsVpcPeeredInput)
pub mod is_vpc_peered_input {
    /// A builder for [`IsVpcPeeredInput`](crate::input::IsVpcPeeredInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`IsVpcPeeredInput`](crate::input::IsVpcPeeredInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::IsVpcPeeredInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::IsVpcPeeredInput {})
        }
    }
}
#[doc(hidden)]
pub type IsVpcPeeredInputOperationOutputAlias = crate::operation::IsVpcPeered;
#[doc(hidden)]
pub type IsVpcPeeredInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl IsVpcPeeredInput {
    /// Consumes the builder and constructs an Operation<[`IsVpcPeered`](crate::operation::IsVpcPeered)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::IsVpcPeered,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::IsVpcPeeredInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::IsVpcPeeredInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::IsVpcPeeredInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.IsVpcPeered",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_is_vpc_peered(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::IsVpcPeered::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "IsVpcPeered",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`IsVpcPeeredInput`](crate::input::IsVpcPeeredInput)
    pub fn builder() -> crate::input::is_vpc_peered_input::Builder {
        crate::input::is_vpc_peered_input::Builder::default()
    }
}

/// See [`OpenInstancePublicPortsInput`](crate::input::OpenInstancePublicPortsInput)
pub mod open_instance_public_ports_input {
    /// A builder for [`OpenInstancePublicPortsInput`](crate::input::OpenInstancePublicPortsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port_info: std::option::Option<crate::model::PortInfo>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An object to describe the ports to open for the specified instance.</p>
        pub fn port_info(mut self, input: crate::model::PortInfo) -> Self {
            self.port_info = Some(input);
            self
        }
        /// <p>An object to describe the ports to open for the specified instance.</p>
        pub fn set_port_info(mut self, input: std::option::Option<crate::model::PortInfo>) -> Self {
            self.port_info = input;
            self
        }
        /// <p>The name of the instance for which to open ports.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance for which to open ports.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`OpenInstancePublicPortsInput`](crate::input::OpenInstancePublicPortsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::OpenInstancePublicPortsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::OpenInstancePublicPortsInput {
                port_info: self.port_info,
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type OpenInstancePublicPortsInputOperationOutputAlias =
    crate::operation::OpenInstancePublicPorts;
#[doc(hidden)]
pub type OpenInstancePublicPortsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl OpenInstancePublicPortsInput {
    /// Consumes the builder and constructs an Operation<[`OpenInstancePublicPorts`](crate::operation::OpenInstancePublicPorts)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::OpenInstancePublicPorts,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::OpenInstancePublicPortsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::OpenInstancePublicPortsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::OpenInstancePublicPortsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.OpenInstancePublicPorts",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_open_instance_public_ports(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::OpenInstancePublicPorts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "OpenInstancePublicPorts",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`OpenInstancePublicPortsInput`](crate::input::OpenInstancePublicPortsInput)
    pub fn builder() -> crate::input::open_instance_public_ports_input::Builder {
        crate::input::open_instance_public_ports_input::Builder::default()
    }
}

/// See [`PeerVpcInput`](crate::input::PeerVpcInput)
pub mod peer_vpc_input {
    /// A builder for [`PeerVpcInput`](crate::input::PeerVpcInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`PeerVpcInput`](crate::input::PeerVpcInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PeerVpcInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::PeerVpcInput {})
        }
    }
}
#[doc(hidden)]
pub type PeerVpcInputOperationOutputAlias = crate::operation::PeerVpc;
#[doc(hidden)]
pub type PeerVpcInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PeerVpcInput {
    /// Consumes the builder and constructs an Operation<[`PeerVpc`](crate::operation::PeerVpc)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PeerVpc,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PeerVpcInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PeerVpcInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PeerVpcInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.PeerVpc",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_peer_vpc(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::PeerVpc::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "PeerVpc",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PeerVpcInput`](crate::input::PeerVpcInput)
    pub fn builder() -> crate::input::peer_vpc_input::Builder {
        crate::input::peer_vpc_input::Builder::default()
    }
}

/// See [`PutAlarmInput`](crate::input::PutAlarmInput)
pub mod put_alarm_input {
    /// A builder for [`PutAlarmInput`](crate::input::PutAlarmInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<crate::model::MetricName>,
        pub(crate) monitored_resource_name: std::option::Option<std::string::String>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) threshold: std::option::Option<f64>,
        pub(crate) evaluation_periods: std::option::Option<i32>,
        pub(crate) datapoints_to_alarm: std::option::Option<i32>,
        pub(crate) treat_missing_data: std::option::Option<crate::model::TreatMissingData>,
        pub(crate) contact_protocols:
            std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
        pub(crate) notification_triggers:
            std::option::Option<std::vec::Vec<crate::model::AlarmState>>,
        pub(crate) notification_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the
        /// previous configuration of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the
        /// previous configuration of the alarm.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The name of the metric to associate with the alarm.</p>
        /// <p>You can configure up to two alarms per metric.</p>
        /// <p>The following metrics are available for each resource type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Instances</b>: <code>BurstCapacityPercentage</code>,
        /// <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>,
        /// <code>NetworkOut</code>, <code>StatusCheckFailed</code>,
        /// <code>StatusCheckFailed_Instance</code>, and
        /// <code>StatusCheckFailed_System</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Load balancers</b>:
        /// <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>,
        /// <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>,
        /// <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>,
        /// <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>,
        /// <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>,
        /// <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Relational databases</b>: <code>CPUUtilization</code>,
        /// <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>,
        /// <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and
        /// <code>NetworkTransmitThroughput</code>.</p>
        /// </li>
        /// </ul>
        /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
        pub fn metric_name(mut self, input: crate::model::MetricName) -> Self {
            self.metric_name = Some(input);
            self
        }
        /// <p>The name of the metric to associate with the alarm.</p>
        /// <p>You can configure up to two alarms per metric.</p>
        /// <p>The following metrics are available for each resource type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>Instances</b>: <code>BurstCapacityPercentage</code>,
        /// <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>,
        /// <code>NetworkOut</code>, <code>StatusCheckFailed</code>,
        /// <code>StatusCheckFailed_Instance</code>, and
        /// <code>StatusCheckFailed_System</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Load balancers</b>:
        /// <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>,
        /// <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>,
        /// <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>,
        /// <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>,
        /// <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>,
        /// <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Relational databases</b>: <code>CPUUtilization</code>,
        /// <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>,
        /// <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and
        /// <code>NetworkTransmitThroughput</code>.</p>
        /// </li>
        /// </ul>
        /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
        pub fn set_metric_name(
            mut self,
            input: std::option::Option<crate::model::MetricName>,
        ) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The name of the Lightsail resource that will be monitored.</p>
        /// <p>Instances, load balancers, and relational databases are the only Lightsail resources
        /// that can currently be monitored by alarms.</p>
        pub fn monitored_resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitored_resource_name = Some(input.into());
            self
        }
        /// <p>The name of the Lightsail resource that will be monitored.</p>
        /// <p>Instances, load balancers, and relational databases are the only Lightsail resources
        /// that can currently be monitored by alarms.</p>
        pub fn set_monitored_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.monitored_resource_name = input;
            self
        }
        /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold.
        /// The specified statistic value is used as the first operand.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold.
        /// The specified statistic value is used as the first operand.</p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p>The value against which the specified statistic is compared.</p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The value against which the specified statistic is compared.</p>
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p>The number of most recent periods over which data is compared to the specified threshold.
        /// If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the
        /// N.</p>
        /// <p>If you are setting an alarm that requires that a number of consecutive data points be
        /// breaching to trigger the alarm, this value specifies the rolling period of time in which data
        /// points are evaluated.</p>
        /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of
        /// 24 to evaluate a metric over a rolling period of two hours.</p>
        /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation
        /// period of 288 (24 hours).</p>
        pub fn evaluation_periods(mut self, input: i32) -> Self {
            self.evaluation_periods = Some(input);
            self
        }
        /// <p>The number of most recent periods over which data is compared to the specified threshold.
        /// If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the
        /// N.</p>
        /// <p>If you are setting an alarm that requires that a number of consecutive data points be
        /// breaching to trigger the alarm, this value specifies the rolling period of time in which data
        /// points are evaluated.</p>
        /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of
        /// 24 to evaluate a metric over a rolling period of two hours.</p>
        /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation
        /// period of 288 (24 hours).</p>
        pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
            self.evaluation_periods = input;
            self
        }
        /// <p>The number of data points that must be not within the specified threshold to trigger the
        /// alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>)
        /// is the M.</p>
        pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
            self.datapoints_to_alarm = Some(input);
            self
        }
        /// <p>The number of data points that must be not within the specified threshold to trigger the
        /// alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>)
        /// is the M.</p>
        pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
            self.datapoints_to_alarm = input;
            self
        }
        /// <p>Sets how this alarm will handle missing data points.</p>
        /// <p>An alarm can treat missing data in the following ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>breaching</code> - Assume the missing data is not within the threshold. Missing
        /// data counts towards the number of times the metric is not within the threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>notBreaching</code> - Assume the missing data is within the threshold. Missing
        /// data does not count towards the number of times the metric is not within the
        /// threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ignore</code> - Ignore the missing data. Maintains the current alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>missing</code> - Missing data is treated as missing.</p>
        /// </li>
        /// </ul>
        /// <p>If <code>treatMissingData</code> is not specified, the default behavior of
        /// <code>missing</code> is used.</p>
        pub fn treat_missing_data(mut self, input: crate::model::TreatMissingData) -> Self {
            self.treat_missing_data = Some(input);
            self
        }
        /// <p>Sets how this alarm will handle missing data points.</p>
        /// <p>An alarm can treat missing data in the following ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>breaching</code> - Assume the missing data is not within the threshold. Missing
        /// data counts towards the number of times the metric is not within the threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>notBreaching</code> - Assume the missing data is within the threshold. Missing
        /// data does not count towards the number of times the metric is not within the
        /// threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ignore</code> - Ignore the missing data. Maintains the current alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>missing</code> - Missing data is treated as missing.</p>
        /// </li>
        /// </ul>
        /// <p>If <code>treatMissingData</code> is not specified, the default behavior of
        /// <code>missing</code> is used.</p>
        pub fn set_treat_missing_data(
            mut self,
            input: std::option::Option<crate::model::TreatMissingData>,
        ) -> Self {
            self.treat_missing_data = input;
            self
        }
        /// Appends an item to `contact_protocols`.
        ///
        /// To override the contents of this collection use [`set_contact_protocols`](Self::set_contact_protocols).
        ///
        /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code>
        /// (text messaging), or both.</p>
        /// <p>A notification is sent via the specified contact protocol if notifications are enabled for
        /// the alarm, and when the alarm is triggered.</p>
        /// <p>A notification is not sent if a contact protocol is not specified, if the specified
        /// contact protocol is not configured in the AWS Region, or if notifications are not enabled
        /// for the alarm using the <code>notificationEnabled</code> paramater.</p>
        /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an
        /// AWS Region.</p>
        pub fn contact_protocols(
            mut self,
            input: impl Into<crate::model::ContactProtocol>,
        ) -> Self {
            let mut v = self.contact_protocols.unwrap_or_default();
            v.push(input.into());
            self.contact_protocols = Some(v);
            self
        }
        /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code>
        /// (text messaging), or both.</p>
        /// <p>A notification is sent via the specified contact protocol if notifications are enabled for
        /// the alarm, and when the alarm is triggered.</p>
        /// <p>A notification is not sent if a contact protocol is not specified, if the specified
        /// contact protocol is not configured in the AWS Region, or if notifications are not enabled
        /// for the alarm using the <code>notificationEnabled</code> paramater.</p>
        /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an
        /// AWS Region.</p>
        pub fn set_contact_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
        ) -> Self {
            self.contact_protocols = input;
            self
        }
        /// Appends an item to `notification_triggers`.
        ///
        /// To override the contents of this collection use [`set_notification_triggers`](Self::set_notification_triggers).
        ///
        /// <p>The alarm states that trigger a notification.</p>
        /// <p>An alarm has the following possible states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
        /// available, or not enough data is available for the metric to determine the alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK</code> - The metric is within the defined threshold.</p>
        /// </li>
        /// </ul>
        /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified.
        /// The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to
        /// the <code>ALARM</code> state.</p>
        /// <ul>
        /// <li>
        /// <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the
        /// alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to
        /// an <code>OK</code> state. This can be thought of as an <i>all clear</i>
        /// alarm notification.</p>
        /// </li>
        /// <li>
        /// <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is
        /// sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to
        /// an <code>INSUFFICIENT_DATA</code> state.</p>
        /// </li>
        /// </ul>
        /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this
        /// parameter.</p>
        pub fn notification_triggers(mut self, input: impl Into<crate::model::AlarmState>) -> Self {
            let mut v = self.notification_triggers.unwrap_or_default();
            v.push(input.into());
            self.notification_triggers = Some(v);
            self
        }
        /// <p>The alarm states that trigger a notification.</p>
        /// <p>An alarm has the following possible states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
        /// available, or not enough data is available for the metric to determine the alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK</code> - The metric is within the defined threshold.</p>
        /// </li>
        /// </ul>
        /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified.
        /// The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to
        /// the <code>ALARM</code> state.</p>
        /// <ul>
        /// <li>
        /// <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the
        /// alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to
        /// an <code>OK</code> state. This can be thought of as an <i>all clear</i>
        /// alarm notification.</p>
        /// </li>
        /// <li>
        /// <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is
        /// sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to
        /// an <code>INSUFFICIENT_DATA</code> state.</p>
        /// </li>
        /// </ul>
        /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this
        /// parameter.</p>
        pub fn set_notification_triggers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlarmState>>,
        ) -> Self {
            self.notification_triggers = input;
            self
        }
        /// <p>Indicates whether the alarm is enabled.</p>
        /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
        pub fn notification_enabled(mut self, input: bool) -> Self {
            self.notification_enabled = Some(input);
            self
        }
        /// <p>Indicates whether the alarm is enabled.</p>
        /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
        pub fn set_notification_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.notification_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`PutAlarmInput`](crate::input::PutAlarmInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutAlarmInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutAlarmInput {
                alarm_name: self.alarm_name,
                metric_name: self.metric_name,
                monitored_resource_name: self.monitored_resource_name,
                comparison_operator: self.comparison_operator,
                threshold: self.threshold,
                evaluation_periods: self.evaluation_periods,
                datapoints_to_alarm: self.datapoints_to_alarm,
                treat_missing_data: self.treat_missing_data,
                contact_protocols: self.contact_protocols,
                notification_triggers: self.notification_triggers,
                notification_enabled: self.notification_enabled,
            })
        }
    }
}
#[doc(hidden)]
pub type PutAlarmInputOperationOutputAlias = crate::operation::PutAlarm;
#[doc(hidden)]
pub type PutAlarmInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutAlarmInput {
    /// Consumes the builder and constructs an Operation<[`PutAlarm`](crate::operation::PutAlarm)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutAlarm,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutAlarmInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutAlarmInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutAlarmInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.PutAlarm",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_put_alarm(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::PutAlarm::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "PutAlarm",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutAlarmInput`](crate::input::PutAlarmInput)
    pub fn builder() -> crate::input::put_alarm_input::Builder {
        crate::input::put_alarm_input::Builder::default()
    }
}

/// See [`PutInstancePublicPortsInput`](crate::input::PutInstancePublicPortsInput)
pub mod put_instance_public_ports_input {
    /// A builder for [`PutInstancePublicPortsInput`](crate::input::PutInstancePublicPortsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) port_infos: std::option::Option<std::vec::Vec<crate::model::PortInfo>>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `port_infos`.
        ///
        /// To override the contents of this collection use [`set_port_infos`](Self::set_port_infos).
        ///
        /// <p>An array of objects to describe the ports to open for the specified instance.</p>
        pub fn port_infos(mut self, input: impl Into<crate::model::PortInfo>) -> Self {
            let mut v = self.port_infos.unwrap_or_default();
            v.push(input.into());
            self.port_infos = Some(v);
            self
        }
        /// <p>An array of objects to describe the ports to open for the specified instance.</p>
        pub fn set_port_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PortInfo>>,
        ) -> Self {
            self.port_infos = input;
            self
        }
        /// <p>The name of the instance for which to open ports.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance for which to open ports.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PutInstancePublicPortsInput`](crate::input::PutInstancePublicPortsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutInstancePublicPortsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutInstancePublicPortsInput {
                port_infos: self.port_infos,
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type PutInstancePublicPortsInputOperationOutputAlias = crate::operation::PutInstancePublicPorts;
#[doc(hidden)]
pub type PutInstancePublicPortsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutInstancePublicPortsInput {
    /// Consumes the builder and constructs an Operation<[`PutInstancePublicPorts`](crate::operation::PutInstancePublicPorts)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutInstancePublicPorts,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutInstancePublicPortsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutInstancePublicPortsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutInstancePublicPortsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.PutInstancePublicPorts",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_instance_public_ports(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutInstancePublicPorts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutInstancePublicPorts",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutInstancePublicPortsInput`](crate::input::PutInstancePublicPortsInput)
    pub fn builder() -> crate::input::put_instance_public_ports_input::Builder {
        crate::input::put_instance_public_ports_input::Builder::default()
    }
}

/// See [`RebootInstanceInput`](crate::input::RebootInstanceInput)
pub mod reboot_instance_input {
    /// A builder for [`RebootInstanceInput`](crate::input::RebootInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance to reboot.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance to reboot.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`RebootInstanceInput`](crate::input::RebootInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RebootInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RebootInstanceInput {
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type RebootInstanceInputOperationOutputAlias = crate::operation::RebootInstance;
#[doc(hidden)]
pub type RebootInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RebootInstanceInput {
    /// Consumes the builder and constructs an Operation<[`RebootInstance`](crate::operation::RebootInstance)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RebootInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RebootInstanceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RebootInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RebootInstanceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.RebootInstance",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_reboot_instance(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RebootInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RebootInstance",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RebootInstanceInput`](crate::input::RebootInstanceInput)
    pub fn builder() -> crate::input::reboot_instance_input::Builder {
        crate::input::reboot_instance_input::Builder::default()
    }
}

/// See [`RebootRelationalDatabaseInput`](crate::input::RebootRelationalDatabaseInput)
pub mod reboot_relational_database_input {
    /// A builder for [`RebootRelationalDatabaseInput`](crate::input::RebootRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your database to reboot.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database to reboot.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`RebootRelationalDatabaseInput`](crate::input::RebootRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RebootRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RebootRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
            })
        }
    }
}
#[doc(hidden)]
pub type RebootRelationalDatabaseInputOperationOutputAlias =
    crate::operation::RebootRelationalDatabase;
#[doc(hidden)]
pub type RebootRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RebootRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`RebootRelationalDatabase`](crate::operation::RebootRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RebootRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RebootRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RebootRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RebootRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.RebootRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_reboot_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RebootRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RebootRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RebootRelationalDatabaseInput`](crate::input::RebootRelationalDatabaseInput)
    pub fn builder() -> crate::input::reboot_relational_database_input::Builder {
        crate::input::reboot_relational_database_input::Builder::default()
    }
}

/// See [`RegisterContainerImageInput`](crate::input::RegisterContainerImageInput)
pub mod register_container_image_input {
    /// A builder for [`RegisterContainerImageInput`](crate::input::RegisterContainerImageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) digest: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the container service for which to register a container image.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service for which to register a container image.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The label for the container image when it's registered to the container service.</p>
        ///
        /// <p>Use a descriptive label that you can use to track the different versions of your
        /// registered container images.</p>
        ///
        /// <p>Use the <code>GetContainerImages</code> action to return the container images registered
        /// to a Lightsail container service. The label is the <code><imagelabel></code> portion
        /// of the following image name example:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>:container-service-1.<imagelabel>.1</code>
        /// </p>
        /// </li>
        /// </ul>
        ///
        /// <p>If the name of your container service is <code>mycontainerservice</code>, and the label
        /// that you specify is <code>mystaticwebsite</code>, then the name of the registered container
        /// image will be <code>:mycontainerservice.mystaticwebsite.1</code>.</p>
        ///
        /// <p>The number at the end of these image name examples represents the version of the
        /// registered container image. If you push and register another container image to the same
        /// Lightsail container service, with the same label, then the version number for the new
        /// registered container image will be <code>2</code>. If you push and register another container
        /// image, the version number will be <code>3</code>, and so on.</p>
        pub fn label(mut self, input: impl Into<std::string::String>) -> Self {
            self.label = Some(input.into());
            self
        }
        /// <p>The label for the container image when it's registered to the container service.</p>
        ///
        /// <p>Use a descriptive label that you can use to track the different versions of your
        /// registered container images.</p>
        ///
        /// <p>Use the <code>GetContainerImages</code> action to return the container images registered
        /// to a Lightsail container service. The label is the <code><imagelabel></code> portion
        /// of the following image name example:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>:container-service-1.<imagelabel>.1</code>
        /// </p>
        /// </li>
        /// </ul>
        ///
        /// <p>If the name of your container service is <code>mycontainerservice</code>, and the label
        /// that you specify is <code>mystaticwebsite</code>, then the name of the registered container
        /// image will be <code>:mycontainerservice.mystaticwebsite.1</code>.</p>
        ///
        /// <p>The number at the end of these image name examples represents the version of the
        /// registered container image. If you push and register another container image to the same
        /// Lightsail container service, with the same label, then the version number for the new
        /// registered container image will be <code>2</code>. If you push and register another container
        /// image, the version number will be <code>3</code>, and so on.</p>
        pub fn set_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.label = input;
            self
        }
        /// <p>The digest of the container image to be registered.</p>
        pub fn digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.digest = Some(input.into());
            self
        }
        /// <p>The digest of the container image to be registered.</p>
        pub fn set_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.digest = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterContainerImageInput`](crate::input::RegisterContainerImageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterContainerImageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterContainerImageInput {
                service_name: self.service_name,
                label: self.label,
                digest: self.digest,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterContainerImageInputOperationOutputAlias = crate::operation::RegisterContainerImage;
#[doc(hidden)]
pub type RegisterContainerImageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RegisterContainerImageInput {
    /// Consumes the builder and constructs an Operation<[`RegisterContainerImage`](crate::operation::RegisterContainerImage)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterContainerImage,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RegisterContainerImageInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RegisterContainerImageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RegisterContainerImageInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.RegisterContainerImage",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_register_container_image(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterContainerImage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterContainerImage",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RegisterContainerImageInput`](crate::input::RegisterContainerImageInput)
    pub fn builder() -> crate::input::register_container_image_input::Builder {
        crate::input::register_container_image_input::Builder::default()
    }
}

/// See [`ReleaseStaticIpInput`](crate::input::ReleaseStaticIpInput)
pub mod release_static_ip_input {
    /// A builder for [`ReleaseStaticIpInput`](crate::input::ReleaseStaticIpInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) static_ip_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the static IP to delete.</p>
        pub fn static_ip_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.static_ip_name = Some(input.into());
            self
        }
        /// <p>The name of the static IP to delete.</p>
        pub fn set_static_ip_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.static_ip_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ReleaseStaticIpInput`](crate::input::ReleaseStaticIpInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ReleaseStaticIpInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ReleaseStaticIpInput {
                static_ip_name: self.static_ip_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ReleaseStaticIpInputOperationOutputAlias = crate::operation::ReleaseStaticIp;
#[doc(hidden)]
pub type ReleaseStaticIpInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ReleaseStaticIpInput {
    /// Consumes the builder and constructs an Operation<[`ReleaseStaticIp`](crate::operation::ReleaseStaticIp)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ReleaseStaticIp,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ReleaseStaticIpInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ReleaseStaticIpInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ReleaseStaticIpInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.ReleaseStaticIp",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_release_static_ip(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ReleaseStaticIp::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ReleaseStaticIp",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ReleaseStaticIpInput`](crate::input::ReleaseStaticIpInput)
    pub fn builder() -> crate::input::release_static_ip_input::Builder {
        crate::input::release_static_ip_input::Builder::default()
    }
}

/// See [`ResetDistributionCacheInput`](crate::input::ResetDistributionCacheInput)
pub mod reset_distribution_cache_input {
    /// A builder for [`ResetDistributionCacheInput`](crate::input::ResetDistributionCacheInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution for which to reset cache.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution for which to reset cache.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ResetDistributionCacheInput`](crate::input::ResetDistributionCacheInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ResetDistributionCacheInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ResetDistributionCacheInput {
                distribution_name: self.distribution_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ResetDistributionCacheInputOperationOutputAlias = crate::operation::ResetDistributionCache;
#[doc(hidden)]
pub type ResetDistributionCacheInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ResetDistributionCacheInput {
    /// Consumes the builder and constructs an Operation<[`ResetDistributionCache`](crate::operation::ResetDistributionCache)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ResetDistributionCache,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ResetDistributionCacheInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ResetDistributionCacheInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ResetDistributionCacheInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.ResetDistributionCache",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_reset_distribution_cache(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ResetDistributionCache::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ResetDistributionCache",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ResetDistributionCacheInput`](crate::input::ResetDistributionCacheInput)
    pub fn builder() -> crate::input::reset_distribution_cache_input::Builder {
        crate::input::reset_distribution_cache_input::Builder::default()
    }
}

/// See [`SendContactMethodVerificationInput`](crate::input::SendContactMethodVerificationInput)
pub mod send_contact_method_verification_input {
    /// A builder for [`SendContactMethodVerificationInput`](crate::input::SendContactMethodVerificationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::ContactMethodVerificationProtocol>,
    }
    impl Builder {
        /// <p>The protocol to verify, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        pub fn protocol(mut self, input: crate::model::ContactMethodVerificationProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol to verify, such as <code>Email</code> or <code>SMS</code> (text
        /// messaging).</p>
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ContactMethodVerificationProtocol>,
        ) -> Self {
            self.protocol = input;
            self
        }
        /// Consumes the builder and constructs a [`SendContactMethodVerificationInput`](crate::input::SendContactMethodVerificationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SendContactMethodVerificationInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SendContactMethodVerificationInput {
                protocol: self.protocol,
            })
        }
    }
}
#[doc(hidden)]
pub type SendContactMethodVerificationInputOperationOutputAlias =
    crate::operation::SendContactMethodVerification;
#[doc(hidden)]
pub type SendContactMethodVerificationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SendContactMethodVerificationInput {
    /// Consumes the builder and constructs an Operation<[`SendContactMethodVerification`](crate::operation::SendContactMethodVerification)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SendContactMethodVerification,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SendContactMethodVerificationInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SendContactMethodVerificationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SendContactMethodVerificationInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.SendContactMethodVerification",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_send_contact_method_verification(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SendContactMethodVerification::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SendContactMethodVerification",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SendContactMethodVerificationInput`](crate::input::SendContactMethodVerificationInput)
    pub fn builder() -> crate::input::send_contact_method_verification_input::Builder {
        crate::input::send_contact_method_verification_input::Builder::default()
    }
}

/// See [`SetIpAddressTypeInput`](crate::input::SetIpAddressTypeInput)
pub mod set_ip_address_type_input {
    /// A builder for [`SetIpAddressTypeInput`](crate::input::SetIpAddressTypeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<crate::model::ResourceType>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) ip_address_type: std::option::Option<crate::model::IpAddressType>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        /// <p>The possible values are <code>Distribution</code>, <code>Instance</code>, and
        /// <code>LoadBalancer</code>.</p>
        /// <note>
        /// <p>Distribution-related APIs are available only in the N. Virginia (<code>us-east-1</code>)
        /// AWS Region. Set your AWS Region configuration to <code>us-east-1</code> to create, view,
        /// or edit distributions.</p>
        /// </note>
        pub fn resource_type(mut self, input: crate::model::ResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>The resource type.</p>
        /// <p>The possible values are <code>Distribution</code>, <code>Instance</code>, and
        /// <code>LoadBalancer</code>.</p>
        /// <note>
        /// <p>Distribution-related APIs are available only in the N. Virginia (<code>us-east-1</code>)
        /// AWS Region. Set your AWS Region configuration to <code>us-east-1</code> to create, view,
        /// or edit distributions.</p>
        /// </note>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::ResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The name of the resource for which to set the IP address type.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource for which to set the IP address type.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The IP address type to set for the specified resource.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.ip_address_type = Some(input);
            self
        }
        /// <p>The IP address type to set for the specified resource.</p>
        ///
        /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
        /// IPv4 and IPv6.</p>
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.ip_address_type = input;
            self
        }
        /// Consumes the builder and constructs a [`SetIpAddressTypeInput`](crate::input::SetIpAddressTypeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetIpAddressTypeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetIpAddressTypeInput {
                resource_type: self.resource_type,
                resource_name: self.resource_name,
                ip_address_type: self.ip_address_type,
            })
        }
    }
}
#[doc(hidden)]
pub type SetIpAddressTypeInputOperationOutputAlias = crate::operation::SetIpAddressType;
#[doc(hidden)]
pub type SetIpAddressTypeInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SetIpAddressTypeInput {
    /// Consumes the builder and constructs an Operation<[`SetIpAddressType`](crate::operation::SetIpAddressType)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetIpAddressType,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SetIpAddressTypeInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SetIpAddressTypeInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SetIpAddressTypeInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.SetIpAddressType",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_set_ip_address_type(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetIpAddressType::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetIpAddressType",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SetIpAddressTypeInput`](crate::input::SetIpAddressTypeInput)
    pub fn builder() -> crate::input::set_ip_address_type_input::Builder {
        crate::input::set_ip_address_type_input::Builder::default()
    }
}

/// See [`SetResourceAccessForBucketInput`](crate::input::SetResourceAccessForBucketInput)
pub mod set_resource_access_for_bucket_input {
    /// A builder for [`SetResourceAccessForBucketInput`](crate::input::SetResourceAccessForBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) access: std::option::Option<crate::model::ResourceBucketAccess>,
    }
    impl Builder {
        /// <p>The name of the Lightsail instance for which to set bucket access. The instance must be
        /// in a running or stopped state.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the Lightsail instance for which to set bucket access. The instance must be
        /// in a running or stopped state.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The name of the bucket for which to set access to another Lightsail resource.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket for which to set access to another Lightsail resource.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The access setting.</p>
        ///
        /// <p>The following access settings are available:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>allow</code> - Allows access to the bucket and its objects.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deny</code> - Denies access to the bucket and its objects. Use this setting to
        /// remove access for a resource previously set to <code>allow</code>.</p>
        /// </li>
        /// </ul>
        pub fn access(mut self, input: crate::model::ResourceBucketAccess) -> Self {
            self.access = Some(input);
            self
        }
        /// <p>The access setting.</p>
        ///
        /// <p>The following access settings are available:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>allow</code> - Allows access to the bucket and its objects.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deny</code> - Denies access to the bucket and its objects. Use this setting to
        /// remove access for a resource previously set to <code>allow</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_access(
            mut self,
            input: std::option::Option<crate::model::ResourceBucketAccess>,
        ) -> Self {
            self.access = input;
            self
        }
        /// Consumes the builder and constructs a [`SetResourceAccessForBucketInput`](crate::input::SetResourceAccessForBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetResourceAccessForBucketInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetResourceAccessForBucketInput {
                resource_name: self.resource_name,
                bucket_name: self.bucket_name,
                access: self.access,
            })
        }
    }
}
#[doc(hidden)]
pub type SetResourceAccessForBucketInputOperationOutputAlias =
    crate::operation::SetResourceAccessForBucket;
#[doc(hidden)]
pub type SetResourceAccessForBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SetResourceAccessForBucketInput {
    /// Consumes the builder and constructs an Operation<[`SetResourceAccessForBucket`](crate::operation::SetResourceAccessForBucket)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetResourceAccessForBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SetResourceAccessForBucketInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SetResourceAccessForBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SetResourceAccessForBucketInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.SetResourceAccessForBucket",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_set_resource_access_for_bucket(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetResourceAccessForBucket::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetResourceAccessForBucket",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SetResourceAccessForBucketInput`](crate::input::SetResourceAccessForBucketInput)
    pub fn builder() -> crate::input::set_resource_access_for_bucket_input::Builder {
        crate::input::set_resource_access_for_bucket_input::Builder::default()
    }
}

/// See [`StartInstanceInput`](crate::input::StartInstanceInput)
pub mod start_instance_input {
    /// A builder for [`StartInstanceInput`](crate::input::StartInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the instance (a virtual private server) to start.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance (a virtual private server) to start.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StartInstanceInput`](crate::input::StartInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartInstanceInput {
                instance_name: self.instance_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StartInstanceInputOperationOutputAlias = crate::operation::StartInstance;
#[doc(hidden)]
pub type StartInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartInstanceInput {
    /// Consumes the builder and constructs an Operation<[`StartInstance`](crate::operation::StartInstance)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartInstanceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartInstanceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.StartInstance",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_start_instance(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartInstance",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartInstanceInput`](crate::input::StartInstanceInput)
    pub fn builder() -> crate::input::start_instance_input::Builder {
        crate::input::start_instance_input::Builder::default()
    }
}

/// See [`StartRelationalDatabaseInput`](crate::input::StartRelationalDatabaseInput)
pub mod start_relational_database_input {
    /// A builder for [`StartRelationalDatabaseInput`](crate::input::StartRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your database to start.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database to start.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRelationalDatabaseInput`](crate::input::StartRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StartRelationalDatabaseInputOperationOutputAlias =
    crate::operation::StartRelationalDatabase;
#[doc(hidden)]
pub type StartRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`StartRelationalDatabase`](crate::operation::StartRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.StartRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartRelationalDatabaseInput`](crate::input::StartRelationalDatabaseInput)
    pub fn builder() -> crate::input::start_relational_database_input::Builder {
        crate::input::start_relational_database_input::Builder::default()
    }
}

/// See [`StopInstanceInput`](crate::input::StopInstanceInput)
pub mod stop_instance_input {
    /// A builder for [`StopInstanceInput`](crate::input::StopInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) force: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the instance (a virtual private server) to stop.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        /// <p>The name of the instance (a virtual private server) to stop.</p>
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        /// <p>When set to <code>True</code>, forces a Lightsail instance that is stuck in a
        /// <code>stopping</code> state to stop.</p>
        /// <important>
        /// <p>Only use the <code>force</code> parameter if your instance is stuck in the
        /// <code>stopping</code> state. In any other state, your instance should stop normally
        /// without adding this parameter to your API request.</p>
        /// </important>
        pub fn force(mut self, input: bool) -> Self {
            self.force = Some(input);
            self
        }
        /// <p>When set to <code>True</code>, forces a Lightsail instance that is stuck in a
        /// <code>stopping</code> state to stop.</p>
        /// <important>
        /// <p>Only use the <code>force</code> parameter if your instance is stuck in the
        /// <code>stopping</code> state. In any other state, your instance should stop normally
        /// without adding this parameter to your API request.</p>
        /// </important>
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.force = input;
            self
        }
        /// Consumes the builder and constructs a [`StopInstanceInput`](crate::input::StopInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopInstanceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopInstanceInput {
                instance_name: self.instance_name,
                force: self.force,
            })
        }
    }
}
#[doc(hidden)]
pub type StopInstanceInputOperationOutputAlias = crate::operation::StopInstance;
#[doc(hidden)]
pub type StopInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopInstanceInput {
    /// Consumes the builder and constructs an Operation<[`StopInstance`](crate::operation::StopInstance)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopInstanceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopInstanceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.StopInstance",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_stop_instance(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopInstance::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopInstance",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopInstanceInput`](crate::input::StopInstanceInput)
    pub fn builder() -> crate::input::stop_instance_input::Builder {
        crate::input::stop_instance_input::Builder::default()
    }
}

/// See [`StopRelationalDatabaseInput`](crate::input::StopRelationalDatabaseInput)
pub mod stop_relational_database_input {
    /// A builder for [`StopRelationalDatabaseInput`](crate::input::StopRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) relational_database_snapshot_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your database to stop.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database to stop.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The name of your new database snapshot to be created before stopping your database.</p>
        pub fn relational_database_snapshot_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = Some(input.into());
            self
        }
        /// <p>The name of your new database snapshot to be created before stopping your database.</p>
        pub fn set_relational_database_snapshot_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_snapshot_name = input;
            self
        }
        /// Consumes the builder and constructs a [`StopRelationalDatabaseInput`](crate::input::StopRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
                relational_database_snapshot_name: self.relational_database_snapshot_name,
            })
        }
    }
}
#[doc(hidden)]
pub type StopRelationalDatabaseInputOperationOutputAlias = crate::operation::StopRelationalDatabase;
#[doc(hidden)]
pub type StopRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`StopRelationalDatabase`](crate::operation::StopRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.StopRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_stop_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopRelationalDatabaseInput`](crate::input::StopRelationalDatabaseInput)
    pub fn builder() -> crate::input::stop_relational_database_input::Builder {
        crate::input::stop_relational_database_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the resource to which you are adding tags.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource to which you are adding tags.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add a tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add a tag.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tag key and optional value.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The tag key and optional value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_name: self.resource_name,
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.TagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TestAlarmInput`](crate::input::TestAlarmInput)
pub mod test_alarm_input {
    /// A builder for [`TestAlarmInput`](crate::input::TestAlarmInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::AlarmState>,
    }
    impl Builder {
        /// <p>The name of the alarm to test.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of the alarm to test.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The alarm state to test.</p>
        /// <p>An alarm has the following possible states that can be tested:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
        /// available, or not enough data is available for the metric to determine the alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK</code> - The metric is within the defined threshold.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: crate::model::AlarmState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The alarm state to test.</p>
        /// <p>An alarm has the following possible states that can be tested:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
        /// available, or not enough data is available for the metric to determine the alarm
        /// state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK</code> - The metric is within the defined threshold.</p>
        /// </li>
        /// </ul>
        pub fn set_state(mut self, input: std::option::Option<crate::model::AlarmState>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`TestAlarmInput`](crate::input::TestAlarmInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TestAlarmInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::TestAlarmInput {
                alarm_name: self.alarm_name,
                state: self.state,
            })
        }
    }
}
#[doc(hidden)]
pub type TestAlarmInputOperationOutputAlias = crate::operation::TestAlarm;
#[doc(hidden)]
pub type TestAlarmInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TestAlarmInput {
    /// Consumes the builder and constructs an Operation<[`TestAlarm`](crate::operation::TestAlarm)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TestAlarm,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TestAlarmInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TestAlarmInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TestAlarmInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.TestAlarm",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_test_alarm(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::TestAlarm::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "TestAlarm",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TestAlarmInput`](crate::input::TestAlarmInput)
    pub fn builder() -> crate::input::test_alarm_input::Builder {
        crate::input::test_alarm_input::Builder::default()
    }
}

/// See [`UnpeerVpcInput`](crate::input::UnpeerVpcInput)
pub mod unpeer_vpc_input {
    /// A builder for [`UnpeerVpcInput`](crate::input::UnpeerVpcInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UnpeerVpcInput`](crate::input::UnpeerVpcInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UnpeerVpcInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::UnpeerVpcInput {})
        }
    }
}
#[doc(hidden)]
pub type UnpeerVpcInputOperationOutputAlias = crate::operation::UnpeerVpc;
#[doc(hidden)]
pub type UnpeerVpcInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UnpeerVpcInput {
    /// Consumes the builder and constructs an Operation<[`UnpeerVpc`](crate::operation::UnpeerVpc)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UnpeerVpc,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UnpeerVpcInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UnpeerVpcInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UnpeerVpcInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UnpeerVpc",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_unpeer_vpc(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::UnpeerVpc::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "UnpeerVpc",
                    "lightsail",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UnpeerVpcInput`](crate::input::UnpeerVpcInput)
    pub fn builder() -> crate::input::unpeer_vpc_input::Builder {
        crate::input::unpeer_vpc_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the resource from which you are removing a tag.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The name of the resource from which you are removing a tag.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove a tag.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove a tag.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys to delete from the specified resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys to delete from the specified resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_name: self.resource_name,
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UntagResource",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateBucketInput`](crate::input::UpdateBucketInput)
pub mod update_bucket_input {
    /// A builder for [`UpdateBucketInput`](crate::input::UpdateBucketInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) access_rules: std::option::Option<crate::model::AccessRules>,
        pub(crate) versioning: std::option::Option<std::string::String>,
        pub(crate) readonly_access_accounts:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) access_log_config: std::option::Option<crate::model::BucketAccessLogConfig>,
    }
    impl Builder {
        /// <p>The name of the bucket to update.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket to update.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>An object that sets the public accessibility of objects in the specified bucket.</p>
        pub fn access_rules(mut self, input: crate::model::AccessRules) -> Self {
            self.access_rules = Some(input);
            self
        }
        /// <p>An object that sets the public accessibility of objects in the specified bucket.</p>
        pub fn set_access_rules(
            mut self,
            input: std::option::Option<crate::model::AccessRules>,
        ) -> Self {
            self.access_rules = input;
            self
        }
        /// <p>Specifies whether to enable or suspend versioning of objects in the bucket.</p>
        ///
        /// <p>The following options can be specified:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Enabled</code> - Enables versioning of objects in the specified bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Suspended</code> - Suspends versioning of objects in the specified bucket.
        /// Existing object versions are retained.</p>
        /// </li>
        /// </ul>
        pub fn versioning(mut self, input: impl Into<std::string::String>) -> Self {
            self.versioning = Some(input.into());
            self
        }
        /// <p>Specifies whether to enable or suspend versioning of objects in the bucket.</p>
        ///
        /// <p>The following options can be specified:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Enabled</code> - Enables versioning of objects in the specified bucket.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Suspended</code> - Suspends versioning of objects in the specified bucket.
        /// Existing object versions are retained.</p>
        /// </li>
        /// </ul>
        pub fn set_versioning(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.versioning = input;
            self
        }
        /// Appends an item to `readonly_access_accounts`.
        ///
        /// To override the contents of this collection use [`set_readonly_access_accounts`](Self::set_readonly_access_accounts).
        ///
        /// <p>An array of strings to specify the AWS account IDs that can access the bucket.</p>
        ///
        /// <p>You can give a maximum of 10 AWS accounts access to a bucket.</p>
        pub fn readonly_access_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.readonly_access_accounts.unwrap_or_default();
            v.push(input.into());
            self.readonly_access_accounts = Some(v);
            self
        }
        /// <p>An array of strings to specify the AWS account IDs that can access the bucket.</p>
        ///
        /// <p>You can give a maximum of 10 AWS accounts access to a bucket.</p>
        pub fn set_readonly_access_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.readonly_access_accounts = input;
            self
        }
        /// <p>An object that describes the access log configuration for the bucket.</p>
        pub fn access_log_config(mut self, input: crate::model::BucketAccessLogConfig) -> Self {
            self.access_log_config = Some(input);
            self
        }
        /// <p>An object that describes the access log configuration for the bucket.</p>
        pub fn set_access_log_config(
            mut self,
            input: std::option::Option<crate::model::BucketAccessLogConfig>,
        ) -> Self {
            self.access_log_config = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateBucketInput`](crate::input::UpdateBucketInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateBucketInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateBucketInput {
                bucket_name: self.bucket_name,
                access_rules: self.access_rules,
                versioning: self.versioning,
                readonly_access_accounts: self.readonly_access_accounts,
                access_log_config: self.access_log_config,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateBucketInputOperationOutputAlias = crate::operation::UpdateBucket;
#[doc(hidden)]
pub type UpdateBucketInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateBucketInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBucket`](crate::operation::UpdateBucket)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateBucket,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateBucketInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateBucketInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateBucketInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateBucket",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_bucket(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateBucket::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateBucket",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateBucketInput`](crate::input::UpdateBucketInput)
    pub fn builder() -> crate::input::update_bucket_input::Builder {
        crate::input::update_bucket_input::Builder::default()
    }
}

/// See [`UpdateBucketBundleInput`](crate::input::UpdateBucketBundleInput)
pub mod update_bucket_bundle_input {
    /// A builder for [`UpdateBucketBundleInput`](crate::input::UpdateBucketBundleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket_name: std::option::Option<std::string::String>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the bucket for which to update the bundle.</p>
        pub fn bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the bucket for which to update the bundle.</p>
        pub fn set_bucket_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket_name = input;
            self
        }
        /// <p>The ID of the new bundle to apply to the bucket.</p>
        ///
        /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
        /// specify.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The ID of the new bundle to apply to the bucket.</p>
        ///
        /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
        /// specify.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateBucketBundleInput`](crate::input::UpdateBucketBundleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateBucketBundleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateBucketBundleInput {
                bucket_name: self.bucket_name,
                bundle_id: self.bundle_id,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateBucketBundleInputOperationOutputAlias = crate::operation::UpdateBucketBundle;
#[doc(hidden)]
pub type UpdateBucketBundleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateBucketBundleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBucketBundle`](crate::operation::UpdateBucketBundle)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateBucketBundle,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateBucketBundleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateBucketBundleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateBucketBundleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateBucketBundle",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_bucket_bundle(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateBucketBundle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateBucketBundle",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateBucketBundleInput`](crate::input::UpdateBucketBundleInput)
    pub fn builder() -> crate::input::update_bucket_bundle_input::Builder {
        crate::input::update_bucket_bundle_input::Builder::default()
    }
}

/// See [`UpdateContainerServiceInput`](crate::input::UpdateContainerServiceInput)
pub mod update_container_service_input {
    /// A builder for [`UpdateContainerServiceInput`](crate::input::UpdateContainerServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) power: std::option::Option<crate::model::ContainerServicePowerName>,
        pub(crate) scale: std::option::Option<i32>,
        pub(crate) is_disabled: std::option::Option<bool>,
        pub(crate) public_domain_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The name of the container service to update.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        /// <p>The name of the container service to update.</p>
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The power for the container service.</p>
        ///
        /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
        /// container service. The <code>power</code> and <code>scale</code> of a container service makes
        /// up its configured capacity. To determine the monthly price of your container service, multiply
        /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
        /// the service.</p>
        ///
        /// <p>Use the <code>GetContainerServicePowers</code> action to view the specifications of each
        /// power option.</p>
        pub fn power(mut self, input: crate::model::ContainerServicePowerName) -> Self {
            self.power = Some(input);
            self
        }
        /// <p>The power for the container service.</p>
        ///
        /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
        /// container service. The <code>power</code> and <code>scale</code> of a container service makes
        /// up its configured capacity. To determine the monthly price of your container service, multiply
        /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
        /// the service.</p>
        ///
        /// <p>Use the <code>GetContainerServicePowers</code> action to view the specifications of each
        /// power option.</p>
        pub fn set_power(
            mut self,
            input: std::option::Option<crate::model::ContainerServicePowerName>,
        ) -> Self {
            self.power = input;
            self
        }
        /// <p>The scale for the container service.</p>
        ///
        /// <p>The scale specifies the allocated compute nodes of the container service. The
        /// <code>power</code> and <code>scale</code> of a container service makes up its configured
        /// capacity. To determine the monthly price of your container service, multiply the base price of
        /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
        /// service.</p>
        pub fn scale(mut self, input: i32) -> Self {
            self.scale = Some(input);
            self
        }
        /// <p>The scale for the container service.</p>
        ///
        /// <p>The scale specifies the allocated compute nodes of the container service. The
        /// <code>power</code> and <code>scale</code> of a container service makes up its configured
        /// capacity. To determine the monthly price of your container service, multiply the base price of
        /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
        /// service.</p>
        pub fn set_scale(mut self, input: std::option::Option<i32>) -> Self {
            self.scale = input;
            self
        }
        /// <p>A Boolean value to indicate whether the container service is disabled.</p>
        pub fn is_disabled(mut self, input: bool) -> Self {
            self.is_disabled = Some(input);
            self
        }
        /// <p>A Boolean value to indicate whether the container service is disabled.</p>
        pub fn set_is_disabled(mut self, input: std::option::Option<bool>) -> Self {
            self.is_disabled = input;
            self
        }
        /// Adds a key-value pair to `public_domain_names`.
        ///
        /// To override the contents of this collection use [`set_public_domain_names`](Self::set_public_domain_names).
        ///
        /// <p>The public domain names to use with the container service, such as
        /// <code>example.com</code> and <code>www.example.com</code>.</p>
        ///
        /// <p>You can specify up to four public domain names for a container service. The domain names
        /// that you specify are used when you create a deployment with a container configured as the
        /// public endpoint of your container service.</p>
        ///
        /// <p>If you don't specify public domain names, then you can use the default domain of the
        /// container service.</p>
        ///
        /// <important>
        /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
        /// names with your container service. Use the <code>CreateCertificate</code> action to create a
        /// certificate for the public domain names you want to use with your container service.</p>
        /// </important>
        ///
        /// <p>You can specify public domain names using a string to array map as shown in the example
        /// later on this page.</p>
        pub fn public_domain_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.public_domain_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.public_domain_names = Some(hash_map);
            self
        }
        /// <p>The public domain names to use with the container service, such as
        /// <code>example.com</code> and <code>www.example.com</code>.</p>
        ///
        /// <p>You can specify up to four public domain names for a container service. The domain names
        /// that you specify are used when you create a deployment with a container configured as the
        /// public endpoint of your container service.</p>
        ///
        /// <p>If you don't specify public domain names, then you can use the default domain of the
        /// container service.</p>
        ///
        /// <important>
        /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
        /// names with your container service. Use the <code>CreateCertificate</code> action to create a
        /// certificate for the public domain names you want to use with your container service.</p>
        /// </important>
        ///
        /// <p>You can specify public domain names using a string to array map as shown in the example
        /// later on this page.</p>
        pub fn set_public_domain_names(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.public_domain_names = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateContainerServiceInput`](crate::input::UpdateContainerServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateContainerServiceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateContainerServiceInput {
                service_name: self.service_name,
                power: self.power,
                scale: self.scale,
                is_disabled: self.is_disabled,
                public_domain_names: self.public_domain_names,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateContainerServiceInputOperationOutputAlias = crate::operation::UpdateContainerService;
#[doc(hidden)]
pub type UpdateContainerServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateContainerServiceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateContainerService`](crate::operation::UpdateContainerService)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateContainerService,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateContainerServiceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateContainerServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateContainerServiceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateContainerService",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_container_service(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateContainerService::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateContainerService",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateContainerServiceInput`](crate::input::UpdateContainerServiceInput)
    pub fn builder() -> crate::input::update_container_service_input::Builder {
        crate::input::update_container_service_input::Builder::default()
    }
}

/// See [`UpdateDistributionInput`](crate::input::UpdateDistributionInput)
pub mod update_distribution_input {
    /// A builder for [`UpdateDistributionInput`](crate::input::UpdateDistributionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
        pub(crate) origin: std::option::Option<crate::model::InputOrigin>,
        pub(crate) default_cache_behavior: std::option::Option<crate::model::CacheBehavior>,
        pub(crate) cache_behavior_settings: std::option::Option<crate::model::CacheSettings>,
        pub(crate) cache_behaviors:
            std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
        pub(crate) is_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the distribution to update.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution to update.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
        /// instance or load balancer.</p>
        /// <p>The distribution pulls, caches, and serves content from the origin.</p>
        pub fn origin(mut self, input: crate::model::InputOrigin) -> Self {
            self.origin = Some(input);
            self
        }
        /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
        /// instance or load balancer.</p>
        /// <p>The distribution pulls, caches, and serves content from the origin.</p>
        pub fn set_origin(mut self, input: std::option::Option<crate::model::InputOrigin>) -> Self {
            self.origin = input;
            self
        }
        /// <p>An object that describes the default cache behavior for the distribution.</p>
        pub fn default_cache_behavior(mut self, input: crate::model::CacheBehavior) -> Self {
            self.default_cache_behavior = Some(input);
            self
        }
        /// <p>An object that describes the default cache behavior for the distribution.</p>
        pub fn set_default_cache_behavior(
            mut self,
            input: std::option::Option<crate::model::CacheBehavior>,
        ) -> Self {
            self.default_cache_behavior = input;
            self
        }
        /// <p>An object that describes the cache behavior settings for the distribution.</p>
        /// <note>
        /// <p>The <code>cacheBehaviorSettings</code> specified in your
        /// <code>UpdateDistributionRequest</code> will replace your distribution's existing
        /// settings.</p>
        /// </note>
        pub fn cache_behavior_settings(mut self, input: crate::model::CacheSettings) -> Self {
            self.cache_behavior_settings = Some(input);
            self
        }
        /// <p>An object that describes the cache behavior settings for the distribution.</p>
        /// <note>
        /// <p>The <code>cacheBehaviorSettings</code> specified in your
        /// <code>UpdateDistributionRequest</code> will replace your distribution's existing
        /// settings.</p>
        /// </note>
        pub fn set_cache_behavior_settings(
            mut self,
            input: std::option::Option<crate::model::CacheSettings>,
        ) -> Self {
            self.cache_behavior_settings = input;
            self
        }
        /// Appends an item to `cache_behaviors`.
        ///
        /// To override the contents of this collection use [`set_cache_behaviors`](Self::set_cache_behaviors).
        ///
        /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
        pub fn cache_behaviors(
            mut self,
            input: impl Into<crate::model::CacheBehaviorPerPath>,
        ) -> Self {
            let mut v = self.cache_behaviors.unwrap_or_default();
            v.push(input.into());
            self.cache_behaviors = Some(v);
            self
        }
        /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
        pub fn set_cache_behaviors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
        ) -> Self {
            self.cache_behaviors = input;
            self
        }
        /// <p>Indicates whether to enable the distribution.</p>
        pub fn is_enabled(mut self, input: bool) -> Self {
            self.is_enabled = Some(input);
            self
        }
        /// <p>Indicates whether to enable the distribution.</p>
        pub fn set_is_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.is_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDistributionInput`](crate::input::UpdateDistributionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDistributionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDistributionInput {
                distribution_name: self.distribution_name,
                origin: self.origin,
                default_cache_behavior: self.default_cache_behavior,
                cache_behavior_settings: self.cache_behavior_settings,
                cache_behaviors: self.cache_behaviors,
                is_enabled: self.is_enabled,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDistributionInputOperationOutputAlias = crate::operation::UpdateDistribution;
#[doc(hidden)]
pub type UpdateDistributionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateDistributionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDistribution`](crate::operation::UpdateDistribution)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDistribution,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateDistributionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateDistributionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateDistributionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateDistribution",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_distribution(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDistribution::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDistribution",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateDistributionInput`](crate::input::UpdateDistributionInput)
    pub fn builder() -> crate::input::update_distribution_input::Builder {
        crate::input::update_distribution_input::Builder::default()
    }
}

/// See [`UpdateDistributionBundleInput`](crate::input::UpdateDistributionBundleInput)
pub mod update_distribution_bundle_input {
    /// A builder for [`UpdateDistributionBundleInput`](crate::input::UpdateDistributionBundleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) distribution_name: std::option::Option<std::string::String>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the distribution for which to update the bundle.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn distribution_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.distribution_name = Some(input.into());
            self
        }
        /// <p>The name of the distribution for which to update the bundle.</p>
        /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
        /// can specify.</p>
        pub fn set_distribution_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.distribution_name = input;
            self
        }
        /// <p>The bundle ID of the new bundle to apply to your distribution.</p>
        /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
        /// IDs that you can specify.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle ID of the new bundle to apply to your distribution.</p>
        /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
        /// IDs that you can specify.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDistributionBundleInput`](crate::input::UpdateDistributionBundleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDistributionBundleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDistributionBundleInput {
                distribution_name: self.distribution_name,
                bundle_id: self.bundle_id,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDistributionBundleInputOperationOutputAlias =
    crate::operation::UpdateDistributionBundle;
#[doc(hidden)]
pub type UpdateDistributionBundleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateDistributionBundleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDistributionBundle`](crate::operation::UpdateDistributionBundle)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDistributionBundle,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateDistributionBundleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateDistributionBundleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateDistributionBundleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateDistributionBundle",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_distribution_bundle(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDistributionBundle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDistributionBundle",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateDistributionBundleInput`](crate::input::UpdateDistributionBundleInput)
    pub fn builder() -> crate::input::update_distribution_bundle_input::Builder {
        crate::input::update_distribution_bundle_input::Builder::default()
    }
}

/// See [`UpdateDomainEntryInput`](crate::input::UpdateDomainEntryInput)
pub mod update_domain_entry_input {
    /// A builder for [`UpdateDomainEntryInput`](crate::input::UpdateDomainEntryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) domain_entry: std::option::Option<crate::model::DomainEntry>,
    }
    impl Builder {
        /// <p>The name of the domain recordset to update.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The name of the domain recordset to update.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>An array of key-value pairs containing information about the domain entry.</p>
        pub fn domain_entry(mut self, input: crate::model::DomainEntry) -> Self {
            self.domain_entry = Some(input);
            self
        }
        /// <p>An array of key-value pairs containing information about the domain entry.</p>
        pub fn set_domain_entry(
            mut self,
            input: std::option::Option<crate::model::DomainEntry>,
        ) -> Self {
            self.domain_entry = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDomainEntryInput`](crate::input::UpdateDomainEntryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDomainEntryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDomainEntryInput {
                domain_name: self.domain_name,
                domain_entry: self.domain_entry,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDomainEntryInputOperationOutputAlias = crate::operation::UpdateDomainEntry;
#[doc(hidden)]
pub type UpdateDomainEntryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateDomainEntryInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDomainEntry`](crate::operation::UpdateDomainEntry)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDomainEntry,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateDomainEntryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateDomainEntryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateDomainEntryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateDomainEntry",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_domain_entry(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDomainEntry::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDomainEntry",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateDomainEntryInput`](crate::input::UpdateDomainEntryInput)
    pub fn builder() -> crate::input::update_domain_entry_input::Builder {
        crate::input::update_domain_entry_input::Builder::default()
    }
}

/// See [`UpdateLoadBalancerAttributeInput`](crate::input::UpdateLoadBalancerAttributeInput)
pub mod update_load_balancer_attribute_input {
    /// A builder for [`UpdateLoadBalancerAttributeInput`](crate::input::UpdateLoadBalancerAttributeInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) attribute_name: std::option::Option<crate::model::LoadBalancerAttributeName>,
        pub(crate) attribute_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer that you want to modify (e.g.,
        /// <code>my-load-balancer</code>.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        /// <p>The name of the load balancer that you want to modify (e.g.,
        /// <code>my-load-balancer</code>.</p>
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>The name of the attribute you want to update. Valid values are below.</p>
        pub fn attribute_name(mut self, input: crate::model::LoadBalancerAttributeName) -> Self {
            self.attribute_name = Some(input);
            self
        }
        /// <p>The name of the attribute you want to update. Valid values are below.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerAttributeName>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// <p>The value that you want to specify for the attribute name.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_value = Some(input.into());
            self
        }
        /// <p>The value that you want to specify for the attribute name.</p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLoadBalancerAttributeInput`](crate::input::UpdateLoadBalancerAttributeInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateLoadBalancerAttributeInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateLoadBalancerAttributeInput {
                load_balancer_name: self.load_balancer_name,
                attribute_name: self.attribute_name,
                attribute_value: self.attribute_value,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateLoadBalancerAttributeInputOperationOutputAlias =
    crate::operation::UpdateLoadBalancerAttribute;
#[doc(hidden)]
pub type UpdateLoadBalancerAttributeInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateLoadBalancerAttributeInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLoadBalancerAttribute`](crate::operation::UpdateLoadBalancerAttribute)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateLoadBalancerAttribute,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateLoadBalancerAttributeInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateLoadBalancerAttributeInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateLoadBalancerAttributeInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateLoadBalancerAttribute",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_load_balancer_attribute(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateLoadBalancerAttribute::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateLoadBalancerAttribute",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateLoadBalancerAttributeInput`](crate::input::UpdateLoadBalancerAttributeInput)
    pub fn builder() -> crate::input::update_load_balancer_attribute_input::Builder {
        crate::input::update_load_balancer_attribute_input::Builder::default()
    }
}

/// See [`UpdateRelationalDatabaseInput`](crate::input::UpdateRelationalDatabaseInput)
pub mod update_relational_database_input {
    /// A builder for [`UpdateRelationalDatabaseInput`](crate::input::UpdateRelationalDatabaseInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) master_user_password: std::option::Option<std::string::String>,
        pub(crate) rotate_master_user_password: std::option::Option<bool>,
        pub(crate) preferred_backup_window: std::option::Option<std::string::String>,
        pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
        pub(crate) enable_backup_retention: std::option::Option<bool>,
        pub(crate) disable_backup_retention: std::option::Option<bool>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) apply_immediately: std::option::Option<bool>,
        pub(crate) ca_certificate_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of your Lightsail database resource to update.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your Lightsail database resource to update.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// <p>The password for the master user. The password can include any printable ASCII character
        /// except "/", """, or "@".</p>
        /// <p>My<b>SQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 41 characters.</p>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 128 characters.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The password for the master user. The password can include any printable ASCII character
        /// except "/", """, or "@".</p>
        /// <p>My<b>SQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 41 characters.</p>
        /// <p>
        /// <b>PostgreSQL</b>
        /// </p>
        /// <p>Constraints: Must contain from 8 to 128 characters.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// <p>When <code>true</code>, the master user password is changed to a new strong password
        /// generated by Lightsail.</p>
        /// <p>Use the <code>get relational database master user password</code> operation to get the new
        /// password.</p>
        pub fn rotate_master_user_password(mut self, input: bool) -> Self {
            self.rotate_master_user_password = Some(input);
            self
        }
        /// <p>When <code>true</code>, the master user password is changed to a new strong password
        /// generated by Lightsail.</p>
        /// <p>Use the <code>get relational database master user password</code> operation to get the new
        /// password.</p>
        pub fn set_rotate_master_user_password(mut self, input: std::option::Option<bool>) -> Self {
            self.rotate_master_user_password = input;
            self
        }
        /// <p>The daily time range during which automated backups are created for your database if
        /// automated backups are enabled.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
        /// <p>Example: <code>16:00-16:30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Must not conflict with the preferred maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// </ul>
        pub fn preferred_backup_window(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_backup_window = Some(input.into());
            self
        }
        /// <p>The daily time range during which automated backups are created for your database if
        /// automated backups are enabled.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
        /// <p>Example: <code>16:00-16:30</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Must not conflict with the preferred maintenance window.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// </ul>
        pub fn set_preferred_backup_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_backup_window = input;
            self
        }
        /// <p>The weekly time range during which system maintenance can occur on your database.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region, occurring on a random day of the week.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
        /// </li>
        /// <li>
        /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = Some(input.into());
            self
        }
        /// <p>The weekly time range during which system maintenance can occur on your database.</p>
        /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
        /// AWS Region, occurring on a random day of the week.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
        /// </li>
        /// <li>
        /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
        /// </li>
        /// <li>
        /// <p>Must be at least 30 minutes.</p>
        /// </li>
        /// <li>
        /// <p>Specified in Coordinated Universal Time (UTC).</p>
        /// </li>
        /// <li>
        /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = input;
            self
        }
        /// <p>When <code>true</code>, enables automated backup retention for your database.</p>
        /// <p>Updates are applied during the next maintenance window because this can result in an
        /// outage.</p>
        pub fn enable_backup_retention(mut self, input: bool) -> Self {
            self.enable_backup_retention = Some(input);
            self
        }
        /// <p>When <code>true</code>, enables automated backup retention for your database.</p>
        /// <p>Updates are applied during the next maintenance window because this can result in an
        /// outage.</p>
        pub fn set_enable_backup_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_backup_retention = input;
            self
        }
        /// <p>When <code>true</code>, disables automated backup retention for your database.</p>
        /// <p>Disabling backup retention deletes all automated database backups. Before disabling this,
        /// you may want to create a snapshot of your database using the <code>create relational database
        /// snapshot</code> operation.</p>
        /// <p>Updates are applied during the next maintenance window because this can result in an
        /// outage.</p>
        pub fn disable_backup_retention(mut self, input: bool) -> Self {
            self.disable_backup_retention = Some(input);
            self
        }
        /// <p>When <code>true</code>, disables automated backup retention for your database.</p>
        /// <p>Disabling backup retention deletes all automated database backups. Before disabling this,
        /// you may want to create a snapshot of your database using the <code>create relational database
        /// snapshot</code> operation.</p>
        /// <p>Updates are applied during the next maintenance window because this can result in an
        /// outage.</p>
        pub fn set_disable_backup_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_backup_retention = input;
            self
        }
        /// <p>Specifies the accessibility options for your database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>Specifies the accessibility options for your database. A value of <code>true</code>
        /// specifies a database that is available to resources outside of your Lightsail account. A
        /// value of <code>false</code> specifies a database that is available only to your Lightsail
        /// resources in the same region as your database.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>When <code>true</code>, applies changes immediately. When <code>false</code>, applies
        /// changes during the preferred maintenance window. Some changes may cause an outage.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn apply_immediately(mut self, input: bool) -> Self {
            self.apply_immediately = Some(input);
            self
        }
        /// <p>When <code>true</code>, applies changes immediately. When <code>false</code>, applies
        /// changes during the preferred maintenance window. Some changes may cause an outage.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn set_apply_immediately(mut self, input: std::option::Option<bool>) -> Self {
            self.apply_immediately = input;
            self
        }
        /// <p>Indicates the certificate that needs to be associated with the database.</p>
        pub fn ca_certificate_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.ca_certificate_identifier = Some(input.into());
            self
        }
        /// <p>Indicates the certificate that needs to be associated with the database.</p>
        pub fn set_ca_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ca_certificate_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRelationalDatabaseInput`](crate::input::UpdateRelationalDatabaseInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRelationalDatabaseInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRelationalDatabaseInput {
                relational_database_name: self.relational_database_name,
                master_user_password: self.master_user_password,
                rotate_master_user_password: self.rotate_master_user_password,
                preferred_backup_window: self.preferred_backup_window,
                preferred_maintenance_window: self.preferred_maintenance_window,
                enable_backup_retention: self.enable_backup_retention,
                disable_backup_retention: self.disable_backup_retention,
                publicly_accessible: self.publicly_accessible,
                apply_immediately: self.apply_immediately,
                ca_certificate_identifier: self.ca_certificate_identifier,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRelationalDatabaseInputOperationOutputAlias =
    crate::operation::UpdateRelationalDatabase;
#[doc(hidden)]
pub type UpdateRelationalDatabaseInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRelationalDatabaseInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRelationalDatabase`](crate::operation::UpdateRelationalDatabase)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRelationalDatabase,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateRelationalDatabaseInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateRelationalDatabaseInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateRelationalDatabaseInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateRelationalDatabase",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_relational_database(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRelationalDatabase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRelationalDatabase",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRelationalDatabaseInput`](crate::input::UpdateRelationalDatabaseInput)
    pub fn builder() -> crate::input::update_relational_database_input::Builder {
        crate::input::update_relational_database_input::Builder::default()
    }
}

/// See [`UpdateRelationalDatabaseParametersInput`](crate::input::UpdateRelationalDatabaseParametersInput)
pub mod update_relational_database_parameters_input {
    /// A builder for [`UpdateRelationalDatabaseParametersInput`](crate::input::UpdateRelationalDatabaseParametersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) relational_database_name: std::option::Option<std::string::String>,
        pub(crate) parameters:
            std::option::Option<std::vec::Vec<crate::model::RelationalDatabaseParameter>>,
    }
    impl Builder {
        /// <p>The name of your database for which to update parameters.</p>
        pub fn relational_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relational_database_name = Some(input.into());
            self
        }
        /// <p>The name of your database for which to update parameters.</p>
        pub fn set_relational_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relational_database_name = input;
            self
        }
        /// Appends an item to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>The database parameters to update.</p>
        pub fn parameters(
            mut self,
            input: impl Into<crate::model::RelationalDatabaseParameter>,
        ) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(input.into());
            self.parameters = Some(v);
            self
        }
        /// <p>The database parameters to update.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelationalDatabaseParameter>>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRelationalDatabaseParametersInput`](crate::input::UpdateRelationalDatabaseParametersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateRelationalDatabaseParametersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateRelationalDatabaseParametersInput {
                relational_database_name: self.relational_database_name,
                parameters: self.parameters,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateRelationalDatabaseParametersInputOperationOutputAlias =
    crate::operation::UpdateRelationalDatabaseParameters;
#[doc(hidden)]
pub type UpdateRelationalDatabaseParametersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateRelationalDatabaseParametersInput {
    /// Consumes the builder and constructs an Operation<[`UpdateRelationalDatabaseParameters`](crate::operation::UpdateRelationalDatabaseParameters)>
    #[allow(clippy::let_and_return)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateRelationalDatabaseParameters,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateRelationalDatabaseParametersInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateRelationalDatabaseParametersInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateRelationalDatabaseParametersInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Lightsail_20161128.UpdateRelationalDatabaseParameters",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_relational_database_parameters(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateRelationalDatabaseParameters::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateRelationalDatabaseParameters",
            "lightsail",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateRelationalDatabaseParametersInput`](crate::input::UpdateRelationalDatabaseParametersInput)
    pub fn builder() -> crate::input::update_relational_database_parameters_input::Builder {
        crate::input::update_relational_database_parameters_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRelationalDatabaseParametersInput {
    /// <p>The name of your database for which to update parameters.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The database parameters to update.</p>
    pub parameters: std::option::Option<std::vec::Vec<crate::model::RelationalDatabaseParameter>>,
}
impl UpdateRelationalDatabaseParametersInput {
    /// <p>The name of your database for which to update parameters.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The database parameters to update.</p>
    pub fn parameters(&self) -> std::option::Option<&[crate::model::RelationalDatabaseParameter]> {
        self.parameters.as_deref()
    }
}
impl std::fmt::Debug for UpdateRelationalDatabaseParametersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRelationalDatabaseParametersInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRelationalDatabaseInput {
    /// <p>The name of your Lightsail database resource to update.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The password for the master user. The password can include any printable ASCII character
    /// except "/", """, or "@".</p>
    /// <p>My<b>SQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 41 characters.</p>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 128 characters.</p>
    pub master_user_password: std::option::Option<std::string::String>,
    /// <p>When <code>true</code>, the master user password is changed to a new strong password
    /// generated by Lightsail.</p>
    /// <p>Use the <code>get relational database master user password</code> operation to get the new
    /// password.</p>
    pub rotate_master_user_password: std::option::Option<bool>,
    /// <p>The daily time range during which automated backups are created for your database if
    /// automated backups are enabled.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
    /// <p>Example: <code>16:00-16:30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Must not conflict with the preferred maintenance window.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// </ul>
    pub preferred_backup_window: std::option::Option<std::string::String>,
    /// <p>The weekly time range during which system maintenance can occur on your database.</p>
    /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    /// AWS Region, occurring on a random day of the week.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
    /// </li>
    /// <li>
    /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
    /// </p>
    /// </li>
    /// </ul>
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>When <code>true</code>, enables automated backup retention for your database.</p>
    /// <p>Updates are applied during the next maintenance window because this can result in an
    /// outage.</p>
    pub enable_backup_retention: std::option::Option<bool>,
    /// <p>When <code>true</code>, disables automated backup retention for your database.</p>
    /// <p>Disabling backup retention deletes all automated database backups. Before disabling this,
    /// you may want to create a snapshot of your database using the <code>create relational database
    /// snapshot</code> operation.</p>
    /// <p>Updates are applied during the next maintenance window because this can result in an
    /// outage.</p>
    pub disable_backup_retention: std::option::Option<bool>,
    /// <p>Specifies the accessibility options for your database. A value of <code>true</code>
    /// specifies a database that is available to resources outside of your Lightsail account. A
    /// value of <code>false</code> specifies a database that is available only to your Lightsail
    /// resources in the same region as your database.</p>
    pub publicly_accessible: std::option::Option<bool>,
    /// <p>When <code>true</code>, applies changes immediately. When <code>false</code>, applies
    /// changes during the preferred maintenance window. Some changes may cause an outage.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub apply_immediately: std::option::Option<bool>,
    /// <p>Indicates the certificate that needs to be associated with the database.</p>
    pub ca_certificate_identifier: std::option::Option<std::string::String>,
}
impl UpdateRelationalDatabaseInput {
    /// <p>The name of your Lightsail database resource to update.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The password for the master user. The password can include any printable ASCII character
    /// except "/", """, or "@".</p>
    /// <p>My<b>SQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 41 characters.</p>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 128 characters.</p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
    /// <p>When <code>true</code>, the master user password is changed to a new strong password
    /// generated by Lightsail.</p>
    /// <p>Use the <code>get relational database master user password</code> operation to get the new
    /// password.</p>
    pub fn rotate_master_user_password(&self) -> std::option::Option<bool> {
        self.rotate_master_user_password
    }
    /// <p>The daily time range during which automated backups are created for your database if
    /// automated backups are enabled.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
    /// <p>Example: <code>16:00-16:30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Must not conflict with the preferred maintenance window.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// </ul>
    pub fn preferred_backup_window(&self) -> std::option::Option<&str> {
        self.preferred_backup_window.as_deref()
    }
    /// <p>The weekly time range during which system maintenance can occur on your database.</p>
    /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    /// AWS Region, occurring on a random day of the week.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
    /// </li>
    /// <li>
    /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
    /// </p>
    /// </li>
    /// </ul>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>When <code>true</code>, enables automated backup retention for your database.</p>
    /// <p>Updates are applied during the next maintenance window because this can result in an
    /// outage.</p>
    pub fn enable_backup_retention(&self) -> std::option::Option<bool> {
        self.enable_backup_retention
    }
    /// <p>When <code>true</code>, disables automated backup retention for your database.</p>
    /// <p>Disabling backup retention deletes all automated database backups. Before disabling this,
    /// you may want to create a snapshot of your database using the <code>create relational database
    /// snapshot</code> operation.</p>
    /// <p>Updates are applied during the next maintenance window because this can result in an
    /// outage.</p>
    pub fn disable_backup_retention(&self) -> std::option::Option<bool> {
        self.disable_backup_retention
    }
    /// <p>Specifies the accessibility options for your database. A value of <code>true</code>
    /// specifies a database that is available to resources outside of your Lightsail account. A
    /// value of <code>false</code> specifies a database that is available only to your Lightsail
    /// resources in the same region as your database.</p>
    pub fn publicly_accessible(&self) -> std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>When <code>true</code>, applies changes immediately. When <code>false</code>, applies
    /// changes during the preferred maintenance window. Some changes may cause an outage.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub fn apply_immediately(&self) -> std::option::Option<bool> {
        self.apply_immediately
    }
    /// <p>Indicates the certificate that needs to be associated with the database.</p>
    pub fn ca_certificate_identifier(&self) -> std::option::Option<&str> {
        self.ca_certificate_identifier.as_deref()
    }
}
impl std::fmt::Debug for UpdateRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("master_user_password", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "rotate_master_user_password",
            &self.rotate_master_user_password,
        );
        formatter.field("preferred_backup_window", &self.preferred_backup_window);
        formatter.field(
            "preferred_maintenance_window",
            &self.preferred_maintenance_window,
        );
        formatter.field("enable_backup_retention", &self.enable_backup_retention);
        formatter.field("disable_backup_retention", &self.disable_backup_retention);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("apply_immediately", &self.apply_immediately);
        formatter.field("ca_certificate_identifier", &self.ca_certificate_identifier);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLoadBalancerAttributeInput {
    /// <p>The name of the load balancer that you want to modify (e.g.,
    /// <code>my-load-balancer</code>.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The name of the attribute you want to update. Valid values are below.</p>
    pub attribute_name: std::option::Option<crate::model::LoadBalancerAttributeName>,
    /// <p>The value that you want to specify for the attribute name.</p>
    pub attribute_value: std::option::Option<std::string::String>,
}
impl UpdateLoadBalancerAttributeInput {
    /// <p>The name of the load balancer that you want to modify (e.g.,
    /// <code>my-load-balancer</code>.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The name of the attribute you want to update. Valid values are below.</p>
    pub fn attribute_name(&self) -> std::option::Option<&crate::model::LoadBalancerAttributeName> {
        self.attribute_name.as_ref()
    }
    /// <p>The value that you want to specify for the attribute name.</p>
    pub fn attribute_value(&self) -> std::option::Option<&str> {
        self.attribute_value.as_deref()
    }
}
impl std::fmt::Debug for UpdateLoadBalancerAttributeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLoadBalancerAttributeInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("attribute_value", &self.attribute_value);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDomainEntryInput {
    /// <p>The name of the domain recordset to update.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs containing information about the domain entry.</p>
    pub domain_entry: std::option::Option<crate::model::DomainEntry>,
}
impl UpdateDomainEntryInput {
    /// <p>The name of the domain recordset to update.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>An array of key-value pairs containing information about the domain entry.</p>
    pub fn domain_entry(&self) -> std::option::Option<&crate::model::DomainEntry> {
        self.domain_entry.as_ref()
    }
}
impl std::fmt::Debug for UpdateDomainEntryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDomainEntryInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("domain_entry", &self.domain_entry);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDistributionBundleInput {
    /// <p>The name of the distribution for which to update the bundle.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
    /// <p>The bundle ID of the new bundle to apply to your distribution.</p>
    /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
    /// IDs that you can specify.</p>
    pub bundle_id: std::option::Option<std::string::String>,
}
impl UpdateDistributionBundleInput {
    /// <p>The name of the distribution for which to update the bundle.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
    /// <p>The bundle ID of the new bundle to apply to your distribution.</p>
    /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
    /// IDs that you can specify.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
}
impl std::fmt::Debug for UpdateDistributionBundleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDistributionBundleInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.field("bundle_id", &self.bundle_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDistributionInput {
    /// <p>The name of the distribution to update.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
    /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
    /// instance or load balancer.</p>
    /// <p>The distribution pulls, caches, and serves content from the origin.</p>
    pub origin: std::option::Option<crate::model::InputOrigin>,
    /// <p>An object that describes the default cache behavior for the distribution.</p>
    pub default_cache_behavior: std::option::Option<crate::model::CacheBehavior>,
    /// <p>An object that describes the cache behavior settings for the distribution.</p>
    /// <note>
    /// <p>The <code>cacheBehaviorSettings</code> specified in your
    /// <code>UpdateDistributionRequest</code> will replace your distribution's existing
    /// settings.</p>
    /// </note>
    pub cache_behavior_settings: std::option::Option<crate::model::CacheSettings>,
    /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
    pub cache_behaviors: std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
    /// <p>Indicates whether to enable the distribution.</p>
    pub is_enabled: std::option::Option<bool>,
}
impl UpdateDistributionInput {
    /// <p>The name of the distribution to update.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
    /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
    /// instance or load balancer.</p>
    /// <p>The distribution pulls, caches, and serves content from the origin.</p>
    pub fn origin(&self) -> std::option::Option<&crate::model::InputOrigin> {
        self.origin.as_ref()
    }
    /// <p>An object that describes the default cache behavior for the distribution.</p>
    pub fn default_cache_behavior(&self) -> std::option::Option<&crate::model::CacheBehavior> {
        self.default_cache_behavior.as_ref()
    }
    /// <p>An object that describes the cache behavior settings for the distribution.</p>
    /// <note>
    /// <p>The <code>cacheBehaviorSettings</code> specified in your
    /// <code>UpdateDistributionRequest</code> will replace your distribution's existing
    /// settings.</p>
    /// </note>
    pub fn cache_behavior_settings(&self) -> std::option::Option<&crate::model::CacheSettings> {
        self.cache_behavior_settings.as_ref()
    }
    /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
    pub fn cache_behaviors(&self) -> std::option::Option<&[crate::model::CacheBehaviorPerPath]> {
        self.cache_behaviors.as_deref()
    }
    /// <p>Indicates whether to enable the distribution.</p>
    pub fn is_enabled(&self) -> std::option::Option<bool> {
        self.is_enabled
    }
}
impl std::fmt::Debug for UpdateDistributionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDistributionInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.field("origin", &self.origin);
        formatter.field("default_cache_behavior", &self.default_cache_behavior);
        formatter.field("cache_behavior_settings", &self.cache_behavior_settings);
        formatter.field("cache_behaviors", &self.cache_behaviors);
        formatter.field("is_enabled", &self.is_enabled);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateContainerServiceInput {
    /// <p>The name of the container service to update.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The power for the container service.</p>
    ///
    /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
    /// container service. The <code>power</code> and <code>scale</code> of a container service makes
    /// up its configured capacity. To determine the monthly price of your container service, multiply
    /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
    /// the service.</p>
    ///
    /// <p>Use the <code>GetContainerServicePowers</code> action to view the specifications of each
    /// power option.</p>
    pub power: std::option::Option<crate::model::ContainerServicePowerName>,
    /// <p>The scale for the container service.</p>
    ///
    /// <p>The scale specifies the allocated compute nodes of the container service. The
    /// <code>power</code> and <code>scale</code> of a container service makes up its configured
    /// capacity. To determine the monthly price of your container service, multiply the base price of
    /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
    /// service.</p>
    pub scale: std::option::Option<i32>,
    /// <p>A Boolean value to indicate whether the container service is disabled.</p>
    pub is_disabled: std::option::Option<bool>,
    /// <p>The public domain names to use with the container service, such as
    /// <code>example.com</code> and <code>www.example.com</code>.</p>
    ///
    /// <p>You can specify up to four public domain names for a container service. The domain names
    /// that you specify are used when you create a deployment with a container configured as the
    /// public endpoint of your container service.</p>
    ///
    /// <p>If you don't specify public domain names, then you can use the default domain of the
    /// container service.</p>
    ///
    /// <important>
    /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
    /// names with your container service. Use the <code>CreateCertificate</code> action to create a
    /// certificate for the public domain names you want to use with your container service.</p>
    /// </important>
    ///
    /// <p>You can specify public domain names using a string to array map as shown in the example
    /// later on this page.</p>
    pub public_domain_names: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl UpdateContainerServiceInput {
    /// <p>The name of the container service to update.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The power for the container service.</p>
    ///
    /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
    /// container service. The <code>power</code> and <code>scale</code> of a container service makes
    /// up its configured capacity. To determine the monthly price of your container service, multiply
    /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
    /// the service.</p>
    ///
    /// <p>Use the <code>GetContainerServicePowers</code> action to view the specifications of each
    /// power option.</p>
    pub fn power(&self) -> std::option::Option<&crate::model::ContainerServicePowerName> {
        self.power.as_ref()
    }
    /// <p>The scale for the container service.</p>
    ///
    /// <p>The scale specifies the allocated compute nodes of the container service. The
    /// <code>power</code> and <code>scale</code> of a container service makes up its configured
    /// capacity. To determine the monthly price of your container service, multiply the base price of
    /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
    /// service.</p>
    pub fn scale(&self) -> std::option::Option<i32> {
        self.scale
    }
    /// <p>A Boolean value to indicate whether the container service is disabled.</p>
    pub fn is_disabled(&self) -> std::option::Option<bool> {
        self.is_disabled
    }
    /// <p>The public domain names to use with the container service, such as
    /// <code>example.com</code> and <code>www.example.com</code>.</p>
    ///
    /// <p>You can specify up to four public domain names for a container service. The domain names
    /// that you specify are used when you create a deployment with a container configured as the
    /// public endpoint of your container service.</p>
    ///
    /// <p>If you don't specify public domain names, then you can use the default domain of the
    /// container service.</p>
    ///
    /// <important>
    /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
    /// names with your container service. Use the <code>CreateCertificate</code> action to create a
    /// certificate for the public domain names you want to use with your container service.</p>
    /// </important>
    ///
    /// <p>You can specify public domain names using a string to array map as shown in the example
    /// later on this page.</p>
    pub fn public_domain_names(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.public_domain_names.as_ref()
    }
}
impl std::fmt::Debug for UpdateContainerServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateContainerServiceInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("power", &self.power);
        formatter.field("scale", &self.scale);
        formatter.field("is_disabled", &self.is_disabled);
        formatter.field("public_domain_names", &self.public_domain_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateBucketBundleInput {
    /// <p>The name of the bucket for which to update the bundle.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The ID of the new bundle to apply to the bucket.</p>
    ///
    /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
    /// specify.</p>
    pub bundle_id: std::option::Option<std::string::String>,
}
impl UpdateBucketBundleInput {
    /// <p>The name of the bucket for which to update the bundle.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The ID of the new bundle to apply to the bucket.</p>
    ///
    /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
    /// specify.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
}
impl std::fmt::Debug for UpdateBucketBundleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateBucketBundleInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("bundle_id", &self.bundle_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateBucketInput {
    /// <p>The name of the bucket to update.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>An object that sets the public accessibility of objects in the specified bucket.</p>
    pub access_rules: std::option::Option<crate::model::AccessRules>,
    /// <p>Specifies whether to enable or suspend versioning of objects in the bucket.</p>
    ///
    /// <p>The following options can be specified:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Enabled</code> - Enables versioning of objects in the specified bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Suspended</code> - Suspends versioning of objects in the specified bucket.
    /// Existing object versions are retained.</p>
    /// </li>
    /// </ul>
    pub versioning: std::option::Option<std::string::String>,
    /// <p>An array of strings to specify the AWS account IDs that can access the bucket.</p>
    ///
    /// <p>You can give a maximum of 10 AWS accounts access to a bucket.</p>
    pub readonly_access_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An object that describes the access log configuration for the bucket.</p>
    pub access_log_config: std::option::Option<crate::model::BucketAccessLogConfig>,
}
impl UpdateBucketInput {
    /// <p>The name of the bucket to update.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>An object that sets the public accessibility of objects in the specified bucket.</p>
    pub fn access_rules(&self) -> std::option::Option<&crate::model::AccessRules> {
        self.access_rules.as_ref()
    }
    /// <p>Specifies whether to enable or suspend versioning of objects in the bucket.</p>
    ///
    /// <p>The following options can be specified:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Enabled</code> - Enables versioning of objects in the specified bucket.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Suspended</code> - Suspends versioning of objects in the specified bucket.
    /// Existing object versions are retained.</p>
    /// </li>
    /// </ul>
    pub fn versioning(&self) -> std::option::Option<&str> {
        self.versioning.as_deref()
    }
    /// <p>An array of strings to specify the AWS account IDs that can access the bucket.</p>
    ///
    /// <p>You can give a maximum of 10 AWS accounts access to a bucket.</p>
    pub fn readonly_access_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.readonly_access_accounts.as_deref()
    }
    /// <p>An object that describes the access log configuration for the bucket.</p>
    pub fn access_log_config(&self) -> std::option::Option<&crate::model::BucketAccessLogConfig> {
        self.access_log_config.as_ref()
    }
}
impl std::fmt::Debug for UpdateBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateBucketInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("access_rules", &self.access_rules);
        formatter.field("versioning", &self.versioning);
        formatter.field("readonly_access_accounts", &self.readonly_access_accounts);
        formatter.field("access_log_config", &self.access_log_config);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The name of the resource from which you are removing a tag.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove a tag.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag keys to delete from the specified resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The name of the resource from which you are removing a tag.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource from which you want to remove a tag.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag keys to delete from the specified resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnpeerVpcInput {}
impl std::fmt::Debug for UnpeerVpcInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnpeerVpcInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestAlarmInput {
    /// <p>The name of the alarm to test.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The alarm state to test.</p>
    /// <p>An alarm has the following possible states that can be tested:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
    /// available, or not enough data is available for the metric to determine the alarm
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OK</code> - The metric is within the defined threshold.</p>
    /// </li>
    /// </ul>
    pub state: std::option::Option<crate::model::AlarmState>,
}
impl TestAlarmInput {
    /// <p>The name of the alarm to test.</p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>The alarm state to test.</p>
    /// <p>An alarm has the following possible states that can be tested:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
    /// available, or not enough data is available for the metric to determine the alarm
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OK</code> - The metric is within the defined threshold.</p>
    /// </li>
    /// </ul>
    pub fn state(&self) -> std::option::Option<&crate::model::AlarmState> {
        self.state.as_ref()
    }
}
impl std::fmt::Debug for TestAlarmInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestAlarmInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The name of the resource to which you are adding tags.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add a tag.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag key and optional value.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The name of the resource to which you are adding tags.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add a tag.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag key and optional value.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopRelationalDatabaseInput {
    /// <p>The name of your database to stop.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The name of your new database snapshot to be created before stopping your database.</p>
    pub relational_database_snapshot_name: std::option::Option<std::string::String>,
}
impl StopRelationalDatabaseInput {
    /// <p>The name of your database to stop.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The name of your new database snapshot to be created before stopping your database.</p>
    pub fn relational_database_snapshot_name(&self) -> std::option::Option<&str> {
        self.relational_database_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for StopRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field(
            "relational_database_snapshot_name",
            &self.relational_database_snapshot_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopInstanceInput {
    /// <p>The name of the instance (a virtual private server) to stop.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>When set to <code>True</code>, forces a Lightsail instance that is stuck in a
    /// <code>stopping</code> state to stop.</p>
    /// <important>
    /// <p>Only use the <code>force</code> parameter if your instance is stuck in the
    /// <code>stopping</code> state. In any other state, your instance should stop normally
    /// without adding this parameter to your API request.</p>
    /// </important>
    pub force: std::option::Option<bool>,
}
impl StopInstanceInput {
    /// <p>The name of the instance (a virtual private server) to stop.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>When set to <code>True</code>, forces a Lightsail instance that is stuck in a
    /// <code>stopping</code> state to stop.</p>
    /// <important>
    /// <p>Only use the <code>force</code> parameter if your instance is stuck in the
    /// <code>stopping</code> state. In any other state, your instance should stop normally
    /// without adding this parameter to your API request.</p>
    /// </important>
    pub fn force(&self) -> std::option::Option<bool> {
        self.force
    }
}
impl std::fmt::Debug for StopInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopInstanceInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.field("force", &self.force);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartRelationalDatabaseInput {
    /// <p>The name of your database to start.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
}
impl StartRelationalDatabaseInput {
    /// <p>The name of your database to start.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
}
impl std::fmt::Debug for StartRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartInstanceInput {
    /// <p>The name of the instance (a virtual private server) to start.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl StartInstanceInput {
    /// <p>The name of the instance (a virtual private server) to start.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for StartInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartInstanceInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetResourceAccessForBucketInput {
    /// <p>The name of the Lightsail instance for which to set bucket access. The instance must be
    /// in a running or stopped state.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The name of the bucket for which to set access to another Lightsail resource.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The access setting.</p>
    ///
    /// <p>The following access settings are available:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>allow</code> - Allows access to the bucket and its objects.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deny</code> - Denies access to the bucket and its objects. Use this setting to
    /// remove access for a resource previously set to <code>allow</code>.</p>
    /// </li>
    /// </ul>
    pub access: std::option::Option<crate::model::ResourceBucketAccess>,
}
impl SetResourceAccessForBucketInput {
    /// <p>The name of the Lightsail instance for which to set bucket access. The instance must be
    /// in a running or stopped state.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The name of the bucket for which to set access to another Lightsail resource.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The access setting.</p>
    ///
    /// <p>The following access settings are available:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>allow</code> - Allows access to the bucket and its objects.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deny</code> - Denies access to the bucket and its objects. Use this setting to
    /// remove access for a resource previously set to <code>allow</code>.</p>
    /// </li>
    /// </ul>
    pub fn access(&self) -> std::option::Option<&crate::model::ResourceBucketAccess> {
        self.access.as_ref()
    }
}
impl std::fmt::Debug for SetResourceAccessForBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetResourceAccessForBucketInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("access", &self.access);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetIpAddressTypeInput {
    /// <p>The resource type.</p>
    /// <p>The possible values are <code>Distribution</code>, <code>Instance</code>, and
    /// <code>LoadBalancer</code>.</p>
    /// <note>
    /// <p>Distribution-related APIs are available only in the N. Virginia (<code>us-east-1</code>)
    /// AWS Region. Set your AWS Region configuration to <code>us-east-1</code> to create, view,
    /// or edit distributions.</p>
    /// </note>
    pub resource_type: std::option::Option<crate::model::ResourceType>,
    /// <p>The name of the resource for which to set the IP address type.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The IP address type to set for the specified resource.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    pub ip_address_type: std::option::Option<crate::model::IpAddressType>,
}
impl SetIpAddressTypeInput {
    /// <p>The resource type.</p>
    /// <p>The possible values are <code>Distribution</code>, <code>Instance</code>, and
    /// <code>LoadBalancer</code>.</p>
    /// <note>
    /// <p>Distribution-related APIs are available only in the N. Virginia (<code>us-east-1</code>)
    /// AWS Region. Set your AWS Region configuration to <code>us-east-1</code> to create, view,
    /// or edit distributions.</p>
    /// </note>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The name of the resource for which to set the IP address type.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The IP address type to set for the specified resource.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    pub fn ip_address_type(&self) -> std::option::Option<&crate::model::IpAddressType> {
        self.ip_address_type.as_ref()
    }
}
impl std::fmt::Debug for SetIpAddressTypeInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetIpAddressTypeInput");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_name", &self.resource_name);
        formatter.field("ip_address_type", &self.ip_address_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendContactMethodVerificationInput {
    /// <p>The protocol to verify, such as <code>Email</code> or <code>SMS</code> (text
    /// messaging).</p>
    pub protocol: std::option::Option<crate::model::ContactMethodVerificationProtocol>,
}
impl SendContactMethodVerificationInput {
    /// <p>The protocol to verify, such as <code>Email</code> or <code>SMS</code> (text
    /// messaging).</p>
    pub fn protocol(
        &self,
    ) -> std::option::Option<&crate::model::ContactMethodVerificationProtocol> {
        self.protocol.as_ref()
    }
}
impl std::fmt::Debug for SendContactMethodVerificationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendContactMethodVerificationInput");
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResetDistributionCacheInput {
    /// <p>The name of the distribution for which to reset cache.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
}
impl ResetDistributionCacheInput {
    /// <p>The name of the distribution for which to reset cache.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
}
impl std::fmt::Debug for ResetDistributionCacheInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResetDistributionCacheInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReleaseStaticIpInput {
    /// <p>The name of the static IP to delete.</p>
    pub static_ip_name: std::option::Option<std::string::String>,
}
impl ReleaseStaticIpInput {
    /// <p>The name of the static IP to delete.</p>
    pub fn static_ip_name(&self) -> std::option::Option<&str> {
        self.static_ip_name.as_deref()
    }
}
impl std::fmt::Debug for ReleaseStaticIpInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReleaseStaticIpInput");
        formatter.field("static_ip_name", &self.static_ip_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterContainerImageInput {
    /// <p>The name of the container service for which to register a container image.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The label for the container image when it's registered to the container service.</p>
    ///
    /// <p>Use a descriptive label that you can use to track the different versions of your
    /// registered container images.</p>
    ///
    /// <p>Use the <code>GetContainerImages</code> action to return the container images registered
    /// to a Lightsail container service. The label is the <code><imagelabel></code> portion
    /// of the following image name example:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>:container-service-1.<imagelabel>.1</code>
    /// </p>
    /// </li>
    /// </ul>
    ///
    /// <p>If the name of your container service is <code>mycontainerservice</code>, and the label
    /// that you specify is <code>mystaticwebsite</code>, then the name of the registered container
    /// image will be <code>:mycontainerservice.mystaticwebsite.1</code>.</p>
    ///
    /// <p>The number at the end of these image name examples represents the version of the
    /// registered container image. If you push and register another container image to the same
    /// Lightsail container service, with the same label, then the version number for the new
    /// registered container image will be <code>2</code>. If you push and register another container
    /// image, the version number will be <code>3</code>, and so on.</p>
    pub label: std::option::Option<std::string::String>,
    /// <p>The digest of the container image to be registered.</p>
    pub digest: std::option::Option<std::string::String>,
}
impl RegisterContainerImageInput {
    /// <p>The name of the container service for which to register a container image.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The label for the container image when it's registered to the container service.</p>
    ///
    /// <p>Use a descriptive label that you can use to track the different versions of your
    /// registered container images.</p>
    ///
    /// <p>Use the <code>GetContainerImages</code> action to return the container images registered
    /// to a Lightsail container service. The label is the <code><imagelabel></code> portion
    /// of the following image name example:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>:container-service-1.<imagelabel>.1</code>
    /// </p>
    /// </li>
    /// </ul>
    ///
    /// <p>If the name of your container service is <code>mycontainerservice</code>, and the label
    /// that you specify is <code>mystaticwebsite</code>, then the name of the registered container
    /// image will be <code>:mycontainerservice.mystaticwebsite.1</code>.</p>
    ///
    /// <p>The number at the end of these image name examples represents the version of the
    /// registered container image. If you push and register another container image to the same
    /// Lightsail container service, with the same label, then the version number for the new
    /// registered container image will be <code>2</code>. If you push and register another container
    /// image, the version number will be <code>3</code>, and so on.</p>
    pub fn label(&self) -> std::option::Option<&str> {
        self.label.as_deref()
    }
    /// <p>The digest of the container image to be registered.</p>
    pub fn digest(&self) -> std::option::Option<&str> {
        self.digest.as_deref()
    }
}
impl std::fmt::Debug for RegisterContainerImageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterContainerImageInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("label", &self.label);
        formatter.field("digest", &self.digest);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RebootRelationalDatabaseInput {
    /// <p>The name of your database to reboot.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
}
impl RebootRelationalDatabaseInput {
    /// <p>The name of your database to reboot.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
}
impl std::fmt::Debug for RebootRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RebootRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RebootInstanceInput {
    /// <p>The name of the instance to reboot.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl RebootInstanceInput {
    /// <p>The name of the instance to reboot.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for RebootInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RebootInstanceInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutInstancePublicPortsInput {
    /// <p>An array of objects to describe the ports to open for the specified instance.</p>
    pub port_infos: std::option::Option<std::vec::Vec<crate::model::PortInfo>>,
    /// <p>The name of the instance for which to open ports.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl PutInstancePublicPortsInput {
    /// <p>An array of objects to describe the ports to open for the specified instance.</p>
    pub fn port_infos(&self) -> std::option::Option<&[crate::model::PortInfo]> {
        self.port_infos.as_deref()
    }
    /// <p>The name of the instance for which to open ports.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for PutInstancePublicPortsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutInstancePublicPortsInput");
        formatter.field("port_infos", &self.port_infos);
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAlarmInput {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the
    /// previous configuration of the alarm.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Instances</b>: <code>BurstCapacityPercentage</code>,
    /// <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>,
    /// <code>NetworkOut</code>, <code>StatusCheckFailed</code>,
    /// <code>StatusCheckFailed_Instance</code>, and
    /// <code>StatusCheckFailed_System</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Load balancers</b>:
    /// <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>,
    /// <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>,
    /// <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>,
    /// <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>,
    /// <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>,
    /// <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Relational databases</b>: <code>CPUUtilization</code>,
    /// <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>,
    /// <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and
    /// <code>NetworkTransmitThroughput</code>.</p>
    /// </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub metric_name: std::option::Option<crate::model::MetricName>,
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources
    /// that can currently be monitored by alarms.</p>
    pub monitored_resource_name: std::option::Option<std::string::String>,
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold.
    /// The specified statistic value is used as the first operand.</p>
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p>The value against which the specified statistic is compared.</p>
    pub threshold: std::option::Option<f64>,
    /// <p>The number of most recent periods over which data is compared to the specified threshold.
    /// If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the
    /// N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be
    /// breaching to trigger the alarm, this value specifies the rolling period of time in which data
    /// points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of
    /// 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation
    /// period of 288 (24 hours).</p>
    pub evaluation_periods: std::option::Option<i32>,
    /// <p>The number of data points that must be not within the specified threshold to trigger the
    /// alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>)
    /// is the M.</p>
    pub datapoints_to_alarm: std::option::Option<i32>,
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>breaching</code> - Assume the missing data is not within the threshold. Missing
    /// data counts towards the number of times the metric is not within the threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>notBreaching</code> - Assume the missing data is within the threshold. Missing
    /// data does not count towards the number of times the metric is not within the
    /// threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ignore</code> - Ignore the missing data. Maintains the current alarm
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>missing</code> - Missing data is treated as missing.</p>
    /// </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of
    /// <code>missing</code> is used.</p>
    pub treat_missing_data: std::option::Option<crate::model::TreatMissingData>,
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code>
    /// (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for
    /// the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified
    /// contact protocol is not configured in the AWS Region, or if notifications are not enabled
    /// for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an
    /// AWS Region.</p>
    pub contact_protocols: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
    /// available, or not enough data is available for the metric to determine the alarm
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OK</code> - The metric is within the defined threshold.</p>
    /// </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified.
    /// The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to
    /// the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li>
    /// <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the
    /// alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to
    /// an <code>OK</code> state. This can be thought of as an <i>all clear</i>
    /// alarm notification.</p>
    /// </li>
    /// <li>
    /// <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is
    /// sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to
    /// an <code>INSUFFICIENT_DATA</code> state.</p>
    /// </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this
    /// parameter.</p>
    pub notification_triggers: std::option::Option<std::vec::Vec<crate::model::AlarmState>>,
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub notification_enabled: std::option::Option<bool>,
}
impl PutAlarmInput {
    /// <p>The name for the alarm. Specify the name of an existing alarm to update, and overwrite the
    /// previous configuration of the alarm.</p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>The name of the metric to associate with the alarm.</p>
    /// <p>You can configure up to two alarms per metric.</p>
    /// <p>The following metrics are available for each resource type:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>Instances</b>: <code>BurstCapacityPercentage</code>,
    /// <code>BurstCapacityTime</code>, <code>CPUUtilization</code>, <code>NetworkIn</code>,
    /// <code>NetworkOut</code>, <code>StatusCheckFailed</code>,
    /// <code>StatusCheckFailed_Instance</code>, and
    /// <code>StatusCheckFailed_System</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Load balancers</b>:
    /// <code>ClientTLSNegotiationErrorCount</code>, <code>HealthyHostCount</code>,
    /// <code>UnhealthyHostCount</code>, <code>HTTPCode_LB_4XX_Count</code>,
    /// <code>HTTPCode_LB_5XX_Count</code>, <code>HTTPCode_Instance_2XX_Count</code>,
    /// <code>HTTPCode_Instance_3XX_Count</code>, <code>HTTPCode_Instance_4XX_Count</code>,
    /// <code>HTTPCode_Instance_5XX_Count</code>, <code>InstanceResponseTime</code>,
    /// <code>RejectedConnectionCount</code>, and <code>RequestCount</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>Relational databases</b>: <code>CPUUtilization</code>,
    /// <code>DatabaseConnections</code>, <code>DiskQueueDepth</code>,
    /// <code>FreeStorageSpace</code>, <code>NetworkReceiveThroughput</code>, and
    /// <code>NetworkTransmitThroughput</code>.</p>
    /// </li>
    /// </ul>
    /// <p>For more information about these metrics, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-resource-health-metrics#available-metrics">Metrics available in Lightsail</a>.</p>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::MetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The name of the Lightsail resource that will be monitored.</p>
    /// <p>Instances, load balancers, and relational databases are the only Lightsail resources
    /// that can currently be monitored by alarms.</p>
    pub fn monitored_resource_name(&self) -> std::option::Option<&str> {
        self.monitored_resource_name.as_deref()
    }
    /// <p>The arithmetic operation to use when comparing the specified statistic to the threshold.
    /// The specified statistic value is used as the first operand.</p>
    pub fn comparison_operator(&self) -> std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    /// <p>The value against which the specified statistic is compared.</p>
    pub fn threshold(&self) -> std::option::Option<f64> {
        self.threshold
    }
    /// <p>The number of most recent periods over which data is compared to the specified threshold.
    /// If you are setting an "M out of N" alarm, this value (<code>evaluationPeriods</code>) is the
    /// N.</p>
    /// <p>If you are setting an alarm that requires that a number of consecutive data points be
    /// breaching to trigger the alarm, this value specifies the rolling period of time in which data
    /// points are evaluated.</p>
    /// <p>Each evaluation period is five minutes long. For example, specify an evaluation period of
    /// 24 to evaluate a metric over a rolling period of two hours.</p>
    /// <p>You can specify a minimum valuation period of 1 (5 minutes), and a maximum evaluation
    /// period of 288 (24 hours).</p>
    pub fn evaluation_periods(&self) -> std::option::Option<i32> {
        self.evaluation_periods
    }
    /// <p>The number of data points that must be not within the specified threshold to trigger the
    /// alarm. If you are setting an "M out of N" alarm, this value (<code>datapointsToAlarm</code>)
    /// is the M.</p>
    pub fn datapoints_to_alarm(&self) -> std::option::Option<i32> {
        self.datapoints_to_alarm
    }
    /// <p>Sets how this alarm will handle missing data points.</p>
    /// <p>An alarm can treat missing data in the following ways:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>breaching</code> - Assume the missing data is not within the threshold. Missing
    /// data counts towards the number of times the metric is not within the threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>notBreaching</code> - Assume the missing data is within the threshold. Missing
    /// data does not count towards the number of times the metric is not within the
    /// threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ignore</code> - Ignore the missing data. Maintains the current alarm
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>missing</code> - Missing data is treated as missing.</p>
    /// </li>
    /// </ul>
    /// <p>If <code>treatMissingData</code> is not specified, the default behavior of
    /// <code>missing</code> is used.</p>
    pub fn treat_missing_data(&self) -> std::option::Option<&crate::model::TreatMissingData> {
        self.treat_missing_data.as_ref()
    }
    /// <p>The contact protocols to use for the alarm, such as <code>Email</code>, <code>SMS</code>
    /// (text messaging), or both.</p>
    /// <p>A notification is sent via the specified contact protocol if notifications are enabled for
    /// the alarm, and when the alarm is triggered.</p>
    /// <p>A notification is not sent if a contact protocol is not specified, if the specified
    /// contact protocol is not configured in the AWS Region, or if notifications are not enabled
    /// for the alarm using the <code>notificationEnabled</code> paramater.</p>
    /// <p>Use the <code>CreateContactMethod</code> action to configure a contact protocol in an
    /// AWS Region.</p>
    pub fn contact_protocols(&self) -> std::option::Option<&[crate::model::ContactProtocol]> {
        self.contact_protocols.as_deref()
    }
    /// <p>The alarm states that trigger a notification.</p>
    /// <p>An alarm has the following possible states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ALARM</code> - The metric is outside of the defined threshold.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INSUFFICIENT_DATA</code> - The alarm has just started, the metric is not
    /// available, or not enough data is available for the metric to determine the alarm
    /// state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OK</code> - The metric is within the defined threshold.</p>
    /// </li>
    /// </ul>
    /// <p>When you specify a notification trigger, the <code>ALARM</code> state must be specified.
    /// The <code>INSUFFICIENT_DATA</code> and <code>OK</code> states can be specified in addition to
    /// the <code>ALARM</code> state.</p>
    /// <ul>
    /// <li>
    /// <p>If you specify <code>OK</code> as an alarm trigger, a notification is sent when the
    /// alarm switches from an <code>ALARM</code> or <code>INSUFFICIENT_DATA</code> alarm state to
    /// an <code>OK</code> state. This can be thought of as an <i>all clear</i>
    /// alarm notification.</p>
    /// </li>
    /// <li>
    /// <p>If you specify <code>INSUFFICIENT_DATA</code> as the alarm trigger, a notification is
    /// sent when the alarm switches from an <code>OK</code> or <code>ALARM</code> alarm state to
    /// an <code>INSUFFICIENT_DATA</code> state.</p>
    /// </li>
    /// </ul>
    /// <p>The notification trigger defaults to <code>ALARM</code> if you don't specify this
    /// parameter.</p>
    pub fn notification_triggers(&self) -> std::option::Option<&[crate::model::AlarmState]> {
        self.notification_triggers.as_deref()
    }
    /// <p>Indicates whether the alarm is enabled.</p>
    /// <p>Notifications are enabled by default if you don't specify this parameter.</p>
    pub fn notification_enabled(&self) -> std::option::Option<bool> {
        self.notification_enabled
    }
}
impl std::fmt::Debug for PutAlarmInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAlarmInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("monitored_resource_name", &self.monitored_resource_name);
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.field("threshold", &self.threshold);
        formatter.field("evaluation_periods", &self.evaluation_periods);
        formatter.field("datapoints_to_alarm", &self.datapoints_to_alarm);
        formatter.field("treat_missing_data", &self.treat_missing_data);
        formatter.field("contact_protocols", &self.contact_protocols);
        formatter.field("notification_triggers", &self.notification_triggers);
        formatter.field("notification_enabled", &self.notification_enabled);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PeerVpcInput {}
impl std::fmt::Debug for PeerVpcInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PeerVpcInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OpenInstancePublicPortsInput {
    /// <p>An object to describe the ports to open for the specified instance.</p>
    pub port_info: std::option::Option<crate::model::PortInfo>,
    /// <p>The name of the instance for which to open ports.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl OpenInstancePublicPortsInput {
    /// <p>An object to describe the ports to open for the specified instance.</p>
    pub fn port_info(&self) -> std::option::Option<&crate::model::PortInfo> {
        self.port_info.as_ref()
    }
    /// <p>The name of the instance for which to open ports.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for OpenInstancePublicPortsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpenInstancePublicPortsInput");
        formatter.field("port_info", &self.port_info);
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IsVpcPeeredInput {}
impl std::fmt::Debug for IsVpcPeeredInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IsVpcPeeredInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportKeyPairInput {
    /// <p>The name of the key pair for which you want to import the public key.</p>
    pub key_pair_name: std::option::Option<std::string::String>,
    /// <p>A base64-encoded public key of the <code>ssh-rsa</code> type.</p>
    pub public_key_base64: std::option::Option<std::string::String>,
}
impl ImportKeyPairInput {
    /// <p>The name of the key pair for which you want to import the public key.</p>
    pub fn key_pair_name(&self) -> std::option::Option<&str> {
        self.key_pair_name.as_deref()
    }
    /// <p>A base64-encoded public key of the <code>ssh-rsa</code> type.</p>
    pub fn public_key_base64(&self) -> std::option::Option<&str> {
        self.public_key_base64.as_deref()
    }
}
impl std::fmt::Debug for ImportKeyPairInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportKeyPairInput");
        formatter.field("key_pair_name", &self.key_pair_name);
        formatter.field("public_key_base64", &self.public_key_base64);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetStaticIpsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetStaticIps</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetStaticIpsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetStaticIps</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetStaticIpsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetStaticIpsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetStaticIpInput {
    /// <p>The name of the static IP in Lightsail.</p>
    pub static_ip_name: std::option::Option<std::string::String>,
}
impl GetStaticIpInput {
    /// <p>The name of the static IP in Lightsail.</p>
    pub fn static_ip_name(&self) -> std::option::Option<&str> {
        self.static_ip_name.as_deref()
    }
}
impl std::fmt::Debug for GetStaticIpInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetStaticIpInput");
        formatter.field("static_ip_name", &self.static_ip_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseSnapshotsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseSnapshots</code>
    /// request. If your results are paginated, the response will return a next page token that you
    /// can specify as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseSnapshotsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseSnapshots</code>
    /// request. If your results are paginated, the response will return a next page token that you
    /// can specify as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseSnapshotsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseSnapshotsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseSnapshotInput {
    /// <p>The name of the database snapshot for which to get information.</p>
    pub relational_database_snapshot_name: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseSnapshotInput {
    /// <p>The name of the database snapshot for which to get information.</p>
    pub fn relational_database_snapshot_name(&self) -> std::option::Option<&str> {
        self.relational_database_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseSnapshotInput");
        formatter.field(
            "relational_database_snapshot_name",
            &self.relational_database_snapshot_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabasesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabases</code> request. If
    /// your results are paginated, the response will return a next page token that you can specify as
    /// the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabasesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabases</code> request. If
    /// your results are paginated, the response will return a next page token that you can specify as
    /// the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabasesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabasesInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseParametersInput {
    /// <p>The name of your database for which to get parameters.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseParameters</code>
    /// request. If your results are paginated, the response will return a next page token that you
    /// can specify as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseParametersInput {
    /// <p>The name of your database for which to get parameters.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseParameters</code>
    /// request. If your results are paginated, the response will return a next page token that you
    /// can specify as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseParametersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseParametersInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseMetricDataInput {
    /// <p>The name of your database from which to get metric data.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid relational database metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value. All relational database metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>CPUUtilization</code>
    /// </b> - The percentage of CPU
    /// utilization currently in use on the database.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>DatabaseConnections</code>
    /// </b> - The number of
    /// database connections in use.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>DiskQueueDepth</code>
    /// </b> - The number of
    /// outstanding IOs (read/write requests) that are waiting to access the disk.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>FreeStorageSpace</code>
    /// </b> - The amount of
    /// available storage space.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkReceiveThroughput</code>
    /// </b> - The incoming
    /// (Receive) network traffic on the database, including both customer database traffic and
    /// AWS traffic used for monitoring and replication.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkTransmitThroughput</code>
    /// </b> - The outgoing
    /// (Transmit) network traffic on the database, including both customer database traffic and
    /// AWS traffic used for monitoring and replication.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::RelationalDatabaseMetricName>,
    /// <p>The granularity, in seconds, of the returned data points.</p>
    /// <p>All relational database metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    pub period: i32,
    /// <p>The start of the time interval from which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the start time.</p>
    ///
    /// </li>
    /// </ul>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end of the time interval from which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the end time.</p>
    ///
    /// </li>
    /// </ul>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The unit for the metric data request. Valid units depend on the metric data being
    /// requested. For the valid units with each available metric, see the <code>metricName</code>
    /// parameter.</p>
    pub unit: std::option::Option<crate::model::MetricUnit>,
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
}
impl GetRelationalDatabaseMetricDataInput {
    /// <p>The name of your database from which to get metric data.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid relational database metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value. All relational database metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>CPUUtilization</code>
    /// </b> - The percentage of CPU
    /// utilization currently in use on the database.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>DatabaseConnections</code>
    /// </b> - The number of
    /// database connections in use.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>DiskQueueDepth</code>
    /// </b> - The number of
    /// outstanding IOs (read/write requests) that are waiting to access the disk.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>FreeStorageSpace</code>
    /// </b> - The amount of
    /// available storage space.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkReceiveThroughput</code>
    /// </b> - The incoming
    /// (Receive) network traffic on the database, including both customer database traffic and
    /// AWS traffic used for monitoring and replication.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkTransmitThroughput</code>
    /// </b> - The outgoing
    /// (Transmit) network traffic on the database, including both customer database traffic and
    /// AWS traffic used for monitoring and replication.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes/Second</code>.</p>
    /// </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::RelationalDatabaseMetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The granularity, in seconds, of the returned data points.</p>
    /// <p>All relational database metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The start of the time interval from which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the start time.</p>
    ///
    /// </li>
    /// </ul>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time interval from which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the end time.</p>
    ///
    /// </li>
    /// </ul>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The unit for the metric data request. Valid units depend on the metric data being
    /// requested. For the valid units with each available metric, see the <code>metricName</code>
    /// parameter.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::MetricUnit> {
        self.unit.as_ref()
    }
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::MetricStatistic]> {
        self.statistics.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseMetricDataInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("period", &self.period);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("unit", &self.unit);
        formatter.field("statistics", &self.statistics);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseMasterUserPasswordInput {
    /// <p>The name of your database for which to get the master user password.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The password version to return.</p>
    /// <p>Specifying <code>CURRENT</code> or <code>PREVIOUS</code> returns the current or previous
    /// passwords respectively. Specifying <code>PENDING</code> returns the newest version of the
    /// password that will rotate to <code>CURRENT</code>. After the <code>PENDING</code> password
    /// rotates to <code>CURRENT</code>, the <code>PENDING</code> password is no longer
    /// available.</p>
    /// <p>Default: <code>CURRENT</code>
    /// </p>
    pub password_version: std::option::Option<crate::model::RelationalDatabasePasswordVersion>,
}
impl GetRelationalDatabaseMasterUserPasswordInput {
    /// <p>The name of your database for which to get the master user password.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The password version to return.</p>
    /// <p>Specifying <code>CURRENT</code> or <code>PREVIOUS</code> returns the current or previous
    /// passwords respectively. Specifying <code>PENDING</code> returns the newest version of the
    /// password that will rotate to <code>CURRENT</code>. After the <code>PENDING</code> password
    /// rotates to <code>CURRENT</code>, the <code>PENDING</code> password is no longer
    /// available.</p>
    /// <p>Default: <code>CURRENT</code>
    /// </p>
    pub fn password_version(
        &self,
    ) -> std::option::Option<&crate::model::RelationalDatabasePasswordVersion> {
        self.password_version.as_ref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseMasterUserPasswordInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseMasterUserPasswordInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("password_version", &self.password_version);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseLogStreamsInput {
    /// <p>The name of your database for which to get log streams.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseLogStreamsInput {
    /// <p>The name of your database for which to get log streams.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseLogStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseLogStreamsInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseLogEventsInput {
    /// <p>The name of your database for which to get log events.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    /// <p>Use the <code>get relational database log streams</code> operation to get a list of
    /// available log streams.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
    /// <p>The start of the time interval from which to get log events.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the start time.</p>
    /// </li>
    /// </ul>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end of the time interval from which to get log events.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the end time.</p>
    ///
    /// </li>
    /// </ul>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>Parameter to specify if the log should start from head or tail. If <code>true</code> is
    /// specified, the log event starts from the head of the log. If <code>false</code> is specified,
    /// the log event starts from the tail of the log.</p>
    /// <note>
    /// <p>For PostgreSQL, the default value of <code>false</code> is the only option
    /// available.</p>
    /// </note>
    pub start_from_head: std::option::Option<bool>,
    /// <p>The token to advance to the next or previous page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseLogEvents</code>
    /// request. If your results are paginated, the response will return a next forward token and/or
    /// next backward token that you can specify as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseLogEventsInput {
    /// <p>The name of your database for which to get log events.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The name of the log stream.</p>
    /// <p>Use the <code>get relational database log streams</code> operation to get a list of
    /// available log streams.</p>
    pub fn log_stream_name(&self) -> std::option::Option<&str> {
        self.log_stream_name.as_deref()
    }
    /// <p>The start of the time interval from which to get log events.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the start time.</p>
    /// </li>
    /// </ul>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time interval from which to get log events.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 8 PM UTC, then you
    /// input <code>1538424000</code> as the end time.</p>
    ///
    /// </li>
    /// </ul>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>Parameter to specify if the log should start from head or tail. If <code>true</code> is
    /// specified, the log event starts from the head of the log. If <code>false</code> is specified,
    /// the log event starts from the tail of the log.</p>
    /// <note>
    /// <p>For PostgreSQL, the default value of <code>false</code> is the only option
    /// available.</p>
    /// </note>
    pub fn start_from_head(&self) -> std::option::Option<bool> {
        self.start_from_head
    }
    /// <p>The token to advance to the next or previous page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseLogEvents</code>
    /// request. If your results are paginated, the response will return a next forward token and/or
    /// next backward token that you can specify as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseLogEventsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseLogEventsInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("start_from_head", &self.start_from_head);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseEventsInput {
    /// <p>The name of the database from which to get events.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The number of minutes in the past from which to retrieve events. For example, to get all
    /// events from the past 2 hours, enter 120.</p>
    /// <p>Default: <code>60</code>
    /// </p>
    /// <p>The minimum is 1 and the maximum is 14 days (20160 minutes).</p>
    pub duration_in_minutes: std::option::Option<i32>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseEvents</code> request.
    /// If your results are paginated, the response will return a next page token that you can specify
    /// as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseEventsInput {
    /// <p>The name of the database from which to get events.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The number of minutes in the past from which to retrieve events. For example, to get all
    /// events from the past 2 hours, enter 120.</p>
    /// <p>Default: <code>60</code>
    /// </p>
    /// <p>The minimum is 1 and the maximum is 14 days (20160 minutes).</p>
    pub fn duration_in_minutes(&self) -> std::option::Option<i32> {
        self.duration_in_minutes
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseEvents</code> request.
    /// If your results are paginated, the response will return a next page token that you can specify
    /// as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseEventsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseEventsInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("duration_in_minutes", &self.duration_in_minutes);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseBundlesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBundles</code> request.
    /// If your results are paginated, the response will return a next page token that you can specify
    /// as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseBundlesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBundles</code> request.
    /// If your results are paginated, the response will return a next page token that you can specify
    /// as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseBundlesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseBundlesInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseBlueprintsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBlueprints</code>
    /// request. If your results are paginated, the response will return a next page token that you
    /// can specify as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseBlueprintsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetRelationalDatabaseBlueprints</code>
    /// request. If your results are paginated, the response will return a next page token that you
    /// can specify as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseBlueprintsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseBlueprintsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRelationalDatabaseInput {
    /// <p>The name of the database that you are looking up.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
}
impl GetRelationalDatabaseInput {
    /// <p>The name of the database that you are looking up.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
}
impl std::fmt::Debug for GetRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRegionsInput {
    /// <p>A Boolean value indicating whether to also include Availability Zones in your get regions
    /// request. Availability Zones are indicated with a letter: e.g., <code>us-east-2a</code>.</p>
    pub include_availability_zones: std::option::Option<bool>,
    /// <p>A Boolean value indicating whether to also include Availability Zones for databases in
    /// your get regions request. Availability Zones are indicated with a letter (e.g.,
    /// <code>us-east-2a</code>).</p>
    pub include_relational_database_availability_zones: std::option::Option<bool>,
}
impl GetRegionsInput {
    /// <p>A Boolean value indicating whether to also include Availability Zones in your get regions
    /// request. Availability Zones are indicated with a letter: e.g., <code>us-east-2a</code>.</p>
    pub fn include_availability_zones(&self) -> std::option::Option<bool> {
        self.include_availability_zones
    }
    /// <p>A Boolean value indicating whether to also include Availability Zones for databases in
    /// your get regions request. Availability Zones are indicated with a letter (e.g.,
    /// <code>us-east-2a</code>).</p>
    pub fn include_relational_database_availability_zones(&self) -> std::option::Option<bool> {
        self.include_relational_database_availability_zones
    }
}
impl std::fmt::Debug for GetRegionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRegionsInput");
        formatter.field(
            "include_availability_zones",
            &self.include_availability_zones,
        );
        formatter.field(
            "include_relational_database_availability_zones",
            &self.include_relational_database_availability_zones,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOperationsForResourceInput {
    /// <p>The name of the resource for which you are requesting information.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetOperationsForResource</code> request. If
    /// your results are paginated, the response will return a next page token that you can specify as
    /// the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetOperationsForResourceInput {
    /// <p>The name of the resource for which you are requesting information.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetOperationsForResource</code> request. If
    /// your results are paginated, the response will return a next page token that you can specify as
    /// the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetOperationsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOperationsForResourceInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOperationsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetOperations</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetOperationsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetOperations</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetOperationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOperationsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOperationInput {
    /// <p>A GUID used to identify the operation.</p>
    pub operation_id: std::option::Option<std::string::String>,
}
impl GetOperationInput {
    /// <p>A GUID used to identify the operation.</p>
    pub fn operation_id(&self) -> std::option::Option<&str> {
        self.operation_id.as_deref()
    }
}
impl std::fmt::Debug for GetOperationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOperationInput");
        formatter.field("operation_id", &self.operation_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoadBalancerTlsCertificatesInput {
    /// <p>The name of the load balancer you associated with your SSL/TLS certificate.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
}
impl GetLoadBalancerTlsCertificatesInput {
    /// <p>The name of the load balancer you associated with your SSL/TLS certificate.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
}
impl std::fmt::Debug for GetLoadBalancerTlsCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoadBalancerTlsCertificatesInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoadBalancersInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetLoadBalancers</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetLoadBalancersInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetLoadBalancers</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetLoadBalancersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoadBalancersInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoadBalancerMetricDataInput {
    /// <p>The name of the load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid load balancer metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>ClientTLSNegotiationErrorCount</code>
    /// </b> - The
    /// number of TLS connections initiated by the client that did not establish a session with
    /// the load balancer due to a TLS error generated by the load balancer. Possible causes
    /// include a mismatch of ciphers or protocols.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HealthyHostCount</code>
    /// </b> - The number of target
    /// instances that are considered healthy.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
    /// <code>Minimum</code>, and <code>Maximum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_2XX_Count</code>
    /// </b> - The number
    /// of HTTP 2XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_3XX_Count</code>
    /// </b> - The number
    /// of HTTP 3XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_4XX_Count</code>
    /// </b> - The number
    /// of HTTP 4XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_5XX_Count</code>
    /// </b> - The number
    /// of HTTP 5XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_LB_4XX_Count</code>
    /// </b> - The number of
    /// HTTP 4XX client error codes that originated from the load balancer. Client errors are
    /// generated when requests are malformed or incomplete. These requests were not received by
    /// the target instance. This count does not include response codes generated by the target
    /// instances.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_LB_5XX_Count</code>
    /// </b> - The number of
    /// HTTP 5XX server error codes that originated from the load balancer. This does not include
    /// any response codes generated by the target instance. This metric is reported if there are
    /// no healthy instances attached to the load balancer, or if the request rate exceeds the
    /// capacity of the instances (spillover) or the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>InstanceResponseTime</code>
    /// </b> - The time elapsed,
    /// in seconds, after the request leaves the load balancer until a response from the target
    /// instance is received.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>RejectedConnectionCount</code>
    /// </b> - The number of
    /// connections that were rejected because the load balancer had reached its maximum number of
    /// connections.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>RequestCount</code>
    /// </b> - The number of requests
    /// processed over IPv4. This count includes only the requests with a response generated by a
    /// target instance of the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>UnhealthyHostCount</code>
    /// </b> - The number of
    /// target instances that are considered unhealthy.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
    /// <code>Minimum</code>, and <code>Maximum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::LoadBalancerMetricName>,
    /// <p>The granularity, in seconds, of the returned data points.</p>
    pub period: i32,
    /// <p>The start time of the period.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end time of the period.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The unit for the metric data request. Valid units depend on the metric data being
    /// requested. For the valid units with each available metric, see the <code>metricName</code>
    /// parameter.</p>
    pub unit: std::option::Option<crate::model::MetricUnit>,
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
}
impl GetLoadBalancerMetricDataInput {
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid load balancer metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>ClientTLSNegotiationErrorCount</code>
    /// </b> - The
    /// number of TLS connections initiated by the client that did not establish a session with
    /// the load balancer due to a TLS error generated by the load balancer. Possible causes
    /// include a mismatch of ciphers or protocols.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HealthyHostCount</code>
    /// </b> - The number of target
    /// instances that are considered healthy.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
    /// <code>Minimum</code>, and <code>Maximum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_2XX_Count</code>
    /// </b> - The number
    /// of HTTP 2XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_3XX_Count</code>
    /// </b> - The number
    /// of HTTP 3XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_4XX_Count</code>
    /// </b> - The number
    /// of HTTP 4XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_Instance_5XX_Count</code>
    /// </b> - The number
    /// of HTTP 5XX response codes generated by the target instances. This does not include any
    /// response codes generated by the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_LB_4XX_Count</code>
    /// </b> - The number of
    /// HTTP 4XX client error codes that originated from the load balancer. Client errors are
    /// generated when requests are malformed or incomplete. These requests were not received by
    /// the target instance. This count does not include response codes generated by the target
    /// instances.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>HTTPCode_LB_5XX_Count</code>
    /// </b> - The number of
    /// HTTP 5XX server error codes that originated from the load balancer. This does not include
    /// any response codes generated by the target instance. This metric is reported if there are
    /// no healthy instances attached to the load balancer, or if the request rate exceeds the
    /// capacity of the instances (spillover) or the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>InstanceResponseTime</code>
    /// </b> - The time elapsed,
    /// in seconds, after the request leaves the load balancer until a response from the target
    /// instance is received.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>RejectedConnectionCount</code>
    /// </b> - The number of
    /// connections that were rejected because the load balancer had reached its maximum number of
    /// connections.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>RequestCount</code>
    /// </b> - The number of requests
    /// processed over IPv4. This count includes only the requests with a response generated by a
    /// target instance of the load balancer.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>. Note that
    /// <code>Minimum</code>, <code>Maximum</code>, and <code>Average</code> all return
    /// <code>1</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>UnhealthyHostCount</code>
    /// </b> - The number of
    /// target instances that are considered unhealthy.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic are <code>Average</code>,
    /// <code>Minimum</code>, and <code>Maximum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::LoadBalancerMetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The granularity, in seconds, of the returned data points.</p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The start time of the period.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end time of the period.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The unit for the metric data request. Valid units depend on the metric data being
    /// requested. For the valid units with each available metric, see the <code>metricName</code>
    /// parameter.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::MetricUnit> {
        self.unit.as_ref()
    }
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::MetricStatistic]> {
        self.statistics.as_deref()
    }
}
impl std::fmt::Debug for GetLoadBalancerMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoadBalancerMetricDataInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("period", &self.period);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("unit", &self.unit);
        formatter.field("statistics", &self.statistics);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLoadBalancerInput {
    /// <p>The name of the load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
}
impl GetLoadBalancerInput {
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
}
impl std::fmt::Debug for GetLoadBalancerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLoadBalancerInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetKeyPairsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetKeyPairs</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetKeyPairsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetKeyPairs</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetKeyPairsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetKeyPairsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetKeyPairInput {
    /// <p>The name of the key pair for which you are requesting information.</p>
    pub key_pair_name: std::option::Option<std::string::String>,
}
impl GetKeyPairInput {
    /// <p>The name of the key pair for which you are requesting information.</p>
    pub fn key_pair_name(&self) -> std::option::Option<&str> {
        self.key_pair_name.as_deref()
    }
}
impl std::fmt::Debug for GetKeyPairInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetKeyPairInput");
        formatter.field("key_pair_name", &self.key_pair_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceStateInput {
    /// <p>The name of the instance to get state information about.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl GetInstanceStateInput {
    /// <p>The name of the instance to get state information about.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for GetInstanceStateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceStateInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceSnapshotsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetInstanceSnapshots</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetInstanceSnapshotsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetInstanceSnapshots</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetInstanceSnapshotsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceSnapshotsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceSnapshotInput {
    /// <p>The name of the snapshot for which you are requesting information.</p>
    pub instance_snapshot_name: std::option::Option<std::string::String>,
}
impl GetInstanceSnapshotInput {
    /// <p>The name of the snapshot for which you are requesting information.</p>
    pub fn instance_snapshot_name(&self) -> std::option::Option<&str> {
        self.instance_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for GetInstanceSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceSnapshotInput");
        formatter.field("instance_snapshot_name", &self.instance_snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstancesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetInstances</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetInstancesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetInstances</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetInstancesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstancesInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstancePortStatesInput {
    /// <p>The name of the instance for which to return firewall port states.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl GetInstancePortStatesInput {
    /// <p>The name of the instance for which to return firewall port states.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for GetInstancePortStatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstancePortStatesInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceMetricDataInput {
    /// <p>The name of the instance for which you want to get metrics data.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid instance metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BurstCapacityPercentage</code>
    /// </b> - The percentage
    /// of CPU performance available for your instance to burst above its baseline. Your instance
    /// continuously accrues and consumes burst capacity. Burst capacity stops accruing when your
    /// instance's <code>BurstCapacityPercentage</code> reaches 100%. For more information, see
    /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BurstCapacityTime</code>
    /// </b> - The available amount
    /// of time for your instance to burst at 100% CPU utilization. Your instance continuously
    /// accrues and consumes burst capacity. Burst capacity time stops accruing when your
    /// instance's <code>BurstCapacityPercentage</code> metric reaches 100%.</p>
    /// <p>Burst capacity time is consumed at the full rate only when your instance operates at
    /// 100% CPU utilization. For example, if your instance operates at 50% CPU utilization in the
    /// burstable zone for a 5-minute period, then it consumes CPU burst capacity minutes at a 50%
    /// rate in that period. Your instance consumed 2 minutes and 30 seconds of CPU burst capacity
    /// minutes in the 5-minute period. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>CPUUtilization</code>
    /// </b> - The percentage of
    /// allocated compute units that are currently in use on the instance. This metric identifies
    /// the processing power to run the applications on the instance. Tools in your operating
    /// system can show a lower percentage than Lightsail when the instance is not allocated a
    /// full processor core.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkIn</code>
    /// </b> - The number of bytes received
    /// on all network interfaces by the instance. This metric identifies the volume of incoming
    /// network traffic to the instance. The number reported is the number of bytes received
    /// during the period. Because this metric is reported in 5-minute intervals, divide the
    /// reported number by 300 to find Bytes/second.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkOut</code>
    /// </b> - The number of bytes sent
    /// out on all network interfaces by the instance. This metric identifies the volume of
    /// outgoing network traffic from the instance. The number reported is the number of bytes
    /// sent during the period. Because this metric is reported in 5-minute intervals, divide the
    /// reported number by 300 to find Bytes/second.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>StatusCheckFailed</code>
    /// </b> - Reports whether the
    /// instance passed or failed both the instance status check and the system status check. This
    /// metric can be either 0 (passed) or 1 (failed). This metric data is available in 1-minute
    /// (60 seconds) granularity.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>StatusCheckFailed_Instance</code>
    /// </b> - Reports
    /// whether the instance passed or failed the instance status check. This metric can be either
    /// 0 (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>StatusCheckFailed_System</code>
    /// </b> - Reports
    /// whether the instance passed or failed the system status check. This metric can be either 0
    /// (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::InstanceMetricName>,
    /// <p>The granularity, in seconds, of the returned data points.</p>
    /// <p>The <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and
    /// <code>StatusCheckFailed_System</code> instance metric data is available in 1-minute (60
    /// seconds) granularity. All other instance metric data is available in 5-minute (300 seconds)
    /// granularity.</p>
    pub period: i32,
    /// <p>The start time of the time period.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end time of the time period.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The unit for the metric data request. Valid units depend on the metric data being
    /// requested. For the valid units to specify with each available metric, see the
    /// <code>metricName</code> parameter.</p>
    pub unit: std::option::Option<crate::model::MetricUnit>,
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
}
impl GetInstanceMetricDataInput {
    /// <p>The name of the instance for which you want to get metrics data.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid instance metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BurstCapacityPercentage</code>
    /// </b> - The percentage
    /// of CPU performance available for your instance to burst above its baseline. Your instance
    /// continuously accrues and consumes burst capacity. Burst capacity stops accruing when your
    /// instance's <code>BurstCapacityPercentage</code> reaches 100%. For more information, see
    /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BurstCapacityTime</code>
    /// </b> - The available amount
    /// of time for your instance to burst at 100% CPU utilization. Your instance continuously
    /// accrues and consumes burst capacity. Burst capacity time stops accruing when your
    /// instance's <code>BurstCapacityPercentage</code> metric reaches 100%.</p>
    /// <p>Burst capacity time is consumed at the full rate only when your instance operates at
    /// 100% CPU utilization. For example, if your instance operates at 50% CPU utilization in the
    /// burstable zone for a 5-minute period, then it consumes CPU burst capacity minutes at a 50%
    /// rate in that period. Your instance consumed 2 minutes and 30 seconds of CPU burst capacity
    /// minutes in the 5-minute period. For more information, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-viewing-instance-burst-capacity">Viewing instance burst capacity in Amazon Lightsail</a>.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Seconds</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>CPUUtilization</code>
    /// </b> - The percentage of
    /// allocated compute units that are currently in use on the instance. This metric identifies
    /// the processing power to run the applications on the instance. Tools in your operating
    /// system can show a lower percentage than Lightsail when the instance is not allocated a
    /// full processor core.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkIn</code>
    /// </b> - The number of bytes received
    /// on all network interfaces by the instance. This metric identifies the volume of incoming
    /// network traffic to the instance. The number reported is the number of bytes received
    /// during the period. Because this metric is reported in 5-minute intervals, divide the
    /// reported number by 300 to find Bytes/second.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NetworkOut</code>
    /// </b> - The number of bytes sent
    /// out on all network interfaces by the instance. This metric identifies the volume of
    /// outgoing network traffic from the instance. The number reported is the number of bytes
    /// sent during the period. Because this metric is reported in 5-minute intervals, divide the
    /// reported number by 300 to find Bytes/second.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>StatusCheckFailed</code>
    /// </b> - Reports whether the
    /// instance passed or failed both the instance status check and the system status check. This
    /// metric can be either 0 (passed) or 1 (failed). This metric data is available in 1-minute
    /// (60 seconds) granularity.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>StatusCheckFailed_Instance</code>
    /// </b> - Reports
    /// whether the instance passed or failed the instance status check. This metric can be either
    /// 0 (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>StatusCheckFailed_System</code>
    /// </b> - Reports
    /// whether the instance passed or failed the system status check. This metric can be either 0
    /// (passed) or 1 (failed). This metric data is available in 1-minute (60 seconds)
    /// granularity.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Count</code>.</p>
    /// </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::InstanceMetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The granularity, in seconds, of the returned data points.</p>
    /// <p>The <code>StatusCheckFailed</code>, <code>StatusCheckFailed_Instance</code>, and
    /// <code>StatusCheckFailed_System</code> instance metric data is available in 1-minute (60
    /// seconds) granularity. All other instance metric data is available in 5-minute (300 seconds)
    /// granularity.</p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The start time of the time period.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end time of the time period.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The unit for the metric data request. Valid units depend on the metric data being
    /// requested. For the valid units to specify with each available metric, see the
    /// <code>metricName</code> parameter.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::MetricUnit> {
        self.unit.as_ref()
    }
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::MetricStatistic]> {
        self.statistics.as_deref()
    }
}
impl std::fmt::Debug for GetInstanceMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceMetricDataInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("period", &self.period);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("unit", &self.unit);
        formatter.field("statistics", &self.statistics);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceAccessDetailsInput {
    /// <p>The name of the instance to access.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>The protocol to use to connect to your instance. Defaults to <code>ssh</code>.</p>
    pub protocol: std::option::Option<crate::model::InstanceAccessProtocol>,
}
impl GetInstanceAccessDetailsInput {
    /// <p>The name of the instance to access.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>The protocol to use to connect to your instance. Defaults to <code>ssh</code>.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::model::InstanceAccessProtocol> {
        self.protocol.as_ref()
    }
}
impl std::fmt::Debug for GetInstanceAccessDetailsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceAccessDetailsInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceInput {
    /// <p>The name of the instance.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl GetInstanceInput {
    /// <p>The name of the instance.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for GetInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetExportSnapshotRecordsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetExportSnapshotRecords</code> request. If
    /// your results are paginated, the response will return a next page token that you can specify as
    /// the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetExportSnapshotRecordsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetExportSnapshotRecords</code> request. If
    /// your results are paginated, the response will return a next page token that you can specify as
    /// the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetExportSnapshotRecordsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetExportSnapshotRecordsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDomainsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDomains</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetDomainsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDomains</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetDomainsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDomainsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDomainInput {
    /// <p>The domain name for which your want to return information about.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl GetDomainInput {
    /// <p>The domain name for which your want to return information about.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
}
impl std::fmt::Debug for GetDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDistributionsInput {
    /// <p>The name of the distribution for which to return information.</p>
    ///
    /// <p>When omitted, the response includes all of your distributions in the AWS Region where
    /// the request is made.</p>
    pub distribution_name: std::option::Option<std::string::String>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDistributions</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetDistributionsInput {
    /// <p>The name of the distribution for which to return information.</p>
    ///
    /// <p>When omitted, the response includes all of your distributions in the AWS Region where
    /// the request is made.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDistributions</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetDistributionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDistributionsInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDistributionMetricDataInput {
    /// <p>The name of the distribution for which to get metric data.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid distribution metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>Requests</code>
    /// </b> - The total number of viewer
    /// requests received by your Lightsail distribution, for all HTTP methods, and for both
    /// HTTP and HTTPS requests.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>None</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BytesDownloaded</code>
    /// </b> - The number of bytes
    /// downloaded by viewers for GET, HEAD, and OPTIONS requests.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>None</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BytesUploaded </code>
    /// </b> - The number of bytes
    /// uploaded to your origin by your Lightsail distribution, using POST and PUT
    /// requests.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>None</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>TotalErrorRate</code>
    /// </b> - The percentage of all
    /// viewer requests for which the response's HTTP status code was 4xx or 5xx.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>4xxErrorRate</code>
    /// </b> - The percentage of all
    /// viewer requests for which the response's HTTP status cod was 4xx. In these cases, the
    /// client or client viewer may have made an error. For example, a status code of 404 (Not
    /// Found) means that the client requested an object that could not be found.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>5xxErrorRate</code>
    /// </b> - The percentage of all
    /// viewer requests for which the response's HTTP status code was 5xx. In these cases, the
    /// origin server did not satisfy the requests. For example, a status code of 503 (Service
    /// Unavailable) means that the origin server is currently unavailable.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::DistributionMetricName>,
    /// <p>The start of the time interval for which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
    /// <code>1538424000</code> as the start time.</p>
    /// </li>
    /// </ul>
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end of the time interval for which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
    /// <code>1538427600</code> as the end time.</p>
    /// </li>
    /// </ul>
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The granularity, in seconds, for the metric data points that will be returned.</p>
    pub period: i32,
    /// <p>The unit for the metric data request.</p>
    /// <p>Valid units depend on the metric data being requested. For the valid units with each
    /// available metric, see the <code>metricName</code> parameter.</p>
    pub unit: std::option::Option<crate::model::MetricUnit>,
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
}
impl GetDistributionMetricDataInput {
    /// <p>The name of the distribution for which to get metric data.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
    /// <p>The metric for which you want to return information.</p>
    /// <p>Valid distribution metric names are listed below, along with the most useful
    /// <code>statistics</code> to include in your request, and the published <code>unit</code>
    /// value.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>Requests</code>
    /// </b> - The total number of viewer
    /// requests received by your Lightsail distribution, for all HTTP methods, and for both
    /// HTTP and HTTPS requests.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>None</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BytesDownloaded</code>
    /// </b> - The number of bytes
    /// downloaded by viewers for GET, HEAD, and OPTIONS requests.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>None</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BytesUploaded </code>
    /// </b> - The number of bytes
    /// uploaded to your origin by your Lightsail distribution, using POST and PUT
    /// requests.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Sum</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>None</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>TotalErrorRate</code>
    /// </b> - The percentage of all
    /// viewer requests for which the response's HTTP status code was 4xx or 5xx.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>4xxErrorRate</code>
    /// </b> - The percentage of all
    /// viewer requests for which the response's HTTP status cod was 4xx. In these cases, the
    /// client or client viewer may have made an error. For example, a status code of 404 (Not
    /// Found) means that the client requested an object that could not be found.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>5xxErrorRate</code>
    /// </b> - The percentage of all
    /// viewer requests for which the response's HTTP status code was 5xx. In these cases, the
    /// origin server did not satisfy the requests. For example, a status code of 503 (Service
    /// Unavailable) means that the origin server is currently unavailable.</p>
    /// <p>
    /// <code>Statistics</code>: The most useful statistic is <code>Average</code>.</p>
    /// <p>
    /// <code>Unit</code>: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::DistributionMetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The start of the time interval for which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
    /// <code>1538424000</code> as the start time.</p>
    /// </li>
    /// </ul>
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time interval for which to get metric data.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
    /// <code>1538427600</code> as the end time.</p>
    /// </li>
    /// </ul>
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The granularity, in seconds, for the metric data points that will be returned.</p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The unit for the metric data request.</p>
    /// <p>Valid units depend on the metric data being requested. For the valid units with each
    /// available metric, see the <code>metricName</code> parameter.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::MetricUnit> {
        self.unit.as_ref()
    }
    /// <p>The statistic for the metric.</p>
    /// <p>The following statistics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of Sum / SampleCount during the specified period. By
    /// comparing this statistic with the Minimum and Maximum values, you can determine the full
    /// scope of a metric and how close the average use is to the Minimum and Maximum values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::MetricStatistic]> {
        self.statistics.as_deref()
    }
}
impl std::fmt::Debug for GetDistributionMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDistributionMetricDataInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("period", &self.period);
        formatter.field("unit", &self.unit);
        formatter.field("statistics", &self.statistics);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDistributionLatestCacheResetInput {
    /// <p>The name of the distribution for which to return the timestamp of the last cache
    /// reset.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    /// <p>When omitted, the response includes the latest cache reset timestamp of all your
    /// distributions.</p>
    pub distribution_name: std::option::Option<std::string::String>,
}
impl GetDistributionLatestCacheResetInput {
    /// <p>The name of the distribution for which to return the timestamp of the last cache
    /// reset.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    /// <p>When omitted, the response includes the latest cache reset timestamp of all your
    /// distributions.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
}
impl std::fmt::Debug for GetDistributionLatestCacheResetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDistributionLatestCacheResetInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDistributionBundlesInput {}
impl std::fmt::Debug for GetDistributionBundlesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDistributionBundlesInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDiskSnapshotsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDiskSnapshots</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetDiskSnapshotsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDiskSnapshots</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetDiskSnapshotsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDiskSnapshotsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDiskSnapshotInput {
    /// <p>The name of the disk snapshot (e.g., <code>my-disk-snapshot</code>).</p>
    pub disk_snapshot_name: std::option::Option<std::string::String>,
}
impl GetDiskSnapshotInput {
    /// <p>The name of the disk snapshot (e.g., <code>my-disk-snapshot</code>).</p>
    pub fn disk_snapshot_name(&self) -> std::option::Option<&str> {
        self.disk_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for GetDiskSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDiskSnapshotInput");
        formatter.field("disk_snapshot_name", &self.disk_snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDisksInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDisks</code> request. If your results are
    /// paginated, the response will return a next page token that you can specify as the page token
    /// in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetDisksInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetDisks</code> request. If your results are
    /// paginated, the response will return a next page token that you can specify as the page token
    /// in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetDisksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDisksInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDiskInput {
    /// <p>The name of the disk (e.g., <code>my-disk</code>).</p>
    pub disk_name: std::option::Option<std::string::String>,
}
impl GetDiskInput {
    /// <p>The name of the disk (e.g., <code>my-disk</code>).</p>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
}
impl std::fmt::Debug for GetDiskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDiskInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerServicesInput {
    /// <p>The name of the container service for which to return information.</p>
    ///
    /// <p>When omitted, the response includes all of your container services in the AWS Region
    /// where the request is made.</p>
    pub service_name: std::option::Option<std::string::String>,
}
impl GetContainerServicesInput {
    /// <p>The name of the container service for which to return information.</p>
    ///
    /// <p>When omitted, the response includes all of your container services in the AWS Region
    /// where the request is made.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
}
impl std::fmt::Debug for GetContainerServicesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerServicesInput");
        formatter.field("service_name", &self.service_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerServicePowersInput {}
impl std::fmt::Debug for GetContainerServicePowersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerServicePowersInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerServiceMetricDataInput {
    /// <p>The name of the container service for which to get metric data.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The metric for which you want to return information.</p>
    ///
    /// <p>Valid container service metric names are listed below, along with the most useful
    /// statistics to include in your request, and the published unit value.</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CPUUtilization</code> - The average percentage of compute units that are
    /// currently in use across all nodes of the container service. This metric identifies the
    /// processing power required to run containers on each node of the container service.</p>
    /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>Unit: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MemoryUtilization</code> - The average percentage of available memory that is
    /// currently in use across all nodes of the container service. This metric identifies the
    /// memory required to run containers on each node of the container service.</p>
    /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>Unit: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::ContainerServiceMetricName>,
    /// <p>The start time of the time period.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end time of the time period.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The granularity, in seconds, of the returned data points.</p>
    ///
    /// <p>All container service metric data is available in 5-minute (300 seconds)
    /// granularity.</p>
    pub period: i32,
    /// <p>The statistic for the metric.</p>
    ///
    /// <p>The following statistics are available:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
    /// the specified period. By comparing this statistic with the <code>Minimum</code> and
    /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
    /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
}
impl GetContainerServiceMetricDataInput {
    /// <p>The name of the container service for which to get metric data.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The metric for which you want to return information.</p>
    ///
    /// <p>Valid container service metric names are listed below, along with the most useful
    /// statistics to include in your request, and the published unit value.</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CPUUtilization</code> - The average percentage of compute units that are
    /// currently in use across all nodes of the container service. This metric identifies the
    /// processing power required to run containers on each node of the container service.</p>
    /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>Unit: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MemoryUtilization</code> - The average percentage of available memory that is
    /// currently in use across all nodes of the container service. This metric identifies the
    /// memory required to run containers on each node of the container service.</p>
    /// <p>Statistics: The most useful statistics are <code>Maximum</code> and
    /// <code>Average</code>.</p>
    /// <p>Unit: The published unit is <code>Percent</code>.</p>
    /// </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::ContainerServiceMetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The start time of the time period.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end time of the time period.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The granularity, in seconds, of the returned data points.</p>
    ///
    /// <p>All container service metric data is available in 5-minute (300 seconds)
    /// granularity.</p>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The statistic for the metric.</p>
    ///
    /// <p>The following statistics are available:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - All values submitted for the matching metric added together. You
    /// can use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
    /// the specified period. By comparing this statistic with the <code>Minimum</code> and
    /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
    /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::MetricStatistic]> {
        self.statistics.as_deref()
    }
}
impl std::fmt::Debug for GetContainerServiceMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerServiceMetricDataInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("period", &self.period);
        formatter.field("statistics", &self.statistics);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerServiceDeploymentsInput {
    /// <p>The name of the container service for which to return deployments.</p>
    pub service_name: std::option::Option<std::string::String>,
}
impl GetContainerServiceDeploymentsInput {
    /// <p>The name of the container service for which to return deployments.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
}
impl std::fmt::Debug for GetContainerServiceDeploymentsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerServiceDeploymentsInput");
        formatter.field("service_name", &self.service_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerLogInput {
    /// <p>The name of the container service for which to get a container log.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The name of the container that is either running or previously ran on the container
    /// service for which to return a log.</p>
    pub container_name: std::option::Option<std::string::String>,
    /// <p>The start of the time interval for which to get log data.</p>
    ///
    /// <p>Constraints:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    ///
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
    /// <code>1538424000</code> as the start time.</p>
    /// </li>
    /// </ul>
    ///
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end of the time interval for which to get log data.</p>
    ///
    /// <p>Constraints:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    ///
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
    /// <code>1538427600</code> as the end time.</p>
    /// </li>
    /// </ul>
    ///
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The pattern to use to filter the returned log events to a specific term.</p>
    ///
    /// <p>The following are a few examples of filter patterns that you can specify:</p>
    /// <ul>
    /// <li>
    /// <p>To return all log events, specify a filter pattern of <code>""</code>.</p>
    /// </li>
    /// <li>
    /// <p>To exclude log events that contain the <code>ERROR</code> term, and return all other
    /// log events, specify a filter pattern of <code>"-ERROR"</code>.</p>
    /// </li>
    /// <li>
    /// <p>To return log events that contain the <code>ERROR</code> term, specify a filter
    /// pattern of <code>"ERROR"</code>.</p>
    /// </li>
    /// <li>
    /// <p>To return log events that contain both the <code>ERROR</code> and
    /// <code>Exception</code> terms, specify a filter pattern of <code>"ERROR
    /// Exception"</code>.</p>
    /// </li>
    /// <li>
    /// <p>To return log events that contain the <code>ERROR</code>
    /// <i>or</i> the <code>Exception</code> term, specify a filter pattern of
    /// <code>"?ERROR ?Exception"</code>.</p>
    /// </li>
    /// </ul>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The token to advance to the next page of results from your request.</p>
    ///
    /// <p>To get a page token, perform an initial <code>GetContainerLog</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetContainerLogInput {
    /// <p>The name of the container service for which to get a container log.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The name of the container that is either running or previously ran on the container
    /// service for which to return a log.</p>
    pub fn container_name(&self) -> std::option::Option<&str> {
        self.container_name.as_deref()
    }
    /// <p>The start of the time interval for which to get log data.</p>
    ///
    /// <p>Constraints:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    ///
    /// <p>For example, if you wish to use a start time of October 1, 2018, at 8 PM UTC, specify
    /// <code>1538424000</code> as the start time.</p>
    /// </li>
    /// </ul>
    ///
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The end of the time interval for which to get log data.</p>
    ///
    /// <p>Constraints:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    ///
    /// <p>For example, if you wish to use an end time of October 1, 2018, at 9 PM UTC, specify
    /// <code>1538427600</code> as the end time.</p>
    /// </li>
    /// </ul>
    ///
    /// <p>You can convert a human-friendly time to Unix time format using a converter like <a href="https://www.epochconverter.com/">Epoch converter</a>.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The pattern to use to filter the returned log events to a specific term.</p>
    ///
    /// <p>The following are a few examples of filter patterns that you can specify:</p>
    /// <ul>
    /// <li>
    /// <p>To return all log events, specify a filter pattern of <code>""</code>.</p>
    /// </li>
    /// <li>
    /// <p>To exclude log events that contain the <code>ERROR</code> term, and return all other
    /// log events, specify a filter pattern of <code>"-ERROR"</code>.</p>
    /// </li>
    /// <li>
    /// <p>To return log events that contain the <code>ERROR</code> term, specify a filter
    /// pattern of <code>"ERROR"</code>.</p>
    /// </li>
    /// <li>
    /// <p>To return log events that contain both the <code>ERROR</code> and
    /// <code>Exception</code> terms, specify a filter pattern of <code>"ERROR
    /// Exception"</code>.</p>
    /// </li>
    /// <li>
    /// <p>To return log events that contain the <code>ERROR</code>
    /// <i>or</i> the <code>Exception</code> term, specify a filter pattern of
    /// <code>"?ERROR ?Exception"</code>.</p>
    /// </li>
    /// </ul>
    pub fn filter_pattern(&self) -> std::option::Option<&str> {
        self.filter_pattern.as_deref()
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    ///
    /// <p>To get a page token, perform an initial <code>GetContainerLog</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetContainerLogInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerLogInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("container_name", &self.container_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerImagesInput {
    /// <p>The name of the container service for which to return registered container images.</p>
    pub service_name: std::option::Option<std::string::String>,
}
impl GetContainerImagesInput {
    /// <p>The name of the container service for which to return registered container images.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
}
impl std::fmt::Debug for GetContainerImagesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerImagesInput");
        formatter.field("service_name", &self.service_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContainerApiMetadataInput {}
impl std::fmt::Debug for GetContainerApiMetadataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContainerApiMetadataInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContactMethodsInput {
    /// <p>The protocols used to send notifications, such as <code>Email</code>, or <code>SMS</code>
    /// (text messaging).</p>
    /// <p>Specify a protocol in your request to return information about a specific contact method
    /// protocol.</p>
    pub protocols: std::option::Option<std::vec::Vec<crate::model::ContactProtocol>>,
}
impl GetContactMethodsInput {
    /// <p>The protocols used to send notifications, such as <code>Email</code>, or <code>SMS</code>
    /// (text messaging).</p>
    /// <p>Specify a protocol in your request to return information about a specific contact method
    /// protocol.</p>
    pub fn protocols(&self) -> std::option::Option<&[crate::model::ContactProtocol]> {
        self.protocols.as_deref()
    }
}
impl std::fmt::Debug for GetContactMethodsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContactMethodsInput");
        formatter.field("protocols", &self.protocols);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCloudFormationStackRecordsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetClouFormationStackRecords</code> request.
    /// If your results are paginated, the response will return a next page token that you can specify
    /// as the page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetCloudFormationStackRecordsInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetClouFormationStackRecords</code> request.
    /// If your results are paginated, the response will return a next page token that you can specify
    /// as the page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetCloudFormationStackRecordsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCloudFormationStackRecordsInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCertificatesInput {
    /// <p>The status of the certificates for which to return information.</p>
    /// <p>For example, specify <code>ISSUED</code> to return only certificates with an
    /// <code>ISSUED</code> status.</p>
    /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
    /// request is made, regardless of their current status.</p>
    pub certificate_statuses: std::option::Option<std::vec::Vec<crate::model::CertificateStatus>>,
    /// <p>Indicates whether to include detailed information about the certificates in the
    /// response.</p>
    /// <p>When omitted, the response includes only the certificate names, Amazon Resource Names
    /// (ARNs), domain names, and tags.</p>
    pub include_certificate_details: bool,
    /// <p>The name for the certificate for which to return information.</p>
    /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
    /// request is made.</p>
    pub certificate_name: std::option::Option<std::string::String>,
}
impl GetCertificatesInput {
    /// <p>The status of the certificates for which to return information.</p>
    /// <p>For example, specify <code>ISSUED</code> to return only certificates with an
    /// <code>ISSUED</code> status.</p>
    /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
    /// request is made, regardless of their current status.</p>
    pub fn certificate_statuses(&self) -> std::option::Option<&[crate::model::CertificateStatus]> {
        self.certificate_statuses.as_deref()
    }
    /// <p>Indicates whether to include detailed information about the certificates in the
    /// response.</p>
    /// <p>When omitted, the response includes only the certificate names, Amazon Resource Names
    /// (ARNs), domain names, and tags.</p>
    pub fn include_certificate_details(&self) -> bool {
        self.include_certificate_details
    }
    /// <p>The name for the certificate for which to return information.</p>
    /// <p>When omitted, the response includes all of your certificates in the AWS Region where the
    /// request is made.</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
}
impl std::fmt::Debug for GetCertificatesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCertificatesInput");
        formatter.field("certificate_statuses", &self.certificate_statuses);
        formatter.field(
            "include_certificate_details",
            &self.include_certificate_details,
        );
        formatter.field("certificate_name", &self.certificate_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBundlesInput {
    /// <p>A Boolean value that indicates whether to include inactive bundle results in your
    /// request.</p>
    pub include_inactive: std::option::Option<bool>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetBundles</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetBundlesInput {
    /// <p>A Boolean value that indicates whether to include inactive bundle results in your
    /// request.</p>
    pub fn include_inactive(&self) -> std::option::Option<bool> {
        self.include_inactive
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetBundles</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetBundlesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBundlesInput");
        formatter.field("include_inactive", &self.include_inactive);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketsInput {
    /// <p>The name of the bucket for which to return information.</p>
    ///
    /// <p>When omitted, the response includes all of your buckets in the AWS Region where the
    /// request is made.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The token to advance to the next page of results from your request.</p>
    ///
    /// <p>To get a page token, perform an initial <code>GetBuckets</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
    /// <p>A Boolean value that indicates whether to include Lightsail instances that were given
    /// access to the bucket using the <a>SetResourceAccessForBucket</a> action.</p>
    pub include_connected_resources: std::option::Option<bool>,
}
impl GetBucketsInput {
    /// <p>The name of the bucket for which to return information.</p>
    ///
    /// <p>When omitted, the response includes all of your buckets in the AWS Region where the
    /// request is made.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    ///
    /// <p>To get a page token, perform an initial <code>GetBuckets</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
    /// <p>A Boolean value that indicates whether to include Lightsail instances that were given
    /// access to the bucket using the <a>SetResourceAccessForBucket</a> action.</p>
    pub fn include_connected_resources(&self) -> std::option::Option<bool> {
        self.include_connected_resources
    }
}
impl std::fmt::Debug for GetBucketsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketsInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("page_token", &self.page_token);
        formatter.field(
            "include_connected_resources",
            &self.include_connected_resources,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketMetricDataInput {
    /// <p>The name of the bucket for which to get metric data.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The metric for which you want to return information.</p>
    ///
    /// <p>Valid bucket metric names are listed below, along with the most useful statistics to
    /// include in your request, and the published unit value.</p>
    ///
    /// <note>
    /// <p>These bucket metrics are reported once per day.</p>
    /// </note>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BucketSizeBytes</code>
    /// </b> - The amount of data in
    /// bytes stored in a bucket. This value is calculated by summing the size of all objects in
    /// the bucket (including object versions), including the size of all parts for all incomplete
    /// multipart uploads to the bucket.</p>
    /// <p>Statistics: The most useful statistic is <code>Maximum</code>.</p>
    /// <p>Unit: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NumberOfObjects</code>
    /// </b> - The total number of
    /// objects stored in a bucket. This value is calculated by counting all objects in the bucket
    /// (including object versions) and the total number of parts for all incomplete multipart
    /// uploads to the bucket.</p>
    /// <p>Statistics: The most useful statistic is <code>Average</code>.</p>
    /// <p>Unit: The published unit is <code>Count</code>.</p>
    /// </li>
    /// </ul>
    pub metric_name: std::option::Option<crate::model::BucketMetricName>,
    /// <p>The timestamp indicating the earliest data to be returned.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The timestamp indicating the latest data to be returned.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The granularity, in seconds, of the returned data points.</p>
    /// <note>
    /// <p>Bucket storage metrics are reported once per day. Therefore, you should specify a period
    /// of 86400 seconds, which is the number of seconds in a day.</p>
    /// </note>
    pub period: i32,
    /// <p>The statistic for the metric.</p>
    ///
    /// <p>The following statistics are available:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - The sum of all values submitted for the matching metric. You can
    /// use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
    /// the specified period. By comparing this statistic with the <code>Minimum</code> and
    /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
    /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::MetricStatistic>>,
    /// <p>The unit for the metric data request.</p>
    /// <p>Valid units depend on the metric data being requested. For the valid units with each
    /// available metric, see the <code>metricName</code> parameter.</p>
    pub unit: std::option::Option<crate::model::MetricUnit>,
}
impl GetBucketMetricDataInput {
    /// <p>The name of the bucket for which to get metric data.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The metric for which you want to return information.</p>
    ///
    /// <p>Valid bucket metric names are listed below, along with the most useful statistics to
    /// include in your request, and the published unit value.</p>
    ///
    /// <note>
    /// <p>These bucket metrics are reported once per day.</p>
    /// </note>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <b>
    /// <code>BucketSizeBytes</code>
    /// </b> - The amount of data in
    /// bytes stored in a bucket. This value is calculated by summing the size of all objects in
    /// the bucket (including object versions), including the size of all parts for all incomplete
    /// multipart uploads to the bucket.</p>
    /// <p>Statistics: The most useful statistic is <code>Maximum</code>.</p>
    /// <p>Unit: The published unit is <code>Bytes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>
    /// <code>NumberOfObjects</code>
    /// </b> - The total number of
    /// objects stored in a bucket. This value is calculated by counting all objects in the bucket
    /// (including object versions) and the total number of parts for all incomplete multipart
    /// uploads to the bucket.</p>
    /// <p>Statistics: The most useful statistic is <code>Average</code>.</p>
    /// <p>Unit: The published unit is <code>Count</code>.</p>
    /// </li>
    /// </ul>
    pub fn metric_name(&self) -> std::option::Option<&crate::model::BucketMetricName> {
        self.metric_name.as_ref()
    }
    /// <p>The timestamp indicating the earliest data to be returned.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.start_time.as_ref()
    }
    /// <p>The timestamp indicating the latest data to be returned.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.end_time.as_ref()
    }
    /// <p>The granularity, in seconds, of the returned data points.</p>
    /// <note>
    /// <p>Bucket storage metrics are reported once per day. Therefore, you should specify a period
    /// of 86400 seconds, which is the number of seconds in a day.</p>
    /// </note>
    pub fn period(&self) -> i32 {
        self.period
    }
    /// <p>The statistic for the metric.</p>
    ///
    /// <p>The following statistics are available:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Minimum</code> - The lowest value observed during the specified period. Use this
    /// value to determine low volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> - The highest value observed during the specified period. Use
    /// this value to determine high volumes of activity for your application.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> - The sum of all values submitted for the matching metric. You can
    /// use this statistic to determine the total volume of a metric.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> - The value of <code>Sum</code> / <code>SampleCount</code> during
    /// the specified period. By comparing this statistic with the <code>Minimum</code> and
    /// <code>Maximum</code> values, you can determine the full scope of a metric and how close
    /// the average use is to the <code>Minimum</code> and <code>Maximum</code> values. This
    /// comparison helps you to know when to increase or decrease your resources.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> - The count, or number, of data points used for the
    /// statistical calculation.</p>
    /// </li>
    /// </ul>
    pub fn statistics(&self) -> std::option::Option<&[crate::model::MetricStatistic]> {
        self.statistics.as_deref()
    }
    /// <p>The unit for the metric data request.</p>
    /// <p>Valid units depend on the metric data being requested. For the valid units with each
    /// available metric, see the <code>metricName</code> parameter.</p>
    pub fn unit(&self) -> std::option::Option<&crate::model::MetricUnit> {
        self.unit.as_ref()
    }
}
impl std::fmt::Debug for GetBucketMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketMetricDataInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("period", &self.period);
        formatter.field("statistics", &self.statistics);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketBundlesInput {
    /// <p>A Boolean value that indicates whether to include inactive (unavailable) bundles in the
    /// response.</p>
    pub include_inactive: std::option::Option<bool>,
}
impl GetBucketBundlesInput {
    /// <p>A Boolean value that indicates whether to include inactive (unavailable) bundles in the
    /// response.</p>
    pub fn include_inactive(&self) -> std::option::Option<bool> {
        self.include_inactive
    }
}
impl std::fmt::Debug for GetBucketBundlesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketBundlesInput");
        formatter.field("include_inactive", &self.include_inactive);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBucketAccessKeysInput {
    /// <p>The name of the bucket for which to return access keys.</p>
    pub bucket_name: std::option::Option<std::string::String>,
}
impl GetBucketAccessKeysInput {
    /// <p>The name of the bucket for which to return access keys.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
}
impl std::fmt::Debug for GetBucketAccessKeysInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBucketAccessKeysInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBlueprintsInput {
    /// <p>A Boolean value indicating whether to include inactive results in your request.</p>
    pub include_inactive: std::option::Option<bool>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetBlueprints</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetBlueprintsInput {
    /// <p>A Boolean value indicating whether to include inactive results in your request.</p>
    pub fn include_inactive(&self) -> std::option::Option<bool> {
        self.include_inactive
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetBlueprints</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetBlueprintsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBlueprintsInput");
        formatter.field("include_inactive", &self.include_inactive);
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAutoSnapshotsInput {
    /// <p>The name of the source instance or disk from which to get automatic snapshot
    /// information.</p>
    pub resource_name: std::option::Option<std::string::String>,
}
impl GetAutoSnapshotsInput {
    /// <p>The name of the source instance or disk from which to get automatic snapshot
    /// information.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
}
impl std::fmt::Debug for GetAutoSnapshotsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAutoSnapshotsInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAlarmsInput {
    /// <p>The name of the alarm.</p>
    /// <p>Specify an alarm name to return information about a specific alarm.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetAlarms</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
    /// <p>The name of the Lightsail resource being monitored by the alarm.</p>
    /// <p>Specify a monitored resource name to return information about all alarms for a specific
    /// resource.</p>
    pub monitored_resource_name: std::option::Option<std::string::String>,
}
impl GetAlarmsInput {
    /// <p>The name of the alarm.</p>
    /// <p>Specify an alarm name to return information about a specific alarm.</p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetAlarms</code> request. If your results
    /// are paginated, the response will return a next page token that you can specify as the page
    /// token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
    /// <p>The name of the Lightsail resource being monitored by the alarm.</p>
    /// <p>Specify a monitored resource name to return information about all alarms for a specific
    /// resource.</p>
    pub fn monitored_resource_name(&self) -> std::option::Option<&str> {
        self.monitored_resource_name.as_deref()
    }
}
impl std::fmt::Debug for GetAlarmsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAlarmsInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("page_token", &self.page_token);
        formatter.field("monitored_resource_name", &self.monitored_resource_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetActiveNamesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetActiveNames</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub page_token: std::option::Option<std::string::String>,
}
impl GetActiveNamesInput {
    /// <p>The token to advance to the next page of results from your request.</p>
    /// <p>To get a page token, perform an initial <code>GetActiveNames</code> request. If your
    /// results are paginated, the response will return a next page token that you can specify as the
    /// page token in a subsequent request.</p>
    pub fn page_token(&self) -> std::option::Option<&str> {
        self.page_token.as_deref()
    }
}
impl std::fmt::Debug for GetActiveNamesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetActiveNamesInput");
        formatter.field("page_token", &self.page_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportSnapshotInput {
    /// <p>The name of the instance or disk snapshot to be exported to Amazon EC2.</p>
    pub source_snapshot_name: std::option::Option<std::string::String>,
}
impl ExportSnapshotInput {
    /// <p>The name of the instance or disk snapshot to be exported to Amazon EC2.</p>
    pub fn source_snapshot_name(&self) -> std::option::Option<&str> {
        self.source_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for ExportSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportSnapshotInput");
        formatter.field("source_snapshot_name", &self.source_snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableAddOnInput {
    /// <p>The name of the source resource for which to enable or modify the add-on.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>An array of strings representing the add-on to enable or modify.</p>
    pub add_on_request: std::option::Option<crate::model::AddOnRequest>,
}
impl EnableAddOnInput {
    /// <p>The name of the source resource for which to enable or modify the add-on.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>An array of strings representing the add-on to enable or modify.</p>
    pub fn add_on_request(&self) -> std::option::Option<&crate::model::AddOnRequest> {
        self.add_on_request.as_ref()
    }
}
impl std::fmt::Debug for EnableAddOnInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableAddOnInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.field("add_on_request", &self.add_on_request);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DownloadDefaultKeyPairInput {}
impl std::fmt::Debug for DownloadDefaultKeyPairInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DownloadDefaultKeyPairInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableAddOnInput {
    /// <p>The add-on type to disable.</p>
    pub add_on_type: std::option::Option<crate::model::AddOnType>,
    /// <p>The name of the source resource for which to disable the add-on.</p>
    pub resource_name: std::option::Option<std::string::String>,
}
impl DisableAddOnInput {
    /// <p>The add-on type to disable.</p>
    pub fn add_on_type(&self) -> std::option::Option<&crate::model::AddOnType> {
        self.add_on_type.as_ref()
    }
    /// <p>The name of the source resource for which to disable the add-on.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
}
impl std::fmt::Debug for DisableAddOnInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableAddOnInput");
        formatter.field("add_on_type", &self.add_on_type);
        formatter.field("resource_name", &self.resource_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachStaticIpInput {
    /// <p>The name of the static IP to detach from the instance.</p>
    pub static_ip_name: std::option::Option<std::string::String>,
}
impl DetachStaticIpInput {
    /// <p>The name of the static IP to detach from the instance.</p>
    pub fn static_ip_name(&self) -> std::option::Option<&str> {
        self.static_ip_name.as_deref()
    }
}
impl std::fmt::Debug for DetachStaticIpInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachStaticIpInput");
        formatter.field("static_ip_name", &self.static_ip_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachInstancesFromLoadBalancerInput {
    /// <p>The name of the Lightsail load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>An array of strings containing the names of the instances you want to detach from the load
    /// balancer.</p>
    pub instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DetachInstancesFromLoadBalancerInput {
    /// <p>The name of the Lightsail load balancer.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>An array of strings containing the names of the instances you want to detach from the load
    /// balancer.</p>
    pub fn instance_names(&self) -> std::option::Option<&[std::string::String]> {
        self.instance_names.as_deref()
    }
}
impl std::fmt::Debug for DetachInstancesFromLoadBalancerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachInstancesFromLoadBalancerInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("instance_names", &self.instance_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachDiskInput {
    /// <p>The unique name of the disk you want to detach from your instance (e.g.,
    /// <code>my-disk</code>).</p>
    pub disk_name: std::option::Option<std::string::String>,
}
impl DetachDiskInput {
    /// <p>The unique name of the disk you want to detach from your instance (e.g.,
    /// <code>my-disk</code>).</p>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
}
impl std::fmt::Debug for DetachDiskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachDiskInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetachCertificateFromDistributionInput {
    /// <p>The name of the distribution from which to detach the certificate.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
}
impl DetachCertificateFromDistributionInput {
    /// <p>The name of the distribution from which to detach the certificate.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
}
impl std::fmt::Debug for DetachCertificateFromDistributionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetachCertificateFromDistributionInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRelationalDatabaseSnapshotInput {
    /// <p>The name of the database snapshot that you are deleting.</p>
    pub relational_database_snapshot_name: std::option::Option<std::string::String>,
}
impl DeleteRelationalDatabaseSnapshotInput {
    /// <p>The name of the database snapshot that you are deleting.</p>
    pub fn relational_database_snapshot_name(&self) -> std::option::Option<&str> {
        self.relational_database_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteRelationalDatabaseSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRelationalDatabaseSnapshotInput");
        formatter.field(
            "relational_database_snapshot_name",
            &self.relational_database_snapshot_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRelationalDatabaseInput {
    /// <p>The name of the database that you are deleting.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>Determines whether a final database snapshot is created before your database is deleted.
    /// If <code>true</code> is specified, no database snapshot is created. If <code>false</code> is
    /// specified, a database snapshot is created before your database is deleted.</p>
    /// <p>You must specify the <code>final relational database snapshot name</code> parameter if the
    /// <code>skip final snapshot</code> parameter is <code>false</code>.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub skip_final_snapshot: std::option::Option<bool>,
    /// <p>The name of the database snapshot created if <code>skip final snapshot</code> is
    /// <code>false</code>, which is the default value for that parameter.</p>
    /// <note>
    /// <p>Specifying this parameter and also specifying the <code>skip final snapshot</code>
    /// parameter to <code>true</code> results in an error.</p>
    /// </note>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub final_relational_database_snapshot_name: std::option::Option<std::string::String>,
}
impl DeleteRelationalDatabaseInput {
    /// <p>The name of the database that you are deleting.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>Determines whether a final database snapshot is created before your database is deleted.
    /// If <code>true</code> is specified, no database snapshot is created. If <code>false</code> is
    /// specified, a database snapshot is created before your database is deleted.</p>
    /// <p>You must specify the <code>final relational database snapshot name</code> parameter if the
    /// <code>skip final snapshot</code> parameter is <code>false</code>.</p>
    /// <p>Default: <code>false</code>
    /// </p>
    pub fn skip_final_snapshot(&self) -> std::option::Option<bool> {
        self.skip_final_snapshot
    }
    /// <p>The name of the database snapshot created if <code>skip final snapshot</code> is
    /// <code>false</code>, which is the default value for that parameter.</p>
    /// <note>
    /// <p>Specifying this parameter and also specifying the <code>skip final snapshot</code>
    /// parameter to <code>true</code> results in an error.</p>
    /// </note>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub fn final_relational_database_snapshot_name(&self) -> std::option::Option<&str> {
        self.final_relational_database_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("skip_final_snapshot", &self.skip_final_snapshot);
        formatter.field(
            "final_relational_database_snapshot_name",
            &self.final_relational_database_snapshot_name,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLoadBalancerTlsCertificateInput {
    /// <p>The load balancer name.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The SSL/TLS certificate name.</p>
    pub certificate_name: std::option::Option<std::string::String>,
    /// <p>When <code>true</code>, forces the deletion of an SSL/TLS certificate.</p>
    /// <p>There can be two certificates associated with a Lightsail load balancer: the primary and
    /// the backup. The <code>force</code> parameter is required when the primary SSL/TLS certificate
    /// is in use by an instance attached to the load balancer.</p>
    pub force: std::option::Option<bool>,
}
impl DeleteLoadBalancerTlsCertificateInput {
    /// <p>The load balancer name.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The SSL/TLS certificate name.</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
    /// <p>When <code>true</code>, forces the deletion of an SSL/TLS certificate.</p>
    /// <p>There can be two certificates associated with a Lightsail load balancer: the primary and
    /// the backup. The <code>force</code> parameter is required when the primary SSL/TLS certificate
    /// is in use by an instance attached to the load balancer.</p>
    pub fn force(&self) -> std::option::Option<bool> {
        self.force
    }
}
impl std::fmt::Debug for DeleteLoadBalancerTlsCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLoadBalancerTlsCertificateInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("certificate_name", &self.certificate_name);
        formatter.field("force", &self.force);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLoadBalancerInput {
    /// <p>The name of the load balancer you want to delete.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
}
impl DeleteLoadBalancerInput {
    /// <p>The name of the load balancer you want to delete.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteLoadBalancerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLoadBalancerInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteKnownHostKeysInput {
    /// <p>The name of the instance for which you want to reset the host key or certificate.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl DeleteKnownHostKeysInput {
    /// <p>The name of the instance for which you want to reset the host key or certificate.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteKnownHostKeysInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteKnownHostKeysInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteKeyPairInput {
    /// <p>The name of the key pair to delete.</p>
    pub key_pair_name: std::option::Option<std::string::String>,
}
impl DeleteKeyPairInput {
    /// <p>The name of the key pair to delete.</p>
    pub fn key_pair_name(&self) -> std::option::Option<&str> {
        self.key_pair_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteKeyPairInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteKeyPairInput");
        formatter.field("key_pair_name", &self.key_pair_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInstanceSnapshotInput {
    /// <p>The name of the snapshot to delete.</p>
    pub instance_snapshot_name: std::option::Option<std::string::String>,
}
impl DeleteInstanceSnapshotInput {
    /// <p>The name of the snapshot to delete.</p>
    pub fn instance_snapshot_name(&self) -> std::option::Option<&str> {
        self.instance_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteInstanceSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInstanceSnapshotInput");
        formatter.field("instance_snapshot_name", &self.instance_snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInstanceInput {
    /// <p>The name of the instance to delete.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
    pub force_delete_add_ons: std::option::Option<bool>,
}
impl DeleteInstanceInput {
    /// <p>The name of the instance to delete.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
    pub fn force_delete_add_ons(&self) -> std::option::Option<bool> {
        self.force_delete_add_ons
    }
}
impl std::fmt::Debug for DeleteInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInstanceInput");
        formatter.field("instance_name", &self.instance_name);
        formatter.field("force_delete_add_ons", &self.force_delete_add_ons);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDomainEntryInput {
    /// <p>The name of the domain entry to delete.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs containing information about your domain entries.</p>
    pub domain_entry: std::option::Option<crate::model::DomainEntry>,
}
impl DeleteDomainEntryInput {
    /// <p>The name of the domain entry to delete.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>An array of key-value pairs containing information about your domain entries.</p>
    pub fn domain_entry(&self) -> std::option::Option<&crate::model::DomainEntry> {
        self.domain_entry.as_ref()
    }
}
impl std::fmt::Debug for DeleteDomainEntryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDomainEntryInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("domain_entry", &self.domain_entry);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDomainInput {
    /// <p>The specific domain name to delete.</p>
    pub domain_name: std::option::Option<std::string::String>,
}
impl DeleteDomainInput {
    /// <p>The specific domain name to delete.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDistributionInput {
    /// <p>The name of the distribution to delete.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
}
impl DeleteDistributionInput {
    /// <p>The name of the distribution to delete.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteDistributionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDistributionInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDiskSnapshotInput {
    /// <p>The name of the disk snapshot you want to delete (e.g.,
    /// <code>my-disk-snapshot</code>).</p>
    pub disk_snapshot_name: std::option::Option<std::string::String>,
}
impl DeleteDiskSnapshotInput {
    /// <p>The name of the disk snapshot you want to delete (e.g.,
    /// <code>my-disk-snapshot</code>).</p>
    pub fn disk_snapshot_name(&self) -> std::option::Option<&str> {
        self.disk_snapshot_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteDiskSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDiskSnapshotInput");
        formatter.field("disk_snapshot_name", &self.disk_snapshot_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDiskInput {
    /// <p>The unique name of the disk you want to delete (e.g., <code>my-disk</code>).</p>
    pub disk_name: std::option::Option<std::string::String>,
    /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
    pub force_delete_add_ons: std::option::Option<bool>,
}
impl DeleteDiskInput {
    /// <p>The unique name of the disk you want to delete (e.g., <code>my-disk</code>).</p>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
    /// <p>A Boolean value to indicate whether to delete the enabled add-ons for the disk.</p>
    pub fn force_delete_add_ons(&self) -> std::option::Option<bool> {
        self.force_delete_add_ons
    }
}
impl std::fmt::Debug for DeleteDiskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDiskInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.field("force_delete_add_ons", &self.force_delete_add_ons);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteContainerServiceInput {
    /// <p>The name of the container service to delete.</p>
    pub service_name: std::option::Option<std::string::String>,
}
impl DeleteContainerServiceInput {
    /// <p>The name of the container service to delete.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteContainerServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteContainerServiceInput");
        formatter.field("service_name", &self.service_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteContainerImageInput {
    /// <p>The name of the container service for which to delete a registered container image.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The name of the container image to delete from the container service.</p>
    ///
    /// <p>Use the <code>GetContainerImages</code> action to get the name of the container images
    /// that are registered to a container service.</p>
    ///
    /// <note>
    /// <p>Container images sourced from your Lightsail container service, that are registered
    /// and stored on your service, start with a colon (<code>:</code>). For example,
    /// <code>:container-service-1.mystaticwebsite.1</code>. Container images sourced from a
    /// public registry like Docker Hub don't start with a colon. For example,
    /// <code>nginx:latest</code> or <code>nginx</code>.</p>
    /// </note>
    pub image: std::option::Option<std::string::String>,
}
impl DeleteContainerImageInput {
    /// <p>The name of the container service for which to delete a registered container image.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The name of the container image to delete from the container service.</p>
    ///
    /// <p>Use the <code>GetContainerImages</code> action to get the name of the container images
    /// that are registered to a container service.</p>
    ///
    /// <note>
    /// <p>Container images sourced from your Lightsail container service, that are registered
    /// and stored on your service, start with a colon (<code>:</code>). For example,
    /// <code>:container-service-1.mystaticwebsite.1</code>. Container images sourced from a
    /// public registry like Docker Hub don't start with a colon. For example,
    /// <code>nginx:latest</code> or <code>nginx</code>.</p>
    /// </note>
    pub fn image(&self) -> std::option::Option<&str> {
        self.image.as_deref()
    }
}
impl std::fmt::Debug for DeleteContainerImageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteContainerImageInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("image", &self.image);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteContactMethodInput {
    /// <p>The protocol that will be deleted, such as <code>Email</code> or <code>SMS</code> (text
    /// messaging).</p>
    /// <note>
    /// <p>To delete an <code>Email</code> and an <code>SMS</code> contact method if you added
    /// both, you must run separate <code>DeleteContactMethod</code> actions to delete each
    /// protocol.</p>
    /// </note>
    pub protocol: std::option::Option<crate::model::ContactProtocol>,
}
impl DeleteContactMethodInput {
    /// <p>The protocol that will be deleted, such as <code>Email</code> or <code>SMS</code> (text
    /// messaging).</p>
    /// <note>
    /// <p>To delete an <code>Email</code> and an <code>SMS</code> contact method if you added
    /// both, you must run separate <code>DeleteContactMethod</code> actions to delete each
    /// protocol.</p>
    /// </note>
    pub fn protocol(&self) -> std::option::Option<&crate::model::ContactProtocol> {
        self.protocol.as_ref()
    }
}
impl std::fmt::Debug for DeleteContactMethodInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteContactMethodInput");
        formatter.field("protocol", &self.protocol);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCertificateInput {
    /// <p>The name of the certificate to delete.</p>
    /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
    /// can specify.</p>
    pub certificate_name: std::option::Option<std::string::String>,
}
impl DeleteCertificateInput {
    /// <p>The name of the certificate to delete.</p>
    /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
    /// can specify.</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCertificateInput");
        formatter.field("certificate_name", &self.certificate_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketAccessKeyInput {
    /// <p>The name of the bucket that the access key belongs to.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The ID of the access key to delete.</p>
    ///
    /// <p>Use the <a>GetBucketAccessKeys</a> action to get a list of access key IDs that
    /// you can specify.</p>
    pub access_key_id: std::option::Option<std::string::String>,
}
impl DeleteBucketAccessKeyInput {
    /// <p>The name of the bucket that the access key belongs to.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The ID of the access key to delete.</p>
    ///
    /// <p>Use the <a>GetBucketAccessKeys</a> action to get a list of access key IDs that
    /// you can specify.</p>
    pub fn access_key_id(&self) -> std::option::Option<&str> {
        self.access_key_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteBucketAccessKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketAccessKeyInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("access_key_id", &self.access_key_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteBucketInput {
    /// <p>The name of the bucket to delete.</p>
    ///
    /// <p>Use the <a>GetBuckets</a> action to get a list of bucket names that you can
    /// specify.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>A Boolean value that indicates whether to force delete the bucket.</p>
    ///
    /// <p>You must force delete the bucket if it has one of the following conditions:</p>
    /// <ul>
    /// <li>
    /// <p>The bucket is the origin of a distribution.</p>
    /// </li>
    /// <li>
    /// <p>The bucket has instances that were granted access to it using the <a>SetResourceAccessForBucket</a> action.</p>
    /// </li>
    /// <li>
    /// <p>The bucket has objects.</p>
    /// </li>
    /// <li>
    /// <p>The bucket has access keys.</p>
    /// </li>
    /// </ul>
    ///
    /// <important>
    /// <p>Force deleting a bucket might impact other resources that rely on the bucket, such as
    /// instances, distributions, or software that use the issued access keys.</p>
    /// </important>
    pub force_delete: std::option::Option<bool>,
}
impl DeleteBucketInput {
    /// <p>The name of the bucket to delete.</p>
    ///
    /// <p>Use the <a>GetBuckets</a> action to get a list of bucket names that you can
    /// specify.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>A Boolean value that indicates whether to force delete the bucket.</p>
    ///
    /// <p>You must force delete the bucket if it has one of the following conditions:</p>
    /// <ul>
    /// <li>
    /// <p>The bucket is the origin of a distribution.</p>
    /// </li>
    /// <li>
    /// <p>The bucket has instances that were granted access to it using the <a>SetResourceAccessForBucket</a> action.</p>
    /// </li>
    /// <li>
    /// <p>The bucket has objects.</p>
    /// </li>
    /// <li>
    /// <p>The bucket has access keys.</p>
    /// </li>
    /// </ul>
    ///
    /// <important>
    /// <p>Force deleting a bucket might impact other resources that rely on the bucket, such as
    /// instances, distributions, or software that use the issued access keys.</p>
    /// </important>
    pub fn force_delete(&self) -> std::option::Option<bool> {
        self.force_delete
    }
}
impl std::fmt::Debug for DeleteBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteBucketInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("force_delete", &self.force_delete);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAutoSnapshotInput {
    /// <p>The name of the source instance or disk from which to delete the automatic
    /// snapshot.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The date of the automatic snapshot to delete in <code>YYYY-MM-DD</code> format. Use the
    /// <code>get auto snapshots</code> operation to get the available automatic snapshots for a
    /// resource.</p>
    pub date: std::option::Option<std::string::String>,
}
impl DeleteAutoSnapshotInput {
    /// <p>The name of the source instance or disk from which to delete the automatic
    /// snapshot.</p>
    pub fn resource_name(&self) -> std::option::Option<&str> {
        self.resource_name.as_deref()
    }
    /// <p>The date of the automatic snapshot to delete in <code>YYYY-MM-DD</code> format. Use the
    /// <code>get auto snapshots</code> operation to get the available automatic snapshots for a
    /// resource.</p>
    pub fn date(&self) -> std::option::Option<&str> {
        self.date.as_deref()
    }
}
impl std::fmt::Debug for DeleteAutoSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAutoSnapshotInput");
        formatter.field("resource_name", &self.resource_name);
        formatter.field("date", &self.date);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAlarmInput {
    /// <p>The name of the alarm to delete.</p>
    pub alarm_name: std::option::Option<std::string::String>,
}
impl DeleteAlarmInput {
    /// <p>The name of the alarm to delete.</p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
}
impl std::fmt::Debug for DeleteAlarmInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAlarmInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRelationalDatabaseSnapshotInput {
    /// <p>The name of the database on which to base your new snapshot.</p>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The name for your new database snapshot.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub relational_database_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateRelationalDatabaseSnapshotInput {
    /// <p>The name of the database on which to base your new snapshot.</p>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The name for your new database snapshot.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub fn relational_database_snapshot_name(&self) -> std::option::Option<&str> {
        self.relational_database_snapshot_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateRelationalDatabaseSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRelationalDatabaseSnapshotInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field(
            "relational_database_snapshot_name",
            &self.relational_database_snapshot_name,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRelationalDatabaseFromSnapshotInput {
    /// <p>The name to use for your new Lightsail database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which to create your new database. Use the
    /// <code>us-east-2a</code> case-sensitive format.</p>
    /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
    /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
    /// your request.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
    /// specifies a database that is available to resources outside of your Lightsail account. A
    /// value of <code>false</code> specifies a database that is available only to your Lightsail
    /// resources in the same region as your database.</p>
    pub publicly_accessible: std::option::Option<bool>,
    /// <p>The name of the database snapshot from which to create your new database.</p>
    pub relational_database_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
    /// your database.</p>
    /// <p>You can get a list of database bundle IDs by using the <code>get relational database
    /// bundles</code> operation.</p>
    /// <p>When creating a new database from a snapshot, you cannot choose a bundle that is smaller
    /// than the bundle of the source database.</p>
    pub relational_database_bundle_id: std::option::Option<std::string::String>,
    /// <p>The name of the source database.</p>
    pub source_relational_database_name: std::option::Option<std::string::String>,
    /// <p>The date and time to restore your database from.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be before the latest restorable time for the database.</p>
    /// </li>
    /// <li>
    /// <p>Cannot be specified if the <code>use latest restorable time</code> parameter is
    /// <code>true</code>.</p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a restore time of October 1, 2018, at 8 PM UTC, then
    /// you input <code>1538424000</code> as the restore time.</p>
    /// </li>
    /// </ul>
    pub restore_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>Specifies whether your database is restored from the latest backup time. A value of
    /// <code>true</code> restores from the latest backup time. </p>
    /// <p>Default: <code>false</code>
    /// </p>
    /// <p>Constraints: Cannot be specified if the <code>restore time</code> parameter is
    /// provided.</p>
    pub use_latest_restorable_time: std::option::Option<bool>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateRelationalDatabaseFromSnapshotInput {
    /// <p>The name to use for your new Lightsail database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The Availability Zone in which to create your new database. Use the
    /// <code>us-east-2a</code> case-sensitive format.</p>
    /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
    /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
    /// your request.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
    /// specifies a database that is available to resources outside of your Lightsail account. A
    /// value of <code>false</code> specifies a database that is available only to your Lightsail
    /// resources in the same region as your database.</p>
    pub fn publicly_accessible(&self) -> std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The name of the database snapshot from which to create your new database.</p>
    pub fn relational_database_snapshot_name(&self) -> std::option::Option<&str> {
        self.relational_database_snapshot_name.as_deref()
    }
    /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
    /// your database.</p>
    /// <p>You can get a list of database bundle IDs by using the <code>get relational database
    /// bundles</code> operation.</p>
    /// <p>When creating a new database from a snapshot, you cannot choose a bundle that is smaller
    /// than the bundle of the source database.</p>
    pub fn relational_database_bundle_id(&self) -> std::option::Option<&str> {
        self.relational_database_bundle_id.as_deref()
    }
    /// <p>The name of the source database.</p>
    pub fn source_relational_database_name(&self) -> std::option::Option<&str> {
        self.source_relational_database_name.as_deref()
    }
    /// <p>The date and time to restore your database from.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be before the latest restorable time for the database.</p>
    /// </li>
    /// <li>
    /// <p>Cannot be specified if the <code>use latest restorable time</code> parameter is
    /// <code>true</code>.</p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Specified in the Unix time format.</p>
    /// <p>For example, if you wish to use a restore time of October 1, 2018, at 8 PM UTC, then
    /// you input <code>1538424000</code> as the restore time.</p>
    /// </li>
    /// </ul>
    pub fn restore_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.restore_time.as_ref()
    }
    /// <p>Specifies whether your database is restored from the latest backup time. A value of
    /// <code>true</code> restores from the latest backup time. </p>
    /// <p>Default: <code>false</code>
    /// </p>
    /// <p>Constraints: Cannot be specified if the <code>restore time</code> parameter is
    /// provided.</p>
    pub fn use_latest_restorable_time(&self) -> std::option::Option<bool> {
        self.use_latest_restorable_time
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateRelationalDatabaseFromSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRelationalDatabaseFromSnapshotInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field(
            "relational_database_snapshot_name",
            &self.relational_database_snapshot_name,
        );
        formatter.field(
            "relational_database_bundle_id",
            &self.relational_database_bundle_id,
        );
        formatter.field(
            "source_relational_database_name",
            &self.source_relational_database_name,
        );
        formatter.field("restore_time", &self.restore_time);
        formatter.field(
            "use_latest_restorable_time",
            &self.use_latest_restorable_time,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRelationalDatabaseInput {
    /// <p>The name to use for your new Lightsail database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub relational_database_name: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which to create your new database. Use the
    /// <code>us-east-2a</code> case-sensitive format.</p>
    /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
    /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
    /// your request.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The blueprint ID for your new database. A blueprint describes the major engine version of
    /// a database.</p>
    /// <p>You can get a list of database blueprints IDs by using the <code>get relational database
    /// blueprints</code> operation.</p>
    pub relational_database_blueprint_id: std::option::Option<std::string::String>,
    /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
    /// your database.</p>
    /// <p>You can get a list of database bundle IDs by using the <code>get relational database
    /// bundles</code> operation.</p>
    pub relational_database_bundle_id: std::option::Option<std::string::String>,
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    /// <p>
    /// <b>MySQL</b>
    /// </p>
    /// <p>The name of the database to create when the Lightsail database resource is created. If
    /// this parameter isn't specified, no database is created in the database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain 1 to 64 letters or numbers.</p>
    /// </li>
    /// <li>
    /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
    /// (0- 9).</p>
    /// </li>
    /// <li>
    /// <p>Can't be a word reserved by the specified database engine.</p>
    /// <p>For more information about reserved words in MySQL, see the Keywords and Reserved
    /// Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>The name of the database to create when the Lightsail database resource is created. If
    /// this parameter isn't specified, a database named <code>postgres</code> is created in the
    /// database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain 1 to 63 letters or numbers.</p>
    /// </li>
    /// <li>
    /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
    /// (0- 9).</p>
    /// </li>
    /// <li>
    /// <p>Can't be a word reserved by the specified database engine.</p>
    /// <p>For more information about reserved words in PostgreSQL, see the SQL Key Words
    /// articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL
    /// 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
    /// 12</a>.</p>
    /// </li>
    /// </ul>
    pub master_database_name: std::option::Option<std::string::String>,
    /// <p>The name for the master user.</p>
    /// <p>
    /// <b>MySQL</b>
    /// </p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Required for MySQL.</p>
    /// </li>
    /// <li>
    /// <p>Must be 1 to 16 letters or numbers. Can contain underscores.</p>
    /// </li>
    /// <li>
    /// <p>First character must be a letter.</p>
    /// </li>
    /// <li>
    /// <p>Can't be a reserved word for the chosen database engine.</p>
    /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
    /// Reserved Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Required for PostgreSQL.</p>
    /// </li>
    /// <li>
    /// <p>Must be 1 to 63 letters or numbers. Can contain underscores.</p>
    /// </li>
    /// <li>
    /// <p>First character must be a letter.</p>
    /// </li>
    /// <li>
    /// <p>Can't be a reserved word for the chosen database engine.</p>
    /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
    /// Reserved Words articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL
    /// 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL
    /// 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
    /// 12</a>.</p>
    /// </li>
    /// </ul>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The password for the master user. The password can include any printable ASCII character
    /// except "/", """, or "@". It cannot contain spaces.</p>
    /// <p>
    /// <b>MySQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 41 characters.</p>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 128 characters.</p>
    pub master_user_password: std::option::Option<std::string::String>,
    /// <p>The daily time range during which automated backups are created for your new database if
    /// automated backups are enabled.</p>
    /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    /// AWS Region. For more information about the preferred backup window time blocks for each
    /// region, see the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Working With Backups</a> guide in the Amazon Relational Database Service (Amazon RDS) documentation.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
    /// <p>Example: <code>16:00-16:30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Must not conflict with the preferred maintenance window.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// </ul>
    pub preferred_backup_window: std::option::Option<std::string::String>,
    /// <p>The weekly time range during which system maintenance can occur on your new
    /// database.</p>
    /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    /// AWS Region, occurring on a random day of the week.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
    /// </li>
    /// <li>
    /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
    /// </p>
    /// </li>
    /// </ul>
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
    /// specifies a database that is available to resources outside of your Lightsail account. A
    /// value of <code>false</code> specifies a database that is available only to your Lightsail
    /// resources in the same region as your database.</p>
    pub publicly_accessible: std::option::Option<bool>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateRelationalDatabaseInput {
    /// <p>The name to use for your new Lightsail database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain from 2 to 255 alphanumeric characters, or hyphens.</p>
    /// </li>
    /// <li>
    /// <p>The first and last character must be a letter or number.</p>
    /// </li>
    /// </ul>
    pub fn relational_database_name(&self) -> std::option::Option<&str> {
        self.relational_database_name.as_deref()
    }
    /// <p>The Availability Zone in which to create your new database. Use the
    /// <code>us-east-2a</code> case-sensitive format.</p>
    /// <p>You can get a list of Availability Zones by using the <code>get regions</code> operation.
    /// Be sure to add the <code>include relational database Availability Zones</code> parameter to
    /// your request.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The blueprint ID for your new database. A blueprint describes the major engine version of
    /// a database.</p>
    /// <p>You can get a list of database blueprints IDs by using the <code>get relational database
    /// blueprints</code> operation.</p>
    pub fn relational_database_blueprint_id(&self) -> std::option::Option<&str> {
        self.relational_database_blueprint_id.as_deref()
    }
    /// <p>The bundle ID for your new database. A bundle describes the performance specifications for
    /// your database.</p>
    /// <p>You can get a list of database bundle IDs by using the <code>get relational database
    /// bundles</code> operation.</p>
    pub fn relational_database_bundle_id(&self) -> std::option::Option<&str> {
        self.relational_database_bundle_id.as_deref()
    }
    /// <p>The meaning of this parameter differs according to the database engine you use.</p>
    /// <p>
    /// <b>MySQL</b>
    /// </p>
    /// <p>The name of the database to create when the Lightsail database resource is created. If
    /// this parameter isn't specified, no database is created in the database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain 1 to 64 letters or numbers.</p>
    /// </li>
    /// <li>
    /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
    /// (0- 9).</p>
    /// </li>
    /// <li>
    /// <p>Can't be a word reserved by the specified database engine.</p>
    /// <p>For more information about reserved words in MySQL, see the Keywords and Reserved
    /// Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, and <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>The name of the database to create when the Lightsail database resource is created. If
    /// this parameter isn't specified, a database named <code>postgres</code> is created in the
    /// database resource.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must contain 1 to 63 letters or numbers.</p>
    /// </li>
    /// <li>
    /// <p>Must begin with a letter. Subsequent characters can be letters, underscores, or digits
    /// (0- 9).</p>
    /// </li>
    /// <li>
    /// <p>Can't be a word reserved by the specified database engine.</p>
    /// <p>For more information about reserved words in PostgreSQL, see the SQL Key Words
    /// articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL
    /// 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
    /// 12</a>.</p>
    /// </li>
    /// </ul>
    pub fn master_database_name(&self) -> std::option::Option<&str> {
        self.master_database_name.as_deref()
    }
    /// <p>The name for the master user.</p>
    /// <p>
    /// <b>MySQL</b>
    /// </p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Required for MySQL.</p>
    /// </li>
    /// <li>
    /// <p>Must be 1 to 16 letters or numbers. Can contain underscores.</p>
    /// </li>
    /// <li>
    /// <p>First character must be a letter.</p>
    /// </li>
    /// <li>
    /// <p>Can't be a reserved word for the chosen database engine.</p>
    /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
    /// Reserved Words articles for <a href="https://dev.mysql.com/doc/refman/5.6/en/keywords.html">MySQL 5.6</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">MySQL 5.7</a>, or <a href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">MySQL 8.0</a>.</p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Required for PostgreSQL.</p>
    /// </li>
    /// <li>
    /// <p>Must be 1 to 63 letters or numbers. Can contain underscores.</p>
    /// </li>
    /// <li>
    /// <p>First character must be a letter.</p>
    /// </li>
    /// <li>
    /// <p>Can't be a reserved word for the chosen database engine.</p>
    /// <p>For more information about reserved words in MySQL 5.6 or 5.7, see the Keywords and
    /// Reserved Words articles for <a href="https://www.postgresql.org/docs/9.6/sql-keywords-appendix.html">PostgreSQL
    /// 9.6</a>, <a href="https://www.postgresql.org/docs/10/sql-keywords-appendix.html">PostgreSQL 10</a>, <a href="https://www.postgresql.org/docs/11/sql-keywords-appendix.html">PostgreSQL
    /// 11</a>, and <a href="https://www.postgresql.org/docs/12/sql-keywords-appendix.html">PostgreSQL
    /// 12</a>.</p>
    /// </li>
    /// </ul>
    pub fn master_username(&self) -> std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>The password for the master user. The password can include any printable ASCII character
    /// except "/", """, or "@". It cannot contain spaces.</p>
    /// <p>
    /// <b>MySQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 41 characters.</p>
    /// <p>
    /// <b>PostgreSQL</b>
    /// </p>
    /// <p>Constraints: Must contain from 8 to 128 characters.</p>
    pub fn master_user_password(&self) -> std::option::Option<&str> {
        self.master_user_password.as_deref()
    }
    /// <p>The daily time range during which automated backups are created for your new database if
    /// automated backups are enabled.</p>
    /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    /// AWS Region. For more information about the preferred backup window time blocks for each
    /// region, see the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Working With Backups</a> guide in the Amazon Relational Database Service (Amazon RDS) documentation.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>hh24:mi-hh24:mi</code> format.</p>
    /// <p>Example: <code>16:00-16:30</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Must not conflict with the preferred maintenance window.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// </ul>
    pub fn preferred_backup_window(&self) -> std::option::Option<&str> {
        self.preferred_backup_window.as_deref()
    }
    /// <p>The weekly time range during which system maintenance can occur on your new
    /// database.</p>
    /// <p>The default is a 30-minute window selected at random from an 8-hour block of time for each
    /// AWS Region, occurring on a random day of the week.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be in the <code>ddd:hh24:mi-ddd:hh24:mi</code> format.</p>
    /// </li>
    /// <li>
    /// <p>Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.</p>
    /// </li>
    /// <li>
    /// <p>Must be at least 30 minutes.</p>
    /// </li>
    /// <li>
    /// <p>Specified in Coordinated Universal Time (UTC).</p>
    /// </li>
    /// <li>
    /// <p>Example: <code>Tue:17:00-Tue:17:30</code>
    /// </p>
    /// </li>
    /// </ul>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>Specifies the accessibility options for your new database. A value of <code>true</code>
    /// specifies a database that is available to resources outside of your Lightsail account. A
    /// value of <code>false</code> specifies a database that is available only to your Lightsail
    /// resources in the same region as your database.</p>
    pub fn publicly_accessible(&self) -> std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateRelationalDatabaseInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRelationalDatabaseInput");
        formatter.field("relational_database_name", &self.relational_database_name);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field(
            "relational_database_blueprint_id",
            &self.relational_database_blueprint_id,
        );
        formatter.field(
            "relational_database_bundle_id",
            &self.relational_database_bundle_id,
        );
        formatter.field("master_database_name", &self.master_database_name);
        formatter.field("master_username", &self.master_username);
        formatter.field("master_user_password", &"*** Sensitive Data Redacted ***");
        formatter.field("preferred_backup_window", &self.preferred_backup_window);
        formatter.field(
            "preferred_maintenance_window",
            &self.preferred_maintenance_window,
        );
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLoadBalancerTlsCertificateInput {
    /// <p>The load balancer name where you want to create the SSL/TLS certificate.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The SSL/TLS certificate name.</p>
    /// <p>You can have up to 10 certificates in your account at one time. Each Lightsail load
    /// balancer can have up to 2 certificates associated with it at one time. There is also an
    /// overall limit to the number of certificates that can be issue in a 365-day period. For more
    /// information, see <a href="http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Limits</a>.</p>
    pub certificate_name: std::option::Option<std::string::String>,
    /// <p>The domain name (e.g., <code>example.com</code>) for your SSL/TLS certificate.</p>
    pub certificate_domain_name: std::option::Option<std::string::String>,
    /// <p>An array of strings listing alternative domains and subdomains for your SSL/TLS
    /// certificate. Lightsail will de-dupe the names for you. You can have a maximum of 9
    /// alternative names (in addition to the 1 primary domain). We do not support wildcards (e.g.,
    /// <code>*.example.com</code>).</p>
    pub certificate_alternative_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateLoadBalancerTlsCertificateInput {
    /// <p>The load balancer name where you want to create the SSL/TLS certificate.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The SSL/TLS certificate name.</p>
    /// <p>You can have up to 10 certificates in your account at one time. Each Lightsail load
    /// balancer can have up to 2 certificates associated with it at one time. There is also an
    /// overall limit to the number of certificates that can be issue in a 365-day period. For more
    /// information, see <a href="http://docs.aws.amazon.com/acm/latest/userguide/acm-limits.html">Limits</a>.</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
    /// <p>The domain name (e.g., <code>example.com</code>) for your SSL/TLS certificate.</p>
    pub fn certificate_domain_name(&self) -> std::option::Option<&str> {
        self.certificate_domain_name.as_deref()
    }
    /// <p>An array of strings listing alternative domains and subdomains for your SSL/TLS
    /// certificate. Lightsail will de-dupe the names for you. You can have a maximum of 9
    /// alternative names (in addition to the 1 primary domain). We do not support wildcards (e.g.,
    /// <code>*.example.com</code>).</p>
    pub fn certificate_alternative_names(&self) -> std::option::Option<&[std::string::String]> {
        self.certificate_alternative_names.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateLoadBalancerTlsCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLoadBalancerTlsCertificateInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("certificate_name", &self.certificate_name);
        formatter.field("certificate_domain_name", &self.certificate_domain_name);
        formatter.field(
            "certificate_alternative_names",
            &self.certificate_alternative_names,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLoadBalancerInput {
    /// <p>The name of your load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The instance port where you're creating your load balancer.</p>
    pub instance_port: i32,
    /// <p>The path you provided to perform the load balancer health check. If you didn't specify a
    /// health check path, Lightsail uses the root path of your website (e.g.,
    /// <code>"/"</code>).</p>
    /// <p>You may want to specify a custom health check path other than the root of your application
    /// if your home page loads slowly or has a lot of media or scripting on it.</p>
    pub health_check_path: std::option::Option<std::string::String>,
    /// <p>The name of the SSL/TLS certificate.</p>
    /// <p>If you specify <code>certificateName</code>, then <code>certificateDomainName</code> is
    /// required (and vice-versa).</p>
    pub certificate_name: std::option::Option<std::string::String>,
    /// <p>The domain name with which your certificate is associated (e.g.,
    /// <code>example.com</code>).</p>
    /// <p>If you specify <code>certificateDomainName</code>, then <code>certificateName</code> is
    /// required (and vice-versa).</p>
    pub certificate_domain_name: std::option::Option<std::string::String>,
    /// <p>The optional alternative domains and subdomains to use with your SSL/TLS certificate
    /// (e.g., <code>www.example.com</code>, <code>example.com</code>, <code>m.example.com</code>,
    /// <code>blog.example.com</code>).</p>
    pub certificate_alternative_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The IP address type for the load balancer.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub ip_address_type: std::option::Option<crate::model::IpAddressType>,
}
impl CreateLoadBalancerInput {
    /// <p>The name of your load balancer.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The instance port where you're creating your load balancer.</p>
    pub fn instance_port(&self) -> i32 {
        self.instance_port
    }
    /// <p>The path you provided to perform the load balancer health check. If you didn't specify a
    /// health check path, Lightsail uses the root path of your website (e.g.,
    /// <code>"/"</code>).</p>
    /// <p>You may want to specify a custom health check path other than the root of your application
    /// if your home page loads slowly or has a lot of media or scripting on it.</p>
    pub fn health_check_path(&self) -> std::option::Option<&str> {
        self.health_check_path.as_deref()
    }
    /// <p>The name of the SSL/TLS certificate.</p>
    /// <p>If you specify <code>certificateName</code>, then <code>certificateDomainName</code> is
    /// required (and vice-versa).</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
    /// <p>The domain name with which your certificate is associated (e.g.,
    /// <code>example.com</code>).</p>
    /// <p>If you specify <code>certificateDomainName</code>, then <code>certificateName</code> is
    /// required (and vice-versa).</p>
    pub fn certificate_domain_name(&self) -> std::option::Option<&str> {
        self.certificate_domain_name.as_deref()
    }
    /// <p>The optional alternative domains and subdomains to use with your SSL/TLS certificate
    /// (e.g., <code>www.example.com</code>, <code>example.com</code>, <code>m.example.com</code>,
    /// <code>blog.example.com</code>).</p>
    pub fn certificate_alternative_names(&self) -> std::option::Option<&[std::string::String]> {
        self.certificate_alternative_names.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The IP address type for the load balancer.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub fn ip_address_type(&self) -> std::option::Option<&crate::model::IpAddressType> {
        self.ip_address_type.as_ref()
    }
}
impl std::fmt::Debug for CreateLoadBalancerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLoadBalancerInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("instance_port", &self.instance_port);
        formatter.field("health_check_path", &self.health_check_path);
        formatter.field("certificate_name", &self.certificate_name);
        formatter.field("certificate_domain_name", &self.certificate_domain_name);
        formatter.field(
            "certificate_alternative_names",
            &self.certificate_alternative_names,
        );
        formatter.field("tags", &self.tags);
        formatter.field("ip_address_type", &self.ip_address_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateKeyPairInput {
    /// <p>The name for your new key pair.</p>
    pub key_pair_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateKeyPairInput {
    /// <p>The name for your new key pair.</p>
    pub fn key_pair_name(&self) -> std::option::Option<&str> {
        self.key_pair_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateKeyPairInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateKeyPairInput");
        formatter.field("key_pair_name", &self.key_pair_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInstanceSnapshotInput {
    /// <p>The name for your new snapshot.</p>
    pub instance_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The Lightsail instance on which to base your snapshot.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateInstanceSnapshotInput {
    /// <p>The name for your new snapshot.</p>
    pub fn instance_snapshot_name(&self) -> std::option::Option<&str> {
        self.instance_snapshot_name.as_deref()
    }
    /// <p>The Lightsail instance on which to base your snapshot.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateInstanceSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInstanceSnapshotInput");
        formatter.field("instance_snapshot_name", &self.instance_snapshot_name);
        formatter.field("instance_name", &self.instance_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInstancesFromSnapshotInput {
    /// <p>The names for your new instances.</p>
    pub instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An object containing information about one or more disk mappings.</p>
    pub attached_disk_mapping: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::DiskMap>>,
    >,
    /// <p>The Availability Zone where you want to create your instances. Use the following
    /// formatting: <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones
    /// by using the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
    /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
    /// parameter to your request.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The name of the instance snapshot on which you are basing your new instances. Use the get
    /// instance snapshots operation to return information about your existing snapshots.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>source instance name</code>
    /// parameter. The <code>instance snapshot name</code> and <code>source instance name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// </ul>
    pub instance_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The bundle of specification information for your virtual private server (or
    /// <i>instance</i>), including the pricing plan (e.g.,
    /// <code>micro_1_0</code>).</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>You can create a launch script that configures a server with additional user data. For
    /// example, <code>apt-get -y update</code>.</p>
    /// <note>
    /// <p>Depending on the machine image you choose, the command to get software on your instance
    /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
    /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
    /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
    /// </note>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The name for your key pair.</p>
    pub key_pair_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
    pub add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
    /// <p>The IP address type for the instance.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub ip_address_type: std::option::Option<crate::model::IpAddressType>,
    /// <p>The name of the source instance from which the source automatic snapshot was
    /// created.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>instance snapshot name</code>
    /// parameter. The <code>source instance name</code> and <code>instance snapshot name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub source_instance_name: std::option::Option<std::string::String>,
    /// <p>The date of the automatic snapshot to use for the new instance. Use the <code>get auto
    /// snapshots</code> operation to identify the dates of the available automatic
    /// snapshots.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
    /// </li>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
    /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
    /// auto snapshot</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub restore_date: std::option::Option<std::string::String>,
    /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>restore date</code>
    /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
    /// date</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub use_latest_restorable_auto_snapshot: std::option::Option<bool>,
}
impl CreateInstancesFromSnapshotInput {
    /// <p>The names for your new instances.</p>
    pub fn instance_names(&self) -> std::option::Option<&[std::string::String]> {
        self.instance_names.as_deref()
    }
    /// <p>An object containing information about one or more disk mappings.</p>
    pub fn attached_disk_mapping(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::DiskMap>>,
    > {
        self.attached_disk_mapping.as_ref()
    }
    /// <p>The Availability Zone where you want to create your instances. Use the following
    /// formatting: <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones
    /// by using the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
    /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
    /// parameter to your request.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The name of the instance snapshot on which you are basing your new instances. Use the get
    /// instance snapshots operation to return information about your existing snapshots.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>source instance name</code>
    /// parameter. The <code>instance snapshot name</code> and <code>source instance name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// </ul>
    pub fn instance_snapshot_name(&self) -> std::option::Option<&str> {
        self.instance_snapshot_name.as_deref()
    }
    /// <p>The bundle of specification information for your virtual private server (or
    /// <i>instance</i>), including the pricing plan (e.g.,
    /// <code>micro_1_0</code>).</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>You can create a launch script that configures a server with additional user data. For
    /// example, <code>apt-get -y update</code>.</p>
    /// <note>
    /// <p>Depending on the machine image you choose, the command to get software on your instance
    /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
    /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
    /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
    /// </note>
    pub fn user_data(&self) -> std::option::Option<&str> {
        self.user_data.as_deref()
    }
    /// <p>The name for your key pair.</p>
    pub fn key_pair_name(&self) -> std::option::Option<&str> {
        self.key_pair_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
    pub fn add_ons(&self) -> std::option::Option<&[crate::model::AddOnRequest]> {
        self.add_ons.as_deref()
    }
    /// <p>The IP address type for the instance.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub fn ip_address_type(&self) -> std::option::Option<&crate::model::IpAddressType> {
        self.ip_address_type.as_ref()
    }
    /// <p>The name of the source instance from which the source automatic snapshot was
    /// created.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>instance snapshot name</code>
    /// parameter. The <code>source instance name</code> and <code>instance snapshot name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn source_instance_name(&self) -> std::option::Option<&str> {
        self.source_instance_name.as_deref()
    }
    /// <p>The date of the automatic snapshot to use for the new instance. Use the <code>get auto
    /// snapshots</code> operation to identify the dates of the available automatic
    /// snapshots.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
    /// </li>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
    /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
    /// auto snapshot</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn restore_date(&self) -> std::option::Option<&str> {
        self.restore_date.as_deref()
    }
    /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>restore date</code>
    /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
    /// date</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new instance from an automatic snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn use_latest_restorable_auto_snapshot(&self) -> std::option::Option<bool> {
        self.use_latest_restorable_auto_snapshot
    }
}
impl std::fmt::Debug for CreateInstancesFromSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInstancesFromSnapshotInput");
        formatter.field("instance_names", &self.instance_names);
        formatter.field("attached_disk_mapping", &self.attached_disk_mapping);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("instance_snapshot_name", &self.instance_snapshot_name);
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("user_data", &self.user_data);
        formatter.field("key_pair_name", &self.key_pair_name);
        formatter.field("tags", &self.tags);
        formatter.field("add_ons", &self.add_ons);
        formatter.field("ip_address_type", &self.ip_address_type);
        formatter.field("source_instance_name", &self.source_instance_name);
        formatter.field("restore_date", &self.restore_date);
        formatter.field(
            "use_latest_restorable_auto_snapshot",
            &self.use_latest_restorable_auto_snapshot,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateInstancesInput {
    /// <p>The names to use for your new Lightsail instances. Separate multiple values using
    /// quotation marks and commas, for example:
    /// <code>["MyFirstInstance","MySecondInstance"]</code>
    /// </p>
    pub instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Availability Zone in which to create your instance. Use the following format:
    /// <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones by using
    /// the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
    /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
    /// parameter to your request.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>(Deprecated) The name for your custom image.</p>
    /// <note>
    /// <p>In releases prior to June 12, 2017, this parameter was ignored by the API. It is now
    /// deprecated.</p>
    /// </note>
    pub custom_image_name: std::option::Option<std::string::String>,
    /// <p>The ID for a virtual private server image (e.g., <code>app_wordpress_4_4</code> or
    /// <code>app_lamp_7_0</code>). Use the <code>get blueprints</code> operation to return a list
    /// of available images (or <i>blueprints</i>).</p>
    /// <note>
    /// <p>Use active blueprints when creating new instances. Inactive blueprints are listed to
    /// support customers with existing instances and are not necessarily available to create new
    /// instances. Blueprints are marked inactive when they become outdated due to operating system
    /// updates or new application releases.</p>
    /// </note>
    pub blueprint_id: std::option::Option<std::string::String>,
    /// <p>The bundle of specification information for your virtual private server (or
    /// <i>instance</i>), including the pricing plan (e.g.,
    /// <code>micro_1_0</code>).</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>A launch script you can create that configures a server with additional user data. For
    /// example, you might want to run <code>apt-get -y update</code>.</p>
    /// <note>
    /// <p>Depending on the machine image you choose, the command to get software on your instance
    /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
    /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
    /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
    /// </note>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The name of your key pair.</p>
    pub key_pair_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
    pub add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
    /// <p>The IP address type for the instance.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub ip_address_type: std::option::Option<crate::model::IpAddressType>,
}
impl CreateInstancesInput {
    /// <p>The names to use for your new Lightsail instances. Separate multiple values using
    /// quotation marks and commas, for example:
    /// <code>["MyFirstInstance","MySecondInstance"]</code>
    /// </p>
    pub fn instance_names(&self) -> std::option::Option<&[std::string::String]> {
        self.instance_names.as_deref()
    }
    /// <p>The Availability Zone in which to create your instance. Use the following format:
    /// <code>us-east-2a</code> (case sensitive). You can get a list of Availability Zones by using
    /// the <a href="http://docs.aws.amazon.com/lightsail/2016-11-28/api-reference/API_GetRegions.html">get
    /// regions</a> operation. Be sure to add the <code>include Availability Zones</code>
    /// parameter to your request.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>(Deprecated) The name for your custom image.</p>
    /// <note>
    /// <p>In releases prior to June 12, 2017, this parameter was ignored by the API. It is now
    /// deprecated.</p>
    /// </note>
    pub fn custom_image_name(&self) -> std::option::Option<&str> {
        self.custom_image_name.as_deref()
    }
    /// <p>The ID for a virtual private server image (e.g., <code>app_wordpress_4_4</code> or
    /// <code>app_lamp_7_0</code>). Use the <code>get blueprints</code> operation to return a list
    /// of available images (or <i>blueprints</i>).</p>
    /// <note>
    /// <p>Use active blueprints when creating new instances. Inactive blueprints are listed to
    /// support customers with existing instances and are not necessarily available to create new
    /// instances. Blueprints are marked inactive when they become outdated due to operating system
    /// updates or new application releases.</p>
    /// </note>
    pub fn blueprint_id(&self) -> std::option::Option<&str> {
        self.blueprint_id.as_deref()
    }
    /// <p>The bundle of specification information for your virtual private server (or
    /// <i>instance</i>), including the pricing plan (e.g.,
    /// <code>micro_1_0</code>).</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>A launch script you can create that configures a server with additional user data. For
    /// example, you might want to run <code>apt-get -y update</code>.</p>
    /// <note>
    /// <p>Depending on the machine image you choose, the command to get software on your instance
    /// varies. Amazon Linux and CentOS use <code>yum</code>, Debian and Ubuntu use
    /// <code>apt-get</code>, and FreeBSD uses <code>pkg</code>. For a complete list, see the
    /// <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/compare-options-choose-lightsail-instance-image">Amazon Lightsail Developer Guide</a>.</p>
    /// </note>
    pub fn user_data(&self) -> std::option::Option<&str> {
        self.user_data.as_deref()
    }
    /// <p>The name of your key pair.</p>
    pub fn key_pair_name(&self) -> std::option::Option<&str> {
        self.key_pair_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>An array of objects representing the add-ons to enable for the new instance.</p>
    pub fn add_ons(&self) -> std::option::Option<&[crate::model::AddOnRequest]> {
        self.add_ons.as_deref()
    }
    /// <p>The IP address type for the instance.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub fn ip_address_type(&self) -> std::option::Option<&crate::model::IpAddressType> {
        self.ip_address_type.as_ref()
    }
}
impl std::fmt::Debug for CreateInstancesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateInstancesInput");
        formatter.field("instance_names", &self.instance_names);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("custom_image_name", &self.custom_image_name);
        formatter.field("blueprint_id", &self.blueprint_id);
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("user_data", &self.user_data);
        formatter.field("key_pair_name", &self.key_pair_name);
        formatter.field("tags", &self.tags);
        formatter.field("add_ons", &self.add_ons);
        formatter.field("ip_address_type", &self.ip_address_type);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDomainEntryInput {
    /// <p>The domain name (e.g., <code>example.com</code>) for which you want to create the domain
    /// entry.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>An array of key-value pairs containing information about the domain entry request.</p>
    pub domain_entry: std::option::Option<crate::model::DomainEntry>,
}
impl CreateDomainEntryInput {
    /// <p>The domain name (e.g., <code>example.com</code>) for which you want to create the domain
    /// entry.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>An array of key-value pairs containing information about the domain entry request.</p>
    pub fn domain_entry(&self) -> std::option::Option<&crate::model::DomainEntry> {
        self.domain_entry.as_ref()
    }
}
impl std::fmt::Debug for CreateDomainEntryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDomainEntryInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("domain_entry", &self.domain_entry);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDomainInput {
    /// <p>The domain name to manage (e.g., <code>example.com</code>).</p>
    /// <note>
    /// <p>You cannot register a new domain name using Lightsail. You must register a domain name
    /// using Amazon Route 53 or another domain name registrar. If you have already registered your
    /// domain, you can enter its name in this parameter to manage the DNS records for that domain
    /// using Lightsail.</p>
    /// </note>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDomainInput {
    /// <p>The domain name to manage (e.g., <code>example.com</code>).</p>
    /// <note>
    /// <p>You cannot register a new domain name using Lightsail. You must register a domain name
    /// using Amazon Route 53 or another domain name registrar. If you have already registered your
    /// domain, you can enter its name in this parameter to manage the DNS records for that domain
    /// using Lightsail.</p>
    /// </note>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDomainInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDomainInput");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDistributionInput {
    /// <p>The name for the distribution.</p>
    pub distribution_name: std::option::Option<std::string::String>,
    /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
    /// instance or load balancer.</p>
    /// <p>The distribution pulls, caches, and serves content from the origin.</p>
    pub origin: std::option::Option<crate::model::InputOrigin>,
    /// <p>An object that describes the default cache behavior for the distribution.</p>
    pub default_cache_behavior: std::option::Option<crate::model::CacheBehavior>,
    /// <p>An object that describes the cache behavior settings for the distribution.</p>
    pub cache_behavior_settings: std::option::Option<crate::model::CacheSettings>,
    /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
    pub cache_behaviors: std::option::Option<std::vec::Vec<crate::model::CacheBehaviorPerPath>>,
    /// <p>The bundle ID to use for the distribution.</p>
    /// <p>A distribution bundle describes the specifications of your distribution, such as the
    /// monthly cost and monthly network transfer quota.</p>
    /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
    /// IDs that you can specify.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The IP address type for the distribution.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub ip_address_type: std::option::Option<crate::model::IpAddressType>,
    /// <p>The tag keys and optional values to add to the distribution during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDistributionInput {
    /// <p>The name for the distribution.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
    /// <p>An object that describes the origin resource for the distribution, such as a Lightsail
    /// instance or load balancer.</p>
    /// <p>The distribution pulls, caches, and serves content from the origin.</p>
    pub fn origin(&self) -> std::option::Option<&crate::model::InputOrigin> {
        self.origin.as_ref()
    }
    /// <p>An object that describes the default cache behavior for the distribution.</p>
    pub fn default_cache_behavior(&self) -> std::option::Option<&crate::model::CacheBehavior> {
        self.default_cache_behavior.as_ref()
    }
    /// <p>An object that describes the cache behavior settings for the distribution.</p>
    pub fn cache_behavior_settings(&self) -> std::option::Option<&crate::model::CacheSettings> {
        self.cache_behavior_settings.as_ref()
    }
    /// <p>An array of objects that describe the per-path cache behavior for the distribution.</p>
    pub fn cache_behaviors(&self) -> std::option::Option<&[crate::model::CacheBehaviorPerPath]> {
        self.cache_behaviors.as_deref()
    }
    /// <p>The bundle ID to use for the distribution.</p>
    /// <p>A distribution bundle describes the specifications of your distribution, such as the
    /// monthly cost and monthly network transfer quota.</p>
    /// <p>Use the <code>GetDistributionBundles</code> action to get a list of distribution bundle
    /// IDs that you can specify.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>The IP address type for the distribution.</p>
    ///
    /// <p>The possible values are <code>ipv4</code> for IPv4 only, and <code>dualstack</code> for
    /// IPv4 and IPv6.</p>
    ///
    /// <p>The default value is <code>dualstack</code>.</p>
    pub fn ip_address_type(&self) -> std::option::Option<&crate::model::IpAddressType> {
        self.ip_address_type.as_ref()
    }
    /// <p>The tag keys and optional values to add to the distribution during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDistributionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDistributionInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.field("origin", &self.origin);
        formatter.field("default_cache_behavior", &self.default_cache_behavior);
        formatter.field("cache_behavior_settings", &self.cache_behavior_settings);
        formatter.field("cache_behaviors", &self.cache_behaviors);
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("ip_address_type", &self.ip_address_type);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDiskSnapshotInput {
    /// <p>The unique name of the source disk (e.g., <code>Disk-Virginia-1</code>).</p>
    /// <note>
    /// <p>This parameter cannot be defined together with the <code>instance name</code> parameter.
    /// The <code>disk name</code> and <code>instance name</code> parameters are mutually
    /// exclusive.</p>
    /// </note>
    pub disk_name: std::option::Option<std::string::String>,
    /// <p>The name of the destination disk snapshot (e.g., <code>my-disk-snapshot</code>) based on
    /// the source disk.</p>
    pub disk_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The unique name of the source instance (e.g., <code>Amazon_Linux-512MB-Virginia-1</code>).
    /// When this is defined, a snapshot of the instance's system volume is created.</p>
    /// <note>
    /// <p>This parameter cannot be defined together with the <code>disk name</code> parameter. The
    /// <code>instance name</code> and <code>disk name</code> parameters are mutually
    /// exclusive.</p>
    /// </note>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDiskSnapshotInput {
    /// <p>The unique name of the source disk (e.g., <code>Disk-Virginia-1</code>).</p>
    /// <note>
    /// <p>This parameter cannot be defined together with the <code>instance name</code> parameter.
    /// The <code>disk name</code> and <code>instance name</code> parameters are mutually
    /// exclusive.</p>
    /// </note>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
    /// <p>The name of the destination disk snapshot (e.g., <code>my-disk-snapshot</code>) based on
    /// the source disk.</p>
    pub fn disk_snapshot_name(&self) -> std::option::Option<&str> {
        self.disk_snapshot_name.as_deref()
    }
    /// <p>The unique name of the source instance (e.g., <code>Amazon_Linux-512MB-Virginia-1</code>).
    /// When this is defined, a snapshot of the instance's system volume is created.</p>
    /// <note>
    /// <p>This parameter cannot be defined together with the <code>disk name</code> parameter. The
    /// <code>instance name</code> and <code>disk name</code> parameters are mutually
    /// exclusive.</p>
    /// </note>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDiskSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDiskSnapshotInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.field("disk_snapshot_name", &self.disk_snapshot_name);
        formatter.field("instance_name", &self.instance_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDiskFromSnapshotInput {
    /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
    pub disk_name: std::option::Option<std::string::String>,
    /// <p>The name of the disk snapshot (e.g., <code>my-snapshot</code>) from which to create the
    /// new storage disk.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>source disk name</code>
    /// parameter. The <code>disk snapshot name</code> and <code>source disk name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// </ul>
    pub disk_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
    /// Choose the same Availability Zone as the Lightsail instance where you want to create the
    /// disk.</p>
    /// <p>Use the GetRegions operation to list the Availability Zones where Lightsail is currently
    /// available.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
    pub size_in_gb: std::option::Option<i32>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
    pub add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
    /// <p>The name of the source disk from which the source automatic snapshot was created.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>disk snapshot name</code>
    /// parameter. The <code>source disk name</code> and <code>disk snapshot name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
    /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub source_disk_name: std::option::Option<std::string::String>,
    /// <p>The date of the automatic snapshot to use for the new disk. Use the <code>get auto
    /// snapshots</code> operation to identify the dates of the available automatic
    /// snapshots.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
    /// </li>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
    /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
    /// auto snapshot</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
    /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub restore_date: std::option::Option<std::string::String>,
    /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>restore date</code>
    /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
    /// date</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
    /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub use_latest_restorable_auto_snapshot: std::option::Option<bool>,
}
impl CreateDiskFromSnapshotInput {
    /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
    /// <p>The name of the disk snapshot (e.g., <code>my-snapshot</code>) from which to create the
    /// new storage disk.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>source disk name</code>
    /// parameter. The <code>disk snapshot name</code> and <code>source disk name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// </ul>
    pub fn disk_snapshot_name(&self) -> std::option::Option<&str> {
        self.disk_snapshot_name.as_deref()
    }
    /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
    /// Choose the same Availability Zone as the Lightsail instance where you want to create the
    /// disk.</p>
    /// <p>Use the GetRegions operation to list the Availability Zones where Lightsail is currently
    /// available.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
    pub fn size_in_gb(&self) -> std::option::Option<i32> {
        self.size_in_gb
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
    pub fn add_ons(&self) -> std::option::Option<&[crate::model::AddOnRequest]> {
        self.add_ons.as_deref()
    }
    /// <p>The name of the source disk from which the source automatic snapshot was created.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>disk snapshot name</code>
    /// parameter. The <code>source disk name</code> and <code>disk snapshot name</code>
    /// parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
    /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn source_disk_name(&self) -> std::option::Option<&str> {
        self.source_disk_name.as_deref()
    }
    /// <p>The date of the automatic snapshot to use for the new disk. Use the <code>get auto
    /// snapshots</code> operation to identify the dates of the available automatic
    /// snapshots.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
    /// </li>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
    /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
    /// auto snapshot</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
    /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn restore_date(&self) -> std::option::Option<&str> {
        self.restore_date.as_deref()
    }
    /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>restore date</code>
    /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
    /// date</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when creating a new disk from an automatic snapshot. For
    /// more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-configuring-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn use_latest_restorable_auto_snapshot(&self) -> std::option::Option<bool> {
        self.use_latest_restorable_auto_snapshot
    }
}
impl std::fmt::Debug for CreateDiskFromSnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDiskFromSnapshotInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.field("disk_snapshot_name", &self.disk_snapshot_name);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("size_in_gb", &self.size_in_gb);
        formatter.field("tags", &self.tags);
        formatter.field("add_ons", &self.add_ons);
        formatter.field("source_disk_name", &self.source_disk_name);
        formatter.field("restore_date", &self.restore_date);
        formatter.field(
            "use_latest_restorable_auto_snapshot",
            &self.use_latest_restorable_auto_snapshot,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDiskInput {
    /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
    pub disk_name: std::option::Option<std::string::String>,
    /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
    /// Use the same Availability Zone as the Lightsail instance to which you want to attach the
    /// disk.</p>
    /// <p>Use the <code>get regions</code> operation to list the Availability Zones where
    /// Lightsail is currently available.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
    pub size_in_gb: std::option::Option<i32>,
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
    pub add_ons: std::option::Option<std::vec::Vec<crate::model::AddOnRequest>>,
}
impl CreateDiskInput {
    /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
    /// <p>The Availability Zone where you want to create the disk (e.g., <code>us-east-2a</code>).
    /// Use the same Availability Zone as the Lightsail instance to which you want to attach the
    /// disk.</p>
    /// <p>Use the <code>get regions</code> operation to list the Availability Zones where
    /// Lightsail is currently available.</p>
    pub fn availability_zone(&self) -> std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The size of the disk in GB (e.g., <code>32</code>).</p>
    pub fn size_in_gb(&self) -> std::option::Option<i32> {
        self.size_in_gb
    }
    /// <p>The tag keys and optional values to add to the resource during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>An array of objects that represent the add-ons to enable for the new disk.</p>
    pub fn add_ons(&self) -> std::option::Option<&[crate::model::AddOnRequest]> {
        self.add_ons.as_deref()
    }
}
impl std::fmt::Debug for CreateDiskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDiskInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("size_in_gb", &self.size_in_gb);
        formatter.field("tags", &self.tags);
        formatter.field("add_ons", &self.add_ons);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContainerServiceRegistryLoginInput {}
impl std::fmt::Debug for CreateContainerServiceRegistryLoginInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContainerServiceRegistryLoginInput");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContainerServiceDeploymentInput {
    /// <p>The name of the container service for which to create the deployment.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>An object that describes the settings of the containers that will be launched on the
    /// container service.</p>
    pub containers: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::Container>,
    >,
    /// <p>An object that describes the settings of the public endpoint for the container
    /// service.</p>
    pub public_endpoint: std::option::Option<crate::model::EndpointRequest>,
}
impl CreateContainerServiceDeploymentInput {
    /// <p>The name of the container service for which to create the deployment.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>An object that describes the settings of the containers that will be launched on the
    /// container service.</p>
    pub fn containers(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, crate::model::Container>>
    {
        self.containers.as_ref()
    }
    /// <p>An object that describes the settings of the public endpoint for the container
    /// service.</p>
    pub fn public_endpoint(&self) -> std::option::Option<&crate::model::EndpointRequest> {
        self.public_endpoint.as_ref()
    }
}
impl std::fmt::Debug for CreateContainerServiceDeploymentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContainerServiceDeploymentInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("containers", &self.containers);
        formatter.field("public_endpoint", &self.public_endpoint);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContainerServiceInput {
    /// <p>The name for the container service.</p>
    ///
    /// <p>The name that you specify for your container service will make up part of its default
    /// domain. The default domain of a container service is typically
    /// <code>https://<ServiceName>.<RandomGUID>.<AWSRegion>.cs.amazonlightsail.com</code>.
    /// If the name of your container service is <code>container-service-1</code>, and it's located in
    /// the US East (Ohio) AWS region (<code>us-east-2</code>), then the domain for your container
    /// service will be like the following example:
    /// <code>https://container-service-1.ur4EXAMPLE2uq.us-east-2.cs.amazonlightsail.com</code>
    /// </p>
    ///
    /// <p>The following are the requirements for container service names:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>Must be unique within each AWS Region in your Lightsail account.</p>
    /// </li>
    /// <li>
    /// <p>Must contain 1 to 63 characters.</p>
    /// </li>
    /// <li>
    /// <p>Must contain only alphanumeric characters and hyphens.</p>
    /// </li>
    /// <li>
    /// <p>A hyphen (-) can separate words but cannot be at the start or end of the name.</p>
    /// </li>
    /// </ul>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The power specification for the container service.</p>
    ///
    /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
    /// container service. The <code>power</code> and <code>scale</code> of a container service makes
    /// up its configured capacity. To determine the monthly price of your container service, multiply
    /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
    /// the service.</p>
    ///
    /// <p>Use the <code>GetContainerServicePowers</code> action to get a list of power options that
    /// you can specify using this parameter, and their base monthly cost.</p>
    pub power: std::option::Option<crate::model::ContainerServicePowerName>,
    /// <p>The scale specification for the container service.</p>
    ///
    /// <p>The scale specifies the allocated compute nodes of the container service. The
    /// <code>power</code> and <code>scale</code> of a container service makes up its configured
    /// capacity. To determine the monthly price of your container service, multiply the base price of
    /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
    /// service.</p>
    pub scale: std::option::Option<i32>,
    /// <p>The tag keys and optional values to add to the container service during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    /// <p>For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The public domain names to use with the container service, such as
    /// <code>example.com</code> and <code>www.example.com</code>.</p>
    ///
    /// <p>You can specify up to four public domain names for a container service. The domain names
    /// that you specify are used when you create a deployment with a container configured as the
    /// public endpoint of your container service.</p>
    ///
    /// <p>If you don't specify public domain names, then you can use the default domain of the
    /// container service.</p>
    ///
    /// <important>
    /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
    /// names with your container service. Use the <code>CreateCertificate</code> action to create a
    /// certificate for the public domain names you want to use with your container service.</p>
    /// </important>
    ///
    /// <p>You can specify public domain names using a string to array map as shown in the example
    /// later on this page.</p>
    pub public_domain_names: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>An object that describes a deployment for the container service.</p>
    ///
    /// <p>A deployment specifies the containers that will be launched on the container service and
    /// their settings, such as the ports to open, the environment variables to apply, and the launch
    /// command to run. It also specifies the container that will serve as the public endpoint of the
    /// deployment and its settings, such as the HTTP or HTTPS port to use, and the health check
    /// configuration.</p>
    pub deployment: std::option::Option<crate::model::ContainerServiceDeploymentRequest>,
}
impl CreateContainerServiceInput {
    /// <p>The name for the container service.</p>
    ///
    /// <p>The name that you specify for your container service will make up part of its default
    /// domain. The default domain of a container service is typically
    /// <code>https://<ServiceName>.<RandomGUID>.<AWSRegion>.cs.amazonlightsail.com</code>.
    /// If the name of your container service is <code>container-service-1</code>, and it's located in
    /// the US East (Ohio) AWS region (<code>us-east-2</code>), then the domain for your container
    /// service will be like the following example:
    /// <code>https://container-service-1.ur4EXAMPLE2uq.us-east-2.cs.amazonlightsail.com</code>
    /// </p>
    ///
    /// <p>The following are the requirements for container service names:</p>
    ///
    /// <ul>
    /// <li>
    /// <p>Must be unique within each AWS Region in your Lightsail account.</p>
    /// </li>
    /// <li>
    /// <p>Must contain 1 to 63 characters.</p>
    /// </li>
    /// <li>
    /// <p>Must contain only alphanumeric characters and hyphens.</p>
    /// </li>
    /// <li>
    /// <p>A hyphen (-) can separate words but cannot be at the start or end of the name.</p>
    /// </li>
    /// </ul>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The power specification for the container service.</p>
    ///
    /// <p>The power specifies the amount of memory, vCPUs, and base monthly cost of each node of the
    /// container service. The <code>power</code> and <code>scale</code> of a container service makes
    /// up its configured capacity. To determine the monthly price of your container service, multiply
    /// the base price of the <code>power</code> with the <code>scale</code> (the number of nodes) of
    /// the service.</p>
    ///
    /// <p>Use the <code>GetContainerServicePowers</code> action to get a list of power options that
    /// you can specify using this parameter, and their base monthly cost.</p>
    pub fn power(&self) -> std::option::Option<&crate::model::ContainerServicePowerName> {
        self.power.as_ref()
    }
    /// <p>The scale specification for the container service.</p>
    ///
    /// <p>The scale specifies the allocated compute nodes of the container service. The
    /// <code>power</code> and <code>scale</code> of a container service makes up its configured
    /// capacity. To determine the monthly price of your container service, multiply the base price of
    /// the <code>power</code> with the <code>scale</code> (the number of nodes) of the
    /// service.</p>
    pub fn scale(&self) -> std::option::Option<i32> {
        self.scale
    }
    /// <p>The tag keys and optional values to add to the container service during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    /// <p>For more information about tags in Lightsail, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-tags">Amazon Lightsail Developer Guide</a>.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The public domain names to use with the container service, such as
    /// <code>example.com</code> and <code>www.example.com</code>.</p>
    ///
    /// <p>You can specify up to four public domain names for a container service. The domain names
    /// that you specify are used when you create a deployment with a container configured as the
    /// public endpoint of your container service.</p>
    ///
    /// <p>If you don't specify public domain names, then you can use the default domain of the
    /// container service.</p>
    ///
    /// <important>
    /// <p>You must create and validate an SSL/TLS certificate before you can use public domain
    /// names with your container service. Use the <code>CreateCertificate</code> action to create a
    /// certificate for the public domain names you want to use with your container service.</p>
    /// </important>
    ///
    /// <p>You can specify public domain names using a string to array map as shown in the example
    /// later on this page.</p>
    pub fn public_domain_names(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.public_domain_names.as_ref()
    }
    /// <p>An object that describes a deployment for the container service.</p>
    ///
    /// <p>A deployment specifies the containers that will be launched on the container service and
    /// their settings, such as the ports to open, the environment variables to apply, and the launch
    /// command to run. It also specifies the container that will serve as the public endpoint of the
    /// deployment and its settings, such as the HTTP or HTTPS port to use, and the health check
    /// configuration.</p>
    pub fn deployment(
        &self,
    ) -> std::option::Option<&crate::model::ContainerServiceDeploymentRequest> {
        self.deployment.as_ref()
    }
}
impl std::fmt::Debug for CreateContainerServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContainerServiceInput");
        formatter.field("service_name", &self.service_name);
        formatter.field("power", &self.power);
        formatter.field("scale", &self.scale);
        formatter.field("tags", &self.tags);
        formatter.field("public_domain_names", &self.public_domain_names);
        formatter.field("deployment", &self.deployment);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContactMethodInput {
    /// <p>The protocol of the contact method, such as <code>Email</code> or <code>SMS</code> (text
    /// messaging).</p>
    /// <p>The <code>SMS</code> protocol is supported only in the following AWS Regions.</p>
    /// <ul>
    /// <li>
    /// <p>US East (N. Virginia) (<code>us-east-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>US West (Oregon) (<code>us-west-2</code>)</p>
    /// </li>
    /// <li>
    /// <p>Europe (Ireland) (<code>eu-west-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>Asia Pacific (Tokyo) (<code>ap-northeast-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>Asia Pacific (Singapore) (<code>ap-southeast-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>Asia Pacific (Sydney) (<code>ap-southeast-2</code>)</p>
    /// </li>
    /// </ul>
    /// <p>For a list of countries/regions where SMS text messages can be sent, and the latest AWS
    /// Regions where SMS text messaging is supported, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-supported-regions-countries.html">Supported Regions and Countries</a> in the <i>Amazon SNS Developer
    /// Guide</i>.</p>
    /// <p>For more information about notifications in Amazon Lightsail, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
    pub protocol: std::option::Option<crate::model::ContactProtocol>,
    /// <p>The destination of the contact method, such as an email address or a mobile phone
    /// number.</p>
    /// <p>Use the E.164 format when specifying a mobile phone number. E.164 is a standard for the
    /// phone number structure used for international telecommunication. Phone numbers that follow
    /// this format can have a maximum of 15 digits, and they are prefixed with the plus character (+)
    /// and the country code. For example, a U.S. phone number in E.164 format would be specified as
    /// +1XXX5550100. For more information, see <a href="https://en.wikipedia.org/wiki/E.164">E.164</a> on <i>Wikipedia</i>.</p>
    pub contact_endpoint: std::option::Option<std::string::String>,
}
impl CreateContactMethodInput {
    /// <p>The protocol of the contact method, such as <code>Email</code> or <code>SMS</code> (text
    /// messaging).</p>
    /// <p>The <code>SMS</code> protocol is supported only in the following AWS Regions.</p>
    /// <ul>
    /// <li>
    /// <p>US East (N. Virginia) (<code>us-east-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>US West (Oregon) (<code>us-west-2</code>)</p>
    /// </li>
    /// <li>
    /// <p>Europe (Ireland) (<code>eu-west-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>Asia Pacific (Tokyo) (<code>ap-northeast-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>Asia Pacific (Singapore) (<code>ap-southeast-1</code>)</p>
    /// </li>
    /// <li>
    /// <p>Asia Pacific (Sydney) (<code>ap-southeast-2</code>)</p>
    /// </li>
    /// </ul>
    /// <p>For a list of countries/regions where SMS text messages can be sent, and the latest AWS
    /// Regions where SMS text messaging is supported, see <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-supported-regions-countries.html">Supported Regions and Countries</a> in the <i>Amazon SNS Developer
    /// Guide</i>.</p>
    /// <p>For more information about notifications in Amazon Lightsail, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-notifications">Notifications in Amazon Lightsail</a>.</p>
    pub fn protocol(&self) -> std::option::Option<&crate::model::ContactProtocol> {
        self.protocol.as_ref()
    }
    /// <p>The destination of the contact method, such as an email address or a mobile phone
    /// number.</p>
    /// <p>Use the E.164 format when specifying a mobile phone number. E.164 is a standard for the
    /// phone number structure used for international telecommunication. Phone numbers that follow
    /// this format can have a maximum of 15 digits, and they are prefixed with the plus character (+)
    /// and the country code. For example, a U.S. phone number in E.164 format would be specified as
    /// +1XXX5550100. For more information, see <a href="https://en.wikipedia.org/wiki/E.164">E.164</a> on <i>Wikipedia</i>.</p>
    pub fn contact_endpoint(&self) -> std::option::Option<&str> {
        self.contact_endpoint.as_deref()
    }
}
impl std::fmt::Debug for CreateContactMethodInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContactMethodInput");
        formatter.field("protocol", &self.protocol);
        formatter.field("contact_endpoint", &self.contact_endpoint);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCloudFormationStackInput {
    /// <p>An array of parameters that will be used to create the new Amazon EC2 instance. You can only
    /// pass one instance entry at a time in this array. You will get an invalid parameter error if
    /// you pass more than one instance entry in this array.</p>
    pub instances: std::option::Option<std::vec::Vec<crate::model::InstanceEntry>>,
}
impl CreateCloudFormationStackInput {
    /// <p>An array of parameters that will be used to create the new Amazon EC2 instance. You can only
    /// pass one instance entry at a time in this array. You will get an invalid parameter error if
    /// you pass more than one instance entry in this array.</p>
    pub fn instances(&self) -> std::option::Option<&[crate::model::InstanceEntry]> {
        self.instances.as_deref()
    }
}
impl std::fmt::Debug for CreateCloudFormationStackInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCloudFormationStackInput");
        formatter.field("instances", &self.instances);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCertificateInput {
    /// <p>The name for the certificate.</p>
    pub certificate_name: std::option::Option<std::string::String>,
    /// <p>The domain name (e.g., <code>example.com</code>) for the certificate.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>An array of strings that specify the alternate domains (e.g., <code>example2.com</code>)
    /// and subdomains (e.g., <code>blog.example.com</code>) for the certificate.</p>
    /// <p>You can specify a maximum of nine alternate domains (in addition to the primary domain
    /// name).</p>
    /// <p>Wildcard domain entries (e.g., <code>*.example.com</code>) are not supported.</p>
    pub subject_alternative_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tag keys and optional values to add to the certificate during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateCertificateInput {
    /// <p>The name for the certificate.</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
    /// <p>The domain name (e.g., <code>example.com</code>) for the certificate.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>An array of strings that specify the alternate domains (e.g., <code>example2.com</code>)
    /// and subdomains (e.g., <code>blog.example.com</code>) for the certificate.</p>
    /// <p>You can specify a maximum of nine alternate domains (in addition to the primary domain
    /// name).</p>
    /// <p>Wildcard domain entries (e.g., <code>*.example.com</code>) are not supported.</p>
    pub fn subject_alternative_names(&self) -> std::option::Option<&[std::string::String]> {
        self.subject_alternative_names.as_deref()
    }
    /// <p>The tag keys and optional values to add to the certificate during create.</p>
    /// <p>Use the <code>TagResource</code> action to tag a resource after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCertificateInput");
        formatter.field("certificate_name", &self.certificate_name);
        formatter.field("domain_name", &self.domain_name);
        formatter.field("subject_alternative_names", &self.subject_alternative_names);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBucketAccessKeyInput {
    /// <p>The name of the bucket that the new access key will belong to, and grant access to.</p>
    pub bucket_name: std::option::Option<std::string::String>,
}
impl CreateBucketAccessKeyInput {
    /// <p>The name of the bucket that the new access key will belong to, and grant access to.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
}
impl std::fmt::Debug for CreateBucketAccessKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBucketAccessKeyInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateBucketInput {
    /// <p>The name for the bucket.</p>
    ///
    /// <p>For more information about bucket names, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/bucket-naming-rules-in-amazon-lightsail">Bucket naming rules in Amazon Lightsail</a> in the <i>Amazon Lightsail Developer
    /// Guide</i>.</p>
    pub bucket_name: std::option::Option<std::string::String>,
    /// <p>The ID of the bundle to use for the bucket.</p>
    ///
    /// <p>A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a
    /// bucket.</p>
    ///
    /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
    /// specify.</p>
    ///
    /// <p>Use the <a>UpdateBucketBundle</a> action to change the bundle after the bucket
    /// is created.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The tag keys and optional values to add to the bucket during creation.</p>
    ///
    /// <p>Use the <a>TagResource</a> action to tag the bucket after it's created.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A Boolean value that indicates whether to enable versioning of objects in the
    /// bucket.</p>
    ///
    /// <p>For more information about versioning, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-managing-bucket-object-versioning">Enabling and suspending object versioning in a bucket in Amazon Lightsail</a> in the
    /// <i>Amazon Lightsail Developer Guide</i>.</p>
    pub enable_object_versioning: std::option::Option<bool>,
}
impl CreateBucketInput {
    /// <p>The name for the bucket.</p>
    ///
    /// <p>For more information about bucket names, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/bucket-naming-rules-in-amazon-lightsail">Bucket naming rules in Amazon Lightsail</a> in the <i>Amazon Lightsail Developer
    /// Guide</i>.</p>
    pub fn bucket_name(&self) -> std::option::Option<&str> {
        self.bucket_name.as_deref()
    }
    /// <p>The ID of the bundle to use for the bucket.</p>
    ///
    /// <p>A bucket bundle specifies the monthly cost, storage space, and data transfer quota for a
    /// bucket.</p>
    ///
    /// <p>Use the <a>GetBucketBundles</a> action to get a list of bundle IDs that you can
    /// specify.</p>
    ///
    /// <p>Use the <a>UpdateBucketBundle</a> action to change the bundle after the bucket
    /// is created.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>The tag keys and optional values to add to the bucket during creation.</p>
    ///
    /// <p>Use the <a>TagResource</a> action to tag the bucket after it's created.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>A Boolean value that indicates whether to enable versioning of objects in the
    /// bucket.</p>
    ///
    /// <p>For more information about versioning, see <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-managing-bucket-object-versioning">Enabling and suspending object versioning in a bucket in Amazon Lightsail</a> in the
    /// <i>Amazon Lightsail Developer Guide</i>.</p>
    pub fn enable_object_versioning(&self) -> std::option::Option<bool> {
        self.enable_object_versioning
    }
}
impl std::fmt::Debug for CreateBucketInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateBucketInput");
        formatter.field("bucket_name", &self.bucket_name);
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("tags", &self.tags);
        formatter.field("enable_object_versioning", &self.enable_object_versioning);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CopySnapshotInput {
    /// <p>The name of the source manual snapshot to copy.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>Define this parameter only when copying a manual snapshot as another manual
    /// snapshot.</p>
    /// </li>
    /// </ul>
    pub source_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The name of the source instance or disk from which the source automatic snapshot was
    /// created.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub source_resource_name: std::option::Option<std::string::String>,
    /// <p>The date of the source automatic snapshot to copy. Use the <code>get auto snapshots</code>
    /// operation to identify the dates of the available automatic snapshots.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
    /// </li>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
    /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
    /// auto snapshot</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub restore_date: std::option::Option<std::string::String>,
    /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot of the
    /// specified source instance or disk.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>restore date</code>
    /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
    /// date</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub use_latest_restorable_auto_snapshot: std::option::Option<bool>,
    /// <p>The name of the new manual snapshot to be created as a copy.</p>
    pub target_snapshot_name: std::option::Option<std::string::String>,
    /// <p>The AWS Region where the source manual or automatic snapshot is located.</p>
    pub source_region: std::option::Option<crate::model::RegionName>,
}
impl CopySnapshotInput {
    /// <p>The name of the source manual snapshot to copy.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>Define this parameter only when copying a manual snapshot as another manual
    /// snapshot.</p>
    /// </li>
    /// </ul>
    pub fn source_snapshot_name(&self) -> std::option::Option<&str> {
        self.source_snapshot_name.as_deref()
    }
    /// <p>The name of the source instance or disk from which the source automatic snapshot was
    /// created.</p>
    /// <p>Constraint:</p>
    /// <ul>
    /// <li>
    /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn source_resource_name(&self) -> std::option::Option<&str> {
        self.source_resource_name.as_deref()
    }
    /// <p>The date of the source automatic snapshot to copy. Use the <code>get auto snapshots</code>
    /// operation to identify the dates of the available automatic snapshots.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Must be specified in <code>YYYY-MM-DD</code> format.</p>
    /// </li>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>use latest restorable auto
    /// snapshot</code> parameter. The <code>restore date</code> and <code>use latest restorable
    /// auto snapshot</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn restore_date(&self) -> std::option::Option<&str> {
        self.restore_date.as_deref()
    }
    /// <p>A Boolean value to indicate whether to use the latest available automatic snapshot of the
    /// specified source instance or disk.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>This parameter cannot be defined together with the <code>restore date</code>
    /// parameter. The <code>use latest restorable auto snapshot</code> and <code>restore
    /// date</code> parameters are mutually exclusive.</p>
    /// </li>
    /// <li>
    /// <p>Define this parameter only when copying an automatic snapshot as a manual snapshot.
    /// For more information, see the <a href="https://lightsail.aws.amazon.com/ls/docs/en_us/articles/amazon-lightsail-keeping-automatic-snapshots">Amazon Lightsail Developer Guide</a>.</p>
    /// </li>
    /// </ul>
    pub fn use_latest_restorable_auto_snapshot(&self) -> std::option::Option<bool> {
        self.use_latest_restorable_auto_snapshot
    }
    /// <p>The name of the new manual snapshot to be created as a copy.</p>
    pub fn target_snapshot_name(&self) -> std::option::Option<&str> {
        self.target_snapshot_name.as_deref()
    }
    /// <p>The AWS Region where the source manual or automatic snapshot is located.</p>
    pub fn source_region(&self) -> std::option::Option<&crate::model::RegionName> {
        self.source_region.as_ref()
    }
}
impl std::fmt::Debug for CopySnapshotInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CopySnapshotInput");
        formatter.field("source_snapshot_name", &self.source_snapshot_name);
        formatter.field("source_resource_name", &self.source_resource_name);
        formatter.field("restore_date", &self.restore_date);
        formatter.field(
            "use_latest_restorable_auto_snapshot",
            &self.use_latest_restorable_auto_snapshot,
        );
        formatter.field("target_snapshot_name", &self.target_snapshot_name);
        formatter.field("source_region", &self.source_region);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloseInstancePublicPortsInput {
    /// <p>An object to describe the ports to close for the specified instance.</p>
    pub port_info: std::option::Option<crate::model::PortInfo>,
    /// <p>The name of the instance for which to close ports.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl CloseInstancePublicPortsInput {
    /// <p>An object to describe the ports to close for the specified instance.</p>
    pub fn port_info(&self) -> std::option::Option<&crate::model::PortInfo> {
        self.port_info.as_ref()
    }
    /// <p>The name of the instance for which to close ports.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for CloseInstancePublicPortsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloseInstancePublicPortsInput");
        formatter.field("port_info", &self.port_info);
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachStaticIpInput {
    /// <p>The name of the static IP.</p>
    pub static_ip_name: std::option::Option<std::string::String>,
    /// <p>The instance name to which you want to attach the static IP address.</p>
    pub instance_name: std::option::Option<std::string::String>,
}
impl AttachStaticIpInput {
    /// <p>The name of the static IP.</p>
    pub fn static_ip_name(&self) -> std::option::Option<&str> {
        self.static_ip_name.as_deref()
    }
    /// <p>The instance name to which you want to attach the static IP address.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
}
impl std::fmt::Debug for AttachStaticIpInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachStaticIpInput");
        formatter.field("static_ip_name", &self.static_ip_name);
        formatter.field("instance_name", &self.instance_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachLoadBalancerTlsCertificateInput {
    /// <p>The name of the load balancer to which you want to associate the SSL/TLS
    /// certificate.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>The name of your SSL/TLS certificate.</p>
    pub certificate_name: std::option::Option<std::string::String>,
}
impl AttachLoadBalancerTlsCertificateInput {
    /// <p>The name of the load balancer to which you want to associate the SSL/TLS
    /// certificate.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The name of your SSL/TLS certificate.</p>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
}
impl std::fmt::Debug for AttachLoadBalancerTlsCertificateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachLoadBalancerTlsCertificateInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("certificate_name", &self.certificate_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachInstancesToLoadBalancerInput {
    /// <p>The name of the load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>An array of strings representing the instance name(s) you want to attach to your load
    /// balancer.</p>
    /// <p>An instance must be <code>running</code> before you can attach it to your load
    /// balancer.</p>
    /// <p>There are no additional limits on the number of instances you can attach to your load
    /// balancer, aside from the limit of Lightsail instances you can create in your account
    /// (20).</p>
    pub instance_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AttachInstancesToLoadBalancerInput {
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(&self) -> std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>An array of strings representing the instance name(s) you want to attach to your load
    /// balancer.</p>
    /// <p>An instance must be <code>running</code> before you can attach it to your load
    /// balancer.</p>
    /// <p>There are no additional limits on the number of instances you can attach to your load
    /// balancer, aside from the limit of Lightsail instances you can create in your account
    /// (20).</p>
    pub fn instance_names(&self) -> std::option::Option<&[std::string::String]> {
        self.instance_names.as_deref()
    }
}
impl std::fmt::Debug for AttachInstancesToLoadBalancerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachInstancesToLoadBalancerInput");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("instance_names", &self.instance_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachDiskInput {
    /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
    pub disk_name: std::option::Option<std::string::String>,
    /// <p>The name of the Lightsail instance where you want to utilize the storage disk.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>The disk path to expose to the instance (e.g., <code>/dev/xvdf</code>).</p>
    pub disk_path: std::option::Option<std::string::String>,
}
impl AttachDiskInput {
    /// <p>The unique Lightsail disk name (e.g., <code>my-disk</code>).</p>
    pub fn disk_name(&self) -> std::option::Option<&str> {
        self.disk_name.as_deref()
    }
    /// <p>The name of the Lightsail instance where you want to utilize the storage disk.</p>
    pub fn instance_name(&self) -> std::option::Option<&str> {
        self.instance_name.as_deref()
    }
    /// <p>The disk path to expose to the instance (e.g., <code>/dev/xvdf</code>).</p>
    pub fn disk_path(&self) -> std::option::Option<&str> {
        self.disk_path.as_deref()
    }
}
impl std::fmt::Debug for AttachDiskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachDiskInput");
        formatter.field("disk_name", &self.disk_name);
        formatter.field("instance_name", &self.instance_name);
        formatter.field("disk_path", &self.disk_path);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttachCertificateToDistributionInput {
    /// <p>The name of the distribution that the certificate will be attached to.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub distribution_name: std::option::Option<std::string::String>,
    /// <p>The name of the certificate to attach to a distribution.</p>
    /// <p>Only certificates with a status of <code>ISSUED</code> can be attached to a
    /// distribution.</p>
    /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
    /// can specify.</p>
    /// <note>
    /// <p>This is the name of the certificate resource type and is used only to reference the
    /// certificate in other API actions. It can be different than the domain name of the
    /// certificate. For example, your certificate name might be
    /// <code>WordPress-Blog-Certificate</code> and the domain name of the certificate might be
    /// <code>example.com</code>.</p>
    /// </note>
    pub certificate_name: std::option::Option<std::string::String>,
}
impl AttachCertificateToDistributionInput {
    /// <p>The name of the distribution that the certificate will be attached to.</p>
    /// <p>Use the <code>GetDistributions</code> action to get a list of distribution names that you
    /// can specify.</p>
    pub fn distribution_name(&self) -> std::option::Option<&str> {
        self.distribution_name.as_deref()
    }
    /// <p>The name of the certificate to attach to a distribution.</p>
    /// <p>Only certificates with a status of <code>ISSUED</code> can be attached to a
    /// distribution.</p>
    /// <p>Use the <code>GetCertificates</code> action to get a list of certificate names that you
    /// can specify.</p>
    /// <note>
    /// <p>This is the name of the certificate resource type and is used only to reference the
    /// certificate in other API actions. It can be different than the domain name of the
    /// certificate. For example, your certificate name might be
    /// <code>WordPress-Blog-Certificate</code> and the domain name of the certificate might be
    /// <code>example.com</code>.</p>
    /// </note>
    pub fn certificate_name(&self) -> std::option::Option<&str> {
        self.certificate_name.as_deref()
    }
}
impl std::fmt::Debug for AttachCertificateToDistributionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttachCertificateToDistributionInput");
        formatter.field("distribution_name", &self.distribution_name);
        formatter.field("certificate_name", &self.certificate_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AllocateStaticIpInput {
    /// <p>The name of the static IP address.</p>
    pub static_ip_name: std::option::Option<std::string::String>,
}
impl AllocateStaticIpInput {
    /// <p>The name of the static IP address.</p>
    pub fn static_ip_name(&self) -> std::option::Option<&str> {
        self.static_ip_name.as_deref()
    }
}
impl std::fmt::Debug for AllocateStaticIpInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AllocateStaticIpInput");
        formatter.field("static_ip_name", &self.static_ip_name);
        formatter.finish()
    }
}
