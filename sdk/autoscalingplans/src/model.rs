// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Describes a scaling instruction for a scalable resource in a scaling plan. Each scaling
/// instruction applies to one resource.</p>
/// <p>AWS Auto Scaling creates target tracking scaling policies based on the scaling instructions.
/// Target tracking scaling policies adjust the capacity of your scalable resource as required
/// to maintain resource utilization at the target value that you specified. </p>
/// <p>AWS Auto Scaling also configures predictive scaling for your Amazon EC2 Auto Scaling groups using a subset of
/// parameters, including the load metric, the scaling metric, the target value for the scaling
/// metric, the predictive scaling mode (forecast and scale or forecast only), and the desired
/// behavior when the forecast capacity exceeds the maximum capacity of the resource. With
/// predictive scaling, AWS Auto Scaling generates forecasts with traffic predictions for the two days
/// ahead and schedules scaling actions that proactively add and remove resource capacity to
/// match the forecast. </p>
/// <important>
/// <p>We recommend waiting a minimum of 24 hours after creating an Auto Scaling group to configure
/// predictive scaling. At minimum, there must be 24 hours of historical data to generate a
/// forecast. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-best-practices.html">Best Practices for
/// AWS Auto Scaling</a> in the <i>AWS Auto Scaling User Guide</i>.</p>
/// </important>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScalingInstruction {
    /// <p>The namespace of the AWS service.</p>
    pub service_namespace: std::option::Option<crate::model::ServiceNamespace>,
    /// <p>The ID of the resource. This string consists of the resource type and unique
    /// identifier.</p>
    /// <ul>
    /// <li>
    /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
    /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
    /// </li>
    /// <li>
    /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
    /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
    /// </li>
    /// <li>
    /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
    /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table/index/my-table-index</code>.</p>
    /// </li>
    /// <li>
    /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
    /// Example: <code>cluster:my-db-cluster</code>.</p>
    /// </li>
    /// </ul>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The scalable dimension associated with the resource.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
    /// </li>
    /// </ul>
    pub scalable_dimension: std::option::Option<crate::model::ScalableDimension>,
    /// <p>The minimum capacity of the resource. </p>
    pub min_capacity: std::option::Option<i32>,
    /// <p>The maximum capacity of the resource. The exception to this upper limit is if you
    /// specify a non-default setting for <b>PredictiveScalingMaxCapacityBehavior</b>. </p>
    pub max_capacity: std::option::Option<i32>,
    /// <p>The target tracking configurations (up to 10). Each of these structures must specify a
    /// unique scaling metric and a target value for the metric. </p>
    pub target_tracking_configurations:
        std::option::Option<std::vec::Vec<crate::model::TargetTrackingConfiguration>>,
    /// <p>The predefined load metric to use for predictive scaling. This parameter or a <b>CustomizedLoadMetricSpecification</b> is required when configuring
    /// predictive scaling, and cannot be used otherwise. </p>
    pub predefined_load_metric_specification:
        std::option::Option<crate::model::PredefinedLoadMetricSpecification>,
    /// <p>The customized load metric to use for predictive scaling. This parameter or a <b>PredefinedLoadMetricSpecification</b> is required when configuring
    /// predictive scaling, and cannot be used otherwise. </p>
    pub customized_load_metric_specification:
        std::option::Option<crate::model::CustomizedLoadMetricSpecification>,
    /// <p>The amount of time, in seconds, to buffer the run time of scheduled scaling actions when
    /// scaling out. For example, if the forecast says to add capacity at 10:00 AM, and the buffer
    /// time is 5 minutes, then the run time of the corresponding scheduled scaling action will be
    /// 9:55 AM. The intention is to give resources time to be provisioned. For example, it can
    /// take a few minutes to launch an EC2 instance. The actual amount of time required depends on
    /// several factors, such as the size of the instance and whether there are startup scripts to
    /// complete. </p>
    /// <p>The value must be less than the forecast interval duration of 3600 seconds (60 minutes).
    /// The default is 300 seconds. </p>
    /// <p>Only valid when configuring predictive scaling. </p>
    pub scheduled_action_buffer_time: std::option::Option<i32>,
    /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
    /// exceeds the maximum capacity specified for the resource. The default value is
    /// <code>SetForecastCapacityToMaxCapacity</code>.</p>
    /// <p>The following are possible values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SetForecastCapacityToMaxCapacity</code> - AWS Auto Scaling cannot scale resource
    /// capacity higher than the maximum capacity. The maximum capacity is enforced as a hard
    /// limit. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SetMaxCapacityToForecastCapacity</code> - AWS Auto Scaling may scale resource
    /// capacity higher than the maximum capacity to equal but not exceed forecast
    /// capacity.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SetMaxCapacityAboveForecastCapacity</code> - AWS Auto Scaling may scale resource
    /// capacity higher than the maximum capacity by a specified buffer value. The intention
    /// is to give the target tracking scaling policy extra capacity if unexpected traffic
    /// occurs. </p>
    /// </li>
    /// </ul>
    /// <p>Only valid when configuring predictive scaling.</p>
    pub predictive_scaling_max_capacity_behavior:
        std::option::Option<crate::model::PredictiveScalingMaxCapacityBehavior>,
    /// <p>The size of the capacity buffer to use when the forecast capacity is close to or exceeds
    /// the maximum capacity. The value is specified as a percentage relative to the forecast
    /// capacity. For example, if the buffer is 10, this means a 10 percent buffer, such that if
    /// the forecast capacity is 50, and the maximum capacity is 40, then the effective maximum
    /// capacity is 55.</p>
    /// <p>Only valid when configuring predictive scaling. Required if the <b>PredictiveScalingMaxCapacityBehavior</b> is set to
    /// <code>SetMaxCapacityAboveForecastCapacity</code>, and cannot be used otherwise.</p>
    /// <p>The range is 1-100.</p>
    pub predictive_scaling_max_capacity_buffer: std::option::Option<i32>,
    /// <p>The predictive scaling mode. The default value is <code>ForecastAndScale</code>.
    /// Otherwise, AWS Auto Scaling forecasts capacity but does not create any scheduled scaling actions
    /// based on the capacity forecast. </p>
    pub predictive_scaling_mode: std::option::Option<crate::model::PredictiveScalingMode>,
    /// <p>Controls whether a resource's externally created scaling policies are kept or replaced. </p>
    /// <p>The default value is <code>KeepExternalPolicies</code>. If the parameter is set to
    /// <code>ReplaceExternalPolicies</code>, any scaling policies that are external to AWS Auto Scaling
    /// are deleted and new target tracking scaling policies created. </p>
    /// <p>Only valid when configuring dynamic scaling. </p>
    /// <p>Condition: The number of existing policies to be replaced must be less than or equal to
    /// 50. If there are more than 50 policies to be replaced, AWS Auto Scaling keeps all existing policies
    /// and does not create new ones.</p>
    pub scaling_policy_update_behavior:
        std::option::Option<crate::model::ScalingPolicyUpdateBehavior>,
    /// <p>Controls whether dynamic scaling by AWS Auto Scaling is disabled. When dynamic scaling is
    /// enabled, AWS Auto Scaling creates target tracking scaling policies based on the specified target
    /// tracking configurations. </p>
    /// <p>The default is enabled (<code>false</code>). </p>
    pub disable_dynamic_scaling: std::option::Option<bool>,
}
impl ScalingInstruction {
    /// <p>The namespace of the AWS service.</p>
    pub fn service_namespace(&self) -> std::option::Option<&crate::model::ServiceNamespace> {
        self.service_namespace.as_ref()
    }
    /// <p>The ID of the resource. This string consists of the resource type and unique
    /// identifier.</p>
    /// <ul>
    /// <li>
    /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
    /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
    /// </li>
    /// <li>
    /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
    /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
    /// </li>
    /// <li>
    /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
    /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table/index/my-table-index</code>.</p>
    /// </li>
    /// <li>
    /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
    /// Example: <code>cluster:my-db-cluster</code>.</p>
    /// </li>
    /// </ul>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The scalable dimension associated with the resource.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
    /// </li>
    /// </ul>
    pub fn scalable_dimension(&self) -> std::option::Option<&crate::model::ScalableDimension> {
        self.scalable_dimension.as_ref()
    }
    /// <p>The minimum capacity of the resource. </p>
    pub fn min_capacity(&self) -> std::option::Option<i32> {
        self.min_capacity
    }
    /// <p>The maximum capacity of the resource. The exception to this upper limit is if you
    /// specify a non-default setting for <b>PredictiveScalingMaxCapacityBehavior</b>. </p>
    pub fn max_capacity(&self) -> std::option::Option<i32> {
        self.max_capacity
    }
    /// <p>The target tracking configurations (up to 10). Each of these structures must specify a
    /// unique scaling metric and a target value for the metric. </p>
    pub fn target_tracking_configurations(
        &self,
    ) -> std::option::Option<&[crate::model::TargetTrackingConfiguration]> {
        self.target_tracking_configurations.as_deref()
    }
    /// <p>The predefined load metric to use for predictive scaling. This parameter or a <b>CustomizedLoadMetricSpecification</b> is required when configuring
    /// predictive scaling, and cannot be used otherwise. </p>
    pub fn predefined_load_metric_specification(
        &self,
    ) -> std::option::Option<&crate::model::PredefinedLoadMetricSpecification> {
        self.predefined_load_metric_specification.as_ref()
    }
    /// <p>The customized load metric to use for predictive scaling. This parameter or a <b>PredefinedLoadMetricSpecification</b> is required when configuring
    /// predictive scaling, and cannot be used otherwise. </p>
    pub fn customized_load_metric_specification(
        &self,
    ) -> std::option::Option<&crate::model::CustomizedLoadMetricSpecification> {
        self.customized_load_metric_specification.as_ref()
    }
    /// <p>The amount of time, in seconds, to buffer the run time of scheduled scaling actions when
    /// scaling out. For example, if the forecast says to add capacity at 10:00 AM, and the buffer
    /// time is 5 minutes, then the run time of the corresponding scheduled scaling action will be
    /// 9:55 AM. The intention is to give resources time to be provisioned. For example, it can
    /// take a few minutes to launch an EC2 instance. The actual amount of time required depends on
    /// several factors, such as the size of the instance and whether there are startup scripts to
    /// complete. </p>
    /// <p>The value must be less than the forecast interval duration of 3600 seconds (60 minutes).
    /// The default is 300 seconds. </p>
    /// <p>Only valid when configuring predictive scaling. </p>
    pub fn scheduled_action_buffer_time(&self) -> std::option::Option<i32> {
        self.scheduled_action_buffer_time
    }
    /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
    /// exceeds the maximum capacity specified for the resource. The default value is
    /// <code>SetForecastCapacityToMaxCapacity</code>.</p>
    /// <p>The following are possible values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SetForecastCapacityToMaxCapacity</code> - AWS Auto Scaling cannot scale resource
    /// capacity higher than the maximum capacity. The maximum capacity is enforced as a hard
    /// limit. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SetMaxCapacityToForecastCapacity</code> - AWS Auto Scaling may scale resource
    /// capacity higher than the maximum capacity to equal but not exceed forecast
    /// capacity.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SetMaxCapacityAboveForecastCapacity</code> - AWS Auto Scaling may scale resource
    /// capacity higher than the maximum capacity by a specified buffer value. The intention
    /// is to give the target tracking scaling policy extra capacity if unexpected traffic
    /// occurs. </p>
    /// </li>
    /// </ul>
    /// <p>Only valid when configuring predictive scaling.</p>
    pub fn predictive_scaling_max_capacity_behavior(
        &self,
    ) -> std::option::Option<&crate::model::PredictiveScalingMaxCapacityBehavior> {
        self.predictive_scaling_max_capacity_behavior.as_ref()
    }
    /// <p>The size of the capacity buffer to use when the forecast capacity is close to or exceeds
    /// the maximum capacity. The value is specified as a percentage relative to the forecast
    /// capacity. For example, if the buffer is 10, this means a 10 percent buffer, such that if
    /// the forecast capacity is 50, and the maximum capacity is 40, then the effective maximum
    /// capacity is 55.</p>
    /// <p>Only valid when configuring predictive scaling. Required if the <b>PredictiveScalingMaxCapacityBehavior</b> is set to
    /// <code>SetMaxCapacityAboveForecastCapacity</code>, and cannot be used otherwise.</p>
    /// <p>The range is 1-100.</p>
    pub fn predictive_scaling_max_capacity_buffer(&self) -> std::option::Option<i32> {
        self.predictive_scaling_max_capacity_buffer
    }
    /// <p>The predictive scaling mode. The default value is <code>ForecastAndScale</code>.
    /// Otherwise, AWS Auto Scaling forecasts capacity but does not create any scheduled scaling actions
    /// based on the capacity forecast. </p>
    pub fn predictive_scaling_mode(
        &self,
    ) -> std::option::Option<&crate::model::PredictiveScalingMode> {
        self.predictive_scaling_mode.as_ref()
    }
    /// <p>Controls whether a resource's externally created scaling policies are kept or replaced. </p>
    /// <p>The default value is <code>KeepExternalPolicies</code>. If the parameter is set to
    /// <code>ReplaceExternalPolicies</code>, any scaling policies that are external to AWS Auto Scaling
    /// are deleted and new target tracking scaling policies created. </p>
    /// <p>Only valid when configuring dynamic scaling. </p>
    /// <p>Condition: The number of existing policies to be replaced must be less than or equal to
    /// 50. If there are more than 50 policies to be replaced, AWS Auto Scaling keeps all existing policies
    /// and does not create new ones.</p>
    pub fn scaling_policy_update_behavior(
        &self,
    ) -> std::option::Option<&crate::model::ScalingPolicyUpdateBehavior> {
        self.scaling_policy_update_behavior.as_ref()
    }
    /// <p>Controls whether dynamic scaling by AWS Auto Scaling is disabled. When dynamic scaling is
    /// enabled, AWS Auto Scaling creates target tracking scaling policies based on the specified target
    /// tracking configurations. </p>
    /// <p>The default is enabled (<code>false</code>). </p>
    pub fn disable_dynamic_scaling(&self) -> std::option::Option<bool> {
        self.disable_dynamic_scaling
    }
}
impl std::fmt::Debug for ScalingInstruction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScalingInstruction");
        formatter.field("service_namespace", &self.service_namespace);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("scalable_dimension", &self.scalable_dimension);
        formatter.field("min_capacity", &self.min_capacity);
        formatter.field("max_capacity", &self.max_capacity);
        formatter.field(
            "target_tracking_configurations",
            &self.target_tracking_configurations,
        );
        formatter.field(
            "predefined_load_metric_specification",
            &self.predefined_load_metric_specification,
        );
        formatter.field(
            "customized_load_metric_specification",
            &self.customized_load_metric_specification,
        );
        formatter.field(
            "scheduled_action_buffer_time",
            &self.scheduled_action_buffer_time,
        );
        formatter.field(
            "predictive_scaling_max_capacity_behavior",
            &self.predictive_scaling_max_capacity_behavior,
        );
        formatter.field(
            "predictive_scaling_max_capacity_buffer",
            &self.predictive_scaling_max_capacity_buffer,
        );
        formatter.field("predictive_scaling_mode", &self.predictive_scaling_mode);
        formatter.field(
            "scaling_policy_update_behavior",
            &self.scaling_policy_update_behavior,
        );
        formatter.field("disable_dynamic_scaling", &self.disable_dynamic_scaling);
        formatter.finish()
    }
}
/// See [`ScalingInstruction`](crate::model::ScalingInstruction)
pub mod scaling_instruction {
    /// A builder for [`ScalingInstruction`](crate::model::ScalingInstruction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_namespace: std::option::Option<crate::model::ServiceNamespace>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) scalable_dimension: std::option::Option<crate::model::ScalableDimension>,
        pub(crate) min_capacity: std::option::Option<i32>,
        pub(crate) max_capacity: std::option::Option<i32>,
        pub(crate) target_tracking_configurations:
            std::option::Option<std::vec::Vec<crate::model::TargetTrackingConfiguration>>,
        pub(crate) predefined_load_metric_specification:
            std::option::Option<crate::model::PredefinedLoadMetricSpecification>,
        pub(crate) customized_load_metric_specification:
            std::option::Option<crate::model::CustomizedLoadMetricSpecification>,
        pub(crate) scheduled_action_buffer_time: std::option::Option<i32>,
        pub(crate) predictive_scaling_max_capacity_behavior:
            std::option::Option<crate::model::PredictiveScalingMaxCapacityBehavior>,
        pub(crate) predictive_scaling_max_capacity_buffer: std::option::Option<i32>,
        pub(crate) predictive_scaling_mode:
            std::option::Option<crate::model::PredictiveScalingMode>,
        pub(crate) scaling_policy_update_behavior:
            std::option::Option<crate::model::ScalingPolicyUpdateBehavior>,
        pub(crate) disable_dynamic_scaling: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The namespace of the AWS service.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.service_namespace = Some(input);
            self
        }
        /// <p>The namespace of the AWS service.</p>
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.service_namespace = input;
            self
        }
        /// <p>The ID of the resource. This string consists of the resource type and unique
        /// identifier.</p>
        /// <ul>
        /// <li>
        /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
        /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
        /// </li>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource. This string consists of the resource type and unique
        /// identifier.</p>
        /// <ul>
        /// <li>
        /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
        /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
        /// </li>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The scalable dimension associated with the resource.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.scalable_dimension = Some(input);
            self
        }
        /// <p>The scalable dimension associated with the resource.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// </ul>
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.scalable_dimension = input;
            self
        }
        /// <p>The minimum capacity of the resource. </p>
        pub fn min_capacity(mut self, input: i32) -> Self {
            self.min_capacity = Some(input);
            self
        }
        /// <p>The minimum capacity of the resource. </p>
        pub fn set_min_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.min_capacity = input;
            self
        }
        /// <p>The maximum capacity of the resource. The exception to this upper limit is if you
        /// specify a non-default setting for <b>PredictiveScalingMaxCapacityBehavior</b>. </p>
        pub fn max_capacity(mut self, input: i32) -> Self {
            self.max_capacity = Some(input);
            self
        }
        /// <p>The maximum capacity of the resource. The exception to this upper limit is if you
        /// specify a non-default setting for <b>PredictiveScalingMaxCapacityBehavior</b>. </p>
        pub fn set_max_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.max_capacity = input;
            self
        }
        /// Appends an item to `target_tracking_configurations`.
        ///
        /// To override the contents of this collection use [`set_target_tracking_configurations`](Self::set_target_tracking_configurations).
        ///
        /// <p>The target tracking configurations (up to 10). Each of these structures must specify a
        /// unique scaling metric and a target value for the metric. </p>
        pub fn target_tracking_configurations(
            mut self,
            input: impl Into<crate::model::TargetTrackingConfiguration>,
        ) -> Self {
            let mut v = self.target_tracking_configurations.unwrap_or_default();
            v.push(input.into());
            self.target_tracking_configurations = Some(v);
            self
        }
        /// <p>The target tracking configurations (up to 10). Each of these structures must specify a
        /// unique scaling metric and a target value for the metric. </p>
        pub fn set_target_tracking_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetTrackingConfiguration>>,
        ) -> Self {
            self.target_tracking_configurations = input;
            self
        }
        /// <p>The predefined load metric to use for predictive scaling. This parameter or a <b>CustomizedLoadMetricSpecification</b> is required when configuring
        /// predictive scaling, and cannot be used otherwise. </p>
        pub fn predefined_load_metric_specification(
            mut self,
            input: crate::model::PredefinedLoadMetricSpecification,
        ) -> Self {
            self.predefined_load_metric_specification = Some(input);
            self
        }
        /// <p>The predefined load metric to use for predictive scaling. This parameter or a <b>CustomizedLoadMetricSpecification</b> is required when configuring
        /// predictive scaling, and cannot be used otherwise. </p>
        pub fn set_predefined_load_metric_specification(
            mut self,
            input: std::option::Option<crate::model::PredefinedLoadMetricSpecification>,
        ) -> Self {
            self.predefined_load_metric_specification = input;
            self
        }
        /// <p>The customized load metric to use for predictive scaling. This parameter or a <b>PredefinedLoadMetricSpecification</b> is required when configuring
        /// predictive scaling, and cannot be used otherwise. </p>
        pub fn customized_load_metric_specification(
            mut self,
            input: crate::model::CustomizedLoadMetricSpecification,
        ) -> Self {
            self.customized_load_metric_specification = Some(input);
            self
        }
        /// <p>The customized load metric to use for predictive scaling. This parameter or a <b>PredefinedLoadMetricSpecification</b> is required when configuring
        /// predictive scaling, and cannot be used otherwise. </p>
        pub fn set_customized_load_metric_specification(
            mut self,
            input: std::option::Option<crate::model::CustomizedLoadMetricSpecification>,
        ) -> Self {
            self.customized_load_metric_specification = input;
            self
        }
        /// <p>The amount of time, in seconds, to buffer the run time of scheduled scaling actions when
        /// scaling out. For example, if the forecast says to add capacity at 10:00 AM, and the buffer
        /// time is 5 minutes, then the run time of the corresponding scheduled scaling action will be
        /// 9:55 AM. The intention is to give resources time to be provisioned. For example, it can
        /// take a few minutes to launch an EC2 instance. The actual amount of time required depends on
        /// several factors, such as the size of the instance and whether there are startup scripts to
        /// complete. </p>
        /// <p>The value must be less than the forecast interval duration of 3600 seconds (60 minutes).
        /// The default is 300 seconds. </p>
        /// <p>Only valid when configuring predictive scaling. </p>
        pub fn scheduled_action_buffer_time(mut self, input: i32) -> Self {
            self.scheduled_action_buffer_time = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, to buffer the run time of scheduled scaling actions when
        /// scaling out. For example, if the forecast says to add capacity at 10:00 AM, and the buffer
        /// time is 5 minutes, then the run time of the corresponding scheduled scaling action will be
        /// 9:55 AM. The intention is to give resources time to be provisioned. For example, it can
        /// take a few minutes to launch an EC2 instance. The actual amount of time required depends on
        /// several factors, such as the size of the instance and whether there are startup scripts to
        /// complete. </p>
        /// <p>The value must be less than the forecast interval duration of 3600 seconds (60 minutes).
        /// The default is 300 seconds. </p>
        /// <p>Only valid when configuring predictive scaling. </p>
        pub fn set_scheduled_action_buffer_time(mut self, input: std::option::Option<i32>) -> Self {
            self.scheduled_action_buffer_time = input;
            self
        }
        /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
        /// exceeds the maximum capacity specified for the resource. The default value is
        /// <code>SetForecastCapacityToMaxCapacity</code>.</p>
        /// <p>The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SetForecastCapacityToMaxCapacity</code> - AWS Auto Scaling cannot scale resource
        /// capacity higher than the maximum capacity. The maximum capacity is enforced as a hard
        /// limit. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SetMaxCapacityToForecastCapacity</code> - AWS Auto Scaling may scale resource
        /// capacity higher than the maximum capacity to equal but not exceed forecast
        /// capacity.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SetMaxCapacityAboveForecastCapacity</code> - AWS Auto Scaling may scale resource
        /// capacity higher than the maximum capacity by a specified buffer value. The intention
        /// is to give the target tracking scaling policy extra capacity if unexpected traffic
        /// occurs. </p>
        /// </li>
        /// </ul>
        /// <p>Only valid when configuring predictive scaling.</p>
        pub fn predictive_scaling_max_capacity_behavior(
            mut self,
            input: crate::model::PredictiveScalingMaxCapacityBehavior,
        ) -> Self {
            self.predictive_scaling_max_capacity_behavior = Some(input);
            self
        }
        /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
        /// exceeds the maximum capacity specified for the resource. The default value is
        /// <code>SetForecastCapacityToMaxCapacity</code>.</p>
        /// <p>The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SetForecastCapacityToMaxCapacity</code> - AWS Auto Scaling cannot scale resource
        /// capacity higher than the maximum capacity. The maximum capacity is enforced as a hard
        /// limit. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SetMaxCapacityToForecastCapacity</code> - AWS Auto Scaling may scale resource
        /// capacity higher than the maximum capacity to equal but not exceed forecast
        /// capacity.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SetMaxCapacityAboveForecastCapacity</code> - AWS Auto Scaling may scale resource
        /// capacity higher than the maximum capacity by a specified buffer value. The intention
        /// is to give the target tracking scaling policy extra capacity if unexpected traffic
        /// occurs. </p>
        /// </li>
        /// </ul>
        /// <p>Only valid when configuring predictive scaling.</p>
        pub fn set_predictive_scaling_max_capacity_behavior(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingMaxCapacityBehavior>,
        ) -> Self {
            self.predictive_scaling_max_capacity_behavior = input;
            self
        }
        /// <p>The size of the capacity buffer to use when the forecast capacity is close to or exceeds
        /// the maximum capacity. The value is specified as a percentage relative to the forecast
        /// capacity. For example, if the buffer is 10, this means a 10 percent buffer, such that if
        /// the forecast capacity is 50, and the maximum capacity is 40, then the effective maximum
        /// capacity is 55.</p>
        /// <p>Only valid when configuring predictive scaling. Required if the <b>PredictiveScalingMaxCapacityBehavior</b> is set to
        /// <code>SetMaxCapacityAboveForecastCapacity</code>, and cannot be used otherwise.</p>
        /// <p>The range is 1-100.</p>
        pub fn predictive_scaling_max_capacity_buffer(mut self, input: i32) -> Self {
            self.predictive_scaling_max_capacity_buffer = Some(input);
            self
        }
        /// <p>The size of the capacity buffer to use when the forecast capacity is close to or exceeds
        /// the maximum capacity. The value is specified as a percentage relative to the forecast
        /// capacity. For example, if the buffer is 10, this means a 10 percent buffer, such that if
        /// the forecast capacity is 50, and the maximum capacity is 40, then the effective maximum
        /// capacity is 55.</p>
        /// <p>Only valid when configuring predictive scaling. Required if the <b>PredictiveScalingMaxCapacityBehavior</b> is set to
        /// <code>SetMaxCapacityAboveForecastCapacity</code>, and cannot be used otherwise.</p>
        /// <p>The range is 1-100.</p>
        pub fn set_predictive_scaling_max_capacity_buffer(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.predictive_scaling_max_capacity_buffer = input;
            self
        }
        /// <p>The predictive scaling mode. The default value is <code>ForecastAndScale</code>.
        /// Otherwise, AWS Auto Scaling forecasts capacity but does not create any scheduled scaling actions
        /// based on the capacity forecast. </p>
        pub fn predictive_scaling_mode(
            mut self,
            input: crate::model::PredictiveScalingMode,
        ) -> Self {
            self.predictive_scaling_mode = Some(input);
            self
        }
        /// <p>The predictive scaling mode. The default value is <code>ForecastAndScale</code>.
        /// Otherwise, AWS Auto Scaling forecasts capacity but does not create any scheduled scaling actions
        /// based on the capacity forecast. </p>
        pub fn set_predictive_scaling_mode(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingMode>,
        ) -> Self {
            self.predictive_scaling_mode = input;
            self
        }
        /// <p>Controls whether a resource's externally created scaling policies are kept or replaced. </p>
        /// <p>The default value is <code>KeepExternalPolicies</code>. If the parameter is set to
        /// <code>ReplaceExternalPolicies</code>, any scaling policies that are external to AWS Auto Scaling
        /// are deleted and new target tracking scaling policies created. </p>
        /// <p>Only valid when configuring dynamic scaling. </p>
        /// <p>Condition: The number of existing policies to be replaced must be less than or equal to
        /// 50. If there are more than 50 policies to be replaced, AWS Auto Scaling keeps all existing policies
        /// and does not create new ones.</p>
        pub fn scaling_policy_update_behavior(
            mut self,
            input: crate::model::ScalingPolicyUpdateBehavior,
        ) -> Self {
            self.scaling_policy_update_behavior = Some(input);
            self
        }
        /// <p>Controls whether a resource's externally created scaling policies are kept or replaced. </p>
        /// <p>The default value is <code>KeepExternalPolicies</code>. If the parameter is set to
        /// <code>ReplaceExternalPolicies</code>, any scaling policies that are external to AWS Auto Scaling
        /// are deleted and new target tracking scaling policies created. </p>
        /// <p>Only valid when configuring dynamic scaling. </p>
        /// <p>Condition: The number of existing policies to be replaced must be less than or equal to
        /// 50. If there are more than 50 policies to be replaced, AWS Auto Scaling keeps all existing policies
        /// and does not create new ones.</p>
        pub fn set_scaling_policy_update_behavior(
            mut self,
            input: std::option::Option<crate::model::ScalingPolicyUpdateBehavior>,
        ) -> Self {
            self.scaling_policy_update_behavior = input;
            self
        }
        /// <p>Controls whether dynamic scaling by AWS Auto Scaling is disabled. When dynamic scaling is
        /// enabled, AWS Auto Scaling creates target tracking scaling policies based on the specified target
        /// tracking configurations. </p>
        /// <p>The default is enabled (<code>false</code>). </p>
        pub fn disable_dynamic_scaling(mut self, input: bool) -> Self {
            self.disable_dynamic_scaling = Some(input);
            self
        }
        /// <p>Controls whether dynamic scaling by AWS Auto Scaling is disabled. When dynamic scaling is
        /// enabled, AWS Auto Scaling creates target tracking scaling policies based on the specified target
        /// tracking configurations. </p>
        /// <p>The default is enabled (<code>false</code>). </p>
        pub fn set_disable_dynamic_scaling(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_dynamic_scaling = input;
            self
        }
        /// Consumes the builder and constructs a [`ScalingInstruction`](crate::model::ScalingInstruction)
        pub fn build(self) -> crate::model::ScalingInstruction {
            crate::model::ScalingInstruction {
                service_namespace: self.service_namespace,
                resource_id: self.resource_id,
                scalable_dimension: self.scalable_dimension,
                min_capacity: self.min_capacity,
                max_capacity: self.max_capacity,
                target_tracking_configurations: self.target_tracking_configurations,
                predefined_load_metric_specification: self.predefined_load_metric_specification,
                customized_load_metric_specification: self.customized_load_metric_specification,
                scheduled_action_buffer_time: self.scheduled_action_buffer_time,
                predictive_scaling_max_capacity_behavior: self
                    .predictive_scaling_max_capacity_behavior,
                predictive_scaling_max_capacity_buffer: self.predictive_scaling_max_capacity_buffer,
                predictive_scaling_mode: self.predictive_scaling_mode,
                scaling_policy_update_behavior: self.scaling_policy_update_behavior,
                disable_dynamic_scaling: self.disable_dynamic_scaling,
            }
        }
    }
}
impl ScalingInstruction {
    /// Creates a new builder-style object to manufacture [`ScalingInstruction`](crate::model::ScalingInstruction)
    pub fn builder() -> crate::model::scaling_instruction::Builder {
        crate::model::scaling_instruction::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingPolicyUpdateBehavior {
    #[allow(missing_docs)] // documentation missing in model
    KeepExternalPolicies,
    #[allow(missing_docs)] // documentation missing in model
    ReplaceExternalPolicies,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalingPolicyUpdateBehavior {
    fn from(s: &str) -> Self {
        match s {
            "KeepExternalPolicies" => ScalingPolicyUpdateBehavior::KeepExternalPolicies,
            "ReplaceExternalPolicies" => ScalingPolicyUpdateBehavior::ReplaceExternalPolicies,
            other => ScalingPolicyUpdateBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalingPolicyUpdateBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalingPolicyUpdateBehavior::from(s))
    }
}
impl ScalingPolicyUpdateBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalingPolicyUpdateBehavior::KeepExternalPolicies => "KeepExternalPolicies",
            ScalingPolicyUpdateBehavior::ReplaceExternalPolicies => "ReplaceExternalPolicies",
            ScalingPolicyUpdateBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["KeepExternalPolicies", "ReplaceExternalPolicies"]
    }
}
impl AsRef<str> for ScalingPolicyUpdateBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredictiveScalingMode {
    #[allow(missing_docs)] // documentation missing in model
    ForecastAndScale,
    #[allow(missing_docs)] // documentation missing in model
    ForecastOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredictiveScalingMode {
    fn from(s: &str) -> Self {
        match s {
            "ForecastAndScale" => PredictiveScalingMode::ForecastAndScale,
            "ForecastOnly" => PredictiveScalingMode::ForecastOnly,
            other => PredictiveScalingMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredictiveScalingMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredictiveScalingMode::from(s))
    }
}
impl PredictiveScalingMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PredictiveScalingMode::ForecastAndScale => "ForecastAndScale",
            PredictiveScalingMode::ForecastOnly => "ForecastOnly",
            PredictiveScalingMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ForecastAndScale", "ForecastOnly"]
    }
}
impl AsRef<str> for PredictiveScalingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredictiveScalingMaxCapacityBehavior {
    #[allow(missing_docs)] // documentation missing in model
    SetForecastCapacityToMaxCapacity,
    #[allow(missing_docs)] // documentation missing in model
    SetMaxCapacityAboveForecastCapacity,
    #[allow(missing_docs)] // documentation missing in model
    SetMaxCapacityToForecastCapacity,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredictiveScalingMaxCapacityBehavior {
    fn from(s: &str) -> Self {
        match s {
            "SetForecastCapacityToMaxCapacity" => {
                PredictiveScalingMaxCapacityBehavior::SetForecastCapacityToMaxCapacity
            }
            "SetMaxCapacityAboveForecastCapacity" => {
                PredictiveScalingMaxCapacityBehavior::SetMaxCapacityAboveForecastCapacity
            }
            "SetMaxCapacityToForecastCapacity" => {
                PredictiveScalingMaxCapacityBehavior::SetMaxCapacityToForecastCapacity
            }
            other => PredictiveScalingMaxCapacityBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredictiveScalingMaxCapacityBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredictiveScalingMaxCapacityBehavior::from(s))
    }
}
impl PredictiveScalingMaxCapacityBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PredictiveScalingMaxCapacityBehavior::SetForecastCapacityToMaxCapacity => {
                "SetForecastCapacityToMaxCapacity"
            }
            PredictiveScalingMaxCapacityBehavior::SetMaxCapacityAboveForecastCapacity => {
                "SetMaxCapacityAboveForecastCapacity"
            }
            PredictiveScalingMaxCapacityBehavior::SetMaxCapacityToForecastCapacity => {
                "SetMaxCapacityToForecastCapacity"
            }
            PredictiveScalingMaxCapacityBehavior::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "SetForecastCapacityToMaxCapacity",
            "SetMaxCapacityAboveForecastCapacity",
            "SetMaxCapacityToForecastCapacity",
        ]
    }
}
impl AsRef<str> for PredictiveScalingMaxCapacityBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a CloudWatch metric of your choosing that can be used for predictive scaling. </p>
/// <p>For predictive scaling to work with a customized load metric specification, AWS Auto Scaling
/// needs access to the <code>Sum</code> and <code>Average</code> statistics that CloudWatch computes
/// from metric data.</p>
/// <p>When you choose a load metric, make sure that the required <code>Sum</code> and
/// <code>Average</code> statistics for your metric are available in CloudWatch and that they
/// provide relevant data for predictive scaling. The <code>Sum</code> statistic must represent
/// the total load on the resource, and the <code>Average</code> statistic must represent the
/// average load per capacity unit of the resource. For example, there is a metric that counts
/// the number of requests processed by your Auto Scaling group. If the <code>Sum</code> statistic
/// represents the total request count processed by the group, then the <code>Average</code>
/// statistic for the specified metric must represent the average request count processed by
/// each instance of the group. </p>
/// <p>If you publish your own metrics, you can aggregate the data points at a given interval
/// and then publish the aggregated data points to CloudWatch. Before AWS Auto Scaling generates the
/// forecast, it sums up all the metric data points that occurred within each hour to match the
/// granularity period that is used in the forecast (60 minutes).</p>
/// <p>For information about terminology, available metrics, or how to publish new metrics, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html">Amazon CloudWatch
/// Concepts</a> in the <i>Amazon CloudWatch User Guide</i>. </p>
/// <p>After creating your scaling plan, you can use the AWS Auto Scaling console to visualize
/// forecasts for the specified metric. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-create-scaling-plan.html#gs-view-resource">View
/// Scaling Information for a Resource</a> in the
/// <i>AWS Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomizedLoadMetricSpecification {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace of the metric.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The dimensions of the metric.</p>
    /// <p>Conditional: If you published your metric with dimensions, you must specify the same
    /// dimensions in your customized load metric specification.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
    /// <p>The statistic of the metric. The only valid value is <code>Sum</code>.</p>
    pub statistic: std::option::Option<crate::model::MetricStatistic>,
    /// <p>The unit of the metric.</p>
    pub unit: std::option::Option<std::string::String>,
}
impl CustomizedLoadMetricSpecification {
    /// <p>The name of the metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The namespace of the metric.</p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The dimensions of the metric.</p>
    /// <p>Conditional: If you published your metric with dimensions, you must specify the same
    /// dimensions in your customized load metric specification.</p>
    pub fn dimensions(&self) -> std::option::Option<&[crate::model::MetricDimension]> {
        self.dimensions.as_deref()
    }
    /// <p>The statistic of the metric. The only valid value is <code>Sum</code>.</p>
    pub fn statistic(&self) -> std::option::Option<&crate::model::MetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p>The unit of the metric.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
}
impl std::fmt::Debug for CustomizedLoadMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomizedLoadMetricSpecification");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("namespace", &self.namespace);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("statistic", &self.statistic);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`CustomizedLoadMetricSpecification`](crate::model::CustomizedLoadMetricSpecification)
pub mod customized_load_metric_specification {
    /// A builder for [`CustomizedLoadMetricSpecification`](crate::model::CustomizedLoadMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
        pub(crate) statistic: std::option::Option<crate::model::MetricStatistic>,
        pub(crate) unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions of the metric.</p>
        /// <p>Conditional: If you published your metric with dimensions, you must specify the same
        /// dimensions in your customized load metric specification.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::MetricDimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions of the metric.</p>
        /// <p>Conditional: If you published your metric with dimensions, you must specify the same
        /// dimensions in your customized load metric specification.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The statistic of the metric. The only valid value is <code>Sum</code>.</p>
        pub fn statistic(mut self, input: crate::model::MetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the metric. The only valid value is <code>Sum</code>.</p>
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::MetricStatistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The unit of the metric.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit of the metric.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomizedLoadMetricSpecification`](crate::model::CustomizedLoadMetricSpecification)
        pub fn build(self) -> crate::model::CustomizedLoadMetricSpecification {
            crate::model::CustomizedLoadMetricSpecification {
                metric_name: self.metric_name,
                namespace: self.namespace,
                dimensions: self.dimensions,
                statistic: self.statistic,
                unit: self.unit,
            }
        }
    }
}
impl CustomizedLoadMetricSpecification {
    /// Creates a new builder-style object to manufacture [`CustomizedLoadMetricSpecification`](crate::model::CustomizedLoadMetricSpecification)
    pub fn builder() -> crate::model::customized_load_metric_specification::Builder {
        crate::model::customized_load_metric_specification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricStatistic {
    #[allow(missing_docs)] // documentation missing in model
    Average,
    #[allow(missing_docs)] // documentation missing in model
    Maximum,
    #[allow(missing_docs)] // documentation missing in model
    Minimum,
    #[allow(missing_docs)] // documentation missing in model
    SampleCount,
    #[allow(missing_docs)] // documentation missing in model
    Sum,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MetricStatistic {
    fn from(s: &str) -> Self {
        match s {
            "Average" => MetricStatistic::Average,
            "Maximum" => MetricStatistic::Maximum,
            "Minimum" => MetricStatistic::Minimum,
            "SampleCount" => MetricStatistic::SampleCount,
            "Sum" => MetricStatistic::Sum,
            other => MetricStatistic::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MetricStatistic {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricStatistic::from(s))
    }
}
impl MetricStatistic {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricStatistic::Average => "Average",
            MetricStatistic::Maximum => "Maximum",
            MetricStatistic::Minimum => "Minimum",
            MetricStatistic::SampleCount => "SampleCount",
            MetricStatistic::Sum => "Sum",
            MetricStatistic::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Average", "Maximum", "Minimum", "SampleCount", "Sum"]
    }
}
impl AsRef<str> for MetricStatistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a dimension for a customized metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricDimension {
    /// <p>The name of the dimension.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the dimension.</p>
    pub value: std::option::Option<std::string::String>,
}
impl MetricDimension {
    /// <p>The name of the dimension.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value of the dimension.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for MetricDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricDimension");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`MetricDimension`](crate::model::MetricDimension)
pub mod metric_dimension {
    /// A builder for [`MetricDimension`](crate::model::MetricDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the dimension.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the dimension.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the dimension.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the dimension.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDimension`](crate::model::MetricDimension)
        pub fn build(self) -> crate::model::MetricDimension {
            crate::model::MetricDimension {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl MetricDimension {
    /// Creates a new builder-style object to manufacture [`MetricDimension`](crate::model::MetricDimension)
    pub fn builder() -> crate::model::metric_dimension::Builder {
        crate::model::metric_dimension::Builder::default()
    }
}

/// <p>Represents a predefined metric that can be used for predictive scaling.</p>
/// <p>After creating your scaling plan, you can use the AWS Auto Scaling console to visualize
/// forecasts for the specified metric. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/plans/userguide/gs-create-scaling-plan.html#gs-view-resource">View
/// Scaling Information for a Resource</a> in the
/// <i>AWS Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredefinedLoadMetricSpecification {
    /// <p>The metric type.</p>
    pub predefined_load_metric_type: std::option::Option<crate::model::LoadMetricType>,
    /// <p>Identifies the resource associated with the metric type. You can't specify a resource
    /// label unless the metric type is <code>ALBTargetGroupRequestCount</code> and there is a
    /// target group for an Application Load Balancer attached to the Auto Scaling group.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format is
    /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
    /// where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>This is an example:
    /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub resource_label: std::option::Option<std::string::String>,
}
impl PredefinedLoadMetricSpecification {
    /// <p>The metric type.</p>
    pub fn predefined_load_metric_type(
        &self,
    ) -> std::option::Option<&crate::model::LoadMetricType> {
        self.predefined_load_metric_type.as_ref()
    }
    /// <p>Identifies the resource associated with the metric type. You can't specify a resource
    /// label unless the metric type is <code>ALBTargetGroupRequestCount</code> and there is a
    /// target group for an Application Load Balancer attached to the Auto Scaling group.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format is
    /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
    /// where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>This is an example:
    /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub fn resource_label(&self) -> std::option::Option<&str> {
        self.resource_label.as_deref()
    }
}
impl std::fmt::Debug for PredefinedLoadMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredefinedLoadMetricSpecification");
        formatter.field(
            "predefined_load_metric_type",
            &self.predefined_load_metric_type,
        );
        formatter.field("resource_label", &self.resource_label);
        formatter.finish()
    }
}
/// See [`PredefinedLoadMetricSpecification`](crate::model::PredefinedLoadMetricSpecification)
pub mod predefined_load_metric_specification {
    /// A builder for [`PredefinedLoadMetricSpecification`](crate::model::PredefinedLoadMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_load_metric_type: std::option::Option<crate::model::LoadMetricType>,
        pub(crate) resource_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric type.</p>
        pub fn predefined_load_metric_type(mut self, input: crate::model::LoadMetricType) -> Self {
            self.predefined_load_metric_type = Some(input);
            self
        }
        /// <p>The metric type.</p>
        pub fn set_predefined_load_metric_type(
            mut self,
            input: std::option::Option<crate::model::LoadMetricType>,
        ) -> Self {
            self.predefined_load_metric_type = input;
            self
        }
        /// <p>Identifies the resource associated with the metric type. You can't specify a resource
        /// label unless the metric type is <code>ALBTargetGroupRequestCount</code> and there is a
        /// target group for an Application Load Balancer attached to the Auto Scaling group.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format is
        /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
        /// where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>This is an example:
        /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn resource_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_label = Some(input.into());
            self
        }
        /// <p>Identifies the resource associated with the metric type. You can't specify a resource
        /// label unless the metric type is <code>ALBTargetGroupRequestCount</code> and there is a
        /// target group for an Application Load Balancer attached to the Auto Scaling group.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format is
        /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
        /// where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>This is an example:
        /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn set_resource_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_label = input;
            self
        }
        /// Consumes the builder and constructs a [`PredefinedLoadMetricSpecification`](crate::model::PredefinedLoadMetricSpecification)
        pub fn build(self) -> crate::model::PredefinedLoadMetricSpecification {
            crate::model::PredefinedLoadMetricSpecification {
                predefined_load_metric_type: self.predefined_load_metric_type,
                resource_label: self.resource_label,
            }
        }
    }
}
impl PredefinedLoadMetricSpecification {
    /// Creates a new builder-style object to manufacture [`PredefinedLoadMetricSpecification`](crate::model::PredefinedLoadMetricSpecification)
    pub fn builder() -> crate::model::predefined_load_metric_specification::Builder {
        crate::model::predefined_load_metric_specification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LoadMetricType {
    #[allow(missing_docs)] // documentation missing in model
    AlbTargetGroupRequestCount,
    #[allow(missing_docs)] // documentation missing in model
    AsgTotalCpuUtilization,
    #[allow(missing_docs)] // documentation missing in model
    AsgTotalNetworkIn,
    #[allow(missing_docs)] // documentation missing in model
    AsgTotalNetworkOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LoadMetricType {
    fn from(s: &str) -> Self {
        match s {
            "ALBTargetGroupRequestCount" => LoadMetricType::AlbTargetGroupRequestCount,
            "ASGTotalCPUUtilization" => LoadMetricType::AsgTotalCpuUtilization,
            "ASGTotalNetworkIn" => LoadMetricType::AsgTotalNetworkIn,
            "ASGTotalNetworkOut" => LoadMetricType::AsgTotalNetworkOut,
            other => LoadMetricType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LoadMetricType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LoadMetricType::from(s))
    }
}
impl LoadMetricType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LoadMetricType::AlbTargetGroupRequestCount => "ALBTargetGroupRequestCount",
            LoadMetricType::AsgTotalCpuUtilization => "ASGTotalCPUUtilization",
            LoadMetricType::AsgTotalNetworkIn => "ASGTotalNetworkIn",
            LoadMetricType::AsgTotalNetworkOut => "ASGTotalNetworkOut",
            LoadMetricType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ALBTargetGroupRequestCount",
            "ASGTotalCPUUtilization",
            "ASGTotalNetworkIn",
            "ASGTotalNetworkOut",
        ]
    }
}
impl AsRef<str> for LoadMetricType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a target tracking configuration to use with AWS Auto Scaling. Used with <a>ScalingInstruction</a> and <a>ScalingPolicy</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetTrackingConfiguration {
    /// <p>A predefined metric. You can specify either a predefined metric or a customized
    /// metric.</p>
    pub predefined_scaling_metric_specification:
        std::option::Option<crate::model::PredefinedScalingMetricSpecification>,
    /// <p>A customized metric. You can specify either a predefined metric or a customized metric.
    /// </p>
    pub customized_scaling_metric_specification:
        std::option::Option<crate::model::CustomizedScalingMetricSpecification>,
    /// <p>The target value for the metric. Although this property accepts numbers of type Double,
    /// it won't accept values that are either too small or too large. Values must be in the range
    /// of -2^360 to 2^360.</p>
    pub target_value: std::option::Option<f64>,
    /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
    /// value is <code>true</code>, scale in is disabled and the target tracking scaling policy
    /// doesn't remove capacity from the scalable resource. Otherwise, scale in is enabled and the
    /// target tracking scaling policy can remove capacity from the scalable resource. </p>
    /// <p>The default value is <code>false</code>.</p>
    pub disable_scale_in: std::option::Option<bool>,
    /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
    /// effect. This property is not used if the scalable resource is an Auto Scaling
    /// group.</p>
    /// <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
    /// (but not excessively) scale out. After Auto Scaling successfully scales out using a target
    /// tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
    /// increase the desired capacity again unless either a larger scale out is triggered or the
    /// cooldown period ends.</p>
    pub scale_out_cooldown: std::option::Option<i32>,
    /// <p>The amount of time, in seconds, after a scale-in activity completes before another
    /// scale-in activity can start. This property is not used if the scalable resource is an Auto Scaling
    /// group.</p>
    /// <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
    /// conservatively to protect your application’s availability, so scale-in activities are blocked
    /// until the cooldown period has expired. However, if another alarm triggers a scale-out activity
    /// during the scale-in cooldown period, Auto Scaling scales out the target immediately. In this case,
    /// the scale-in cooldown period stops and doesn't complete.</p>
    pub scale_in_cooldown: std::option::Option<i32>,
    /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
    /// CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.</p>
    pub estimated_instance_warmup: std::option::Option<i32>,
}
impl TargetTrackingConfiguration {
    /// <p>A predefined metric. You can specify either a predefined metric or a customized
    /// metric.</p>
    pub fn predefined_scaling_metric_specification(
        &self,
    ) -> std::option::Option<&crate::model::PredefinedScalingMetricSpecification> {
        self.predefined_scaling_metric_specification.as_ref()
    }
    /// <p>A customized metric. You can specify either a predefined metric or a customized metric.
    /// </p>
    pub fn customized_scaling_metric_specification(
        &self,
    ) -> std::option::Option<&crate::model::CustomizedScalingMetricSpecification> {
        self.customized_scaling_metric_specification.as_ref()
    }
    /// <p>The target value for the metric. Although this property accepts numbers of type Double,
    /// it won't accept values that are either too small or too large. Values must be in the range
    /// of -2^360 to 2^360.</p>
    pub fn target_value(&self) -> std::option::Option<f64> {
        self.target_value
    }
    /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
    /// value is <code>true</code>, scale in is disabled and the target tracking scaling policy
    /// doesn't remove capacity from the scalable resource. Otherwise, scale in is enabled and the
    /// target tracking scaling policy can remove capacity from the scalable resource. </p>
    /// <p>The default value is <code>false</code>.</p>
    pub fn disable_scale_in(&self) -> std::option::Option<bool> {
        self.disable_scale_in
    }
    /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
    /// effect. This property is not used if the scalable resource is an Auto Scaling
    /// group.</p>
    /// <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
    /// (but not excessively) scale out. After Auto Scaling successfully scales out using a target
    /// tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
    /// increase the desired capacity again unless either a larger scale out is triggered or the
    /// cooldown period ends.</p>
    pub fn scale_out_cooldown(&self) -> std::option::Option<i32> {
        self.scale_out_cooldown
    }
    /// <p>The amount of time, in seconds, after a scale-in activity completes before another
    /// scale-in activity can start. This property is not used if the scalable resource is an Auto Scaling
    /// group.</p>
    /// <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
    /// conservatively to protect your application’s availability, so scale-in activities are blocked
    /// until the cooldown period has expired. However, if another alarm triggers a scale-out activity
    /// during the scale-in cooldown period, Auto Scaling scales out the target immediately. In this case,
    /// the scale-in cooldown period stops and doesn't complete.</p>
    pub fn scale_in_cooldown(&self) -> std::option::Option<i32> {
        self.scale_in_cooldown
    }
    /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
    /// CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.</p>
    pub fn estimated_instance_warmup(&self) -> std::option::Option<i32> {
        self.estimated_instance_warmup
    }
}
impl std::fmt::Debug for TargetTrackingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetTrackingConfiguration");
        formatter.field(
            "predefined_scaling_metric_specification",
            &self.predefined_scaling_metric_specification,
        );
        formatter.field(
            "customized_scaling_metric_specification",
            &self.customized_scaling_metric_specification,
        );
        formatter.field("target_value", &self.target_value);
        formatter.field("disable_scale_in", &self.disable_scale_in);
        formatter.field("scale_out_cooldown", &self.scale_out_cooldown);
        formatter.field("scale_in_cooldown", &self.scale_in_cooldown);
        formatter.field("estimated_instance_warmup", &self.estimated_instance_warmup);
        formatter.finish()
    }
}
/// See [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
pub mod target_tracking_configuration {
    /// A builder for [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_scaling_metric_specification:
            std::option::Option<crate::model::PredefinedScalingMetricSpecification>,
        pub(crate) customized_scaling_metric_specification:
            std::option::Option<crate::model::CustomizedScalingMetricSpecification>,
        pub(crate) target_value: std::option::Option<f64>,
        pub(crate) disable_scale_in: std::option::Option<bool>,
        pub(crate) scale_out_cooldown: std::option::Option<i32>,
        pub(crate) scale_in_cooldown: std::option::Option<i32>,
        pub(crate) estimated_instance_warmup: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A predefined metric. You can specify either a predefined metric or a customized
        /// metric.</p>
        pub fn predefined_scaling_metric_specification(
            mut self,
            input: crate::model::PredefinedScalingMetricSpecification,
        ) -> Self {
            self.predefined_scaling_metric_specification = Some(input);
            self
        }
        /// <p>A predefined metric. You can specify either a predefined metric or a customized
        /// metric.</p>
        pub fn set_predefined_scaling_metric_specification(
            mut self,
            input: std::option::Option<crate::model::PredefinedScalingMetricSpecification>,
        ) -> Self {
            self.predefined_scaling_metric_specification = input;
            self
        }
        /// <p>A customized metric. You can specify either a predefined metric or a customized metric.
        /// </p>
        pub fn customized_scaling_metric_specification(
            mut self,
            input: crate::model::CustomizedScalingMetricSpecification,
        ) -> Self {
            self.customized_scaling_metric_specification = Some(input);
            self
        }
        /// <p>A customized metric. You can specify either a predefined metric or a customized metric.
        /// </p>
        pub fn set_customized_scaling_metric_specification(
            mut self,
            input: std::option::Option<crate::model::CustomizedScalingMetricSpecification>,
        ) -> Self {
            self.customized_scaling_metric_specification = input;
            self
        }
        /// <p>The target value for the metric. Although this property accepts numbers of type Double,
        /// it won't accept values that are either too small or too large. Values must be in the range
        /// of -2^360 to 2^360.</p>
        pub fn target_value(mut self, input: f64) -> Self {
            self.target_value = Some(input);
            self
        }
        /// <p>The target value for the metric. Although this property accepts numbers of type Double,
        /// it won't accept values that are either too small or too large. Values must be in the range
        /// of -2^360 to 2^360.</p>
        pub fn set_target_value(mut self, input: std::option::Option<f64>) -> Self {
            self.target_value = input;
            self
        }
        /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
        /// value is <code>true</code>, scale in is disabled and the target tracking scaling policy
        /// doesn't remove capacity from the scalable resource. Otherwise, scale in is enabled and the
        /// target tracking scaling policy can remove capacity from the scalable resource. </p>
        /// <p>The default value is <code>false</code>.</p>
        pub fn disable_scale_in(mut self, input: bool) -> Self {
            self.disable_scale_in = Some(input);
            self
        }
        /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
        /// value is <code>true</code>, scale in is disabled and the target tracking scaling policy
        /// doesn't remove capacity from the scalable resource. Otherwise, scale in is enabled and the
        /// target tracking scaling policy can remove capacity from the scalable resource. </p>
        /// <p>The default value is <code>false</code>.</p>
        pub fn set_disable_scale_in(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_scale_in = input;
            self
        }
        /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
        /// effect. This property is not used if the scalable resource is an Auto Scaling
        /// group.</p>
        /// <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
        /// (but not excessively) scale out. After Auto Scaling successfully scales out using a target
        /// tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
        /// increase the desired capacity again unless either a larger scale out is triggered or the
        /// cooldown period ends.</p>
        pub fn scale_out_cooldown(mut self, input: i32) -> Self {
            self.scale_out_cooldown = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
        /// effect. This property is not used if the scalable resource is an Auto Scaling
        /// group.</p>
        /// <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
        /// (but not excessively) scale out. After Auto Scaling successfully scales out using a target
        /// tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
        /// increase the desired capacity again unless either a larger scale out is triggered or the
        /// cooldown period ends.</p>
        pub fn set_scale_out_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.scale_out_cooldown = input;
            self
        }
        /// <p>The amount of time, in seconds, after a scale-in activity completes before another
        /// scale-in activity can start. This property is not used if the scalable resource is an Auto Scaling
        /// group.</p>
        /// <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
        /// conservatively to protect your application’s availability, so scale-in activities are blocked
        /// until the cooldown period has expired. However, if another alarm triggers a scale-out activity
        /// during the scale-in cooldown period, Auto Scaling scales out the target immediately. In this case,
        /// the scale-in cooldown period stops and doesn't complete.</p>
        pub fn scale_in_cooldown(mut self, input: i32) -> Self {
            self.scale_in_cooldown = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, after a scale-in activity completes before another
        /// scale-in activity can start. This property is not used if the scalable resource is an Auto Scaling
        /// group.</p>
        /// <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
        /// conservatively to protect your application’s availability, so scale-in activities are blocked
        /// until the cooldown period has expired. However, if another alarm triggers a scale-out activity
        /// during the scale-in cooldown period, Auto Scaling scales out the target immediately. In this case,
        /// the scale-in cooldown period stops and doesn't complete.</p>
        pub fn set_scale_in_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.scale_in_cooldown = input;
            self
        }
        /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
        /// CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.</p>
        pub fn estimated_instance_warmup(mut self, input: i32) -> Self {
            self.estimated_instance_warmup = Some(input);
            self
        }
        /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
        /// CloudWatch metrics. This value is used only if the resource is an Auto Scaling group.</p>
        pub fn set_estimated_instance_warmup(mut self, input: std::option::Option<i32>) -> Self {
            self.estimated_instance_warmup = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
        pub fn build(self) -> crate::model::TargetTrackingConfiguration {
            crate::model::TargetTrackingConfiguration {
                predefined_scaling_metric_specification: self
                    .predefined_scaling_metric_specification,
                customized_scaling_metric_specification: self
                    .customized_scaling_metric_specification,
                target_value: self.target_value,
                disable_scale_in: self.disable_scale_in,
                scale_out_cooldown: self.scale_out_cooldown,
                scale_in_cooldown: self.scale_in_cooldown,
                estimated_instance_warmup: self.estimated_instance_warmup,
            }
        }
    }
}
impl TargetTrackingConfiguration {
    /// Creates a new builder-style object to manufacture [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
    pub fn builder() -> crate::model::target_tracking_configuration::Builder {
        crate::model::target_tracking_configuration::Builder::default()
    }
}

/// <p>Represents a CloudWatch metric of your choosing that can be used for dynamic scaling as part
/// of a target tracking scaling policy. </p>
/// <p>To create your customized scaling metric specification:</p>
/// <ul>
/// <li>
/// <p>Add values for each required parameter from CloudWatch. You can use an existing metric,
/// or a new metric that you create. To use your own metric, you must first publish the
/// metric to CloudWatch. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publish Custom
/// Metrics</a> in the <i>Amazon CloudWatch User Guide</i>.</p>
/// </li>
/// <li>
/// <p>Choose a metric that changes proportionally with capacity. The value of the metric
/// should increase or decrease in inverse proportion to the number of capacity units.
/// That is, the value of the metric should decrease when capacity increases. </p>
/// </li>
/// </ul>
/// <p>For information about terminology, available metrics, or how to publish new metrics, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html">Amazon CloudWatch
/// Concepts</a> in the <i>Amazon CloudWatch User Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomizedScalingMetricSpecification {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace of the metric.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The dimensions of the metric.</p>
    /// <p>Conditional: If you published your metric with dimensions, you must specify the same
    /// dimensions in your customized scaling metric specification.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
    /// <p>The statistic of the metric.</p>
    pub statistic: std::option::Option<crate::model::MetricStatistic>,
    /// <p>The unit of the metric. </p>
    pub unit: std::option::Option<std::string::String>,
}
impl CustomizedScalingMetricSpecification {
    /// <p>The name of the metric.</p>
    pub fn metric_name(&self) -> std::option::Option<&str> {
        self.metric_name.as_deref()
    }
    /// <p>The namespace of the metric.</p>
    pub fn namespace(&self) -> std::option::Option<&str> {
        self.namespace.as_deref()
    }
    /// <p>The dimensions of the metric.</p>
    /// <p>Conditional: If you published your metric with dimensions, you must specify the same
    /// dimensions in your customized scaling metric specification.</p>
    pub fn dimensions(&self) -> std::option::Option<&[crate::model::MetricDimension]> {
        self.dimensions.as_deref()
    }
    /// <p>The statistic of the metric.</p>
    pub fn statistic(&self) -> std::option::Option<&crate::model::MetricStatistic> {
        self.statistic.as_ref()
    }
    /// <p>The unit of the metric. </p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
}
impl std::fmt::Debug for CustomizedScalingMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomizedScalingMetricSpecification");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("namespace", &self.namespace);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("statistic", &self.statistic);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`CustomizedScalingMetricSpecification`](crate::model::CustomizedScalingMetricSpecification)
pub mod customized_scaling_metric_specification {
    /// A builder for [`CustomizedScalingMetricSpecification`](crate::model::CustomizedScalingMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
        pub(crate) statistic: std::option::Option<crate::model::MetricStatistic>,
        pub(crate) unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions of the metric.</p>
        /// <p>Conditional: If you published your metric with dimensions, you must specify the same
        /// dimensions in your customized scaling metric specification.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::MetricDimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions of the metric.</p>
        /// <p>Conditional: If you published your metric with dimensions, you must specify the same
        /// dimensions in your customized scaling metric specification.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The statistic of the metric.</p>
        pub fn statistic(mut self, input: crate::model::MetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic of the metric.</p>
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::MetricStatistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The unit of the metric. </p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The unit of the metric. </p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomizedScalingMetricSpecification`](crate::model::CustomizedScalingMetricSpecification)
        pub fn build(self) -> crate::model::CustomizedScalingMetricSpecification {
            crate::model::CustomizedScalingMetricSpecification {
                metric_name: self.metric_name,
                namespace: self.namespace,
                dimensions: self.dimensions,
                statistic: self.statistic,
                unit: self.unit,
            }
        }
    }
}
impl CustomizedScalingMetricSpecification {
    /// Creates a new builder-style object to manufacture [`CustomizedScalingMetricSpecification`](crate::model::CustomizedScalingMetricSpecification)
    pub fn builder() -> crate::model::customized_scaling_metric_specification::Builder {
        crate::model::customized_scaling_metric_specification::Builder::default()
    }
}

/// <p>Represents a predefined metric that can be used for dynamic scaling as part of a target
/// tracking scaling policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredefinedScalingMetricSpecification {
    /// <p>The metric type. The <code>ALBRequestCountPerTarget</code> metric type applies only to
    /// Auto Scaling groups, Spot Fleet requests, and ECS services.</p>
    pub predefined_scaling_metric_type: std::option::Option<crate::model::ScalingMetricType>,
    /// <p>Identifies the resource associated with the metric type. You can't specify a resource
    /// label unless the metric type is <code>ALBRequestCountPerTarget</code> and there is a target
    /// group for an Application Load Balancer attached to the Auto Scaling group, Spot Fleet request, or
    /// ECS service.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format is
    /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
    /// where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>This is an example:
    /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub resource_label: std::option::Option<std::string::String>,
}
impl PredefinedScalingMetricSpecification {
    /// <p>The metric type. The <code>ALBRequestCountPerTarget</code> metric type applies only to
    /// Auto Scaling groups, Spot Fleet requests, and ECS services.</p>
    pub fn predefined_scaling_metric_type(
        &self,
    ) -> std::option::Option<&crate::model::ScalingMetricType> {
        self.predefined_scaling_metric_type.as_ref()
    }
    /// <p>Identifies the resource associated with the metric type. You can't specify a resource
    /// label unless the metric type is <code>ALBRequestCountPerTarget</code> and there is a target
    /// group for an Application Load Balancer attached to the Auto Scaling group, Spot Fleet request, or
    /// ECS service.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format is
    /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
    /// where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>This is an example:
    /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub fn resource_label(&self) -> std::option::Option<&str> {
        self.resource_label.as_deref()
    }
}
impl std::fmt::Debug for PredefinedScalingMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredefinedScalingMetricSpecification");
        formatter.field(
            "predefined_scaling_metric_type",
            &self.predefined_scaling_metric_type,
        );
        formatter.field("resource_label", &self.resource_label);
        formatter.finish()
    }
}
/// See [`PredefinedScalingMetricSpecification`](crate::model::PredefinedScalingMetricSpecification)
pub mod predefined_scaling_metric_specification {
    /// A builder for [`PredefinedScalingMetricSpecification`](crate::model::PredefinedScalingMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_scaling_metric_type:
            std::option::Option<crate::model::ScalingMetricType>,
        pub(crate) resource_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric type. The <code>ALBRequestCountPerTarget</code> metric type applies only to
        /// Auto Scaling groups, Spot Fleet requests, and ECS services.</p>
        pub fn predefined_scaling_metric_type(
            mut self,
            input: crate::model::ScalingMetricType,
        ) -> Self {
            self.predefined_scaling_metric_type = Some(input);
            self
        }
        /// <p>The metric type. The <code>ALBRequestCountPerTarget</code> metric type applies only to
        /// Auto Scaling groups, Spot Fleet requests, and ECS services.</p>
        pub fn set_predefined_scaling_metric_type(
            mut self,
            input: std::option::Option<crate::model::ScalingMetricType>,
        ) -> Self {
            self.predefined_scaling_metric_type = input;
            self
        }
        /// <p>Identifies the resource associated with the metric type. You can't specify a resource
        /// label unless the metric type is <code>ALBRequestCountPerTarget</code> and there is a target
        /// group for an Application Load Balancer attached to the Auto Scaling group, Spot Fleet request, or
        /// ECS service.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format is
        /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
        /// where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>This is an example:
        /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn resource_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_label = Some(input.into());
            self
        }
        /// <p>Identifies the resource associated with the metric type. You can't specify a resource
        /// label unless the metric type is <code>ALBRequestCountPerTarget</code> and there is a target
        /// group for an Application Load Balancer attached to the Auto Scaling group, Spot Fleet request, or
        /// ECS service.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format is
        /// app/<load-balancer-name>/<load-balancer-id>/targetgroup/<target-group-name>/<target-group-id>,
        /// where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>This is an example:
        /// app/EC2Co-EcsEl-1TKLTMITMM0EO/f37c06a68c1748aa/targetgroup/EC2Co-Defau-LDNM7Q3ZH1ZN/6d4ea56ca2d6a18d.</p>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn set_resource_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_label = input;
            self
        }
        /// Consumes the builder and constructs a [`PredefinedScalingMetricSpecification`](crate::model::PredefinedScalingMetricSpecification)
        pub fn build(self) -> crate::model::PredefinedScalingMetricSpecification {
            crate::model::PredefinedScalingMetricSpecification {
                predefined_scaling_metric_type: self.predefined_scaling_metric_type,
                resource_label: self.resource_label,
            }
        }
    }
}
impl PredefinedScalingMetricSpecification {
    /// Creates a new builder-style object to manufacture [`PredefinedScalingMetricSpecification`](crate::model::PredefinedScalingMetricSpecification)
    pub fn builder() -> crate::model::predefined_scaling_metric_specification::Builder {
        crate::model::predefined_scaling_metric_specification::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingMetricType {
    #[allow(missing_docs)] // documentation missing in model
    AlbRequestCountPerTarget,
    #[allow(missing_docs)] // documentation missing in model
    AsgAverageCpuUtilization,
    #[allow(missing_docs)] // documentation missing in model
    AsgAverageNetworkIn,
    #[allow(missing_docs)] // documentation missing in model
    AsgAverageNetworkOut,
    #[allow(missing_docs)] // documentation missing in model
    DynamoDbReadCapacityUtilization,
    #[allow(missing_docs)] // documentation missing in model
    DynamoDbWriteCapacityUtilization,
    #[allow(missing_docs)] // documentation missing in model
    Ec2SpotFleetRequestAverageCpuUtilization,
    #[allow(missing_docs)] // documentation missing in model
    Ec2SpotFleetRequestAverageNetworkIn,
    #[allow(missing_docs)] // documentation missing in model
    Ec2SpotFleetRequestAverageNetworkOut,
    #[allow(missing_docs)] // documentation missing in model
    EcsServiceAverageCpuUtilization,
    #[allow(missing_docs)] // documentation missing in model
    EcsServiceAverageMemoryUtilization,
    #[allow(missing_docs)] // documentation missing in model
    RdsReaderAverageCpuUtilization,
    #[allow(missing_docs)] // documentation missing in model
    RdsReaderAverageDatabaseConnections,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalingMetricType {
    fn from(s: &str) -> Self {
        match s {
            "ALBRequestCountPerTarget" => ScalingMetricType::AlbRequestCountPerTarget,
            "ASGAverageCPUUtilization" => ScalingMetricType::AsgAverageCpuUtilization,
            "ASGAverageNetworkIn" => ScalingMetricType::AsgAverageNetworkIn,
            "ASGAverageNetworkOut" => ScalingMetricType::AsgAverageNetworkOut,
            "DynamoDBReadCapacityUtilization" => ScalingMetricType::DynamoDbReadCapacityUtilization,
            "DynamoDBWriteCapacityUtilization" => {
                ScalingMetricType::DynamoDbWriteCapacityUtilization
            }
            "EC2SpotFleetRequestAverageCPUUtilization" => {
                ScalingMetricType::Ec2SpotFleetRequestAverageCpuUtilization
            }
            "EC2SpotFleetRequestAverageNetworkIn" => {
                ScalingMetricType::Ec2SpotFleetRequestAverageNetworkIn
            }
            "EC2SpotFleetRequestAverageNetworkOut" => {
                ScalingMetricType::Ec2SpotFleetRequestAverageNetworkOut
            }
            "ECSServiceAverageCPUUtilization" => ScalingMetricType::EcsServiceAverageCpuUtilization,
            "ECSServiceAverageMemoryUtilization" => {
                ScalingMetricType::EcsServiceAverageMemoryUtilization
            }
            "RDSReaderAverageCPUUtilization" => ScalingMetricType::RdsReaderAverageCpuUtilization,
            "RDSReaderAverageDatabaseConnections" => {
                ScalingMetricType::RdsReaderAverageDatabaseConnections
            }
            other => ScalingMetricType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalingMetricType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalingMetricType::from(s))
    }
}
impl ScalingMetricType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalingMetricType::AlbRequestCountPerTarget => "ALBRequestCountPerTarget",
            ScalingMetricType::AsgAverageCpuUtilization => "ASGAverageCPUUtilization",
            ScalingMetricType::AsgAverageNetworkIn => "ASGAverageNetworkIn",
            ScalingMetricType::AsgAverageNetworkOut => "ASGAverageNetworkOut",
            ScalingMetricType::DynamoDbReadCapacityUtilization => "DynamoDBReadCapacityUtilization",
            ScalingMetricType::DynamoDbWriteCapacityUtilization => {
                "DynamoDBWriteCapacityUtilization"
            }
            ScalingMetricType::Ec2SpotFleetRequestAverageCpuUtilization => {
                "EC2SpotFleetRequestAverageCPUUtilization"
            }
            ScalingMetricType::Ec2SpotFleetRequestAverageNetworkIn => {
                "EC2SpotFleetRequestAverageNetworkIn"
            }
            ScalingMetricType::Ec2SpotFleetRequestAverageNetworkOut => {
                "EC2SpotFleetRequestAverageNetworkOut"
            }
            ScalingMetricType::EcsServiceAverageCpuUtilization => "ECSServiceAverageCPUUtilization",
            ScalingMetricType::EcsServiceAverageMemoryUtilization => {
                "ECSServiceAverageMemoryUtilization"
            }
            ScalingMetricType::RdsReaderAverageCpuUtilization => "RDSReaderAverageCPUUtilization",
            ScalingMetricType::RdsReaderAverageDatabaseConnections => {
                "RDSReaderAverageDatabaseConnections"
            }
            ScalingMetricType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ALBRequestCountPerTarget",
            "ASGAverageCPUUtilization",
            "ASGAverageNetworkIn",
            "ASGAverageNetworkOut",
            "DynamoDBReadCapacityUtilization",
            "DynamoDBWriteCapacityUtilization",
            "EC2SpotFleetRequestAverageCPUUtilization",
            "EC2SpotFleetRequestAverageNetworkIn",
            "EC2SpotFleetRequestAverageNetworkOut",
            "ECSServiceAverageCPUUtilization",
            "ECSServiceAverageMemoryUtilization",
            "RDSReaderAverageCPUUtilization",
            "RDSReaderAverageDatabaseConnections",
        ]
    }
}
impl AsRef<str> for ScalingMetricType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalableDimension {
    #[allow(missing_docs)] // documentation missing in model
    AutoScalingGroupDesiredCapacity,
    #[allow(missing_docs)] // documentation missing in model
    DynamoDbIndexReadCapacityUnits,
    #[allow(missing_docs)] // documentation missing in model
    DynamoDbIndexWriteCapacityUnits,
    #[allow(missing_docs)] // documentation missing in model
    DynamoDbTableReadCapacityUnits,
    #[allow(missing_docs)] // documentation missing in model
    DynamoDbTableWriteCapacityUnits,
    #[allow(missing_docs)] // documentation missing in model
    Ec2SpotFleetRequestTargetCapacity,
    #[allow(missing_docs)] // documentation missing in model
    EcsServiceDesiredCount,
    #[allow(missing_docs)] // documentation missing in model
    RdsClusterReadReplicaCount,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalableDimension {
    fn from(s: &str) -> Self {
        match s {
            "autoscaling:autoScalingGroup:DesiredCapacity" => {
                ScalableDimension::AutoScalingGroupDesiredCapacity
            }
            "dynamodb:index:ReadCapacityUnits" => ScalableDimension::DynamoDbIndexReadCapacityUnits,
            "dynamodb:index:WriteCapacityUnits" => {
                ScalableDimension::DynamoDbIndexWriteCapacityUnits
            }
            "dynamodb:table:ReadCapacityUnits" => ScalableDimension::DynamoDbTableReadCapacityUnits,
            "dynamodb:table:WriteCapacityUnits" => {
                ScalableDimension::DynamoDbTableWriteCapacityUnits
            }
            "ec2:spot-fleet-request:TargetCapacity" => {
                ScalableDimension::Ec2SpotFleetRequestTargetCapacity
            }
            "ecs:service:DesiredCount" => ScalableDimension::EcsServiceDesiredCount,
            "rds:cluster:ReadReplicaCount" => ScalableDimension::RdsClusterReadReplicaCount,
            other => ScalableDimension::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalableDimension {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalableDimension::from(s))
    }
}
impl ScalableDimension {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalableDimension::AutoScalingGroupDesiredCapacity => {
                "autoscaling:autoScalingGroup:DesiredCapacity"
            }
            ScalableDimension::DynamoDbIndexReadCapacityUnits => "dynamodb:index:ReadCapacityUnits",
            ScalableDimension::DynamoDbIndexWriteCapacityUnits => {
                "dynamodb:index:WriteCapacityUnits"
            }
            ScalableDimension::DynamoDbTableReadCapacityUnits => "dynamodb:table:ReadCapacityUnits",
            ScalableDimension::DynamoDbTableWriteCapacityUnits => {
                "dynamodb:table:WriteCapacityUnits"
            }
            ScalableDimension::Ec2SpotFleetRequestTargetCapacity => {
                "ec2:spot-fleet-request:TargetCapacity"
            }
            ScalableDimension::EcsServiceDesiredCount => "ecs:service:DesiredCount",
            ScalableDimension::RdsClusterReadReplicaCount => "rds:cluster:ReadReplicaCount",
            ScalableDimension::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "autoscaling:autoScalingGroup:DesiredCapacity",
            "dynamodb:index:ReadCapacityUnits",
            "dynamodb:index:WriteCapacityUnits",
            "dynamodb:table:ReadCapacityUnits",
            "dynamodb:table:WriteCapacityUnits",
            "ec2:spot-fleet-request:TargetCapacity",
            "ecs:service:DesiredCount",
            "rds:cluster:ReadReplicaCount",
        ]
    }
}
impl AsRef<str> for ScalableDimension {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceNamespace {
    #[allow(missing_docs)] // documentation missing in model
    Autoscaling,
    #[allow(missing_docs)] // documentation missing in model
    Dynamodb,
    #[allow(missing_docs)] // documentation missing in model
    Ec2,
    #[allow(missing_docs)] // documentation missing in model
    Ecs,
    #[allow(missing_docs)] // documentation missing in model
    Rds,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ServiceNamespace {
    fn from(s: &str) -> Self {
        match s {
            "autoscaling" => ServiceNamespace::Autoscaling,
            "dynamodb" => ServiceNamespace::Dynamodb,
            "ec2" => ServiceNamespace::Ec2,
            "ecs" => ServiceNamespace::Ecs,
            "rds" => ServiceNamespace::Rds,
            other => ServiceNamespace::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ServiceNamespace {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceNamespace::from(s))
    }
}
impl ServiceNamespace {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceNamespace::Autoscaling => "autoscaling",
            ServiceNamespace::Dynamodb => "dynamodb",
            ServiceNamespace::Ec2 => "ec2",
            ServiceNamespace::Ecs => "ecs",
            ServiceNamespace::Rds => "rds",
            ServiceNamespace::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["autoscaling", "dynamodb", "ec2", "ecs", "rds"]
    }
}
impl AsRef<str> for ServiceNamespace {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents an application source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSource {
    /// <p>The Amazon Resource Name (ARN) of a AWS CloudFormation stack.</p>
    pub cloud_formation_stack_arn: std::option::Option<std::string::String>,
    /// <p>A set of tags (up to 50).</p>
    pub tag_filters: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
}
impl ApplicationSource {
    /// <p>The Amazon Resource Name (ARN) of a AWS CloudFormation stack.</p>
    pub fn cloud_formation_stack_arn(&self) -> std::option::Option<&str> {
        self.cloud_formation_stack_arn.as_deref()
    }
    /// <p>A set of tags (up to 50).</p>
    pub fn tag_filters(&self) -> std::option::Option<&[crate::model::TagFilter]> {
        self.tag_filters.as_deref()
    }
}
impl std::fmt::Debug for ApplicationSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSource");
        formatter.field("cloud_formation_stack_arn", &self.cloud_formation_stack_arn);
        formatter.field("tag_filters", &self.tag_filters);
        formatter.finish()
    }
}
/// See [`ApplicationSource`](crate::model::ApplicationSource)
pub mod application_source {
    /// A builder for [`ApplicationSource`](crate::model::ApplicationSource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_formation_stack_arn: std::option::Option<std::string::String>,
        pub(crate) tag_filters: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a AWS CloudFormation stack.</p>
        pub fn cloud_formation_stack_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cloud_formation_stack_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a AWS CloudFormation stack.</p>
        pub fn set_cloud_formation_stack_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cloud_formation_stack_arn = input;
            self
        }
        /// Appends an item to `tag_filters`.
        ///
        /// To override the contents of this collection use [`set_tag_filters`](Self::set_tag_filters).
        ///
        /// <p>A set of tags (up to 50).</p>
        pub fn tag_filters(mut self, input: impl Into<crate::model::TagFilter>) -> Self {
            let mut v = self.tag_filters.unwrap_or_default();
            v.push(input.into());
            self.tag_filters = Some(v);
            self
        }
        /// <p>A set of tags (up to 50).</p>
        pub fn set_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
        ) -> Self {
            self.tag_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSource`](crate::model::ApplicationSource)
        pub fn build(self) -> crate::model::ApplicationSource {
            crate::model::ApplicationSource {
                cloud_formation_stack_arn: self.cloud_formation_stack_arn,
                tag_filters: self.tag_filters,
            }
        }
    }
}
impl ApplicationSource {
    /// Creates a new builder-style object to manufacture [`ApplicationSource`](crate::model::ApplicationSource)
    pub fn builder() -> crate::model::application_source::Builder {
        crate::model::application_source::Builder::default()
    }
}

/// <p>Represents a tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagFilter {
    /// <p>The tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag values (0 to 20).</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TagFilter {
    /// <p>The tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag values (0 to 20).</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl std::fmt::Debug for TagFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagFilter");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`TagFilter`](crate::model::TagFilter)
pub mod tag_filter {
    /// A builder for [`TagFilter`](crate::model::TagFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The tag values (0 to 20).</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The tag values (0 to 20).</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`TagFilter`](crate::model::TagFilter)
        pub fn build(self) -> crate::model::TagFilter {
            crate::model::TagFilter {
                key: self.key,
                values: self.values,
            }
        }
    }
}
impl TagFilter {
    /// Creates a new builder-style object to manufacture [`TagFilter`](crate::model::TagFilter)
    pub fn builder() -> crate::model::tag_filter::Builder {
        crate::model::tag_filter::Builder::default()
    }
}

/// <p>Represents a single value in the forecast data used for predictive scaling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Datapoint {
    /// <p>The time stamp for the data point in UTC format.</p>
    pub timestamp: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The value of the data point.</p>
    pub value: std::option::Option<f64>,
}
impl Datapoint {
    /// <p>The time stamp for the data point in UTC format.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.timestamp.as_ref()
    }
    /// <p>The value of the data point.</p>
    pub fn value(&self) -> std::option::Option<f64> {
        self.value
    }
}
impl std::fmt::Debug for Datapoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Datapoint");
        formatter.field("timestamp", &self.timestamp);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Datapoint`](crate::model::Datapoint)
pub mod datapoint {
    /// A builder for [`Datapoint`](crate::model::Datapoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The time stamp for the data point in UTC format.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::Instant) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time stamp for the data point in UTC format.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The value of the data point.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value of the data point.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Datapoint`](crate::model::Datapoint)
        pub fn build(self) -> crate::model::Datapoint {
            crate::model::Datapoint {
                timestamp: self.timestamp,
                value: self.value,
            }
        }
    }
}
impl Datapoint {
    /// Creates a new builder-style object to manufacture [`Datapoint`](crate::model::Datapoint)
    pub fn builder() -> crate::model::datapoint::Builder {
        crate::model::datapoint::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ForecastDataType {
    #[allow(missing_docs)] // documentation missing in model
    CapacityForecast,
    #[allow(missing_docs)] // documentation missing in model
    LoadForecast,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledActionMaxCapacity,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledActionMinCapacity,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ForecastDataType {
    fn from(s: &str) -> Self {
        match s {
            "CapacityForecast" => ForecastDataType::CapacityForecast,
            "LoadForecast" => ForecastDataType::LoadForecast,
            "ScheduledActionMaxCapacity" => ForecastDataType::ScheduledActionMaxCapacity,
            "ScheduledActionMinCapacity" => ForecastDataType::ScheduledActionMinCapacity,
            other => ForecastDataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ForecastDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ForecastDataType::from(s))
    }
}
impl ForecastDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ForecastDataType::CapacityForecast => "CapacityForecast",
            ForecastDataType::LoadForecast => "LoadForecast",
            ForecastDataType::ScheduledActionMaxCapacity => "ScheduledActionMaxCapacity",
            ForecastDataType::ScheduledActionMinCapacity => "ScheduledActionMinCapacity",
            ForecastDataType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CapacityForecast",
            "LoadForecast",
            "ScheduledActionMaxCapacity",
            "ScheduledActionMinCapacity",
        ]
    }
}
impl AsRef<str> for ForecastDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a scaling plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScalingPlan {
    /// <p>The name of the scaling plan.</p>
    pub scaling_plan_name: std::option::Option<std::string::String>,
    /// <p>The version number of the scaling plan.</p>
    pub scaling_plan_version: std::option::Option<i64>,
    /// <p>A CloudFormation stack or a set of tags. You can create one scaling plan per application
    /// source.</p>
    pub application_source: std::option::Option<crate::model::ApplicationSource>,
    /// <p>The scaling instructions.</p>
    pub scaling_instructions: std::option::Option<std::vec::Vec<crate::model::ScalingInstruction>>,
    /// <p>The status of the scaling plan.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Active</code> - The scaling plan is active.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ActiveWithProblems</code> - The scaling plan is active, but the scaling
    /// configuration for one or more resources could not be applied.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreationInProgress</code> - The scaling plan is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreationFailed</code> - The scaling plan could not be created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DeletionInProgress</code> - The scaling plan is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DeletionFailed</code> - The scaling plan could not be deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UpdateInProgress</code> - The scaling plan is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UpdateFailed</code> - The scaling plan could not be updated.</p>
    /// </li>
    /// </ul>
    pub status_code: std::option::Option<crate::model::ScalingPlanStatusCode>,
    /// <p>A simple message about the current status of the scaling plan.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The Unix time stamp when the scaling plan entered the current status.</p>
    pub status_start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The Unix time stamp when the scaling plan was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::Instant>,
}
impl ScalingPlan {
    /// <p>The name of the scaling plan.</p>
    pub fn scaling_plan_name(&self) -> std::option::Option<&str> {
        self.scaling_plan_name.as_deref()
    }
    /// <p>The version number of the scaling plan.</p>
    pub fn scaling_plan_version(&self) -> std::option::Option<i64> {
        self.scaling_plan_version
    }
    /// <p>A CloudFormation stack or a set of tags. You can create one scaling plan per application
    /// source.</p>
    pub fn application_source(&self) -> std::option::Option<&crate::model::ApplicationSource> {
        self.application_source.as_ref()
    }
    /// <p>The scaling instructions.</p>
    pub fn scaling_instructions(&self) -> std::option::Option<&[crate::model::ScalingInstruction]> {
        self.scaling_instructions.as_deref()
    }
    /// <p>The status of the scaling plan.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Active</code> - The scaling plan is active.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ActiveWithProblems</code> - The scaling plan is active, but the scaling
    /// configuration for one or more resources could not be applied.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreationInProgress</code> - The scaling plan is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CreationFailed</code> - The scaling plan could not be created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DeletionInProgress</code> - The scaling plan is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DeletionFailed</code> - The scaling plan could not be deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UpdateInProgress</code> - The scaling plan is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UpdateFailed</code> - The scaling plan could not be updated.</p>
    /// </li>
    /// </ul>
    pub fn status_code(&self) -> std::option::Option<&crate::model::ScalingPlanStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>A simple message about the current status of the scaling plan.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The Unix time stamp when the scaling plan entered the current status.</p>
    pub fn status_start_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.status_start_time.as_ref()
    }
    /// <p>The Unix time stamp when the scaling plan was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::Instant> {
        self.creation_time.as_ref()
    }
}
impl std::fmt::Debug for ScalingPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScalingPlan");
        formatter.field("scaling_plan_name", &self.scaling_plan_name);
        formatter.field("scaling_plan_version", &self.scaling_plan_version);
        formatter.field("application_source", &self.application_source);
        formatter.field("scaling_instructions", &self.scaling_instructions);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("status_start_time", &self.status_start_time);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`ScalingPlan`](crate::model::ScalingPlan)
pub mod scaling_plan {
    /// A builder for [`ScalingPlan`](crate::model::ScalingPlan)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scaling_plan_name: std::option::Option<std::string::String>,
        pub(crate) scaling_plan_version: std::option::Option<i64>,
        pub(crate) application_source: std::option::Option<crate::model::ApplicationSource>,
        pub(crate) scaling_instructions:
            std::option::Option<std::vec::Vec<crate::model::ScalingInstruction>>,
        pub(crate) status_code: std::option::Option<crate::model::ScalingPlanStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) status_start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the scaling plan.</p>
        pub fn scaling_plan_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scaling_plan_name = Some(input.into());
            self
        }
        /// <p>The name of the scaling plan.</p>
        pub fn set_scaling_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scaling_plan_name = input;
            self
        }
        /// <p>The version number of the scaling plan.</p>
        pub fn scaling_plan_version(mut self, input: i64) -> Self {
            self.scaling_plan_version = Some(input);
            self
        }
        /// <p>The version number of the scaling plan.</p>
        pub fn set_scaling_plan_version(mut self, input: std::option::Option<i64>) -> Self {
            self.scaling_plan_version = input;
            self
        }
        /// <p>A CloudFormation stack or a set of tags. You can create one scaling plan per application
        /// source.</p>
        pub fn application_source(mut self, input: crate::model::ApplicationSource) -> Self {
            self.application_source = Some(input);
            self
        }
        /// <p>A CloudFormation stack or a set of tags. You can create one scaling plan per application
        /// source.</p>
        pub fn set_application_source(
            mut self,
            input: std::option::Option<crate::model::ApplicationSource>,
        ) -> Self {
            self.application_source = input;
            self
        }
        /// Appends an item to `scaling_instructions`.
        ///
        /// To override the contents of this collection use [`set_scaling_instructions`](Self::set_scaling_instructions).
        ///
        /// <p>The scaling instructions.</p>
        pub fn scaling_instructions(
            mut self,
            input: impl Into<crate::model::ScalingInstruction>,
        ) -> Self {
            let mut v = self.scaling_instructions.unwrap_or_default();
            v.push(input.into());
            self.scaling_instructions = Some(v);
            self
        }
        /// <p>The scaling instructions.</p>
        pub fn set_scaling_instructions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScalingInstruction>>,
        ) -> Self {
            self.scaling_instructions = input;
            self
        }
        /// <p>The status of the scaling plan.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Active</code> - The scaling plan is active.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ActiveWithProblems</code> - The scaling plan is active, but the scaling
        /// configuration for one or more resources could not be applied.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreationInProgress</code> - The scaling plan is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreationFailed</code> - The scaling plan could not be created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DeletionInProgress</code> - The scaling plan is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DeletionFailed</code> - The scaling plan could not be deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UpdateInProgress</code> - The scaling plan is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UpdateFailed</code> - The scaling plan could not be updated.</p>
        /// </li>
        /// </ul>
        pub fn status_code(mut self, input: crate::model::ScalingPlanStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status of the scaling plan.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Active</code> - The scaling plan is active.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ActiveWithProblems</code> - The scaling plan is active, but the scaling
        /// configuration for one or more resources could not be applied.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreationInProgress</code> - The scaling plan is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CreationFailed</code> - The scaling plan could not be created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DeletionInProgress</code> - The scaling plan is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DeletionFailed</code> - The scaling plan could not be deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UpdateInProgress</code> - The scaling plan is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UpdateFailed</code> - The scaling plan could not be updated.</p>
        /// </li>
        /// </ul>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::ScalingPlanStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>A simple message about the current status of the scaling plan.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>A simple message about the current status of the scaling plan.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The Unix time stamp when the scaling plan entered the current status.</p>
        pub fn status_start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.status_start_time = Some(input);
            self
        }
        /// <p>The Unix time stamp when the scaling plan entered the current status.</p>
        pub fn set_status_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.status_start_time = input;
            self
        }
        /// <p>The Unix time stamp when the scaling plan was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The Unix time stamp when the scaling plan was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ScalingPlan`](crate::model::ScalingPlan)
        pub fn build(self) -> crate::model::ScalingPlan {
            crate::model::ScalingPlan {
                scaling_plan_name: self.scaling_plan_name,
                scaling_plan_version: self.scaling_plan_version,
                application_source: self.application_source,
                scaling_instructions: self.scaling_instructions,
                status_code: self.status_code,
                status_message: self.status_message,
                status_start_time: self.status_start_time,
                creation_time: self.creation_time,
            }
        }
    }
}
impl ScalingPlan {
    /// Creates a new builder-style object to manufacture [`ScalingPlan`](crate::model::ScalingPlan)
    pub fn builder() -> crate::model::scaling_plan::Builder {
        crate::model::scaling_plan::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingPlanStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    ActiveWithProblems,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    DeletionFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeletionInProgress,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalingPlanStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "Active" => ScalingPlanStatusCode::Active,
            "ActiveWithProblems" => ScalingPlanStatusCode::ActiveWithProblems,
            "CreationFailed" => ScalingPlanStatusCode::CreationFailed,
            "CreationInProgress" => ScalingPlanStatusCode::CreationInProgress,
            "DeletionFailed" => ScalingPlanStatusCode::DeletionFailed,
            "DeletionInProgress" => ScalingPlanStatusCode::DeletionInProgress,
            "UpdateFailed" => ScalingPlanStatusCode::UpdateFailed,
            "UpdateInProgress" => ScalingPlanStatusCode::UpdateInProgress,
            other => ScalingPlanStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalingPlanStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalingPlanStatusCode::from(s))
    }
}
impl ScalingPlanStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalingPlanStatusCode::Active => "Active",
            ScalingPlanStatusCode::ActiveWithProblems => "ActiveWithProblems",
            ScalingPlanStatusCode::CreationFailed => "CreationFailed",
            ScalingPlanStatusCode::CreationInProgress => "CreationInProgress",
            ScalingPlanStatusCode::DeletionFailed => "DeletionFailed",
            ScalingPlanStatusCode::DeletionInProgress => "DeletionInProgress",
            ScalingPlanStatusCode::UpdateFailed => "UpdateFailed",
            ScalingPlanStatusCode::UpdateInProgress => "UpdateInProgress",
            ScalingPlanStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Active",
            "ActiveWithProblems",
            "CreationFailed",
            "CreationInProgress",
            "DeletionFailed",
            "DeletionInProgress",
            "UpdateFailed",
            "UpdateInProgress",
        ]
    }
}
impl AsRef<str> for ScalingPlanStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a scalable resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScalingPlanResource {
    /// <p>The name of the scaling plan.</p>
    pub scaling_plan_name: std::option::Option<std::string::String>,
    /// <p>The version number of the scaling plan.</p>
    pub scaling_plan_version: std::option::Option<i64>,
    /// <p>The namespace of the AWS service.</p>
    pub service_namespace: std::option::Option<crate::model::ServiceNamespace>,
    /// <p>The ID of the resource. This string consists of the resource type and unique
    /// identifier.</p>
    /// <ul>
    /// <li>
    /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
    /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
    /// </li>
    /// <li>
    /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
    /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
    /// </li>
    /// <li>
    /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
    /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table/index/my-table-index</code>.</p>
    /// </li>
    /// <li>
    /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
    /// Example: <code>cluster:my-db-cluster</code>.</p>
    /// </li>
    /// </ul>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The scalable dimension for the resource.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
    /// </li>
    /// </ul>
    pub scalable_dimension: std::option::Option<crate::model::ScalableDimension>,
    /// <p>The scaling policies.</p>
    pub scaling_policies: std::option::Option<std::vec::Vec<crate::model::ScalingPolicy>>,
    /// <p>The scaling status of the resource.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Active</code> - The scaling configuration is active.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Inactive</code> - The scaling configuration is not active because the
    /// scaling plan is being created or the scaling configuration could not be applied.
    /// Check the status message for more information.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PartiallyActive</code> - The scaling configuration is partially active
    /// because the scaling plan is being created or deleted or the scaling configuration
    /// could not be fully applied. Check the status message for more information.</p>
    /// </li>
    /// </ul>
    pub scaling_status_code: std::option::Option<crate::model::ScalingStatusCode>,
    /// <p>A simple message about the current scaling status of the resource.</p>
    pub scaling_status_message: std::option::Option<std::string::String>,
}
impl ScalingPlanResource {
    /// <p>The name of the scaling plan.</p>
    pub fn scaling_plan_name(&self) -> std::option::Option<&str> {
        self.scaling_plan_name.as_deref()
    }
    /// <p>The version number of the scaling plan.</p>
    pub fn scaling_plan_version(&self) -> std::option::Option<i64> {
        self.scaling_plan_version
    }
    /// <p>The namespace of the AWS service.</p>
    pub fn service_namespace(&self) -> std::option::Option<&crate::model::ServiceNamespace> {
        self.service_namespace.as_ref()
    }
    /// <p>The ID of the resource. This string consists of the resource type and unique
    /// identifier.</p>
    /// <ul>
    /// <li>
    /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
    /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
    /// </li>
    /// <li>
    /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
    /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
    /// </li>
    /// <li>
    /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
    /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table</code>.</p>
    /// </li>
    /// <li>
    /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
    /// Example: <code>table/my-table/index/my-table-index</code>.</p>
    /// </li>
    /// <li>
    /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
    /// Example: <code>cluster:my-db-cluster</code>.</p>
    /// </li>
    /// </ul>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The scalable dimension for the resource.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
    /// </li>
    /// </ul>
    pub fn scalable_dimension(&self) -> std::option::Option<&crate::model::ScalableDimension> {
        self.scalable_dimension.as_ref()
    }
    /// <p>The scaling policies.</p>
    pub fn scaling_policies(&self) -> std::option::Option<&[crate::model::ScalingPolicy]> {
        self.scaling_policies.as_deref()
    }
    /// <p>The scaling status of the resource.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Active</code> - The scaling configuration is active.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Inactive</code> - The scaling configuration is not active because the
    /// scaling plan is being created or the scaling configuration could not be applied.
    /// Check the status message for more information.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PartiallyActive</code> - The scaling configuration is partially active
    /// because the scaling plan is being created or deleted or the scaling configuration
    /// could not be fully applied. Check the status message for more information.</p>
    /// </li>
    /// </ul>
    pub fn scaling_status_code(&self) -> std::option::Option<&crate::model::ScalingStatusCode> {
        self.scaling_status_code.as_ref()
    }
    /// <p>A simple message about the current scaling status of the resource.</p>
    pub fn scaling_status_message(&self) -> std::option::Option<&str> {
        self.scaling_status_message.as_deref()
    }
}
impl std::fmt::Debug for ScalingPlanResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScalingPlanResource");
        formatter.field("scaling_plan_name", &self.scaling_plan_name);
        formatter.field("scaling_plan_version", &self.scaling_plan_version);
        formatter.field("service_namespace", &self.service_namespace);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("scalable_dimension", &self.scalable_dimension);
        formatter.field("scaling_policies", &self.scaling_policies);
        formatter.field("scaling_status_code", &self.scaling_status_code);
        formatter.field("scaling_status_message", &self.scaling_status_message);
        formatter.finish()
    }
}
/// See [`ScalingPlanResource`](crate::model::ScalingPlanResource)
pub mod scaling_plan_resource {
    /// A builder for [`ScalingPlanResource`](crate::model::ScalingPlanResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scaling_plan_name: std::option::Option<std::string::String>,
        pub(crate) scaling_plan_version: std::option::Option<i64>,
        pub(crate) service_namespace: std::option::Option<crate::model::ServiceNamespace>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) scalable_dimension: std::option::Option<crate::model::ScalableDimension>,
        pub(crate) scaling_policies:
            std::option::Option<std::vec::Vec<crate::model::ScalingPolicy>>,
        pub(crate) scaling_status_code: std::option::Option<crate::model::ScalingStatusCode>,
        pub(crate) scaling_status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the scaling plan.</p>
        pub fn scaling_plan_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scaling_plan_name = Some(input.into());
            self
        }
        /// <p>The name of the scaling plan.</p>
        pub fn set_scaling_plan_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scaling_plan_name = input;
            self
        }
        /// <p>The version number of the scaling plan.</p>
        pub fn scaling_plan_version(mut self, input: i64) -> Self {
            self.scaling_plan_version = Some(input);
            self
        }
        /// <p>The version number of the scaling plan.</p>
        pub fn set_scaling_plan_version(mut self, input: std::option::Option<i64>) -> Self {
            self.scaling_plan_version = input;
            self
        }
        /// <p>The namespace of the AWS service.</p>
        pub fn service_namespace(mut self, input: crate::model::ServiceNamespace) -> Self {
            self.service_namespace = Some(input);
            self
        }
        /// <p>The namespace of the AWS service.</p>
        pub fn set_service_namespace(
            mut self,
            input: std::option::Option<crate::model::ServiceNamespace>,
        ) -> Self {
            self.service_namespace = input;
            self
        }
        /// <p>The ID of the resource. This string consists of the resource type and unique
        /// identifier.</p>
        /// <ul>
        /// <li>
        /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
        /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
        /// </li>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// </ul>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource. This string consists of the resource type and unique
        /// identifier.</p>
        /// <ul>
        /// <li>
        /// <p>Auto Scaling group - The resource type is <code>autoScalingGroup</code> and the unique identifier is the
        /// name of the Auto Scaling group. Example: <code>autoScalingGroup/my-asg</code>.</p>
        /// </li>
        /// <li>
        /// <p>ECS service - The resource type is <code>service</code> and the unique identifier is the cluster name  
        /// and service name. Example: <code>service/default/sample-webapp</code>.</p>
        /// </li>
        /// <li>
        /// <p>Spot Fleet request - The resource type is <code>spot-fleet-request</code> and the unique identifier is the
        /// Spot Fleet request ID. Example: <code>spot-fleet-request/sfr-73fbd2ce-aa30-494c-8788-1cee4EXAMPLE</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB table - The resource type is <code>table</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table</code>.</p>
        /// </li>
        /// <li>
        /// <p>DynamoDB global secondary index - The resource type is <code>index</code> and the unique identifier is the resource ID.
        /// Example: <code>table/my-table/index/my-table-index</code>.</p>
        /// </li>
        /// <li>
        /// <p>Aurora DB cluster - The resource type is <code>cluster</code> and the unique identifier is the cluster name.
        /// Example: <code>cluster:my-db-cluster</code>.</p>
        /// </li>
        /// </ul>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The scalable dimension for the resource.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// </ul>
        pub fn scalable_dimension(mut self, input: crate::model::ScalableDimension) -> Self {
            self.scalable_dimension = Some(input);
            self
        }
        /// <p>The scalable dimension for the resource.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>autoscaling:autoScalingGroup:DesiredCapacity</code> - The desired capacity of an Auto Scaling group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ecs:service:DesiredCount</code> - The desired task count of an ECS service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ec2:spot-fleet-request:TargetCapacity</code> - The target capacity of a Spot Fleet request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:table:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:ReadCapacityUnits</code> - The provisioned read capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dynamodb:index:WriteCapacityUnits</code> - The provisioned write capacity for a DynamoDB global secondary index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rds:cluster:ReadReplicaCount</code> - The count of Aurora Replicas in an Aurora DB cluster. Available for Aurora MySQL-compatible edition and Aurora PostgreSQL-compatible edition.</p>
        /// </li>
        /// </ul>
        pub fn set_scalable_dimension(
            mut self,
            input: std::option::Option<crate::model::ScalableDimension>,
        ) -> Self {
            self.scalable_dimension = input;
            self
        }
        /// Appends an item to `scaling_policies`.
        ///
        /// To override the contents of this collection use [`set_scaling_policies`](Self::set_scaling_policies).
        ///
        /// <p>The scaling policies.</p>
        pub fn scaling_policies(mut self, input: impl Into<crate::model::ScalingPolicy>) -> Self {
            let mut v = self.scaling_policies.unwrap_or_default();
            v.push(input.into());
            self.scaling_policies = Some(v);
            self
        }
        /// <p>The scaling policies.</p>
        pub fn set_scaling_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScalingPolicy>>,
        ) -> Self {
            self.scaling_policies = input;
            self
        }
        /// <p>The scaling status of the resource.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Active</code> - The scaling configuration is active.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Inactive</code> - The scaling configuration is not active because the
        /// scaling plan is being created or the scaling configuration could not be applied.
        /// Check the status message for more information.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PartiallyActive</code> - The scaling configuration is partially active
        /// because the scaling plan is being created or deleted or the scaling configuration
        /// could not be fully applied. Check the status message for more information.</p>
        /// </li>
        /// </ul>
        pub fn scaling_status_code(mut self, input: crate::model::ScalingStatusCode) -> Self {
            self.scaling_status_code = Some(input);
            self
        }
        /// <p>The scaling status of the resource.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Active</code> - The scaling configuration is active.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Inactive</code> - The scaling configuration is not active because the
        /// scaling plan is being created or the scaling configuration could not be applied.
        /// Check the status message for more information.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PartiallyActive</code> - The scaling configuration is partially active
        /// because the scaling plan is being created or deleted or the scaling configuration
        /// could not be fully applied. Check the status message for more information.</p>
        /// </li>
        /// </ul>
        pub fn set_scaling_status_code(
            mut self,
            input: std::option::Option<crate::model::ScalingStatusCode>,
        ) -> Self {
            self.scaling_status_code = input;
            self
        }
        /// <p>A simple message about the current scaling status of the resource.</p>
        pub fn scaling_status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.scaling_status_message = Some(input.into());
            self
        }
        /// <p>A simple message about the current scaling status of the resource.</p>
        pub fn set_scaling_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scaling_status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ScalingPlanResource`](crate::model::ScalingPlanResource)
        pub fn build(self) -> crate::model::ScalingPlanResource {
            crate::model::ScalingPlanResource {
                scaling_plan_name: self.scaling_plan_name,
                scaling_plan_version: self.scaling_plan_version,
                service_namespace: self.service_namespace,
                resource_id: self.resource_id,
                scalable_dimension: self.scalable_dimension,
                scaling_policies: self.scaling_policies,
                scaling_status_code: self.scaling_status_code,
                scaling_status_message: self.scaling_status_message,
            }
        }
    }
}
impl ScalingPlanResource {
    /// Creates a new builder-style object to manufacture [`ScalingPlanResource`](crate::model::ScalingPlanResource)
    pub fn builder() -> crate::model::scaling_plan_resource::Builder {
        crate::model::scaling_plan_resource::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    PartiallyActive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalingStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "Active" => ScalingStatusCode::Active,
            "Inactive" => ScalingStatusCode::Inactive,
            "PartiallyActive" => ScalingStatusCode::PartiallyActive,
            other => ScalingStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalingStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalingStatusCode::from(s))
    }
}
impl ScalingStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScalingStatusCode::Active => "Active",
            ScalingStatusCode::Inactive => "Inactive",
            ScalingStatusCode::PartiallyActive => "PartiallyActive",
            ScalingStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "Inactive", "PartiallyActive"]
    }
}
impl AsRef<str> for ScalingStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a scaling policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScalingPolicy {
    /// <p>The name of the scaling policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The type of scaling policy.</p>
    pub policy_type: std::option::Option<crate::model::PolicyType>,
    /// <p>The target tracking scaling policy. Includes support for predefined or customized
    /// metrics.</p>
    pub target_tracking_configuration:
        std::option::Option<crate::model::TargetTrackingConfiguration>,
}
impl ScalingPolicy {
    /// <p>The name of the scaling policy.</p>
    pub fn policy_name(&self) -> std::option::Option<&str> {
        self.policy_name.as_deref()
    }
    /// <p>The type of scaling policy.</p>
    pub fn policy_type(&self) -> std::option::Option<&crate::model::PolicyType> {
        self.policy_type.as_ref()
    }
    /// <p>The target tracking scaling policy. Includes support for predefined or customized
    /// metrics.</p>
    pub fn target_tracking_configuration(
        &self,
    ) -> std::option::Option<&crate::model::TargetTrackingConfiguration> {
        self.target_tracking_configuration.as_ref()
    }
}
impl std::fmt::Debug for ScalingPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScalingPolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_type", &self.policy_type);
        formatter.field(
            "target_tracking_configuration",
            &self.target_tracking_configuration,
        );
        formatter.finish()
    }
}
/// See [`ScalingPolicy`](crate::model::ScalingPolicy)
pub mod scaling_policy {
    /// A builder for [`ScalingPolicy`](crate::model::ScalingPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_type: std::option::Option<crate::model::PolicyType>,
        pub(crate) target_tracking_configuration:
            std::option::Option<crate::model::TargetTrackingConfiguration>,
    }
    impl Builder {
        /// <p>The name of the scaling policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the scaling policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The type of scaling policy.</p>
        pub fn policy_type(mut self, input: crate::model::PolicyType) -> Self {
            self.policy_type = Some(input);
            self
        }
        /// <p>The type of scaling policy.</p>
        pub fn set_policy_type(
            mut self,
            input: std::option::Option<crate::model::PolicyType>,
        ) -> Self {
            self.policy_type = input;
            self
        }
        /// <p>The target tracking scaling policy. Includes support for predefined or customized
        /// metrics.</p>
        pub fn target_tracking_configuration(
            mut self,
            input: crate::model::TargetTrackingConfiguration,
        ) -> Self {
            self.target_tracking_configuration = Some(input);
            self
        }
        /// <p>The target tracking scaling policy. Includes support for predefined or customized
        /// metrics.</p>
        pub fn set_target_tracking_configuration(
            mut self,
            input: std::option::Option<crate::model::TargetTrackingConfiguration>,
        ) -> Self {
            self.target_tracking_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ScalingPolicy`](crate::model::ScalingPolicy)
        pub fn build(self) -> crate::model::ScalingPolicy {
            crate::model::ScalingPolicy {
                policy_name: self.policy_name,
                policy_type: self.policy_type,
                target_tracking_configuration: self.target_tracking_configuration,
            }
        }
    }
}
impl ScalingPolicy {
    /// Creates a new builder-style object to manufacture [`ScalingPolicy`](crate::model::ScalingPolicy)
    pub fn builder() -> crate::model::scaling_policy::Builder {
        crate::model::scaling_policy::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PolicyType {
    #[allow(missing_docs)] // documentation missing in model
    TargetTrackingScaling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PolicyType {
    fn from(s: &str) -> Self {
        match s {
            "TargetTrackingScaling" => PolicyType::TargetTrackingScaling,
            other => PolicyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PolicyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PolicyType::from(s))
    }
}
impl PolicyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PolicyType::TargetTrackingScaling => "TargetTrackingScaling",
            PolicyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["TargetTrackingScaling"]
    }
}
impl AsRef<str> for PolicyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
