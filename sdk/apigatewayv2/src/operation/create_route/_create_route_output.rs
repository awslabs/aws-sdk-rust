// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRouteOutput {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    #[doc(hidden)]
    pub api_gateway_managed: bool,
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    #[doc(hidden)]
    pub api_key_required: bool,
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    #[doc(hidden)]
    pub authorization_scopes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    #[doc(hidden)]
    pub authorization_type: std::option::Option<crate::types::AuthorizationType>,
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    #[doc(hidden)]
    pub authorizer_id: std::option::Option<std::string::String>,
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    #[doc(hidden)]
    pub model_selection_expression: std::option::Option<std::string::String>,
    /// <p>The operation name for the route.</p>
    #[doc(hidden)]
    pub operation_name: std::option::Option<std::string::String>,
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    #[doc(hidden)]
    pub request_models:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    #[doc(hidden)]
    pub request_parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::types::ParameterConstraints>,
    >,
    /// <p>The route ID.</p>
    #[doc(hidden)]
    pub route_id: std::option::Option<std::string::String>,
    /// <p>The route key for the route.</p>
    #[doc(hidden)]
    pub route_key: std::option::Option<std::string::String>,
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    #[doc(hidden)]
    pub route_response_selection_expression: std::option::Option<std::string::String>,
    /// <p>The target for the route.</p>
    #[doc(hidden)]
    pub target: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl CreateRouteOutput {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    pub fn api_gateway_managed(&self) -> bool {
        self.api_gateway_managed
    }
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    pub fn api_key_required(&self) -> bool {
        self.api_key_required
    }
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    pub fn authorization_scopes(&self) -> std::option::Option<&[std::string::String]> {
        self.authorization_scopes.as_deref()
    }
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    pub fn authorization_type(&self) -> std::option::Option<&crate::types::AuthorizationType> {
        self.authorization_type.as_ref()
    }
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    pub fn authorizer_id(&self) -> std::option::Option<&str> {
        self.authorizer_id.as_deref()
    }
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    pub fn model_selection_expression(&self) -> std::option::Option<&str> {
        self.model_selection_expression.as_deref()
    }
    /// <p>The operation name for the route.</p>
    pub fn operation_name(&self) -> std::option::Option<&str> {
        self.operation_name.as_deref()
    }
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    pub fn request_models(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.request_models.as_ref()
    }
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    pub fn request_parameters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::types::ParameterConstraints>,
    > {
        self.request_parameters.as_ref()
    }
    /// <p>The route ID.</p>
    pub fn route_id(&self) -> std::option::Option<&str> {
        self.route_id.as_deref()
    }
    /// <p>The route key for the route.</p>
    pub fn route_key(&self) -> std::option::Option<&str> {
        self.route_key.as_deref()
    }
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    pub fn route_response_selection_expression(&self) -> std::option::Option<&str> {
        self.route_response_selection_expression.as_deref()
    }
    /// <p>The target for the route.</p>
    pub fn target(&self) -> std::option::Option<&str> {
        self.target.as_deref()
    }
}
impl aws_http::request_id::RequestId for CreateRouteOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl CreateRouteOutput {
    /// Creates a new builder-style object to manufacture [`CreateRouteOutput`](crate::operation::create_route::CreateRouteOutput).
    pub fn builder() -> crate::operation::create_route::builders::CreateRouteOutputBuilder {
        crate::operation::create_route::builders::CreateRouteOutputBuilder::default()
    }
}

/// A builder for [`CreateRouteOutput`](crate::operation::create_route::CreateRouteOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateRouteOutputBuilder {
    pub(crate) api_gateway_managed: std::option::Option<bool>,
    pub(crate) api_key_required: std::option::Option<bool>,
    pub(crate) authorization_scopes: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) authorization_type: std::option::Option<crate::types::AuthorizationType>,
    pub(crate) authorizer_id: std::option::Option<std::string::String>,
    pub(crate) model_selection_expression: std::option::Option<std::string::String>,
    pub(crate) operation_name: std::option::Option<std::string::String>,
    pub(crate) request_models:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) request_parameters: std::option::Option<
        std::collections::HashMap<std::string::String, crate::types::ParameterConstraints>,
    >,
    pub(crate) route_id: std::option::Option<std::string::String>,
    pub(crate) route_key: std::option::Option<std::string::String>,
    pub(crate) route_response_selection_expression: std::option::Option<std::string::String>,
    pub(crate) target: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl CreateRouteOutputBuilder {
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    pub fn api_gateway_managed(mut self, input: bool) -> Self {
        self.api_gateway_managed = Some(input);
        self
    }
    /// <p>Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.</p>
    pub fn set_api_gateway_managed(mut self, input: std::option::Option<bool>) -> Self {
        self.api_gateway_managed = input;
        self
    }
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    pub fn api_key_required(mut self, input: bool) -> Self {
        self.api_key_required = Some(input);
        self
    }
    /// <p>Specifies whether an API key is required for this route. Supported only for WebSocket APIs.</p>
    pub fn set_api_key_required(mut self, input: std::option::Option<bool>) -> Self {
        self.api_key_required = input;
        self
    }
    /// Appends an item to `authorization_scopes`.
    ///
    /// To override the contents of this collection use [`set_authorization_scopes`](Self::set_authorization_scopes).
    ///
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    pub fn authorization_scopes(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.authorization_scopes.unwrap_or_default();
        v.push(input.into());
        self.authorization_scopes = Some(v);
        self
    }
    /// <p>A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.</p>
    pub fn set_authorization_scopes(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.authorization_scopes = input;
        self
    }
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    pub fn authorization_type(mut self, input: crate::types::AuthorizationType) -> Self {
        self.authorization_type = Some(input);
        self
    }
    /// <p>The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.</p>
    pub fn set_authorization_type(
        mut self,
        input: std::option::Option<crate::types::AuthorizationType>,
    ) -> Self {
        self.authorization_type = input;
        self
    }
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    pub fn authorizer_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.authorizer_id = Some(input.into());
        self
    }
    /// <p>The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.</p>
    pub fn set_authorizer_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.authorizer_id = input;
        self
    }
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    pub fn model_selection_expression(mut self, input: impl Into<std::string::String>) -> Self {
        self.model_selection_expression = Some(input.into());
        self
    }
    /// <p>The model selection expression for the route. Supported only for WebSocket APIs.</p>
    pub fn set_model_selection_expression(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.model_selection_expression = input;
        self
    }
    /// <p>The operation name for the route.</p>
    pub fn operation_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.operation_name = Some(input.into());
        self
    }
    /// <p>The operation name for the route.</p>
    pub fn set_operation_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.operation_name = input;
        self
    }
    /// Adds a key-value pair to `request_models`.
    ///
    /// To override the contents of this collection use [`set_request_models`](Self::set_request_models).
    ///
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    pub fn request_models(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.request_models.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.request_models = Some(hash_map);
        self
    }
    /// <p>The request models for the route. Supported only for WebSocket APIs.</p>
    pub fn set_request_models(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.request_models = input;
        self
    }
    /// Adds a key-value pair to `request_parameters`.
    ///
    /// To override the contents of this collection use [`set_request_parameters`](Self::set_request_parameters).
    ///
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    pub fn request_parameters(
        mut self,
        k: impl Into<std::string::String>,
        v: crate::types::ParameterConstraints,
    ) -> Self {
        let mut hash_map = self.request_parameters.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.request_parameters = Some(hash_map);
        self
    }
    /// <p>The request parameters for the route. Supported only for WebSocket APIs.</p>
    pub fn set_request_parameters(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, crate::types::ParameterConstraints>,
        >,
    ) -> Self {
        self.request_parameters = input;
        self
    }
    /// <p>The route ID.</p>
    pub fn route_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.route_id = Some(input.into());
        self
    }
    /// <p>The route ID.</p>
    pub fn set_route_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.route_id = input;
        self
    }
    /// <p>The route key for the route.</p>
    pub fn route_key(mut self, input: impl Into<std::string::String>) -> Self {
        self.route_key = Some(input.into());
        self
    }
    /// <p>The route key for the route.</p>
    pub fn set_route_key(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.route_key = input;
        self
    }
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    pub fn route_response_selection_expression(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.route_response_selection_expression = Some(input.into());
        self
    }
    /// <p>The route response selection expression for the route. Supported only for WebSocket APIs.</p>
    pub fn set_route_response_selection_expression(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.route_response_selection_expression = input;
        self
    }
    /// <p>The target for the route.</p>
    pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
        self.target = Some(input.into());
        self
    }
    /// <p>The target for the route.</p>
    pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.target = input;
        self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`CreateRouteOutput`](crate::operation::create_route::CreateRouteOutput).
    pub fn build(self) -> crate::operation::create_route::CreateRouteOutput {
        crate::operation::create_route::CreateRouteOutput {
            api_gateway_managed: self.api_gateway_managed.unwrap_or_default(),
            api_key_required: self.api_key_required.unwrap_or_default(),
            authorization_scopes: self.authorization_scopes,
            authorization_type: self.authorization_type,
            authorizer_id: self.authorizer_id,
            model_selection_expression: self.model_selection_expression,
            operation_name: self.operation_name,
            request_models: self.request_models,
            request_parameters: self.request_parameters,
            route_id: self.route_id,
            route_key: self.route_key,
            route_response_selection_expression: self.route_response_selection_expression,
            target: self.target,
            _request_id: self._request_id,
        }
    }
}
