// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a generated test case, consisting of query content, guard content, and expected results.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct AutomatedReasoningPolicyGeneratedTestCase {
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub query_content: ::std::string::String,
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub guard_content: ::std::string::String,
    /// <p>The expected results of the generated test case. Possible values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// </ul>
    pub expected_aggregated_findings_result: crate::types::AutomatedReasoningCheckResult,
}
impl AutomatedReasoningPolicyGeneratedTestCase {
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub fn query_content(&self) -> &str {
        use std::ops::Deref;
        self.query_content.deref()
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub fn guard_content(&self) -> &str {
        use std::ops::Deref;
        self.guard_content.deref()
    }
    /// <p>The expected results of the generated test case. Possible values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// </ul>
    pub fn expected_aggregated_findings_result(&self) -> &crate::types::AutomatedReasoningCheckResult {
        &self.expected_aggregated_findings_result
    }
}
impl ::std::fmt::Debug for AutomatedReasoningPolicyGeneratedTestCase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("AutomatedReasoningPolicyGeneratedTestCase");
        formatter.field("query_content", &"*** Sensitive Data Redacted ***");
        formatter.field("guard_content", &"*** Sensitive Data Redacted ***");
        formatter.field("expected_aggregated_findings_result", &self.expected_aggregated_findings_result);
        formatter.finish()
    }
}
impl AutomatedReasoningPolicyGeneratedTestCase {
    /// Creates a new builder-style object to manufacture [`AutomatedReasoningPolicyGeneratedTestCase`](crate::types::AutomatedReasoningPolicyGeneratedTestCase).
    pub fn builder() -> crate::types::builders::AutomatedReasoningPolicyGeneratedTestCaseBuilder {
        crate::types::builders::AutomatedReasoningPolicyGeneratedTestCaseBuilder::default()
    }
}

/// A builder for [`AutomatedReasoningPolicyGeneratedTestCase`](crate::types::AutomatedReasoningPolicyGeneratedTestCase).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct AutomatedReasoningPolicyGeneratedTestCaseBuilder {
    pub(crate) query_content: ::std::option::Option<::std::string::String>,
    pub(crate) guard_content: ::std::option::Option<::std::string::String>,
    pub(crate) expected_aggregated_findings_result: ::std::option::Option<crate::types::AutomatedReasoningCheckResult>,
}
impl AutomatedReasoningPolicyGeneratedTestCaseBuilder {
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    /// This field is required.
    pub fn query_content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.query_content = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub fn set_query_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.query_content = input;
        self
    }
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub fn get_query_content(&self) -> &::std::option::Option<::std::string::String> {
        &self.query_content
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    /// This field is required.
    pub fn guard_content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.guard_content = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub fn set_guard_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.guard_content = input;
        self
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub fn get_guard_content(&self) -> &::std::option::Option<::std::string::String> {
        &self.guard_content
    }
    /// <p>The expected results of the generated test case. Possible values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// </ul>
    /// This field is required.
    pub fn expected_aggregated_findings_result(mut self, input: crate::types::AutomatedReasoningCheckResult) -> Self {
        self.expected_aggregated_findings_result = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expected results of the generated test case. Possible values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// </ul>
    pub fn set_expected_aggregated_findings_result(mut self, input: ::std::option::Option<crate::types::AutomatedReasoningCheckResult>) -> Self {
        self.expected_aggregated_findings_result = input;
        self
    }
    /// <p>The expected results of the generated test case. Possible values include:</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// </ul>
    pub fn get_expected_aggregated_findings_result(&self) -> &::std::option::Option<crate::types::AutomatedReasoningCheckResult> {
        &self.expected_aggregated_findings_result
    }
    /// Consumes the builder and constructs a [`AutomatedReasoningPolicyGeneratedTestCase`](crate::types::AutomatedReasoningPolicyGeneratedTestCase).
    /// This method will fail if any of the following fields are not set:
    /// - [`query_content`](crate::types::builders::AutomatedReasoningPolicyGeneratedTestCaseBuilder::query_content)
    /// - [`guard_content`](crate::types::builders::AutomatedReasoningPolicyGeneratedTestCaseBuilder::guard_content)
    /// - [`expected_aggregated_findings_result`](crate::types::builders::AutomatedReasoningPolicyGeneratedTestCaseBuilder::expected_aggregated_findings_result)
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::types::AutomatedReasoningPolicyGeneratedTestCase, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(
            crate::types::AutomatedReasoningPolicyGeneratedTestCase {
                query_content: self.query_content
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("query_content", "query_content was not specified but it is required when building AutomatedReasoningPolicyGeneratedTestCase")
                    )?
                ,
                guard_content: self.guard_content
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("guard_content", "guard_content was not specified but it is required when building AutomatedReasoningPolicyGeneratedTestCase")
                    )?
                ,
                expected_aggregated_findings_result: self.expected_aggregated_findings_result
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("expected_aggregated_findings_result", "expected_aggregated_findings_result was not specified but it is required when building AutomatedReasoningPolicyGeneratedTestCase")
                    )?
                ,
            }
        )
    }
}
impl ::std::fmt::Debug for AutomatedReasoningPolicyGeneratedTestCaseBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("AutomatedReasoningPolicyGeneratedTestCaseBuilder");
        formatter.field("query_content", &"*** Sensitive Data Redacted ***");
        formatter.field("guard_content", &"*** Sensitive Data Redacted ***");
        formatter.field("expected_aggregated_findings_result", &self.expected_aggregated_findings_result);
        formatter.finish()
    }
}
