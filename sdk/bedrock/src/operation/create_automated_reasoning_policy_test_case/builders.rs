// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_automated_reasoning_policy_test_case::_create_automated_reasoning_policy_test_case_output::CreateAutomatedReasoningPolicyTestCaseOutputBuilder;

pub use crate::operation::create_automated_reasoning_policy_test_case::_create_automated_reasoning_policy_test_case_input::CreateAutomatedReasoningPolicyTestCaseInputBuilder;

impl crate::operation::create_automated_reasoning_policy_test_case::builders::CreateAutomatedReasoningPolicyTestCaseInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_automated_reasoning_policy_test_case();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateAutomatedReasoningPolicyTestCase`.
///
/// <p>Creates a test for an Automated Reasoning policy. Tests validate that your policy works as expected by providing sample inputs and expected outcomes. Use tests to verify policy behavior before deploying to production.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateAutomatedReasoningPolicyTestCaseFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_automated_reasoning_policy_test_case::builders::CreateAutomatedReasoningPolicyTestCaseInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseOutput,
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseError,
    > for CreateAutomatedReasoningPolicyTestCaseFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseOutput,
            crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateAutomatedReasoningPolicyTestCaseFluentBuilder {
    /// Creates a new `CreateAutomatedReasoningPolicyTestCaseFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateAutomatedReasoningPolicyTestCase as a reference.
    pub fn as_input(
        &self,
    ) -> &crate::operation::create_automated_reasoning_policy_test_case::builders::CreateAutomatedReasoningPolicyTestCaseInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins =
            crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCase::operation_runtime_plugins(
                self.handle.runtime_plugins.clone(),
                &self.handle.conf,
                self.config_override,
            );
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCase::orchestrate(&runtime_plugins, input)
            .await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseOutput,
        crate::operation::create_automated_reasoning_policy_test_case::CreateAutomatedReasoningPolicyTestCaseError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to create the test.</p>
    pub fn policy_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.policy_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to create the test.</p>
    pub fn set_policy_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_policy_arn(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to create the test.</p>
    pub fn get_policy_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_policy_arn()
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub fn guard_content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.guard_content(input.into());
        self
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub fn set_guard_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_guard_content(input);
        self
    }
    /// <p>The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.</p>
    pub fn get_guard_content(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_guard_content()
    }
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub fn query_content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.query_content(input.into());
        self
    }
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub fn set_query_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_query_content(input);
        self
    }
    /// <p>The input query or prompt that generated the content. This provides context for the validation.</p>
    pub fn get_query_content(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_query_content()
    }
    /// <p>The expected result of the Automated Reasoning check. Valid values include: , TOO_COMPLEX, and NO_TRANSLATIONS.</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// <li>
    /// <p><code>TRANSLATION_AMBIGUOUS</code> - Detected an ambiguity in the translation meant it would be unsound to continue with validity checking. Additional context or follow-up questions might be needed to get translation to succeed.</p></li>
    /// <li>
    /// <p><code>TOO_COMPLEX</code> - The input contains too much information for Automated Reasoning to process within its latency limits.</p></li>
    /// <li>
    /// <p><code>NO_TRANSLATIONS</code> - Identifies that some or all of the input prompt wasn't translated into logic. This can happen if the input isn't relevant to the Automated Reasoning policy, or if the policy doesn't have variables to model relevant input. If Automated Reasoning can't translate anything, you get a single <code>NO_TRANSLATIONS</code> finding. You might also see a <code>NO_TRANSLATIONS</code> (along with other findings) if some part of the validation isn't translated.</p></li>
    /// </ul>
    pub fn expected_aggregated_findings_result(mut self, input: crate::types::AutomatedReasoningCheckResult) -> Self {
        self.inner = self.inner.expected_aggregated_findings_result(input);
        self
    }
    /// <p>The expected result of the Automated Reasoning check. Valid values include: , TOO_COMPLEX, and NO_TRANSLATIONS.</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// <li>
    /// <p><code>TRANSLATION_AMBIGUOUS</code> - Detected an ambiguity in the translation meant it would be unsound to continue with validity checking. Additional context or follow-up questions might be needed to get translation to succeed.</p></li>
    /// <li>
    /// <p><code>TOO_COMPLEX</code> - The input contains too much information for Automated Reasoning to process within its latency limits.</p></li>
    /// <li>
    /// <p><code>NO_TRANSLATIONS</code> - Identifies that some or all of the input prompt wasn't translated into logic. This can happen if the input isn't relevant to the Automated Reasoning policy, or if the policy doesn't have variables to model relevant input. If Automated Reasoning can't translate anything, you get a single <code>NO_TRANSLATIONS</code> finding. You might also see a <code>NO_TRANSLATIONS</code> (along with other findings) if some part of the validation isn't translated.</p></li>
    /// </ul>
    pub fn set_expected_aggregated_findings_result(mut self, input: ::std::option::Option<crate::types::AutomatedReasoningCheckResult>) -> Self {
        self.inner = self.inner.set_expected_aggregated_findings_result(input);
        self
    }
    /// <p>The expected result of the Automated Reasoning check. Valid values include: , TOO_COMPLEX, and NO_TRANSLATIONS.</p>
    /// <ul>
    /// <li>
    /// <p><code>VALID</code> - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.</p></li>
    /// <li>
    /// <p><code>INVALID</code> - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.</p></li>
    /// <li>
    /// <p><code>SATISFIABLE</code> - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p></li>
    /// <li>
    /// <p><code>IMPOSSIBLE</code> - Automated Reasoning can’t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p></li>
    /// <li>
    /// <p><code>TRANSLATION_AMBIGUOUS</code> - Detected an ambiguity in the translation meant it would be unsound to continue with validity checking. Additional context or follow-up questions might be needed to get translation to succeed.</p></li>
    /// <li>
    /// <p><code>TOO_COMPLEX</code> - The input contains too much information for Automated Reasoning to process within its latency limits.</p></li>
    /// <li>
    /// <p><code>NO_TRANSLATIONS</code> - Identifies that some or all of the input prompt wasn't translated into logic. This can happen if the input isn't relevant to the Automated Reasoning policy, or if the policy doesn't have variables to model relevant input. If Automated Reasoning can't translate anything, you get a single <code>NO_TRANSLATIONS</code> finding. You might also see a <code>NO_TRANSLATIONS</code> (along with other findings) if some part of the validation isn't translated.</p></li>
    /// </ul>
    pub fn get_expected_aggregated_findings_result(&self) -> &::std::option::Option<crate::types::AutomatedReasoningCheckResult> {
        self.inner.get_expected_aggregated_findings_result()
    }
    /// <p>A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.</p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_request_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_request_token(input);
        self
    }
    /// <p>A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_request_token()
    }
    /// <p>The minimum confidence level for logic validation. Content that meets the threshold is considered a high-confidence finding that can be validated.</p>
    pub fn confidence_threshold(mut self, input: f64) -> Self {
        self.inner = self.inner.confidence_threshold(input);
        self
    }
    /// <p>The minimum confidence level for logic validation. Content that meets the threshold is considered a high-confidence finding that can be validated.</p>
    pub fn set_confidence_threshold(mut self, input: ::std::option::Option<f64>) -> Self {
        self.inner = self.inner.set_confidence_threshold(input);
        self
    }
    /// <p>The minimum confidence level for logic validation. Content that meets the threshold is considered a high-confidence finding that can be validated.</p>
    pub fn get_confidence_threshold(&self) -> &::std::option::Option<f64> {
        self.inner.get_confidence_threshold()
    }
}
