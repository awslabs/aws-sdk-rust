// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>All the customer-modifiable InfluxDB v3 Enterprise parameters in Timestream for InfluxDB.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InfluxDBv3EnterpriseParameters {
    /// <p>Limits the number of Parquet files a query can access. If a query attempts to read more than this limit, InfluxDB 3 returns an error.</p>
    /// <p>Default: 432</p>
    pub query_file_limit: ::std::option::Option<i32>,
    /// <p>Defines the size of the query log. Up to this many queries remain in the log before older queries are evicted to make room for new ones.</p>
    /// <p>Default: 1000</p>
    pub query_log_size: ::std::option::Option<i32>,
    /// <p>Sets the filter directive for logs.</p>
    pub log_filter: ::std::option::Option<::std::string::String>,
    /// <p>Defines the message format for logs.</p>
    /// <p>Default: full</p>
    pub log_format: ::std::option::Option<crate::types::LogFormats>,
    /// <p>Sets the maximum number of DataFusion runtime threads to use.</p>
    pub data_fusion_num_threads: ::std::option::Option<i32>,
    /// <p>Specifies the DataFusion tokio runtime type.</p>
    /// <p>Default: multi-thread</p>
    pub data_fusion_runtime_type: ::std::option::Option<crate::types::DataFusionRuntimeType>,
    /// <p>Disables the LIFO slot of the DataFusion runtime.</p>
    pub data_fusion_runtime_disable_lifo_slot: ::std::option::Option<bool>,
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion tokio runtime polls for external events–for example: timers, I/O.</p>
    pub data_fusion_runtime_event_interval: ::std::option::Option<i32>,
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion runtime polls the global task queue.</p>
    pub data_fusion_runtime_global_queue_interval: ::std::option::Option<i32>,
    /// <p>Specifies the limit for additional threads spawned by the DataFusion runtime.</p>
    pub data_fusion_runtime_max_blocking_threads: ::std::option::Option<i32>,
    /// <p>Configures the maximum number of events processed per tick by the tokio DataFusion runtime.</p>
    pub data_fusion_runtime_max_io_events_per_tick: ::std::option::Option<i32>,
    /// <p>Sets a custom timeout for a thread in the blocking pool of the tokio DataFusion runtime.</p>
    pub data_fusion_runtime_thread_keep_alive: ::std::option::Option<crate::types::Duration>,
    /// <p>Sets the thread priority for tokio DataFusion runtime workers.</p>
    /// <p>Default: 10</p>
    pub data_fusion_runtime_thread_priority: ::std::option::Option<i32>,
    /// <p>When multiple parquet files are required in a sorted way (deduplication for example), specifies the maximum fanout.</p>
    /// <p>Default: 1000</p>
    pub data_fusion_max_parquet_fanout: ::std::option::Option<i32>,
    /// <p>Uses a cached parquet loader when reading parquet files from the object store.</p>
    pub data_fusion_use_cached_parquet_loader: ::std::option::Option<bool>,
    /// <p>Provides custom configuration to DataFusion as a comma-separated list of key:value pairs.</p>
    pub data_fusion_config: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the maximum size of HTTP requests.</p>
    /// <p>Default: 10485760</p>
    pub max_http_request_size: ::std::option::Option<i64>,
    /// <p>Specifies the threshold for the internal memory buffer. Supports either a percentage (portion of available memory) or absolute value in MB–for example: 70% or 100</p>
    /// <p>Default: 70%</p>
    pub force_snapshot_mem_threshold: ::std::option::Option<crate::types::PercentOrAbsoluteLong>,
    /// <p>Defines the number of WAL files to attempt to remove in a snapshot. This, multiplied by the interval, determines how often snapshots are taken.</p>
    /// <p>Default: 600</p>
    pub wal_snapshot_size: ::std::option::Option<i32>,
    /// <p>Specifies the maximum number of write requests that can be buffered before a flush must be executed and succeed.</p>
    /// <p>Default: 100000</p>
    pub wal_max_write_buffer_size: ::std::option::Option<i32>,
    /// <p>Specifies the number of snapshotted WAL files to retain in the object store. Flushing the WAL files does not clear the WAL files immediately; they are deleted when the number of snapshotted WAL files exceeds this number.</p>
    /// <p>Default: 300</p>
    pub snapshotted_wal_files_to_keep: ::std::option::Option<i32>,
    /// <p>Specifies the interval to prefetch into the Parquet cache during compaction.</p>
    /// <p>Default: 3d</p>
    pub preemptive_cache_age: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies the percentage of entries to prune during a prune operation on the in-memory Parquet cache.</p>
    /// <p>Default: 0.1</p>
    pub parquet_mem_cache_prune_percentage: ::std::option::Option<f32>,
    /// <p>Sets the interval to check if the in-memory Parquet cache needs to be pruned.</p>
    /// <p>Default: 1s</p>
    pub parquet_mem_cache_prune_interval: ::std::option::Option<crate::types::Duration>,
    /// <p>Disables the in-memory Parquet cache. By default, the cache is enabled.</p>
    pub disable_parquet_mem_cache: ::std::option::Option<bool>,
    /// <p>Specifies the time window for caching recent Parquet files in memory.</p>
    /// <p>Default: 5h</p>
    pub parquet_mem_cache_query_path_duration: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies the interval to evict expired entries from the Last-N-Value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub last_cache_eviction_interval: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies the interval to evict expired entries from the distinct value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub distinct_cache_eviction_interval: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies the duration that Parquet files are arranged into. Data timestamps land each row into a file of this duration. Supported durations are 1m, 5m, and 10m. These files are known as “generation 1” files, which the compactor can merge into larger generations.</p>
    /// <p>Default: 10m</p>
    pub gen1_duration: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies the size of memory pool used during query execution. Can be given as absolute value in bytes or as a percentage of the total available memory–for example: 8000000000 or 10%.</p>
    /// <p>Default: 20%</p>
    pub exec_mem_pool_bytes: ::std::option::Option<crate::types::PercentOrAbsoluteLong>,
    /// <p>Specifies the size of the in-memory Parquet cache in megabytes or percentage of total available memory.</p>
    /// <p>Default: 20%</p>
    pub parquet_mem_cache_size: ::std::option::Option<crate::types::PercentOrAbsoluteLong>,
    /// <p>Determines whether WAL replay should fail when encountering errors.</p>
    /// <p>Default: false</p>
    pub wal_replay_fail_on_error: ::std::option::Option<bool>,
    /// <p>Concurrency limit during WAL replay. Setting this number too high can lead to OOM. The default is dynamically determined.</p>
    /// <p>Default: max(num_cpus, 10)</p>
    pub wal_replay_concurrency_limit: ::std::option::Option<i32>,
    /// <p>Specifies the maximum number of entries in the table index cache.</p>
    /// <p>Default: 1000</p>
    pub table_index_cache_max_entries: ::std::option::Option<i32>,
    /// <p>Limits the concurrency level for table index cache operations.</p>
    /// <p>Default: 8</p>
    pub table_index_cache_concurrency_limit: ::std::option::Option<i32>,
    /// <p>Specifies how far back to look when creating generation 1 Parquet files.</p>
    /// <p>Default: 24h</p>
    pub gen1_lookback_duration: ::std::option::Option<crate::types::Duration>,
    /// <p>The interval at which retention policies are checked and enforced. Enter as a human-readable time–for example: 30m or 1h.</p>
    /// <p>Default: 30m</p>
    pub retention_check_interval: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies the grace period before permanently deleting data.</p>
    /// <p>Default: 24h</p>
    pub delete_grace_period: ::std::option::Option<crate::types::Duration>,
    /// <p>Sets the default duration for hard deletion of data.</p>
    /// <p>Default: 90d</p>
    pub hard_delete_default_duration: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies number of instances in the DbCluster which can both ingest and query.</p>
    pub ingest_query_instances: i32,
    /// <p>Specifies number of instances in the DbCluster which can only query.</p>
    pub query_only_instances: i32,
    /// <p>Specifies if the compactor instance should be a standalone instance or not.</p>
    pub dedicated_compactor: bool,
    /// <p>Specifies the soft limit for the number of rows per file that the compactor writes. The compactor may write more rows than this limit.</p>
    /// <p>Default: 1000000</p>
    pub compaction_row_limit: ::std::option::Option<i32>,
    /// <p>Sets the maximum number of files included in any compaction plan.</p>
    /// <p>Default: 500</p>
    pub compaction_max_num_files_per_plan: ::std::option::Option<i32>,
    /// <p>Specifies the duration of the first level of compaction (gen2). Later levels of compaction are multiples of this duration. This value should be equal to or greater than the gen1 duration.</p>
    /// <p>Default: 20m</p>
    pub compaction_gen2_duration: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies a comma-separated list of multiples defining the duration of each level of compaction. The number of elements in the list determines the number of compaction levels. The first element specifies the duration of the first level (gen3); subsequent levels are multiples of the previous level.</p>
    /// <p>Default: 3,4,6,5</p>
    pub compaction_multipliers: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the amount of time that the compactor waits after finishing a compaction run to delete files marked as needing deletion during that compaction run.</p>
    /// <p>Default: 10m</p>
    pub compaction_cleanup_wait: ::std::option::Option<crate::types::Duration>,
    /// <p>Specifies how often the compactor checks for new compaction work to perform.</p>
    /// <p>Default: 10s</p>
    pub compaction_check_interval: ::std::option::Option<crate::types::Duration>,
    /// <p>Disables populating the last-N-value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub last_value_cache_disable_from_history: ::std::option::Option<bool>,
    /// <p>Disables populating the distinct value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub distinct_value_cache_disable_from_history: ::std::option::Option<bool>,
    /// <p>Specifies the interval at which data replication occurs between cluster nodes.</p>
    /// <p>Default: 250ms</p>
    pub replication_interval: ::std::option::Option<crate::types::Duration>,
    /// <p>Defines how often the catalog synchronizes across cluster nodes.</p>
    /// <p>Default: 10s</p>
    pub catalog_sync_interval: ::std::option::Option<crate::types::Duration>,
}
impl InfluxDBv3EnterpriseParameters {
    /// <p>Limits the number of Parquet files a query can access. If a query attempts to read more than this limit, InfluxDB 3 returns an error.</p>
    /// <p>Default: 432</p>
    pub fn query_file_limit(&self) -> ::std::option::Option<i32> {
        self.query_file_limit
    }
    /// <p>Defines the size of the query log. Up to this many queries remain in the log before older queries are evicted to make room for new ones.</p>
    /// <p>Default: 1000</p>
    pub fn query_log_size(&self) -> ::std::option::Option<i32> {
        self.query_log_size
    }
    /// <p>Sets the filter directive for logs.</p>
    pub fn log_filter(&self) -> ::std::option::Option<&str> {
        self.log_filter.as_deref()
    }
    /// <p>Defines the message format for logs.</p>
    /// <p>Default: full</p>
    pub fn log_format(&self) -> ::std::option::Option<&crate::types::LogFormats> {
        self.log_format.as_ref()
    }
    /// <p>Sets the maximum number of DataFusion runtime threads to use.</p>
    pub fn data_fusion_num_threads(&self) -> ::std::option::Option<i32> {
        self.data_fusion_num_threads
    }
    /// <p>Specifies the DataFusion tokio runtime type.</p>
    /// <p>Default: multi-thread</p>
    pub fn data_fusion_runtime_type(&self) -> ::std::option::Option<&crate::types::DataFusionRuntimeType> {
        self.data_fusion_runtime_type.as_ref()
    }
    /// <p>Disables the LIFO slot of the DataFusion runtime.</p>
    pub fn data_fusion_runtime_disable_lifo_slot(&self) -> ::std::option::Option<bool> {
        self.data_fusion_runtime_disable_lifo_slot
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion tokio runtime polls for external events–for example: timers, I/O.</p>
    pub fn data_fusion_runtime_event_interval(&self) -> ::std::option::Option<i32> {
        self.data_fusion_runtime_event_interval
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion runtime polls the global task queue.</p>
    pub fn data_fusion_runtime_global_queue_interval(&self) -> ::std::option::Option<i32> {
        self.data_fusion_runtime_global_queue_interval
    }
    /// <p>Specifies the limit for additional threads spawned by the DataFusion runtime.</p>
    pub fn data_fusion_runtime_max_blocking_threads(&self) -> ::std::option::Option<i32> {
        self.data_fusion_runtime_max_blocking_threads
    }
    /// <p>Configures the maximum number of events processed per tick by the tokio DataFusion runtime.</p>
    pub fn data_fusion_runtime_max_io_events_per_tick(&self) -> ::std::option::Option<i32> {
        self.data_fusion_runtime_max_io_events_per_tick
    }
    /// <p>Sets a custom timeout for a thread in the blocking pool of the tokio DataFusion runtime.</p>
    pub fn data_fusion_runtime_thread_keep_alive(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.data_fusion_runtime_thread_keep_alive.as_ref()
    }
    /// <p>Sets the thread priority for tokio DataFusion runtime workers.</p>
    /// <p>Default: 10</p>
    pub fn data_fusion_runtime_thread_priority(&self) -> ::std::option::Option<i32> {
        self.data_fusion_runtime_thread_priority
    }
    /// <p>When multiple parquet files are required in a sorted way (deduplication for example), specifies the maximum fanout.</p>
    /// <p>Default: 1000</p>
    pub fn data_fusion_max_parquet_fanout(&self) -> ::std::option::Option<i32> {
        self.data_fusion_max_parquet_fanout
    }
    /// <p>Uses a cached parquet loader when reading parquet files from the object store.</p>
    pub fn data_fusion_use_cached_parquet_loader(&self) -> ::std::option::Option<bool> {
        self.data_fusion_use_cached_parquet_loader
    }
    /// <p>Provides custom configuration to DataFusion as a comma-separated list of key:value pairs.</p>
    pub fn data_fusion_config(&self) -> ::std::option::Option<&str> {
        self.data_fusion_config.as_deref()
    }
    /// <p>Specifies the maximum size of HTTP requests.</p>
    /// <p>Default: 10485760</p>
    pub fn max_http_request_size(&self) -> ::std::option::Option<i64> {
        self.max_http_request_size
    }
    /// <p>Specifies the threshold for the internal memory buffer. Supports either a percentage (portion of available memory) or absolute value in MB–for example: 70% or 100</p>
    /// <p>Default: 70%</p>
    pub fn force_snapshot_mem_threshold(&self) -> ::std::option::Option<&crate::types::PercentOrAbsoluteLong> {
        self.force_snapshot_mem_threshold.as_ref()
    }
    /// <p>Defines the number of WAL files to attempt to remove in a snapshot. This, multiplied by the interval, determines how often snapshots are taken.</p>
    /// <p>Default: 600</p>
    pub fn wal_snapshot_size(&self) -> ::std::option::Option<i32> {
        self.wal_snapshot_size
    }
    /// <p>Specifies the maximum number of write requests that can be buffered before a flush must be executed and succeed.</p>
    /// <p>Default: 100000</p>
    pub fn wal_max_write_buffer_size(&self) -> ::std::option::Option<i32> {
        self.wal_max_write_buffer_size
    }
    /// <p>Specifies the number of snapshotted WAL files to retain in the object store. Flushing the WAL files does not clear the WAL files immediately; they are deleted when the number of snapshotted WAL files exceeds this number.</p>
    /// <p>Default: 300</p>
    pub fn snapshotted_wal_files_to_keep(&self) -> ::std::option::Option<i32> {
        self.snapshotted_wal_files_to_keep
    }
    /// <p>Specifies the interval to prefetch into the Parquet cache during compaction.</p>
    /// <p>Default: 3d</p>
    pub fn preemptive_cache_age(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.preemptive_cache_age.as_ref()
    }
    /// <p>Specifies the percentage of entries to prune during a prune operation on the in-memory Parquet cache.</p>
    /// <p>Default: 0.1</p>
    pub fn parquet_mem_cache_prune_percentage(&self) -> ::std::option::Option<f32> {
        self.parquet_mem_cache_prune_percentage
    }
    /// <p>Sets the interval to check if the in-memory Parquet cache needs to be pruned.</p>
    /// <p>Default: 1s</p>
    pub fn parquet_mem_cache_prune_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.parquet_mem_cache_prune_interval.as_ref()
    }
    /// <p>Disables the in-memory Parquet cache. By default, the cache is enabled.</p>
    pub fn disable_parquet_mem_cache(&self) -> ::std::option::Option<bool> {
        self.disable_parquet_mem_cache
    }
    /// <p>Specifies the time window for caching recent Parquet files in memory.</p>
    /// <p>Default: 5h</p>
    pub fn parquet_mem_cache_query_path_duration(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.parquet_mem_cache_query_path_duration.as_ref()
    }
    /// <p>Specifies the interval to evict expired entries from the Last-N-Value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn last_cache_eviction_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.last_cache_eviction_interval.as_ref()
    }
    /// <p>Specifies the interval to evict expired entries from the distinct value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn distinct_cache_eviction_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.distinct_cache_eviction_interval.as_ref()
    }
    /// <p>Specifies the duration that Parquet files are arranged into. Data timestamps land each row into a file of this duration. Supported durations are 1m, 5m, and 10m. These files are known as “generation 1” files, which the compactor can merge into larger generations.</p>
    /// <p>Default: 10m</p>
    pub fn gen1_duration(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.gen1_duration.as_ref()
    }
    /// <p>Specifies the size of memory pool used during query execution. Can be given as absolute value in bytes or as a percentage of the total available memory–for example: 8000000000 or 10%.</p>
    /// <p>Default: 20%</p>
    pub fn exec_mem_pool_bytes(&self) -> ::std::option::Option<&crate::types::PercentOrAbsoluteLong> {
        self.exec_mem_pool_bytes.as_ref()
    }
    /// <p>Specifies the size of the in-memory Parquet cache in megabytes or percentage of total available memory.</p>
    /// <p>Default: 20%</p>
    pub fn parquet_mem_cache_size(&self) -> ::std::option::Option<&crate::types::PercentOrAbsoluteLong> {
        self.parquet_mem_cache_size.as_ref()
    }
    /// <p>Determines whether WAL replay should fail when encountering errors.</p>
    /// <p>Default: false</p>
    pub fn wal_replay_fail_on_error(&self) -> ::std::option::Option<bool> {
        self.wal_replay_fail_on_error
    }
    /// <p>Concurrency limit during WAL replay. Setting this number too high can lead to OOM. The default is dynamically determined.</p>
    /// <p>Default: max(num_cpus, 10)</p>
    pub fn wal_replay_concurrency_limit(&self) -> ::std::option::Option<i32> {
        self.wal_replay_concurrency_limit
    }
    /// <p>Specifies the maximum number of entries in the table index cache.</p>
    /// <p>Default: 1000</p>
    pub fn table_index_cache_max_entries(&self) -> ::std::option::Option<i32> {
        self.table_index_cache_max_entries
    }
    /// <p>Limits the concurrency level for table index cache operations.</p>
    /// <p>Default: 8</p>
    pub fn table_index_cache_concurrency_limit(&self) -> ::std::option::Option<i32> {
        self.table_index_cache_concurrency_limit
    }
    /// <p>Specifies how far back to look when creating generation 1 Parquet files.</p>
    /// <p>Default: 24h</p>
    pub fn gen1_lookback_duration(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.gen1_lookback_duration.as_ref()
    }
    /// <p>The interval at which retention policies are checked and enforced. Enter as a human-readable time–for example: 30m or 1h.</p>
    /// <p>Default: 30m</p>
    pub fn retention_check_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.retention_check_interval.as_ref()
    }
    /// <p>Specifies the grace period before permanently deleting data.</p>
    /// <p>Default: 24h</p>
    pub fn delete_grace_period(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.delete_grace_period.as_ref()
    }
    /// <p>Sets the default duration for hard deletion of data.</p>
    /// <p>Default: 90d</p>
    pub fn hard_delete_default_duration(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.hard_delete_default_duration.as_ref()
    }
    /// <p>Specifies number of instances in the DbCluster which can both ingest and query.</p>
    pub fn ingest_query_instances(&self) -> i32 {
        self.ingest_query_instances
    }
    /// <p>Specifies number of instances in the DbCluster which can only query.</p>
    pub fn query_only_instances(&self) -> i32 {
        self.query_only_instances
    }
    /// <p>Specifies if the compactor instance should be a standalone instance or not.</p>
    pub fn dedicated_compactor(&self) -> bool {
        self.dedicated_compactor
    }
    /// <p>Specifies the soft limit for the number of rows per file that the compactor writes. The compactor may write more rows than this limit.</p>
    /// <p>Default: 1000000</p>
    pub fn compaction_row_limit(&self) -> ::std::option::Option<i32> {
        self.compaction_row_limit
    }
    /// <p>Sets the maximum number of files included in any compaction plan.</p>
    /// <p>Default: 500</p>
    pub fn compaction_max_num_files_per_plan(&self) -> ::std::option::Option<i32> {
        self.compaction_max_num_files_per_plan
    }
    /// <p>Specifies the duration of the first level of compaction (gen2). Later levels of compaction are multiples of this duration. This value should be equal to or greater than the gen1 duration.</p>
    /// <p>Default: 20m</p>
    pub fn compaction_gen2_duration(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.compaction_gen2_duration.as_ref()
    }
    /// <p>Specifies a comma-separated list of multiples defining the duration of each level of compaction. The number of elements in the list determines the number of compaction levels. The first element specifies the duration of the first level (gen3); subsequent levels are multiples of the previous level.</p>
    /// <p>Default: 3,4,6,5</p>
    pub fn compaction_multipliers(&self) -> ::std::option::Option<&str> {
        self.compaction_multipliers.as_deref()
    }
    /// <p>Specifies the amount of time that the compactor waits after finishing a compaction run to delete files marked as needing deletion during that compaction run.</p>
    /// <p>Default: 10m</p>
    pub fn compaction_cleanup_wait(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.compaction_cleanup_wait.as_ref()
    }
    /// <p>Specifies how often the compactor checks for new compaction work to perform.</p>
    /// <p>Default: 10s</p>
    pub fn compaction_check_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.compaction_check_interval.as_ref()
    }
    /// <p>Disables populating the last-N-value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn last_value_cache_disable_from_history(&self) -> ::std::option::Option<bool> {
        self.last_value_cache_disable_from_history
    }
    /// <p>Disables populating the distinct value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn distinct_value_cache_disable_from_history(&self) -> ::std::option::Option<bool> {
        self.distinct_value_cache_disable_from_history
    }
    /// <p>Specifies the interval at which data replication occurs between cluster nodes.</p>
    /// <p>Default: 250ms</p>
    pub fn replication_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.replication_interval.as_ref()
    }
    /// <p>Defines how often the catalog synchronizes across cluster nodes.</p>
    /// <p>Default: 10s</p>
    pub fn catalog_sync_interval(&self) -> ::std::option::Option<&crate::types::Duration> {
        self.catalog_sync_interval.as_ref()
    }
}
impl InfluxDBv3EnterpriseParameters {
    /// Creates a new builder-style object to manufacture [`InfluxDBv3EnterpriseParameters`](crate::types::InfluxDBv3EnterpriseParameters).
    pub fn builder() -> crate::types::builders::InfluxDBv3EnterpriseParametersBuilder {
        crate::types::builders::InfluxDBv3EnterpriseParametersBuilder::default()
    }
}

/// A builder for [`InfluxDBv3EnterpriseParameters`](crate::types::InfluxDBv3EnterpriseParameters).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct InfluxDBv3EnterpriseParametersBuilder {
    pub(crate) query_file_limit: ::std::option::Option<i32>,
    pub(crate) query_log_size: ::std::option::Option<i32>,
    pub(crate) log_filter: ::std::option::Option<::std::string::String>,
    pub(crate) log_format: ::std::option::Option<crate::types::LogFormats>,
    pub(crate) data_fusion_num_threads: ::std::option::Option<i32>,
    pub(crate) data_fusion_runtime_type: ::std::option::Option<crate::types::DataFusionRuntimeType>,
    pub(crate) data_fusion_runtime_disable_lifo_slot: ::std::option::Option<bool>,
    pub(crate) data_fusion_runtime_event_interval: ::std::option::Option<i32>,
    pub(crate) data_fusion_runtime_global_queue_interval: ::std::option::Option<i32>,
    pub(crate) data_fusion_runtime_max_blocking_threads: ::std::option::Option<i32>,
    pub(crate) data_fusion_runtime_max_io_events_per_tick: ::std::option::Option<i32>,
    pub(crate) data_fusion_runtime_thread_keep_alive: ::std::option::Option<crate::types::Duration>,
    pub(crate) data_fusion_runtime_thread_priority: ::std::option::Option<i32>,
    pub(crate) data_fusion_max_parquet_fanout: ::std::option::Option<i32>,
    pub(crate) data_fusion_use_cached_parquet_loader: ::std::option::Option<bool>,
    pub(crate) data_fusion_config: ::std::option::Option<::std::string::String>,
    pub(crate) max_http_request_size: ::std::option::Option<i64>,
    pub(crate) force_snapshot_mem_threshold: ::std::option::Option<crate::types::PercentOrAbsoluteLong>,
    pub(crate) wal_snapshot_size: ::std::option::Option<i32>,
    pub(crate) wal_max_write_buffer_size: ::std::option::Option<i32>,
    pub(crate) snapshotted_wal_files_to_keep: ::std::option::Option<i32>,
    pub(crate) preemptive_cache_age: ::std::option::Option<crate::types::Duration>,
    pub(crate) parquet_mem_cache_prune_percentage: ::std::option::Option<f32>,
    pub(crate) parquet_mem_cache_prune_interval: ::std::option::Option<crate::types::Duration>,
    pub(crate) disable_parquet_mem_cache: ::std::option::Option<bool>,
    pub(crate) parquet_mem_cache_query_path_duration: ::std::option::Option<crate::types::Duration>,
    pub(crate) last_cache_eviction_interval: ::std::option::Option<crate::types::Duration>,
    pub(crate) distinct_cache_eviction_interval: ::std::option::Option<crate::types::Duration>,
    pub(crate) gen1_duration: ::std::option::Option<crate::types::Duration>,
    pub(crate) exec_mem_pool_bytes: ::std::option::Option<crate::types::PercentOrAbsoluteLong>,
    pub(crate) parquet_mem_cache_size: ::std::option::Option<crate::types::PercentOrAbsoluteLong>,
    pub(crate) wal_replay_fail_on_error: ::std::option::Option<bool>,
    pub(crate) wal_replay_concurrency_limit: ::std::option::Option<i32>,
    pub(crate) table_index_cache_max_entries: ::std::option::Option<i32>,
    pub(crate) table_index_cache_concurrency_limit: ::std::option::Option<i32>,
    pub(crate) gen1_lookback_duration: ::std::option::Option<crate::types::Duration>,
    pub(crate) retention_check_interval: ::std::option::Option<crate::types::Duration>,
    pub(crate) delete_grace_period: ::std::option::Option<crate::types::Duration>,
    pub(crate) hard_delete_default_duration: ::std::option::Option<crate::types::Duration>,
    pub(crate) ingest_query_instances: ::std::option::Option<i32>,
    pub(crate) query_only_instances: ::std::option::Option<i32>,
    pub(crate) dedicated_compactor: ::std::option::Option<bool>,
    pub(crate) compaction_row_limit: ::std::option::Option<i32>,
    pub(crate) compaction_max_num_files_per_plan: ::std::option::Option<i32>,
    pub(crate) compaction_gen2_duration: ::std::option::Option<crate::types::Duration>,
    pub(crate) compaction_multipliers: ::std::option::Option<::std::string::String>,
    pub(crate) compaction_cleanup_wait: ::std::option::Option<crate::types::Duration>,
    pub(crate) compaction_check_interval: ::std::option::Option<crate::types::Duration>,
    pub(crate) last_value_cache_disable_from_history: ::std::option::Option<bool>,
    pub(crate) distinct_value_cache_disable_from_history: ::std::option::Option<bool>,
    pub(crate) replication_interval: ::std::option::Option<crate::types::Duration>,
    pub(crate) catalog_sync_interval: ::std::option::Option<crate::types::Duration>,
}
impl InfluxDBv3EnterpriseParametersBuilder {
    /// <p>Limits the number of Parquet files a query can access. If a query attempts to read more than this limit, InfluxDB 3 returns an error.</p>
    /// <p>Default: 432</p>
    pub fn query_file_limit(mut self, input: i32) -> Self {
        self.query_file_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Limits the number of Parquet files a query can access. If a query attempts to read more than this limit, InfluxDB 3 returns an error.</p>
    /// <p>Default: 432</p>
    pub fn set_query_file_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.query_file_limit = input;
        self
    }
    /// <p>Limits the number of Parquet files a query can access. If a query attempts to read more than this limit, InfluxDB 3 returns an error.</p>
    /// <p>Default: 432</p>
    pub fn get_query_file_limit(&self) -> &::std::option::Option<i32> {
        &self.query_file_limit
    }
    /// <p>Defines the size of the query log. Up to this many queries remain in the log before older queries are evicted to make room for new ones.</p>
    /// <p>Default: 1000</p>
    pub fn query_log_size(mut self, input: i32) -> Self {
        self.query_log_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the size of the query log. Up to this many queries remain in the log before older queries are evicted to make room for new ones.</p>
    /// <p>Default: 1000</p>
    pub fn set_query_log_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.query_log_size = input;
        self
    }
    /// <p>Defines the size of the query log. Up to this many queries remain in the log before older queries are evicted to make room for new ones.</p>
    /// <p>Default: 1000</p>
    pub fn get_query_log_size(&self) -> &::std::option::Option<i32> {
        &self.query_log_size
    }
    /// <p>Sets the filter directive for logs.</p>
    pub fn log_filter(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.log_filter = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Sets the filter directive for logs.</p>
    pub fn set_log_filter(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.log_filter = input;
        self
    }
    /// <p>Sets the filter directive for logs.</p>
    pub fn get_log_filter(&self) -> &::std::option::Option<::std::string::String> {
        &self.log_filter
    }
    /// <p>Defines the message format for logs.</p>
    /// <p>Default: full</p>
    pub fn log_format(mut self, input: crate::types::LogFormats) -> Self {
        self.log_format = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the message format for logs.</p>
    /// <p>Default: full</p>
    pub fn set_log_format(mut self, input: ::std::option::Option<crate::types::LogFormats>) -> Self {
        self.log_format = input;
        self
    }
    /// <p>Defines the message format for logs.</p>
    /// <p>Default: full</p>
    pub fn get_log_format(&self) -> &::std::option::Option<crate::types::LogFormats> {
        &self.log_format
    }
    /// <p>Sets the maximum number of DataFusion runtime threads to use.</p>
    pub fn data_fusion_num_threads(mut self, input: i32) -> Self {
        self.data_fusion_num_threads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the maximum number of DataFusion runtime threads to use.</p>
    pub fn set_data_fusion_num_threads(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_num_threads = input;
        self
    }
    /// <p>Sets the maximum number of DataFusion runtime threads to use.</p>
    pub fn get_data_fusion_num_threads(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_num_threads
    }
    /// <p>Specifies the DataFusion tokio runtime type.</p>
    /// <p>Default: multi-thread</p>
    pub fn data_fusion_runtime_type(mut self, input: crate::types::DataFusionRuntimeType) -> Self {
        self.data_fusion_runtime_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the DataFusion tokio runtime type.</p>
    /// <p>Default: multi-thread</p>
    pub fn set_data_fusion_runtime_type(mut self, input: ::std::option::Option<crate::types::DataFusionRuntimeType>) -> Self {
        self.data_fusion_runtime_type = input;
        self
    }
    /// <p>Specifies the DataFusion tokio runtime type.</p>
    /// <p>Default: multi-thread</p>
    pub fn get_data_fusion_runtime_type(&self) -> &::std::option::Option<crate::types::DataFusionRuntimeType> {
        &self.data_fusion_runtime_type
    }
    /// <p>Disables the LIFO slot of the DataFusion runtime.</p>
    pub fn data_fusion_runtime_disable_lifo_slot(mut self, input: bool) -> Self {
        self.data_fusion_runtime_disable_lifo_slot = ::std::option::Option::Some(input);
        self
    }
    /// <p>Disables the LIFO slot of the DataFusion runtime.</p>
    pub fn set_data_fusion_runtime_disable_lifo_slot(mut self, input: ::std::option::Option<bool>) -> Self {
        self.data_fusion_runtime_disable_lifo_slot = input;
        self
    }
    /// <p>Disables the LIFO slot of the DataFusion runtime.</p>
    pub fn get_data_fusion_runtime_disable_lifo_slot(&self) -> &::std::option::Option<bool> {
        &self.data_fusion_runtime_disable_lifo_slot
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion tokio runtime polls for external events–for example: timers, I/O.</p>
    pub fn data_fusion_runtime_event_interval(mut self, input: i32) -> Self {
        self.data_fusion_runtime_event_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion tokio runtime polls for external events–for example: timers, I/O.</p>
    pub fn set_data_fusion_runtime_event_interval(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_runtime_event_interval = input;
        self
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion tokio runtime polls for external events–for example: timers, I/O.</p>
    pub fn get_data_fusion_runtime_event_interval(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_runtime_event_interval
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion runtime polls the global task queue.</p>
    pub fn data_fusion_runtime_global_queue_interval(mut self, input: i32) -> Self {
        self.data_fusion_runtime_global_queue_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion runtime polls the global task queue.</p>
    pub fn set_data_fusion_runtime_global_queue_interval(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_runtime_global_queue_interval = input;
        self
    }
    /// <p>Sets the number of scheduler ticks after which the scheduler of the DataFusion runtime polls the global task queue.</p>
    pub fn get_data_fusion_runtime_global_queue_interval(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_runtime_global_queue_interval
    }
    /// <p>Specifies the limit for additional threads spawned by the DataFusion runtime.</p>
    pub fn data_fusion_runtime_max_blocking_threads(mut self, input: i32) -> Self {
        self.data_fusion_runtime_max_blocking_threads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the limit for additional threads spawned by the DataFusion runtime.</p>
    pub fn set_data_fusion_runtime_max_blocking_threads(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_runtime_max_blocking_threads = input;
        self
    }
    /// <p>Specifies the limit for additional threads spawned by the DataFusion runtime.</p>
    pub fn get_data_fusion_runtime_max_blocking_threads(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_runtime_max_blocking_threads
    }
    /// <p>Configures the maximum number of events processed per tick by the tokio DataFusion runtime.</p>
    pub fn data_fusion_runtime_max_io_events_per_tick(mut self, input: i32) -> Self {
        self.data_fusion_runtime_max_io_events_per_tick = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configures the maximum number of events processed per tick by the tokio DataFusion runtime.</p>
    pub fn set_data_fusion_runtime_max_io_events_per_tick(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_runtime_max_io_events_per_tick = input;
        self
    }
    /// <p>Configures the maximum number of events processed per tick by the tokio DataFusion runtime.</p>
    pub fn get_data_fusion_runtime_max_io_events_per_tick(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_runtime_max_io_events_per_tick
    }
    /// <p>Sets a custom timeout for a thread in the blocking pool of the tokio DataFusion runtime.</p>
    pub fn data_fusion_runtime_thread_keep_alive(mut self, input: crate::types::Duration) -> Self {
        self.data_fusion_runtime_thread_keep_alive = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets a custom timeout for a thread in the blocking pool of the tokio DataFusion runtime.</p>
    pub fn set_data_fusion_runtime_thread_keep_alive(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.data_fusion_runtime_thread_keep_alive = input;
        self
    }
    /// <p>Sets a custom timeout for a thread in the blocking pool of the tokio DataFusion runtime.</p>
    pub fn get_data_fusion_runtime_thread_keep_alive(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.data_fusion_runtime_thread_keep_alive
    }
    /// <p>Sets the thread priority for tokio DataFusion runtime workers.</p>
    /// <p>Default: 10</p>
    pub fn data_fusion_runtime_thread_priority(mut self, input: i32) -> Self {
        self.data_fusion_runtime_thread_priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the thread priority for tokio DataFusion runtime workers.</p>
    /// <p>Default: 10</p>
    pub fn set_data_fusion_runtime_thread_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_runtime_thread_priority = input;
        self
    }
    /// <p>Sets the thread priority for tokio DataFusion runtime workers.</p>
    /// <p>Default: 10</p>
    pub fn get_data_fusion_runtime_thread_priority(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_runtime_thread_priority
    }
    /// <p>When multiple parquet files are required in a sorted way (deduplication for example), specifies the maximum fanout.</p>
    /// <p>Default: 1000</p>
    pub fn data_fusion_max_parquet_fanout(mut self, input: i32) -> Self {
        self.data_fusion_max_parquet_fanout = ::std::option::Option::Some(input);
        self
    }
    /// <p>When multiple parquet files are required in a sorted way (deduplication for example), specifies the maximum fanout.</p>
    /// <p>Default: 1000</p>
    pub fn set_data_fusion_max_parquet_fanout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.data_fusion_max_parquet_fanout = input;
        self
    }
    /// <p>When multiple parquet files are required in a sorted way (deduplication for example), specifies the maximum fanout.</p>
    /// <p>Default: 1000</p>
    pub fn get_data_fusion_max_parquet_fanout(&self) -> &::std::option::Option<i32> {
        &self.data_fusion_max_parquet_fanout
    }
    /// <p>Uses a cached parquet loader when reading parquet files from the object store.</p>
    pub fn data_fusion_use_cached_parquet_loader(mut self, input: bool) -> Self {
        self.data_fusion_use_cached_parquet_loader = ::std::option::Option::Some(input);
        self
    }
    /// <p>Uses a cached parquet loader when reading parquet files from the object store.</p>
    pub fn set_data_fusion_use_cached_parquet_loader(mut self, input: ::std::option::Option<bool>) -> Self {
        self.data_fusion_use_cached_parquet_loader = input;
        self
    }
    /// <p>Uses a cached parquet loader when reading parquet files from the object store.</p>
    pub fn get_data_fusion_use_cached_parquet_loader(&self) -> &::std::option::Option<bool> {
        &self.data_fusion_use_cached_parquet_loader
    }
    /// <p>Provides custom configuration to DataFusion as a comma-separated list of key:value pairs.</p>
    pub fn data_fusion_config(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.data_fusion_config = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Provides custom configuration to DataFusion as a comma-separated list of key:value pairs.</p>
    pub fn set_data_fusion_config(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.data_fusion_config = input;
        self
    }
    /// <p>Provides custom configuration to DataFusion as a comma-separated list of key:value pairs.</p>
    pub fn get_data_fusion_config(&self) -> &::std::option::Option<::std::string::String> {
        &self.data_fusion_config
    }
    /// <p>Specifies the maximum size of HTTP requests.</p>
    /// <p>Default: 10485760</p>
    pub fn max_http_request_size(mut self, input: i64) -> Self {
        self.max_http_request_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the maximum size of HTTP requests.</p>
    /// <p>Default: 10485760</p>
    pub fn set_max_http_request_size(mut self, input: ::std::option::Option<i64>) -> Self {
        self.max_http_request_size = input;
        self
    }
    /// <p>Specifies the maximum size of HTTP requests.</p>
    /// <p>Default: 10485760</p>
    pub fn get_max_http_request_size(&self) -> &::std::option::Option<i64> {
        &self.max_http_request_size
    }
    /// <p>Specifies the threshold for the internal memory buffer. Supports either a percentage (portion of available memory) or absolute value in MB–for example: 70% or 100</p>
    /// <p>Default: 70%</p>
    pub fn force_snapshot_mem_threshold(mut self, input: crate::types::PercentOrAbsoluteLong) -> Self {
        self.force_snapshot_mem_threshold = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the threshold for the internal memory buffer. Supports either a percentage (portion of available memory) or absolute value in MB–for example: 70% or 100</p>
    /// <p>Default: 70%</p>
    pub fn set_force_snapshot_mem_threshold(mut self, input: ::std::option::Option<crate::types::PercentOrAbsoluteLong>) -> Self {
        self.force_snapshot_mem_threshold = input;
        self
    }
    /// <p>Specifies the threshold for the internal memory buffer. Supports either a percentage (portion of available memory) or absolute value in MB–for example: 70% or 100</p>
    /// <p>Default: 70%</p>
    pub fn get_force_snapshot_mem_threshold(&self) -> &::std::option::Option<crate::types::PercentOrAbsoluteLong> {
        &self.force_snapshot_mem_threshold
    }
    /// <p>Defines the number of WAL files to attempt to remove in a snapshot. This, multiplied by the interval, determines how often snapshots are taken.</p>
    /// <p>Default: 600</p>
    pub fn wal_snapshot_size(mut self, input: i32) -> Self {
        self.wal_snapshot_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the number of WAL files to attempt to remove in a snapshot. This, multiplied by the interval, determines how often snapshots are taken.</p>
    /// <p>Default: 600</p>
    pub fn set_wal_snapshot_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.wal_snapshot_size = input;
        self
    }
    /// <p>Defines the number of WAL files to attempt to remove in a snapshot. This, multiplied by the interval, determines how often snapshots are taken.</p>
    /// <p>Default: 600</p>
    pub fn get_wal_snapshot_size(&self) -> &::std::option::Option<i32> {
        &self.wal_snapshot_size
    }
    /// <p>Specifies the maximum number of write requests that can be buffered before a flush must be executed and succeed.</p>
    /// <p>Default: 100000</p>
    pub fn wal_max_write_buffer_size(mut self, input: i32) -> Self {
        self.wal_max_write_buffer_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the maximum number of write requests that can be buffered before a flush must be executed and succeed.</p>
    /// <p>Default: 100000</p>
    pub fn set_wal_max_write_buffer_size(mut self, input: ::std::option::Option<i32>) -> Self {
        self.wal_max_write_buffer_size = input;
        self
    }
    /// <p>Specifies the maximum number of write requests that can be buffered before a flush must be executed and succeed.</p>
    /// <p>Default: 100000</p>
    pub fn get_wal_max_write_buffer_size(&self) -> &::std::option::Option<i32> {
        &self.wal_max_write_buffer_size
    }
    /// <p>Specifies the number of snapshotted WAL files to retain in the object store. Flushing the WAL files does not clear the WAL files immediately; they are deleted when the number of snapshotted WAL files exceeds this number.</p>
    /// <p>Default: 300</p>
    pub fn snapshotted_wal_files_to_keep(mut self, input: i32) -> Self {
        self.snapshotted_wal_files_to_keep = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the number of snapshotted WAL files to retain in the object store. Flushing the WAL files does not clear the WAL files immediately; they are deleted when the number of snapshotted WAL files exceeds this number.</p>
    /// <p>Default: 300</p>
    pub fn set_snapshotted_wal_files_to_keep(mut self, input: ::std::option::Option<i32>) -> Self {
        self.snapshotted_wal_files_to_keep = input;
        self
    }
    /// <p>Specifies the number of snapshotted WAL files to retain in the object store. Flushing the WAL files does not clear the WAL files immediately; they are deleted when the number of snapshotted WAL files exceeds this number.</p>
    /// <p>Default: 300</p>
    pub fn get_snapshotted_wal_files_to_keep(&self) -> &::std::option::Option<i32> {
        &self.snapshotted_wal_files_to_keep
    }
    /// <p>Specifies the interval to prefetch into the Parquet cache during compaction.</p>
    /// <p>Default: 3d</p>
    pub fn preemptive_cache_age(mut self, input: crate::types::Duration) -> Self {
        self.preemptive_cache_age = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the interval to prefetch into the Parquet cache during compaction.</p>
    /// <p>Default: 3d</p>
    pub fn set_preemptive_cache_age(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.preemptive_cache_age = input;
        self
    }
    /// <p>Specifies the interval to prefetch into the Parquet cache during compaction.</p>
    /// <p>Default: 3d</p>
    pub fn get_preemptive_cache_age(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.preemptive_cache_age
    }
    /// <p>Specifies the percentage of entries to prune during a prune operation on the in-memory Parquet cache.</p>
    /// <p>Default: 0.1</p>
    pub fn parquet_mem_cache_prune_percentage(mut self, input: f32) -> Self {
        self.parquet_mem_cache_prune_percentage = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the percentage of entries to prune during a prune operation on the in-memory Parquet cache.</p>
    /// <p>Default: 0.1</p>
    pub fn set_parquet_mem_cache_prune_percentage(mut self, input: ::std::option::Option<f32>) -> Self {
        self.parquet_mem_cache_prune_percentage = input;
        self
    }
    /// <p>Specifies the percentage of entries to prune during a prune operation on the in-memory Parquet cache.</p>
    /// <p>Default: 0.1</p>
    pub fn get_parquet_mem_cache_prune_percentage(&self) -> &::std::option::Option<f32> {
        &self.parquet_mem_cache_prune_percentage
    }
    /// <p>Sets the interval to check if the in-memory Parquet cache needs to be pruned.</p>
    /// <p>Default: 1s</p>
    pub fn parquet_mem_cache_prune_interval(mut self, input: crate::types::Duration) -> Self {
        self.parquet_mem_cache_prune_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the interval to check if the in-memory Parquet cache needs to be pruned.</p>
    /// <p>Default: 1s</p>
    pub fn set_parquet_mem_cache_prune_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.parquet_mem_cache_prune_interval = input;
        self
    }
    /// <p>Sets the interval to check if the in-memory Parquet cache needs to be pruned.</p>
    /// <p>Default: 1s</p>
    pub fn get_parquet_mem_cache_prune_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.parquet_mem_cache_prune_interval
    }
    /// <p>Disables the in-memory Parquet cache. By default, the cache is enabled.</p>
    pub fn disable_parquet_mem_cache(mut self, input: bool) -> Self {
        self.disable_parquet_mem_cache = ::std::option::Option::Some(input);
        self
    }
    /// <p>Disables the in-memory Parquet cache. By default, the cache is enabled.</p>
    pub fn set_disable_parquet_mem_cache(mut self, input: ::std::option::Option<bool>) -> Self {
        self.disable_parquet_mem_cache = input;
        self
    }
    /// <p>Disables the in-memory Parquet cache. By default, the cache is enabled.</p>
    pub fn get_disable_parquet_mem_cache(&self) -> &::std::option::Option<bool> {
        &self.disable_parquet_mem_cache
    }
    /// <p>Specifies the time window for caching recent Parquet files in memory.</p>
    /// <p>Default: 5h</p>
    pub fn parquet_mem_cache_query_path_duration(mut self, input: crate::types::Duration) -> Self {
        self.parquet_mem_cache_query_path_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the time window for caching recent Parquet files in memory.</p>
    /// <p>Default: 5h</p>
    pub fn set_parquet_mem_cache_query_path_duration(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.parquet_mem_cache_query_path_duration = input;
        self
    }
    /// <p>Specifies the time window for caching recent Parquet files in memory.</p>
    /// <p>Default: 5h</p>
    pub fn get_parquet_mem_cache_query_path_duration(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.parquet_mem_cache_query_path_duration
    }
    /// <p>Specifies the interval to evict expired entries from the Last-N-Value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn last_cache_eviction_interval(mut self, input: crate::types::Duration) -> Self {
        self.last_cache_eviction_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the interval to evict expired entries from the Last-N-Value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn set_last_cache_eviction_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.last_cache_eviction_interval = input;
        self
    }
    /// <p>Specifies the interval to evict expired entries from the Last-N-Value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn get_last_cache_eviction_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.last_cache_eviction_interval
    }
    /// <p>Specifies the interval to evict expired entries from the distinct value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn distinct_cache_eviction_interval(mut self, input: crate::types::Duration) -> Self {
        self.distinct_cache_eviction_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the interval to evict expired entries from the distinct value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn set_distinct_cache_eviction_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.distinct_cache_eviction_interval = input;
        self
    }
    /// <p>Specifies the interval to evict expired entries from the distinct value cache, expressed as a human-readable duration–for example: 20s, 1m, 1h.</p>
    /// <p>Default: 10s</p>
    pub fn get_distinct_cache_eviction_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.distinct_cache_eviction_interval
    }
    /// <p>Specifies the duration that Parquet files are arranged into. Data timestamps land each row into a file of this duration. Supported durations are 1m, 5m, and 10m. These files are known as “generation 1” files, which the compactor can merge into larger generations.</p>
    /// <p>Default: 10m</p>
    pub fn gen1_duration(mut self, input: crate::types::Duration) -> Self {
        self.gen1_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the duration that Parquet files are arranged into. Data timestamps land each row into a file of this duration. Supported durations are 1m, 5m, and 10m. These files are known as “generation 1” files, which the compactor can merge into larger generations.</p>
    /// <p>Default: 10m</p>
    pub fn set_gen1_duration(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.gen1_duration = input;
        self
    }
    /// <p>Specifies the duration that Parquet files are arranged into. Data timestamps land each row into a file of this duration. Supported durations are 1m, 5m, and 10m. These files are known as “generation 1” files, which the compactor can merge into larger generations.</p>
    /// <p>Default: 10m</p>
    pub fn get_gen1_duration(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.gen1_duration
    }
    /// <p>Specifies the size of memory pool used during query execution. Can be given as absolute value in bytes or as a percentage of the total available memory–for example: 8000000000 or 10%.</p>
    /// <p>Default: 20%</p>
    pub fn exec_mem_pool_bytes(mut self, input: crate::types::PercentOrAbsoluteLong) -> Self {
        self.exec_mem_pool_bytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the size of memory pool used during query execution. Can be given as absolute value in bytes or as a percentage of the total available memory–for example: 8000000000 or 10%.</p>
    /// <p>Default: 20%</p>
    pub fn set_exec_mem_pool_bytes(mut self, input: ::std::option::Option<crate::types::PercentOrAbsoluteLong>) -> Self {
        self.exec_mem_pool_bytes = input;
        self
    }
    /// <p>Specifies the size of memory pool used during query execution. Can be given as absolute value in bytes or as a percentage of the total available memory–for example: 8000000000 or 10%.</p>
    /// <p>Default: 20%</p>
    pub fn get_exec_mem_pool_bytes(&self) -> &::std::option::Option<crate::types::PercentOrAbsoluteLong> {
        &self.exec_mem_pool_bytes
    }
    /// <p>Specifies the size of the in-memory Parquet cache in megabytes or percentage of total available memory.</p>
    /// <p>Default: 20%</p>
    pub fn parquet_mem_cache_size(mut self, input: crate::types::PercentOrAbsoluteLong) -> Self {
        self.parquet_mem_cache_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the size of the in-memory Parquet cache in megabytes or percentage of total available memory.</p>
    /// <p>Default: 20%</p>
    pub fn set_parquet_mem_cache_size(mut self, input: ::std::option::Option<crate::types::PercentOrAbsoluteLong>) -> Self {
        self.parquet_mem_cache_size = input;
        self
    }
    /// <p>Specifies the size of the in-memory Parquet cache in megabytes or percentage of total available memory.</p>
    /// <p>Default: 20%</p>
    pub fn get_parquet_mem_cache_size(&self) -> &::std::option::Option<crate::types::PercentOrAbsoluteLong> {
        &self.parquet_mem_cache_size
    }
    /// <p>Determines whether WAL replay should fail when encountering errors.</p>
    /// <p>Default: false</p>
    pub fn wal_replay_fail_on_error(mut self, input: bool) -> Self {
        self.wal_replay_fail_on_error = ::std::option::Option::Some(input);
        self
    }
    /// <p>Determines whether WAL replay should fail when encountering errors.</p>
    /// <p>Default: false</p>
    pub fn set_wal_replay_fail_on_error(mut self, input: ::std::option::Option<bool>) -> Self {
        self.wal_replay_fail_on_error = input;
        self
    }
    /// <p>Determines whether WAL replay should fail when encountering errors.</p>
    /// <p>Default: false</p>
    pub fn get_wal_replay_fail_on_error(&self) -> &::std::option::Option<bool> {
        &self.wal_replay_fail_on_error
    }
    /// <p>Concurrency limit during WAL replay. Setting this number too high can lead to OOM. The default is dynamically determined.</p>
    /// <p>Default: max(num_cpus, 10)</p>
    pub fn wal_replay_concurrency_limit(mut self, input: i32) -> Self {
        self.wal_replay_concurrency_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Concurrency limit during WAL replay. Setting this number too high can lead to OOM. The default is dynamically determined.</p>
    /// <p>Default: max(num_cpus, 10)</p>
    pub fn set_wal_replay_concurrency_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.wal_replay_concurrency_limit = input;
        self
    }
    /// <p>Concurrency limit during WAL replay. Setting this number too high can lead to OOM. The default is dynamically determined.</p>
    /// <p>Default: max(num_cpus, 10)</p>
    pub fn get_wal_replay_concurrency_limit(&self) -> &::std::option::Option<i32> {
        &self.wal_replay_concurrency_limit
    }
    /// <p>Specifies the maximum number of entries in the table index cache.</p>
    /// <p>Default: 1000</p>
    pub fn table_index_cache_max_entries(mut self, input: i32) -> Self {
        self.table_index_cache_max_entries = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the maximum number of entries in the table index cache.</p>
    /// <p>Default: 1000</p>
    pub fn set_table_index_cache_max_entries(mut self, input: ::std::option::Option<i32>) -> Self {
        self.table_index_cache_max_entries = input;
        self
    }
    /// <p>Specifies the maximum number of entries in the table index cache.</p>
    /// <p>Default: 1000</p>
    pub fn get_table_index_cache_max_entries(&self) -> &::std::option::Option<i32> {
        &self.table_index_cache_max_entries
    }
    /// <p>Limits the concurrency level for table index cache operations.</p>
    /// <p>Default: 8</p>
    pub fn table_index_cache_concurrency_limit(mut self, input: i32) -> Self {
        self.table_index_cache_concurrency_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Limits the concurrency level for table index cache operations.</p>
    /// <p>Default: 8</p>
    pub fn set_table_index_cache_concurrency_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.table_index_cache_concurrency_limit = input;
        self
    }
    /// <p>Limits the concurrency level for table index cache operations.</p>
    /// <p>Default: 8</p>
    pub fn get_table_index_cache_concurrency_limit(&self) -> &::std::option::Option<i32> {
        &self.table_index_cache_concurrency_limit
    }
    /// <p>Specifies how far back to look when creating generation 1 Parquet files.</p>
    /// <p>Default: 24h</p>
    pub fn gen1_lookback_duration(mut self, input: crate::types::Duration) -> Self {
        self.gen1_lookback_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies how far back to look when creating generation 1 Parquet files.</p>
    /// <p>Default: 24h</p>
    pub fn set_gen1_lookback_duration(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.gen1_lookback_duration = input;
        self
    }
    /// <p>Specifies how far back to look when creating generation 1 Parquet files.</p>
    /// <p>Default: 24h</p>
    pub fn get_gen1_lookback_duration(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.gen1_lookback_duration
    }
    /// <p>The interval at which retention policies are checked and enforced. Enter as a human-readable time–for example: 30m or 1h.</p>
    /// <p>Default: 30m</p>
    pub fn retention_check_interval(mut self, input: crate::types::Duration) -> Self {
        self.retention_check_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>The interval at which retention policies are checked and enforced. Enter as a human-readable time–for example: 30m or 1h.</p>
    /// <p>Default: 30m</p>
    pub fn set_retention_check_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.retention_check_interval = input;
        self
    }
    /// <p>The interval at which retention policies are checked and enforced. Enter as a human-readable time–for example: 30m or 1h.</p>
    /// <p>Default: 30m</p>
    pub fn get_retention_check_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.retention_check_interval
    }
    /// <p>Specifies the grace period before permanently deleting data.</p>
    /// <p>Default: 24h</p>
    pub fn delete_grace_period(mut self, input: crate::types::Duration) -> Self {
        self.delete_grace_period = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the grace period before permanently deleting data.</p>
    /// <p>Default: 24h</p>
    pub fn set_delete_grace_period(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.delete_grace_period = input;
        self
    }
    /// <p>Specifies the grace period before permanently deleting data.</p>
    /// <p>Default: 24h</p>
    pub fn get_delete_grace_period(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.delete_grace_period
    }
    /// <p>Sets the default duration for hard deletion of data.</p>
    /// <p>Default: 90d</p>
    pub fn hard_delete_default_duration(mut self, input: crate::types::Duration) -> Self {
        self.hard_delete_default_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the default duration for hard deletion of data.</p>
    /// <p>Default: 90d</p>
    pub fn set_hard_delete_default_duration(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.hard_delete_default_duration = input;
        self
    }
    /// <p>Sets the default duration for hard deletion of data.</p>
    /// <p>Default: 90d</p>
    pub fn get_hard_delete_default_duration(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.hard_delete_default_duration
    }
    /// <p>Specifies number of instances in the DbCluster which can both ingest and query.</p>
    /// This field is required.
    pub fn ingest_query_instances(mut self, input: i32) -> Self {
        self.ingest_query_instances = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies number of instances in the DbCluster which can both ingest and query.</p>
    pub fn set_ingest_query_instances(mut self, input: ::std::option::Option<i32>) -> Self {
        self.ingest_query_instances = input;
        self
    }
    /// <p>Specifies number of instances in the DbCluster which can both ingest and query.</p>
    pub fn get_ingest_query_instances(&self) -> &::std::option::Option<i32> {
        &self.ingest_query_instances
    }
    /// <p>Specifies number of instances in the DbCluster which can only query.</p>
    /// This field is required.
    pub fn query_only_instances(mut self, input: i32) -> Self {
        self.query_only_instances = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies number of instances in the DbCluster which can only query.</p>
    pub fn set_query_only_instances(mut self, input: ::std::option::Option<i32>) -> Self {
        self.query_only_instances = input;
        self
    }
    /// <p>Specifies number of instances in the DbCluster which can only query.</p>
    pub fn get_query_only_instances(&self) -> &::std::option::Option<i32> {
        &self.query_only_instances
    }
    /// <p>Specifies if the compactor instance should be a standalone instance or not.</p>
    /// This field is required.
    pub fn dedicated_compactor(mut self, input: bool) -> Self {
        self.dedicated_compactor = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies if the compactor instance should be a standalone instance or not.</p>
    pub fn set_dedicated_compactor(mut self, input: ::std::option::Option<bool>) -> Self {
        self.dedicated_compactor = input;
        self
    }
    /// <p>Specifies if the compactor instance should be a standalone instance or not.</p>
    pub fn get_dedicated_compactor(&self) -> &::std::option::Option<bool> {
        &self.dedicated_compactor
    }
    /// <p>Specifies the soft limit for the number of rows per file that the compactor writes. The compactor may write more rows than this limit.</p>
    /// <p>Default: 1000000</p>
    pub fn compaction_row_limit(mut self, input: i32) -> Self {
        self.compaction_row_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the soft limit for the number of rows per file that the compactor writes. The compactor may write more rows than this limit.</p>
    /// <p>Default: 1000000</p>
    pub fn set_compaction_row_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compaction_row_limit = input;
        self
    }
    /// <p>Specifies the soft limit for the number of rows per file that the compactor writes. The compactor may write more rows than this limit.</p>
    /// <p>Default: 1000000</p>
    pub fn get_compaction_row_limit(&self) -> &::std::option::Option<i32> {
        &self.compaction_row_limit
    }
    /// <p>Sets the maximum number of files included in any compaction plan.</p>
    /// <p>Default: 500</p>
    pub fn compaction_max_num_files_per_plan(mut self, input: i32) -> Self {
        self.compaction_max_num_files_per_plan = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the maximum number of files included in any compaction plan.</p>
    /// <p>Default: 500</p>
    pub fn set_compaction_max_num_files_per_plan(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compaction_max_num_files_per_plan = input;
        self
    }
    /// <p>Sets the maximum number of files included in any compaction plan.</p>
    /// <p>Default: 500</p>
    pub fn get_compaction_max_num_files_per_plan(&self) -> &::std::option::Option<i32> {
        &self.compaction_max_num_files_per_plan
    }
    /// <p>Specifies the duration of the first level of compaction (gen2). Later levels of compaction are multiples of this duration. This value should be equal to or greater than the gen1 duration.</p>
    /// <p>Default: 20m</p>
    pub fn compaction_gen2_duration(mut self, input: crate::types::Duration) -> Self {
        self.compaction_gen2_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the duration of the first level of compaction (gen2). Later levels of compaction are multiples of this duration. This value should be equal to or greater than the gen1 duration.</p>
    /// <p>Default: 20m</p>
    pub fn set_compaction_gen2_duration(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.compaction_gen2_duration = input;
        self
    }
    /// <p>Specifies the duration of the first level of compaction (gen2). Later levels of compaction are multiples of this duration. This value should be equal to or greater than the gen1 duration.</p>
    /// <p>Default: 20m</p>
    pub fn get_compaction_gen2_duration(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.compaction_gen2_duration
    }
    /// <p>Specifies a comma-separated list of multiples defining the duration of each level of compaction. The number of elements in the list determines the number of compaction levels. The first element specifies the duration of the first level (gen3); subsequent levels are multiples of the previous level.</p>
    /// <p>Default: 3,4,6,5</p>
    pub fn compaction_multipliers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.compaction_multipliers = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies a comma-separated list of multiples defining the duration of each level of compaction. The number of elements in the list determines the number of compaction levels. The first element specifies the duration of the first level (gen3); subsequent levels are multiples of the previous level.</p>
    /// <p>Default: 3,4,6,5</p>
    pub fn set_compaction_multipliers(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.compaction_multipliers = input;
        self
    }
    /// <p>Specifies a comma-separated list of multiples defining the duration of each level of compaction. The number of elements in the list determines the number of compaction levels. The first element specifies the duration of the first level (gen3); subsequent levels are multiples of the previous level.</p>
    /// <p>Default: 3,4,6,5</p>
    pub fn get_compaction_multipliers(&self) -> &::std::option::Option<::std::string::String> {
        &self.compaction_multipliers
    }
    /// <p>Specifies the amount of time that the compactor waits after finishing a compaction run to delete files marked as needing deletion during that compaction run.</p>
    /// <p>Default: 10m</p>
    pub fn compaction_cleanup_wait(mut self, input: crate::types::Duration) -> Self {
        self.compaction_cleanup_wait = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the amount of time that the compactor waits after finishing a compaction run to delete files marked as needing deletion during that compaction run.</p>
    /// <p>Default: 10m</p>
    pub fn set_compaction_cleanup_wait(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.compaction_cleanup_wait = input;
        self
    }
    /// <p>Specifies the amount of time that the compactor waits after finishing a compaction run to delete files marked as needing deletion during that compaction run.</p>
    /// <p>Default: 10m</p>
    pub fn get_compaction_cleanup_wait(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.compaction_cleanup_wait
    }
    /// <p>Specifies how often the compactor checks for new compaction work to perform.</p>
    /// <p>Default: 10s</p>
    pub fn compaction_check_interval(mut self, input: crate::types::Duration) -> Self {
        self.compaction_check_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies how often the compactor checks for new compaction work to perform.</p>
    /// <p>Default: 10s</p>
    pub fn set_compaction_check_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.compaction_check_interval = input;
        self
    }
    /// <p>Specifies how often the compactor checks for new compaction work to perform.</p>
    /// <p>Default: 10s</p>
    pub fn get_compaction_check_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.compaction_check_interval
    }
    /// <p>Disables populating the last-N-value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn last_value_cache_disable_from_history(mut self, input: bool) -> Self {
        self.last_value_cache_disable_from_history = ::std::option::Option::Some(input);
        self
    }
    /// <p>Disables populating the last-N-value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn set_last_value_cache_disable_from_history(mut self, input: ::std::option::Option<bool>) -> Self {
        self.last_value_cache_disable_from_history = input;
        self
    }
    /// <p>Disables populating the last-N-value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn get_last_value_cache_disable_from_history(&self) -> &::std::option::Option<bool> {
        &self.last_value_cache_disable_from_history
    }
    /// <p>Disables populating the distinct value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn distinct_value_cache_disable_from_history(mut self, input: bool) -> Self {
        self.distinct_value_cache_disable_from_history = ::std::option::Option::Some(input);
        self
    }
    /// <p>Disables populating the distinct value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn set_distinct_value_cache_disable_from_history(mut self, input: ::std::option::Option<bool>) -> Self {
        self.distinct_value_cache_disable_from_history = input;
        self
    }
    /// <p>Disables populating the distinct value cache from historical data. If disabled, the cache is still populated with data from the write-ahead log (WAL).</p>
    pub fn get_distinct_value_cache_disable_from_history(&self) -> &::std::option::Option<bool> {
        &self.distinct_value_cache_disable_from_history
    }
    /// <p>Specifies the interval at which data replication occurs between cluster nodes.</p>
    /// <p>Default: 250ms</p>
    pub fn replication_interval(mut self, input: crate::types::Duration) -> Self {
        self.replication_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the interval at which data replication occurs between cluster nodes.</p>
    /// <p>Default: 250ms</p>
    pub fn set_replication_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.replication_interval = input;
        self
    }
    /// <p>Specifies the interval at which data replication occurs between cluster nodes.</p>
    /// <p>Default: 250ms</p>
    pub fn get_replication_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.replication_interval
    }
    /// <p>Defines how often the catalog synchronizes across cluster nodes.</p>
    /// <p>Default: 10s</p>
    pub fn catalog_sync_interval(mut self, input: crate::types::Duration) -> Self {
        self.catalog_sync_interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines how often the catalog synchronizes across cluster nodes.</p>
    /// <p>Default: 10s</p>
    pub fn set_catalog_sync_interval(mut self, input: ::std::option::Option<crate::types::Duration>) -> Self {
        self.catalog_sync_interval = input;
        self
    }
    /// <p>Defines how often the catalog synchronizes across cluster nodes.</p>
    /// <p>Default: 10s</p>
    pub fn get_catalog_sync_interval(&self) -> &::std::option::Option<crate::types::Duration> {
        &self.catalog_sync_interval
    }
    /// Consumes the builder and constructs a [`InfluxDBv3EnterpriseParameters`](crate::types::InfluxDBv3EnterpriseParameters).
    /// This method will fail if any of the following fields are not set:
    /// - [`ingest_query_instances`](crate::types::builders::InfluxDBv3EnterpriseParametersBuilder::ingest_query_instances)
    /// - [`query_only_instances`](crate::types::builders::InfluxDBv3EnterpriseParametersBuilder::query_only_instances)
    /// - [`dedicated_compactor`](crate::types::builders::InfluxDBv3EnterpriseParametersBuilder::dedicated_compactor)
    pub fn build(self) -> ::std::result::Result<crate::types::InfluxDBv3EnterpriseParameters, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::InfluxDBv3EnterpriseParameters {
            query_file_limit: self.query_file_limit,
            query_log_size: self.query_log_size,
            log_filter: self.log_filter,
            log_format: self.log_format,
            data_fusion_num_threads: self.data_fusion_num_threads,
            data_fusion_runtime_type: self.data_fusion_runtime_type,
            data_fusion_runtime_disable_lifo_slot: self.data_fusion_runtime_disable_lifo_slot,
            data_fusion_runtime_event_interval: self.data_fusion_runtime_event_interval,
            data_fusion_runtime_global_queue_interval: self.data_fusion_runtime_global_queue_interval,
            data_fusion_runtime_max_blocking_threads: self.data_fusion_runtime_max_blocking_threads,
            data_fusion_runtime_max_io_events_per_tick: self.data_fusion_runtime_max_io_events_per_tick,
            data_fusion_runtime_thread_keep_alive: self.data_fusion_runtime_thread_keep_alive,
            data_fusion_runtime_thread_priority: self.data_fusion_runtime_thread_priority,
            data_fusion_max_parquet_fanout: self.data_fusion_max_parquet_fanout,
            data_fusion_use_cached_parquet_loader: self.data_fusion_use_cached_parquet_loader,
            data_fusion_config: self.data_fusion_config,
            max_http_request_size: self.max_http_request_size,
            force_snapshot_mem_threshold: self.force_snapshot_mem_threshold,
            wal_snapshot_size: self.wal_snapshot_size,
            wal_max_write_buffer_size: self.wal_max_write_buffer_size,
            snapshotted_wal_files_to_keep: self.snapshotted_wal_files_to_keep,
            preemptive_cache_age: self.preemptive_cache_age,
            parquet_mem_cache_prune_percentage: self.parquet_mem_cache_prune_percentage,
            parquet_mem_cache_prune_interval: self.parquet_mem_cache_prune_interval,
            disable_parquet_mem_cache: self.disable_parquet_mem_cache,
            parquet_mem_cache_query_path_duration: self.parquet_mem_cache_query_path_duration,
            last_cache_eviction_interval: self.last_cache_eviction_interval,
            distinct_cache_eviction_interval: self.distinct_cache_eviction_interval,
            gen1_duration: self.gen1_duration,
            exec_mem_pool_bytes: self.exec_mem_pool_bytes,
            parquet_mem_cache_size: self.parquet_mem_cache_size,
            wal_replay_fail_on_error: self.wal_replay_fail_on_error,
            wal_replay_concurrency_limit: self.wal_replay_concurrency_limit,
            table_index_cache_max_entries: self.table_index_cache_max_entries,
            table_index_cache_concurrency_limit: self.table_index_cache_concurrency_limit,
            gen1_lookback_duration: self.gen1_lookback_duration,
            retention_check_interval: self.retention_check_interval,
            delete_grace_period: self.delete_grace_period,
            hard_delete_default_duration: self.hard_delete_default_duration,
            ingest_query_instances: self.ingest_query_instances.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "ingest_query_instances",
                    "ingest_query_instances was not specified but it is required when building InfluxDBv3EnterpriseParameters",
                )
            })?,
            query_only_instances: self.query_only_instances.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "query_only_instances",
                    "query_only_instances was not specified but it is required when building InfluxDBv3EnterpriseParameters",
                )
            })?,
            dedicated_compactor: self.dedicated_compactor.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "dedicated_compactor",
                    "dedicated_compactor was not specified but it is required when building InfluxDBv3EnterpriseParameters",
                )
            })?,
            compaction_row_limit: self.compaction_row_limit,
            compaction_max_num_files_per_plan: self.compaction_max_num_files_per_plan,
            compaction_gen2_duration: self.compaction_gen2_duration,
            compaction_multipliers: self.compaction_multipliers,
            compaction_cleanup_wait: self.compaction_cleanup_wait,
            compaction_check_interval: self.compaction_check_interval,
            last_value_cache_disable_from_history: self.last_value_cache_disable_from_history,
            distinct_value_cache_disable_from_history: self.distinct_value_cache_disable_from_history,
            replication_interval: self.replication_interval,
            catalog_sync_interval: self.catalog_sync_interval,
        })
    }
}
