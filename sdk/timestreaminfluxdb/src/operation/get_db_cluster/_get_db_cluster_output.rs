// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetDbClusterOutput {
    /// <p>Service-generated unique identifier of the DB cluster to retrieve.</p>
    pub id: ::std::string::String,
    /// <p>Customer-supplied name of the Timestream for InfluxDB cluster.</p>
    pub name: ::std::string::String,
    /// <p>The Amazon Resource Name (ARN) of the DB cluster.</p>
    pub arn: ::std::string::String,
    /// <p>The status of the DB cluster.</p>
    pub status: ::std::option::Option<crate::types::ClusterStatus>,
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for write and read operations.</p>
    pub endpoint: ::std::option::Option<::std::string::String>,
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for read-only operations.</p>
    pub reader_endpoint: ::std::option::Option<::std::string::String>,
    /// <p>The port number on which InfluxDB accepts connections.</p>
    pub port: ::std::option::Option<i32>,
    /// <p>Deployment type of the DB cluster.</p>
    pub deployment_type: ::std::option::Option<crate::types::ClusterDeploymentType>,
    /// <p>The Timestream for InfluxDB instance type that InfluxDB runs on.</p>
    pub db_instance_type: ::std::option::Option<crate::types::DbInstanceType>,
    /// <p>Specifies whether the network type of the Timestream for InfluxDB cluster is IPv4, which can communicate over IPv4 protocol only, or DUAL, which can communicate over both IPv4 and IPv6 protocols.</p>
    pub network_type: ::std::option::Option<crate::types::NetworkType>,
    /// <p>The Timestream for InfluxDB DB storage type that InfluxDB stores data on.</p>
    pub db_storage_type: ::std::option::Option<crate::types::DbStorageType>,
    /// <p>The amount of storage allocated for your DB storage type (in gibibytes).</p>
    pub allocated_storage: ::std::option::Option<i32>,
    /// <p>The engine type of your DB cluster.</p>
    pub engine_type: ::std::option::Option<crate::types::EngineType>,
    /// <p>Indicates if the DB cluster has a public IP to facilitate access from outside the VPC.</p>
    pub publicly_accessible: ::std::option::Option<bool>,
    /// <p>The ID of the DB parameter group assigned to your DB cluster.</p>
    pub db_parameter_group_identifier: ::std::option::Option<::std::string::String>,
    /// <p>Configuration for sending InfluxDB engine logs to send to specified S3 bucket.</p>
    pub log_delivery_configuration: ::std::option::Option<crate::types::LogDeliveryConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.</p>
    pub influx_auth_parameters_secret_arn: ::std::option::Option<::std::string::String>,
    /// <p>A list of VPC subnet IDs associated with the DB cluster.</p>
    pub vpc_subnet_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A list of VPC security group IDs associated with the DB cluster.</p>
    pub vpc_security_group_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The configured failover mode for the DB cluster.</p>
    pub failover_mode: ::std::option::Option<crate::types::FailoverMode>,
    _request_id: Option<String>,
}
impl GetDbClusterOutput {
    /// <p>Service-generated unique identifier of the DB cluster to retrieve.</p>
    pub fn id(&self) -> &str {
        use std::ops::Deref;
        self.id.deref()
    }
    /// <p>Customer-supplied name of the Timestream for InfluxDB cluster.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the DB cluster.</p>
    pub fn arn(&self) -> &str {
        use std::ops::Deref;
        self.arn.deref()
    }
    /// <p>The status of the DB cluster.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::ClusterStatus> {
        self.status.as_ref()
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for write and read operations.</p>
    pub fn endpoint(&self) -> ::std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for read-only operations.</p>
    pub fn reader_endpoint(&self) -> ::std::option::Option<&str> {
        self.reader_endpoint.as_deref()
    }
    /// <p>The port number on which InfluxDB accepts connections.</p>
    pub fn port(&self) -> ::std::option::Option<i32> {
        self.port
    }
    /// <p>Deployment type of the DB cluster.</p>
    pub fn deployment_type(&self) -> ::std::option::Option<&crate::types::ClusterDeploymentType> {
        self.deployment_type.as_ref()
    }
    /// <p>The Timestream for InfluxDB instance type that InfluxDB runs on.</p>
    pub fn db_instance_type(&self) -> ::std::option::Option<&crate::types::DbInstanceType> {
        self.db_instance_type.as_ref()
    }
    /// <p>Specifies whether the network type of the Timestream for InfluxDB cluster is IPv4, which can communicate over IPv4 protocol only, or DUAL, which can communicate over both IPv4 and IPv6 protocols.</p>
    pub fn network_type(&self) -> ::std::option::Option<&crate::types::NetworkType> {
        self.network_type.as_ref()
    }
    /// <p>The Timestream for InfluxDB DB storage type that InfluxDB stores data on.</p>
    pub fn db_storage_type(&self) -> ::std::option::Option<&crate::types::DbStorageType> {
        self.db_storage_type.as_ref()
    }
    /// <p>The amount of storage allocated for your DB storage type (in gibibytes).</p>
    pub fn allocated_storage(&self) -> ::std::option::Option<i32> {
        self.allocated_storage
    }
    /// <p>The engine type of your DB cluster.</p>
    pub fn engine_type(&self) -> ::std::option::Option<&crate::types::EngineType> {
        self.engine_type.as_ref()
    }
    /// <p>Indicates if the DB cluster has a public IP to facilitate access from outside the VPC.</p>
    pub fn publicly_accessible(&self) -> ::std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The ID of the DB parameter group assigned to your DB cluster.</p>
    pub fn db_parameter_group_identifier(&self) -> ::std::option::Option<&str> {
        self.db_parameter_group_identifier.as_deref()
    }
    /// <p>Configuration for sending InfluxDB engine logs to send to specified S3 bucket.</p>
    pub fn log_delivery_configuration(&self) -> ::std::option::Option<&crate::types::LogDeliveryConfiguration> {
        self.log_delivery_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.</p>
    pub fn influx_auth_parameters_secret_arn(&self) -> ::std::option::Option<&str> {
        self.influx_auth_parameters_secret_arn.as_deref()
    }
    /// <p>A list of VPC subnet IDs associated with the DB cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.vpc_subnet_ids.is_none()`.
    pub fn vpc_subnet_ids(&self) -> &[::std::string::String] {
        self.vpc_subnet_ids.as_deref().unwrap_or_default()
    }
    /// <p>A list of VPC security group IDs associated with the DB cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.vpc_security_group_ids.is_none()`.
    pub fn vpc_security_group_ids(&self) -> &[::std::string::String] {
        self.vpc_security_group_ids.as_deref().unwrap_or_default()
    }
    /// <p>The configured failover mode for the DB cluster.</p>
    pub fn failover_mode(&self) -> ::std::option::Option<&crate::types::FailoverMode> {
        self.failover_mode.as_ref()
    }
}
impl ::aws_types::request_id::RequestId for GetDbClusterOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetDbClusterOutput {
    /// Creates a new builder-style object to manufacture [`GetDbClusterOutput`](crate::operation::get_db_cluster::GetDbClusterOutput).
    pub fn builder() -> crate::operation::get_db_cluster::builders::GetDbClusterOutputBuilder {
        crate::operation::get_db_cluster::builders::GetDbClusterOutputBuilder::default()
    }
}

/// A builder for [`GetDbClusterOutput`](crate::operation::get_db_cluster::GetDbClusterOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GetDbClusterOutputBuilder {
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::ClusterStatus>,
    pub(crate) endpoint: ::std::option::Option<::std::string::String>,
    pub(crate) reader_endpoint: ::std::option::Option<::std::string::String>,
    pub(crate) port: ::std::option::Option<i32>,
    pub(crate) deployment_type: ::std::option::Option<crate::types::ClusterDeploymentType>,
    pub(crate) db_instance_type: ::std::option::Option<crate::types::DbInstanceType>,
    pub(crate) network_type: ::std::option::Option<crate::types::NetworkType>,
    pub(crate) db_storage_type: ::std::option::Option<crate::types::DbStorageType>,
    pub(crate) allocated_storage: ::std::option::Option<i32>,
    pub(crate) engine_type: ::std::option::Option<crate::types::EngineType>,
    pub(crate) publicly_accessible: ::std::option::Option<bool>,
    pub(crate) db_parameter_group_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) log_delivery_configuration: ::std::option::Option<crate::types::LogDeliveryConfiguration>,
    pub(crate) influx_auth_parameters_secret_arn: ::std::option::Option<::std::string::String>,
    pub(crate) vpc_subnet_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) vpc_security_group_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) failover_mode: ::std::option::Option<crate::types::FailoverMode>,
    _request_id: Option<String>,
}
impl GetDbClusterOutputBuilder {
    /// <p>Service-generated unique identifier of the DB cluster to retrieve.</p>
    /// This field is required.
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Service-generated unique identifier of the DB cluster to retrieve.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>Service-generated unique identifier of the DB cluster to retrieve.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>Customer-supplied name of the Timestream for InfluxDB cluster.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Customer-supplied name of the Timestream for InfluxDB cluster.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>Customer-supplied name of the Timestream for InfluxDB cluster.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The Amazon Resource Name (ARN) of the DB cluster.</p>
    /// This field is required.
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the DB cluster.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the DB cluster.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The status of the DB cluster.</p>
    pub fn status(mut self, input: crate::types::ClusterStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the DB cluster.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::ClusterStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the DB cluster.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::ClusterStatus> {
        &self.status
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for write and read operations.</p>
    pub fn endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for write and read operations.</p>
    pub fn set_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.endpoint = input;
        self
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for write and read operations.</p>
    pub fn get_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.endpoint
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for read-only operations.</p>
    pub fn reader_endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.reader_endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for read-only operations.</p>
    pub fn set_reader_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.reader_endpoint = input;
        self
    }
    /// <p>The endpoint used to connect to the Timestream for InfluxDB cluster for read-only operations.</p>
    pub fn get_reader_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.reader_endpoint
    }
    /// <p>The port number on which InfluxDB accepts connections.</p>
    pub fn port(mut self, input: i32) -> Self {
        self.port = ::std::option::Option::Some(input);
        self
    }
    /// <p>The port number on which InfluxDB accepts connections.</p>
    pub fn set_port(mut self, input: ::std::option::Option<i32>) -> Self {
        self.port = input;
        self
    }
    /// <p>The port number on which InfluxDB accepts connections.</p>
    pub fn get_port(&self) -> &::std::option::Option<i32> {
        &self.port
    }
    /// <p>Deployment type of the DB cluster.</p>
    pub fn deployment_type(mut self, input: crate::types::ClusterDeploymentType) -> Self {
        self.deployment_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Deployment type of the DB cluster.</p>
    pub fn set_deployment_type(mut self, input: ::std::option::Option<crate::types::ClusterDeploymentType>) -> Self {
        self.deployment_type = input;
        self
    }
    /// <p>Deployment type of the DB cluster.</p>
    pub fn get_deployment_type(&self) -> &::std::option::Option<crate::types::ClusterDeploymentType> {
        &self.deployment_type
    }
    /// <p>The Timestream for InfluxDB instance type that InfluxDB runs on.</p>
    pub fn db_instance_type(mut self, input: crate::types::DbInstanceType) -> Self {
        self.db_instance_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Timestream for InfluxDB instance type that InfluxDB runs on.</p>
    pub fn set_db_instance_type(mut self, input: ::std::option::Option<crate::types::DbInstanceType>) -> Self {
        self.db_instance_type = input;
        self
    }
    /// <p>The Timestream for InfluxDB instance type that InfluxDB runs on.</p>
    pub fn get_db_instance_type(&self) -> &::std::option::Option<crate::types::DbInstanceType> {
        &self.db_instance_type
    }
    /// <p>Specifies whether the network type of the Timestream for InfluxDB cluster is IPv4, which can communicate over IPv4 protocol only, or DUAL, which can communicate over both IPv4 and IPv6 protocols.</p>
    pub fn network_type(mut self, input: crate::types::NetworkType) -> Self {
        self.network_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the network type of the Timestream for InfluxDB cluster is IPv4, which can communicate over IPv4 protocol only, or DUAL, which can communicate over both IPv4 and IPv6 protocols.</p>
    pub fn set_network_type(mut self, input: ::std::option::Option<crate::types::NetworkType>) -> Self {
        self.network_type = input;
        self
    }
    /// <p>Specifies whether the network type of the Timestream for InfluxDB cluster is IPv4, which can communicate over IPv4 protocol only, or DUAL, which can communicate over both IPv4 and IPv6 protocols.</p>
    pub fn get_network_type(&self) -> &::std::option::Option<crate::types::NetworkType> {
        &self.network_type
    }
    /// <p>The Timestream for InfluxDB DB storage type that InfluxDB stores data on.</p>
    pub fn db_storage_type(mut self, input: crate::types::DbStorageType) -> Self {
        self.db_storage_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Timestream for InfluxDB DB storage type that InfluxDB stores data on.</p>
    pub fn set_db_storage_type(mut self, input: ::std::option::Option<crate::types::DbStorageType>) -> Self {
        self.db_storage_type = input;
        self
    }
    /// <p>The Timestream for InfluxDB DB storage type that InfluxDB stores data on.</p>
    pub fn get_db_storage_type(&self) -> &::std::option::Option<crate::types::DbStorageType> {
        &self.db_storage_type
    }
    /// <p>The amount of storage allocated for your DB storage type (in gibibytes).</p>
    pub fn allocated_storage(mut self, input: i32) -> Self {
        self.allocated_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of storage allocated for your DB storage type (in gibibytes).</p>
    pub fn set_allocated_storage(mut self, input: ::std::option::Option<i32>) -> Self {
        self.allocated_storage = input;
        self
    }
    /// <p>The amount of storage allocated for your DB storage type (in gibibytes).</p>
    pub fn get_allocated_storage(&self) -> &::std::option::Option<i32> {
        &self.allocated_storage
    }
    /// <p>The engine type of your DB cluster.</p>
    pub fn engine_type(mut self, input: crate::types::EngineType) -> Self {
        self.engine_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The engine type of your DB cluster.</p>
    pub fn set_engine_type(mut self, input: ::std::option::Option<crate::types::EngineType>) -> Self {
        self.engine_type = input;
        self
    }
    /// <p>The engine type of your DB cluster.</p>
    pub fn get_engine_type(&self) -> &::std::option::Option<crate::types::EngineType> {
        &self.engine_type
    }
    /// <p>Indicates if the DB cluster has a public IP to facilitate access from outside the VPC.</p>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.publicly_accessible = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates if the DB cluster has a public IP to facilitate access from outside the VPC.</p>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.publicly_accessible = input;
        self
    }
    /// <p>Indicates if the DB cluster has a public IP to facilitate access from outside the VPC.</p>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        &self.publicly_accessible
    }
    /// <p>The ID of the DB parameter group assigned to your DB cluster.</p>
    pub fn db_parameter_group_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_parameter_group_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the DB parameter group assigned to your DB cluster.</p>
    pub fn set_db_parameter_group_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_parameter_group_identifier = input;
        self
    }
    /// <p>The ID of the DB parameter group assigned to your DB cluster.</p>
    pub fn get_db_parameter_group_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_parameter_group_identifier
    }
    /// <p>Configuration for sending InfluxDB engine logs to send to specified S3 bucket.</p>
    pub fn log_delivery_configuration(mut self, input: crate::types::LogDeliveryConfiguration) -> Self {
        self.log_delivery_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration for sending InfluxDB engine logs to send to specified S3 bucket.</p>
    pub fn set_log_delivery_configuration(mut self, input: ::std::option::Option<crate::types::LogDeliveryConfiguration>) -> Self {
        self.log_delivery_configuration = input;
        self
    }
    /// <p>Configuration for sending InfluxDB engine logs to send to specified S3 bucket.</p>
    pub fn get_log_delivery_configuration(&self) -> &::std::option::Option<crate::types::LogDeliveryConfiguration> {
        &self.log_delivery_configuration
    }
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.</p>
    pub fn influx_auth_parameters_secret_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.influx_auth_parameters_secret_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.</p>
    pub fn set_influx_auth_parameters_secret_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.influx_auth_parameters_secret_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Secrets Manager secret containing the initial InfluxDB authorization parameters. The secret value is a JSON formatted key-value pair holding InfluxDB authorization values: organization, bucket, username, and password.</p>
    pub fn get_influx_auth_parameters_secret_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.influx_auth_parameters_secret_arn
    }
    /// Appends an item to `vpc_subnet_ids`.
    ///
    /// To override the contents of this collection use [`set_vpc_subnet_ids`](Self::set_vpc_subnet_ids).
    ///
    /// <p>A list of VPC subnet IDs associated with the DB cluster.</p>
    pub fn vpc_subnet_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.vpc_subnet_ids.unwrap_or_default();
        v.push(input.into());
        self.vpc_subnet_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of VPC subnet IDs associated with the DB cluster.</p>
    pub fn set_vpc_subnet_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.vpc_subnet_ids = input;
        self
    }
    /// <p>A list of VPC subnet IDs associated with the DB cluster.</p>
    pub fn get_vpc_subnet_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.vpc_subnet_ids
    }
    /// Appends an item to `vpc_security_group_ids`.
    ///
    /// To override the contents of this collection use [`set_vpc_security_group_ids`](Self::set_vpc_security_group_ids).
    ///
    /// <p>A list of VPC security group IDs associated with the DB cluster.</p>
    pub fn vpc_security_group_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.vpc_security_group_ids.unwrap_or_default();
        v.push(input.into());
        self.vpc_security_group_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of VPC security group IDs associated with the DB cluster.</p>
    pub fn set_vpc_security_group_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.vpc_security_group_ids = input;
        self
    }
    /// <p>A list of VPC security group IDs associated with the DB cluster.</p>
    pub fn get_vpc_security_group_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.vpc_security_group_ids
    }
    /// <p>The configured failover mode for the DB cluster.</p>
    pub fn failover_mode(mut self, input: crate::types::FailoverMode) -> Self {
        self.failover_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configured failover mode for the DB cluster.</p>
    pub fn set_failover_mode(mut self, input: ::std::option::Option<crate::types::FailoverMode>) -> Self {
        self.failover_mode = input;
        self
    }
    /// <p>The configured failover mode for the DB cluster.</p>
    pub fn get_failover_mode(&self) -> &::std::option::Option<crate::types::FailoverMode> {
        &self.failover_mode
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetDbClusterOutput`](crate::operation::get_db_cluster::GetDbClusterOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`id`](crate::operation::get_db_cluster::builders::GetDbClusterOutputBuilder::id)
    /// - [`name`](crate::operation::get_db_cluster::builders::GetDbClusterOutputBuilder::name)
    /// - [`arn`](crate::operation::get_db_cluster::builders::GetDbClusterOutputBuilder::arn)
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::get_db_cluster::GetDbClusterOutput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::get_db_cluster::GetDbClusterOutput {
            id: self.id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "id",
                    "id was not specified but it is required when building GetDbClusterOutput",
                )
            })?,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building GetDbClusterOutput",
                )
            })?,
            arn: self.arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "arn",
                    "arn was not specified but it is required when building GetDbClusterOutput",
                )
            })?,
            status: self.status,
            endpoint: self.endpoint,
            reader_endpoint: self.reader_endpoint,
            port: self.port,
            deployment_type: self.deployment_type,
            db_instance_type: self.db_instance_type,
            network_type: self.network_type,
            db_storage_type: self.db_storage_type,
            allocated_storage: self.allocated_storage,
            engine_type: self.engine_type,
            publicly_accessible: self.publicly_accessible,
            db_parameter_group_identifier: self.db_parameter_group_identifier,
            log_delivery_configuration: self.log_delivery_configuration,
            influx_auth_parameters_secret_arn: self.influx_auth_parameters_secret_arn,
            vpc_subnet_ids: self.vpc_subnet_ids,
            vpc_security_group_ids: self.vpc_security_group_ids,
            failover_mode: self.failover_mode,
            _request_id: self._request_id,
        })
    }
}
