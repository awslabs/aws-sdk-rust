// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `HistoryEventType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let historyeventtype = unimplemented!();
/// match historyeventtype {
///     HistoryEventType::ActivityFailed => { /* ... */ },
///     HistoryEventType::ActivityScheduleFailed => { /* ... */ },
///     HistoryEventType::ActivityScheduled => { /* ... */ },
///     HistoryEventType::ActivityStarted => { /* ... */ },
///     HistoryEventType::ActivitySucceeded => { /* ... */ },
///     HistoryEventType::ActivityTimedOut => { /* ... */ },
///     HistoryEventType::ChoiceStateEntered => { /* ... */ },
///     HistoryEventType::ChoiceStateExited => { /* ... */ },
///     HistoryEventType::ExecutionAborted => { /* ... */ },
///     HistoryEventType::ExecutionFailed => { /* ... */ },
///     HistoryEventType::ExecutionStarted => { /* ... */ },
///     HistoryEventType::ExecutionSucceeded => { /* ... */ },
///     HistoryEventType::ExecutionTimedOut => { /* ... */ },
///     HistoryEventType::FailStateEntered => { /* ... */ },
///     HistoryEventType::LambdaFunctionFailed => { /* ... */ },
///     HistoryEventType::LambdaFunctionScheduleFailed => { /* ... */ },
///     HistoryEventType::LambdaFunctionScheduled => { /* ... */ },
///     HistoryEventType::LambdaFunctionStartFailed => { /* ... */ },
///     HistoryEventType::LambdaFunctionStarted => { /* ... */ },
///     HistoryEventType::LambdaFunctionSucceeded => { /* ... */ },
///     HistoryEventType::LambdaFunctionTimedOut => { /* ... */ },
///     HistoryEventType::MapIterationAborted => { /* ... */ },
///     HistoryEventType::MapIterationFailed => { /* ... */ },
///     HistoryEventType::MapIterationStarted => { /* ... */ },
///     HistoryEventType::MapIterationSucceeded => { /* ... */ },
///     HistoryEventType::MapRunAborted => { /* ... */ },
///     HistoryEventType::MapRunFailed => { /* ... */ },
///     HistoryEventType::MapRunStarted => { /* ... */ },
///     HistoryEventType::MapRunSucceeded => { /* ... */ },
///     HistoryEventType::MapStateAborted => { /* ... */ },
///     HistoryEventType::MapStateEntered => { /* ... */ },
///     HistoryEventType::MapStateExited => { /* ... */ },
///     HistoryEventType::MapStateFailed => { /* ... */ },
///     HistoryEventType::MapStateStarted => { /* ... */ },
///     HistoryEventType::MapStateSucceeded => { /* ... */ },
///     HistoryEventType::ParallelStateAborted => { /* ... */ },
///     HistoryEventType::ParallelStateEntered => { /* ... */ },
///     HistoryEventType::ParallelStateExited => { /* ... */ },
///     HistoryEventType::ParallelStateFailed => { /* ... */ },
///     HistoryEventType::ParallelStateStarted => { /* ... */ },
///     HistoryEventType::ParallelStateSucceeded => { /* ... */ },
///     HistoryEventType::PassStateEntered => { /* ... */ },
///     HistoryEventType::PassStateExited => { /* ... */ },
///     HistoryEventType::SucceedStateEntered => { /* ... */ },
///     HistoryEventType::SucceedStateExited => { /* ... */ },
///     HistoryEventType::TaskFailed => { /* ... */ },
///     HistoryEventType::TaskScheduled => { /* ... */ },
///     HistoryEventType::TaskStartFailed => { /* ... */ },
///     HistoryEventType::TaskStarted => { /* ... */ },
///     HistoryEventType::TaskStateAborted => { /* ... */ },
///     HistoryEventType::TaskStateEntered => { /* ... */ },
///     HistoryEventType::TaskStateExited => { /* ... */ },
///     HistoryEventType::TaskSubmitFailed => { /* ... */ },
///     HistoryEventType::TaskSubmitted => { /* ... */ },
///     HistoryEventType::TaskSucceeded => { /* ... */ },
///     HistoryEventType::TaskTimedOut => { /* ... */ },
///     HistoryEventType::WaitStateAborted => { /* ... */ },
///     HistoryEventType::WaitStateEntered => { /* ... */ },
///     HistoryEventType::WaitStateExited => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `historyeventtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `HistoryEventType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `HistoryEventType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `HistoryEventType::NewFeature` is defined.
/// Specifically, when `historyeventtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `HistoryEventType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum HistoryEventType {
    #[allow(missing_docs)] // documentation missing in model
    ActivityFailed,
    #[allow(missing_docs)] // documentation missing in model
    ActivityScheduleFailed,
    #[allow(missing_docs)] // documentation missing in model
    ActivityScheduled,
    #[allow(missing_docs)] // documentation missing in model
    ActivityStarted,
    #[allow(missing_docs)] // documentation missing in model
    ActivitySucceeded,
    #[allow(missing_docs)] // documentation missing in model
    ActivityTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    ChoiceStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    ChoiceStateExited,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionAborted,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionFailed,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionStarted,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    FailStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionFailed,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionScheduleFailed,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionScheduled,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionStartFailed,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionStarted,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    LambdaFunctionTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    MapIterationAborted,
    #[allow(missing_docs)] // documentation missing in model
    MapIterationFailed,
    #[allow(missing_docs)] // documentation missing in model
    MapIterationStarted,
    #[allow(missing_docs)] // documentation missing in model
    MapIterationSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    MapRunAborted,
    #[allow(missing_docs)] // documentation missing in model
    MapRunFailed,
    #[allow(missing_docs)] // documentation missing in model
    MapRunStarted,
    #[allow(missing_docs)] // documentation missing in model
    MapRunSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    MapStateAborted,
    #[allow(missing_docs)] // documentation missing in model
    MapStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    MapStateExited,
    #[allow(missing_docs)] // documentation missing in model
    MapStateFailed,
    #[allow(missing_docs)] // documentation missing in model
    MapStateStarted,
    #[allow(missing_docs)] // documentation missing in model
    MapStateSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    ParallelStateAborted,
    #[allow(missing_docs)] // documentation missing in model
    ParallelStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    ParallelStateExited,
    #[allow(missing_docs)] // documentation missing in model
    ParallelStateFailed,
    #[allow(missing_docs)] // documentation missing in model
    ParallelStateStarted,
    #[allow(missing_docs)] // documentation missing in model
    ParallelStateSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    PassStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    PassStateExited,
    #[allow(missing_docs)] // documentation missing in model
    SucceedStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    SucceedStateExited,
    #[allow(missing_docs)] // documentation missing in model
    TaskFailed,
    #[allow(missing_docs)] // documentation missing in model
    TaskScheduled,
    #[allow(missing_docs)] // documentation missing in model
    TaskStartFailed,
    #[allow(missing_docs)] // documentation missing in model
    TaskStarted,
    #[allow(missing_docs)] // documentation missing in model
    TaskStateAborted,
    #[allow(missing_docs)] // documentation missing in model
    TaskStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    TaskStateExited,
    #[allow(missing_docs)] // documentation missing in model
    TaskSubmitFailed,
    #[allow(missing_docs)] // documentation missing in model
    TaskSubmitted,
    #[allow(missing_docs)] // documentation missing in model
    TaskSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    TaskTimedOut,
    #[allow(missing_docs)] // documentation missing in model
    WaitStateAborted,
    #[allow(missing_docs)] // documentation missing in model
    WaitStateEntered,
    #[allow(missing_docs)] // documentation missing in model
    WaitStateExited,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue)
}
impl std::convert::From<&str> for HistoryEventType {
                fn from(s: &str) -> Self {
                    match s {
                        "ActivityFailed" => HistoryEventType::ActivityFailed,
"ActivityScheduleFailed" => HistoryEventType::ActivityScheduleFailed,
"ActivityScheduled" => HistoryEventType::ActivityScheduled,
"ActivityStarted" => HistoryEventType::ActivityStarted,
"ActivitySucceeded" => HistoryEventType::ActivitySucceeded,
"ActivityTimedOut" => HistoryEventType::ActivityTimedOut,
"ChoiceStateEntered" => HistoryEventType::ChoiceStateEntered,
"ChoiceStateExited" => HistoryEventType::ChoiceStateExited,
"ExecutionAborted" => HistoryEventType::ExecutionAborted,
"ExecutionFailed" => HistoryEventType::ExecutionFailed,
"ExecutionStarted" => HistoryEventType::ExecutionStarted,
"ExecutionSucceeded" => HistoryEventType::ExecutionSucceeded,
"ExecutionTimedOut" => HistoryEventType::ExecutionTimedOut,
"FailStateEntered" => HistoryEventType::FailStateEntered,
"LambdaFunctionFailed" => HistoryEventType::LambdaFunctionFailed,
"LambdaFunctionScheduleFailed" => HistoryEventType::LambdaFunctionScheduleFailed,
"LambdaFunctionScheduled" => HistoryEventType::LambdaFunctionScheduled,
"LambdaFunctionStartFailed" => HistoryEventType::LambdaFunctionStartFailed,
"LambdaFunctionStarted" => HistoryEventType::LambdaFunctionStarted,
"LambdaFunctionSucceeded" => HistoryEventType::LambdaFunctionSucceeded,
"LambdaFunctionTimedOut" => HistoryEventType::LambdaFunctionTimedOut,
"MapIterationAborted" => HistoryEventType::MapIterationAborted,
"MapIterationFailed" => HistoryEventType::MapIterationFailed,
"MapIterationStarted" => HistoryEventType::MapIterationStarted,
"MapIterationSucceeded" => HistoryEventType::MapIterationSucceeded,
"MapRunAborted" => HistoryEventType::MapRunAborted,
"MapRunFailed" => HistoryEventType::MapRunFailed,
"MapRunStarted" => HistoryEventType::MapRunStarted,
"MapRunSucceeded" => HistoryEventType::MapRunSucceeded,
"MapStateAborted" => HistoryEventType::MapStateAborted,
"MapStateEntered" => HistoryEventType::MapStateEntered,
"MapStateExited" => HistoryEventType::MapStateExited,
"MapStateFailed" => HistoryEventType::MapStateFailed,
"MapStateStarted" => HistoryEventType::MapStateStarted,
"MapStateSucceeded" => HistoryEventType::MapStateSucceeded,
"ParallelStateAborted" => HistoryEventType::ParallelStateAborted,
"ParallelStateEntered" => HistoryEventType::ParallelStateEntered,
"ParallelStateExited" => HistoryEventType::ParallelStateExited,
"ParallelStateFailed" => HistoryEventType::ParallelStateFailed,
"ParallelStateStarted" => HistoryEventType::ParallelStateStarted,
"ParallelStateSucceeded" => HistoryEventType::ParallelStateSucceeded,
"PassStateEntered" => HistoryEventType::PassStateEntered,
"PassStateExited" => HistoryEventType::PassStateExited,
"SucceedStateEntered" => HistoryEventType::SucceedStateEntered,
"SucceedStateExited" => HistoryEventType::SucceedStateExited,
"TaskFailed" => HistoryEventType::TaskFailed,
"TaskScheduled" => HistoryEventType::TaskScheduled,
"TaskStartFailed" => HistoryEventType::TaskStartFailed,
"TaskStarted" => HistoryEventType::TaskStarted,
"TaskStateAborted" => HistoryEventType::TaskStateAborted,
"TaskStateEntered" => HistoryEventType::TaskStateEntered,
"TaskStateExited" => HistoryEventType::TaskStateExited,
"TaskSubmitFailed" => HistoryEventType::TaskSubmitFailed,
"TaskSubmitted" => HistoryEventType::TaskSubmitted,
"TaskSucceeded" => HistoryEventType::TaskSucceeded,
"TaskTimedOut" => HistoryEventType::TaskTimedOut,
"WaitStateAborted" => HistoryEventType::WaitStateAborted,
"WaitStateEntered" => HistoryEventType::WaitStateEntered,
"WaitStateExited" => HistoryEventType::WaitStateExited,
other => HistoryEventType::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
                    }
                }
            }
impl std::str::FromStr for HistoryEventType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(HistoryEventType::from(s))
                }
            }
impl HistoryEventType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    HistoryEventType::ActivityFailed => "ActivityFailed",
    HistoryEventType::ActivityScheduleFailed => "ActivityScheduleFailed",
    HistoryEventType::ActivityScheduled => "ActivityScheduled",
    HistoryEventType::ActivityStarted => "ActivityStarted",
    HistoryEventType::ActivitySucceeded => "ActivitySucceeded",
    HistoryEventType::ActivityTimedOut => "ActivityTimedOut",
    HistoryEventType::ChoiceStateEntered => "ChoiceStateEntered",
    HistoryEventType::ChoiceStateExited => "ChoiceStateExited",
    HistoryEventType::ExecutionAborted => "ExecutionAborted",
    HistoryEventType::ExecutionFailed => "ExecutionFailed",
    HistoryEventType::ExecutionStarted => "ExecutionStarted",
    HistoryEventType::ExecutionSucceeded => "ExecutionSucceeded",
    HistoryEventType::ExecutionTimedOut => "ExecutionTimedOut",
    HistoryEventType::FailStateEntered => "FailStateEntered",
    HistoryEventType::LambdaFunctionFailed => "LambdaFunctionFailed",
    HistoryEventType::LambdaFunctionScheduleFailed => "LambdaFunctionScheduleFailed",
    HistoryEventType::LambdaFunctionScheduled => "LambdaFunctionScheduled",
    HistoryEventType::LambdaFunctionStartFailed => "LambdaFunctionStartFailed",
    HistoryEventType::LambdaFunctionStarted => "LambdaFunctionStarted",
    HistoryEventType::LambdaFunctionSucceeded => "LambdaFunctionSucceeded",
    HistoryEventType::LambdaFunctionTimedOut => "LambdaFunctionTimedOut",
    HistoryEventType::MapIterationAborted => "MapIterationAborted",
    HistoryEventType::MapIterationFailed => "MapIterationFailed",
    HistoryEventType::MapIterationStarted => "MapIterationStarted",
    HistoryEventType::MapIterationSucceeded => "MapIterationSucceeded",
    HistoryEventType::MapRunAborted => "MapRunAborted",
    HistoryEventType::MapRunFailed => "MapRunFailed",
    HistoryEventType::MapRunStarted => "MapRunStarted",
    HistoryEventType::MapRunSucceeded => "MapRunSucceeded",
    HistoryEventType::MapStateAborted => "MapStateAborted",
    HistoryEventType::MapStateEntered => "MapStateEntered",
    HistoryEventType::MapStateExited => "MapStateExited",
    HistoryEventType::MapStateFailed => "MapStateFailed",
    HistoryEventType::MapStateStarted => "MapStateStarted",
    HistoryEventType::MapStateSucceeded => "MapStateSucceeded",
    HistoryEventType::ParallelStateAborted => "ParallelStateAborted",
    HistoryEventType::ParallelStateEntered => "ParallelStateEntered",
    HistoryEventType::ParallelStateExited => "ParallelStateExited",
    HistoryEventType::ParallelStateFailed => "ParallelStateFailed",
    HistoryEventType::ParallelStateStarted => "ParallelStateStarted",
    HistoryEventType::ParallelStateSucceeded => "ParallelStateSucceeded",
    HistoryEventType::PassStateEntered => "PassStateEntered",
    HistoryEventType::PassStateExited => "PassStateExited",
    HistoryEventType::SucceedStateEntered => "SucceedStateEntered",
    HistoryEventType::SucceedStateExited => "SucceedStateExited",
    HistoryEventType::TaskFailed => "TaskFailed",
    HistoryEventType::TaskScheduled => "TaskScheduled",
    HistoryEventType::TaskStartFailed => "TaskStartFailed",
    HistoryEventType::TaskStarted => "TaskStarted",
    HistoryEventType::TaskStateAborted => "TaskStateAborted",
    HistoryEventType::TaskStateEntered => "TaskStateEntered",
    HistoryEventType::TaskStateExited => "TaskStateExited",
    HistoryEventType::TaskSubmitFailed => "TaskSubmitFailed",
    HistoryEventType::TaskSubmitted => "TaskSubmitted",
    HistoryEventType::TaskSucceeded => "TaskSucceeded",
    HistoryEventType::TaskTimedOut => "TaskTimedOut",
    HistoryEventType::WaitStateAborted => "WaitStateAborted",
    HistoryEventType::WaitStateEntered => "WaitStateEntered",
    HistoryEventType::WaitStateExited => "WaitStateExited",
    HistoryEventType::Unknown(value) => value.as_str()
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ActivityFailed", "ActivityScheduleFailed", "ActivityScheduled", "ActivityStarted", "ActivitySucceeded", "ActivityTimedOut", "ChoiceStateEntered", "ChoiceStateExited", "ExecutionAborted", "ExecutionFailed", "ExecutionStarted", "ExecutionSucceeded", "ExecutionTimedOut", "FailStateEntered", "LambdaFunctionFailed", "LambdaFunctionScheduleFailed", "LambdaFunctionScheduled", "LambdaFunctionStartFailed", "LambdaFunctionStarted", "LambdaFunctionSucceeded", "LambdaFunctionTimedOut", "MapIterationAborted", "MapIterationFailed", "MapIterationStarted", "MapIterationSucceeded", "MapRunAborted", "MapRunFailed", "MapRunStarted", "MapRunSucceeded", "MapStateAborted", "MapStateEntered", "MapStateExited", "MapStateFailed", "MapStateStarted", "MapStateSucceeded", "ParallelStateAborted", "ParallelStateEntered", "ParallelStateExited", "ParallelStateFailed", "ParallelStateStarted", "ParallelStateSucceeded", "PassStateEntered", "PassStateExited", "SucceedStateEntered", "SucceedStateExited", "TaskFailed", "TaskScheduled", "TaskStartFailed", "TaskStarted", "TaskStateAborted", "TaskStateEntered", "TaskStateExited", "TaskSubmitFailed", "TaskSubmitted", "TaskSucceeded", "TaskTimedOut", "WaitStateAborted", "WaitStateEntered", "WaitStateExited"]
                }
            }
impl AsRef<str> for HistoryEventType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }

