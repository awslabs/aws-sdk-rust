// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum Error {
    /// <p>The specified activity does not exist.</p>
    ActivityDoesNotExist(crate::types::error::ActivityDoesNotExist),
    /// <p>The maximum number of activities has been reached. Existing activities must be deleted before a new activity can be created.</p>
    ActivityLimitExceeded(crate::types::error::ActivityLimitExceeded),
    /// <p>The maximum number of workers concurrently polling for activity tasks has been reached.</p>
    ActivityWorkerLimitExceeded(crate::types::error::ActivityWorkerLimitExceeded),
    /// <p>Updating or deleting a resource can cause an inconsistent state. This error occurs when there're concurrent requests for <code>DeleteStateMachineVersion</code>, <code>PublishStateMachineVersion</code>, or <code>UpdateStateMachine</code> with the <code>publish</code> parameter set to <code>true</code>.</p>
    /// <p>HTTP Status Code: 409</p>
    ConflictException(crate::types::error::ConflictException),
    /// <p>The execution has the same <code>name</code> as another execution (but a different <code>input</code>).</p><note>
    /// <p>Executions with the same <code>name</code> and <code>input</code> are considered idempotent.</p>
    /// </note>
    ExecutionAlreadyExists(crate::types::error::ExecutionAlreadyExists),
    /// <p>The specified execution does not exist.</p>
    ExecutionDoesNotExist(crate::types::error::ExecutionDoesNotExist),
    /// <p>The maximum number of running executions has been reached. Running executions must end or be stopped before a new execution can be started.</p>
    ExecutionLimitExceeded(crate::types::error::ExecutionLimitExceeded),
    /// <p>The execution Amazon Resource Name (ARN) that you specified for <code>executionArn</code> cannot be redriven.</p>
    ExecutionNotRedrivable(crate::types::error::ExecutionNotRedrivable),
    /// <p>The provided Amazon Resource Name (ARN) is not valid.</p>
    InvalidArn(crate::types::error::InvalidArn),
    /// <p>The provided Amazon States Language definition is not valid.</p>
    InvalidDefinition(crate::types::error::InvalidDefinition),
    /// <p>The provided JSON input data is not valid.</p>
    InvalidExecutionInput(crate::types::error::InvalidExecutionInput),
    /// <p></p>
    InvalidLoggingConfiguration(crate::types::error::InvalidLoggingConfiguration),
    /// <p>The provided name is not valid.</p>
    InvalidName(crate::types::error::InvalidName),
    /// <p>The provided JSON output data is not valid.</p>
    InvalidOutput(crate::types::error::InvalidOutput),
    /// <p>The provided token is not valid.</p>
    InvalidToken(crate::types::error::InvalidToken),
    /// <p>Your <code>tracingConfiguration</code> key does not match, or <code>enabled</code> has not been set to <code>true</code> or <code>false</code>.</p>
    InvalidTracingConfiguration(crate::types::error::InvalidTracingConfiguration),
    /// <p>Request is missing a required parameter. This error occurs if both <code>definition</code> and <code>roleArn</code> are not specified.</p>
    MissingRequiredParameter(crate::types::error::MissingRequiredParameter),
    /// <p>Could not find the referenced resource.</p>
    ResourceNotFound(crate::types::error::ResourceNotFound),
    /// <p>The request would cause a service quota to be exceeded.</p>
    /// <p>HTTP Status Code: 402</p>
    ServiceQuotaExceededException(crate::types::error::ServiceQuotaExceededException),
    /// <p>A state machine with the same name but a different definition or role ARN already exists.</p>
    StateMachineAlreadyExists(crate::types::error::StateMachineAlreadyExists),
    /// <p>The specified state machine is being deleted.</p>
    StateMachineDeleting(crate::types::error::StateMachineDeleting),
    /// <p>The specified state machine does not exist.</p>
    StateMachineDoesNotExist(crate::types::error::StateMachineDoesNotExist),
    /// <p>The maximum number of state machines has been reached. Existing state machines must be deleted before a new state machine can be created.</p>
    StateMachineLimitExceeded(crate::types::error::StateMachineLimitExceeded),
    /// <p></p>
    StateMachineTypeNotSupported(crate::types::error::StateMachineTypeNotSupported),
    /// <p>The activity does not exist.</p>
    TaskDoesNotExist(crate::types::error::TaskDoesNotExist),
    /// <p>The task token has either expired or the task associated with the token has already been closed.</p>
    TaskTimedOut(crate::types::error::TaskTimedOut),
    /// <p>You've exceeded the number of tags allowed for a resource. See the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/limits.html"> Limits Topic</a> in the Step Functions Developer Guide.</p>
    TooManyTags(crate::types::error::TooManyTags),
    /// <p>The input does not satisfy the constraints specified by an Amazon Web Services service.</p>
    ValidationException(crate::types::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-Error) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::ActivityDoesNotExist(inner) => inner.fmt(f),
            Error::ActivityLimitExceeded(inner) => inner.fmt(f),
            Error::ActivityWorkerLimitExceeded(inner) => inner.fmt(f),
            Error::ConflictException(inner) => inner.fmt(f),
            Error::ExecutionAlreadyExists(inner) => inner.fmt(f),
            Error::ExecutionDoesNotExist(inner) => inner.fmt(f),
            Error::ExecutionLimitExceeded(inner) => inner.fmt(f),
            Error::ExecutionNotRedrivable(inner) => inner.fmt(f),
            Error::InvalidArn(inner) => inner.fmt(f),
            Error::InvalidDefinition(inner) => inner.fmt(f),
            Error::InvalidExecutionInput(inner) => inner.fmt(f),
            Error::InvalidLoggingConfiguration(inner) => inner.fmt(f),
            Error::InvalidName(inner) => inner.fmt(f),
            Error::InvalidOutput(inner) => inner.fmt(f),
            Error::InvalidToken(inner) => inner.fmt(f),
            Error::InvalidTracingConfiguration(inner) => inner.fmt(f),
            Error::MissingRequiredParameter(inner) => inner.fmt(f),
            Error::ResourceNotFound(inner) => inner.fmt(f),
            Error::ServiceQuotaExceededException(inner) => inner.fmt(f),
            Error::StateMachineAlreadyExists(inner) => inner.fmt(f),
            Error::StateMachineDeleting(inner) => inner.fmt(f),
            Error::StateMachineDoesNotExist(inner) => inner.fmt(f),
            Error::StateMachineLimitExceeded(inner) => inner.fmt(f),
            Error::StateMachineTypeNotSupported(inner) => inner.fmt(f),
            Error::TaskDoesNotExist(inner) => inner.fmt(f),
            Error::TaskTimedOut(inner) => inner.fmt(f),
            Error::TooManyTags(inner) => inner.fmt(f),
            Error::ValidationException(inner) => inner.fmt(f),
            Error::Unhandled(_) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl From<::aws_smithy_types::error::operation::BuildError> for Error {
    fn from(value: ::aws_smithy_types::error::operation::BuildError) -> Self {
        Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: value.into(),
            meta: ::std::default::Default::default(),
        })
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for Error {
    fn meta(&self) -> &::aws_smithy_types::error::metadata::ErrorMetadata {
        match self {
            Self::ActivityDoesNotExist(inner) => inner.meta(),
            Self::ActivityLimitExceeded(inner) => inner.meta(),
            Self::ActivityWorkerLimitExceeded(inner) => inner.meta(),
            Self::ConflictException(inner) => inner.meta(),
            Self::ExecutionAlreadyExists(inner) => inner.meta(),
            Self::ExecutionDoesNotExist(inner) => inner.meta(),
            Self::ExecutionLimitExceeded(inner) => inner.meta(),
            Self::ExecutionNotRedrivable(inner) => inner.meta(),
            Self::InvalidArn(inner) => inner.meta(),
            Self::InvalidDefinition(inner) => inner.meta(),
            Self::InvalidExecutionInput(inner) => inner.meta(),
            Self::InvalidLoggingConfiguration(inner) => inner.meta(),
            Self::InvalidName(inner) => inner.meta(),
            Self::InvalidOutput(inner) => inner.meta(),
            Self::InvalidToken(inner) => inner.meta(),
            Self::InvalidTracingConfiguration(inner) => inner.meta(),
            Self::MissingRequiredParameter(inner) => inner.meta(),
            Self::ResourceNotFound(inner) => inner.meta(),
            Self::ServiceQuotaExceededException(inner) => inner.meta(),
            Self::StateMachineAlreadyExists(inner) => inner.meta(),
            Self::StateMachineDeleting(inner) => inner.meta(),
            Self::StateMachineDoesNotExist(inner) => inner.meta(),
            Self::StateMachineLimitExceeded(inner) => inner.meta(),
            Self::StateMachineTypeNotSupported(inner) => inner.meta(),
            Self::TaskDoesNotExist(inner) => inner.meta(),
            Self::TaskTimedOut(inner) => inner.meta(),
            Self::TooManyTags(inner) => inner.meta(),
            Self::ValidationException(inner) => inner.meta(),
            Self::Unhandled(inner) => &inner.meta,
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::create_activity::CreateActivityError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::create_activity::CreateActivityError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::create_activity::CreateActivityError> for Error {
    fn from(err: crate::operation::create_activity::CreateActivityError) -> Self {
        match err {
            crate::operation::create_activity::CreateActivityError::ActivityLimitExceeded(inner) => Error::ActivityLimitExceeded(inner),
            crate::operation::create_activity::CreateActivityError::InvalidName(inner) => Error::InvalidName(inner),
            crate::operation::create_activity::CreateActivityError::TooManyTags(inner) => Error::TooManyTags(inner),
            crate::operation::create_activity::CreateActivityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::create_state_machine::CreateStateMachineError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::create_state_machine::CreateStateMachineError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::create_state_machine::CreateStateMachineError> for Error {
    fn from(err: crate::operation::create_state_machine::CreateStateMachineError) -> Self {
        match err {
            crate::operation::create_state_machine::CreateStateMachineError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::create_state_machine::CreateStateMachineError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::create_state_machine::CreateStateMachineError::InvalidDefinition(inner) => Error::InvalidDefinition(inner),
            crate::operation::create_state_machine::CreateStateMachineError::InvalidLoggingConfiguration(inner) => {
                Error::InvalidLoggingConfiguration(inner)
            }
            crate::operation::create_state_machine::CreateStateMachineError::InvalidName(inner) => Error::InvalidName(inner),
            crate::operation::create_state_machine::CreateStateMachineError::InvalidTracingConfiguration(inner) => {
                Error::InvalidTracingConfiguration(inner)
            }
            crate::operation::create_state_machine::CreateStateMachineError::StateMachineAlreadyExists(inner) => {
                Error::StateMachineAlreadyExists(inner)
            }
            crate::operation::create_state_machine::CreateStateMachineError::StateMachineDeleting(inner) => Error::StateMachineDeleting(inner),
            crate::operation::create_state_machine::CreateStateMachineError::StateMachineLimitExceeded(inner) => {
                Error::StateMachineLimitExceeded(inner)
            }
            crate::operation::create_state_machine::CreateStateMachineError::StateMachineTypeNotSupported(inner) => {
                Error::StateMachineTypeNotSupported(inner)
            }
            crate::operation::create_state_machine::CreateStateMachineError::TooManyTags(inner) => Error::TooManyTags(inner),
            crate::operation::create_state_machine::CreateStateMachineError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::create_state_machine::CreateStateMachineError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::create_state_machine_alias::CreateStateMachineAliasError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::create_state_machine_alias::CreateStateMachineAliasError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::create_state_machine_alias::CreateStateMachineAliasError> for Error {
    fn from(err: crate::operation::create_state_machine_alias::CreateStateMachineAliasError) -> Self {
        match err {
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::InvalidName(inner) => Error::InvalidName(inner),
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::ServiceQuotaExceededException(inner) => {
                Error::ServiceQuotaExceededException(inner)
            }
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::StateMachineDeleting(inner) => {
                Error::StateMachineDeleting(inner)
            }
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::create_state_machine_alias::CreateStateMachineAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_activity::DeleteActivityError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_activity::DeleteActivityError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_activity::DeleteActivityError> for Error {
    fn from(err: crate::operation::delete_activity::DeleteActivityError) -> Self {
        match err {
            crate::operation::delete_activity::DeleteActivityError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::delete_activity::DeleteActivityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_state_machine::DeleteStateMachineError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_state_machine::DeleteStateMachineError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_state_machine::DeleteStateMachineError> for Error {
    fn from(err: crate::operation::delete_state_machine::DeleteStateMachineError) -> Self {
        match err {
            crate::operation::delete_state_machine::DeleteStateMachineError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::delete_state_machine::DeleteStateMachineError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::delete_state_machine::DeleteStateMachineError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError> for Error {
    fn from(err: crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError) -> Self {
        match err {
            crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::delete_state_machine_alias::DeleteStateMachineAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_state_machine_version::DeleteStateMachineVersionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::delete_state_machine_version::DeleteStateMachineVersionError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_state_machine_version::DeleteStateMachineVersionError> for Error {
    fn from(err: crate::operation::delete_state_machine_version::DeleteStateMachineVersionError) -> Self {
        match err {
            crate::operation::delete_state_machine_version::DeleteStateMachineVersionError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::operation::delete_state_machine_version::DeleteStateMachineVersionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::delete_state_machine_version::DeleteStateMachineVersionError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::delete_state_machine_version::DeleteStateMachineVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_activity::DescribeActivityError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_activity::DescribeActivityError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::describe_activity::DescribeActivityError> for Error {
    fn from(err: crate::operation::describe_activity::DescribeActivityError) -> Self {
        match err {
            crate::operation::describe_activity::DescribeActivityError::ActivityDoesNotExist(inner) => Error::ActivityDoesNotExist(inner),
            crate::operation::describe_activity::DescribeActivityError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::describe_activity::DescribeActivityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_execution::DescribeExecutionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_execution::DescribeExecutionError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::describe_execution::DescribeExecutionError> for Error {
    fn from(err: crate::operation::describe_execution::DescribeExecutionError) -> Self {
        match err {
            crate::operation::describe_execution::DescribeExecutionError::ExecutionDoesNotExist(inner) => Error::ExecutionDoesNotExist(inner),
            crate::operation::describe_execution::DescribeExecutionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::describe_execution::DescribeExecutionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_map_run::DescribeMapRunError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_map_run::DescribeMapRunError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::describe_map_run::DescribeMapRunError> for Error {
    fn from(err: crate::operation::describe_map_run::DescribeMapRunError) -> Self {
        match err {
            crate::operation::describe_map_run::DescribeMapRunError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::describe_map_run::DescribeMapRunError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::describe_map_run::DescribeMapRunError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_state_machine::DescribeStateMachineError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_state_machine::DescribeStateMachineError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::describe_state_machine::DescribeStateMachineError> for Error {
    fn from(err: crate::operation::describe_state_machine::DescribeStateMachineError) -> Self {
        match err {
            crate::operation::describe_state_machine::DescribeStateMachineError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::describe_state_machine::DescribeStateMachineError::StateMachineDoesNotExist(inner) => {
                Error::StateMachineDoesNotExist(inner)
            }
            crate::operation::describe_state_machine::DescribeStateMachineError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError> for Error {
    fn from(err: crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError) -> Self {
        match err {
            crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::describe_state_machine_alias::DescribeStateMachineAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError> for Error {
    fn from(err: crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError) -> Self {
        match err {
            crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError::ExecutionDoesNotExist(inner) => {
                Error::ExecutionDoesNotExist(inner)
            }
            crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError::InvalidArn(inner) => {
                Error::InvalidArn(inner)
            }
            crate::operation::describe_state_machine_for_execution::DescribeStateMachineForExecutionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::get_activity_task::GetActivityTaskError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::get_activity_task::GetActivityTaskError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::get_activity_task::GetActivityTaskError> for Error {
    fn from(err: crate::operation::get_activity_task::GetActivityTaskError) -> Self {
        match err {
            crate::operation::get_activity_task::GetActivityTaskError::ActivityDoesNotExist(inner) => Error::ActivityDoesNotExist(inner),
            crate::operation::get_activity_task::GetActivityTaskError::ActivityWorkerLimitExceeded(inner) => {
                Error::ActivityWorkerLimitExceeded(inner)
            }
            crate::operation::get_activity_task::GetActivityTaskError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::get_activity_task::GetActivityTaskError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::get_execution_history::GetExecutionHistoryError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::get_execution_history::GetExecutionHistoryError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::get_execution_history::GetExecutionHistoryError> for Error {
    fn from(err: crate::operation::get_execution_history::GetExecutionHistoryError) -> Self {
        match err {
            crate::operation::get_execution_history::GetExecutionHistoryError::ExecutionDoesNotExist(inner) => Error::ExecutionDoesNotExist(inner),
            crate::operation::get_execution_history::GetExecutionHistoryError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::get_execution_history::GetExecutionHistoryError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::get_execution_history::GetExecutionHistoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_activities::ListActivitiesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_activities::ListActivitiesError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_activities::ListActivitiesError> for Error {
    fn from(err: crate::operation::list_activities::ListActivitiesError) -> Self {
        match err {
            crate::operation::list_activities::ListActivitiesError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::list_activities::ListActivitiesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_executions::ListExecutionsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_executions::ListExecutionsError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_executions::ListExecutionsError> for Error {
    fn from(err: crate::operation::list_executions::ListExecutionsError) -> Self {
        match err {
            crate::operation::list_executions::ListExecutionsError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::list_executions::ListExecutionsError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::list_executions::ListExecutionsError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::list_executions::ListExecutionsError::StateMachineDoesNotExist(inner) => Error::StateMachineDoesNotExist(inner),
            crate::operation::list_executions::ListExecutionsError::StateMachineTypeNotSupported(inner) => Error::StateMachineTypeNotSupported(inner),
            crate::operation::list_executions::ListExecutionsError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::list_executions::ListExecutionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_map_runs::ListMapRunsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_map_runs::ListMapRunsError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_map_runs::ListMapRunsError> for Error {
    fn from(err: crate::operation::list_map_runs::ListMapRunsError) -> Self {
        match err {
            crate::operation::list_map_runs::ListMapRunsError::ExecutionDoesNotExist(inner) => Error::ExecutionDoesNotExist(inner),
            crate::operation::list_map_runs::ListMapRunsError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::list_map_runs::ListMapRunsError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::list_map_runs::ListMapRunsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_state_machine_aliases::ListStateMachineAliasesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_state_machine_aliases::ListStateMachineAliasesError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_state_machine_aliases::ListStateMachineAliasesError> for Error {
    fn from(err: crate::operation::list_state_machine_aliases::ListStateMachineAliasesError) -> Self {
        match err {
            crate::operation::list_state_machine_aliases::ListStateMachineAliasesError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::list_state_machine_aliases::ListStateMachineAliasesError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::list_state_machine_aliases::ListStateMachineAliasesError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::list_state_machine_aliases::ListStateMachineAliasesError::StateMachineDeleting(inner) => {
                Error::StateMachineDeleting(inner)
            }
            crate::operation::list_state_machine_aliases::ListStateMachineAliasesError::StateMachineDoesNotExist(inner) => {
                Error::StateMachineDoesNotExist(inner)
            }
            crate::operation::list_state_machine_aliases::ListStateMachineAliasesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_state_machines::ListStateMachinesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_state_machines::ListStateMachinesError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_state_machines::ListStateMachinesError> for Error {
    fn from(err: crate::operation::list_state_machines::ListStateMachinesError) -> Self {
        match err {
            crate::operation::list_state_machines::ListStateMachinesError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::list_state_machines::ListStateMachinesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_state_machine_versions::ListStateMachineVersionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_state_machine_versions::ListStateMachineVersionsError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_state_machine_versions::ListStateMachineVersionsError> for Error {
    fn from(err: crate::operation::list_state_machine_versions::ListStateMachineVersionsError) -> Self {
        match err {
            crate::operation::list_state_machine_versions::ListStateMachineVersionsError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::list_state_machine_versions::ListStateMachineVersionsError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::list_state_machine_versions::ListStateMachineVersionsError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::list_state_machine_versions::ListStateMachineVersionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_tags_for_resource::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_tags_for_resource::ListTagsForResourceError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_tags_for_resource::ListTagsForResourceError> for Error {
    fn from(err: crate::operation::list_tags_for_resource::ListTagsForResourceError) -> Self {
        match err {
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::publish_state_machine_version::PublishStateMachineVersionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::publish_state_machine_version::PublishStateMachineVersionError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::publish_state_machine_version::PublishStateMachineVersionError> for Error {
    fn from(err: crate::operation::publish_state_machine_version::PublishStateMachineVersionError) -> Self {
        match err {
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::ConflictException(inner) => {
                Error::ConflictException(inner)
            }
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::ServiceQuotaExceededException(inner) => {
                Error::ServiceQuotaExceededException(inner)
            }
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::StateMachineDeleting(inner) => {
                Error::StateMachineDeleting(inner)
            }
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::StateMachineDoesNotExist(inner) => {
                Error::StateMachineDoesNotExist(inner)
            }
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::publish_state_machine_version::PublishStateMachineVersionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::redrive_execution::RedriveExecutionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::redrive_execution::RedriveExecutionError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::redrive_execution::RedriveExecutionError> for Error {
    fn from(err: crate::operation::redrive_execution::RedriveExecutionError) -> Self {
        match err {
            crate::operation::redrive_execution::RedriveExecutionError::ExecutionDoesNotExist(inner) => Error::ExecutionDoesNotExist(inner),
            crate::operation::redrive_execution::RedriveExecutionError::ExecutionLimitExceeded(inner) => Error::ExecutionLimitExceeded(inner),
            crate::operation::redrive_execution::RedriveExecutionError::ExecutionNotRedrivable(inner) => Error::ExecutionNotRedrivable(inner),
            crate::operation::redrive_execution::RedriveExecutionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::redrive_execution::RedriveExecutionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::send_task_failure::SendTaskFailureError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::send_task_failure::SendTaskFailureError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::send_task_failure::SendTaskFailureError> for Error {
    fn from(err: crate::operation::send_task_failure::SendTaskFailureError) -> Self {
        match err {
            crate::operation::send_task_failure::SendTaskFailureError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::send_task_failure::SendTaskFailureError::TaskDoesNotExist(inner) => Error::TaskDoesNotExist(inner),
            crate::operation::send_task_failure::SendTaskFailureError::TaskTimedOut(inner) => Error::TaskTimedOut(inner),
            crate::operation::send_task_failure::SendTaskFailureError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::send_task_heartbeat::SendTaskHeartbeatError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::send_task_heartbeat::SendTaskHeartbeatError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::send_task_heartbeat::SendTaskHeartbeatError> for Error {
    fn from(err: crate::operation::send_task_heartbeat::SendTaskHeartbeatError) -> Self {
        match err {
            crate::operation::send_task_heartbeat::SendTaskHeartbeatError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::send_task_heartbeat::SendTaskHeartbeatError::TaskDoesNotExist(inner) => Error::TaskDoesNotExist(inner),
            crate::operation::send_task_heartbeat::SendTaskHeartbeatError::TaskTimedOut(inner) => Error::TaskTimedOut(inner),
            crate::operation::send_task_heartbeat::SendTaskHeartbeatError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::send_task_success::SendTaskSuccessError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::send_task_success::SendTaskSuccessError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::send_task_success::SendTaskSuccessError> for Error {
    fn from(err: crate::operation::send_task_success::SendTaskSuccessError) -> Self {
        match err {
            crate::operation::send_task_success::SendTaskSuccessError::InvalidOutput(inner) => Error::InvalidOutput(inner),
            crate::operation::send_task_success::SendTaskSuccessError::InvalidToken(inner) => Error::InvalidToken(inner),
            crate::operation::send_task_success::SendTaskSuccessError::TaskDoesNotExist(inner) => Error::TaskDoesNotExist(inner),
            crate::operation::send_task_success::SendTaskSuccessError::TaskTimedOut(inner) => Error::TaskTimedOut(inner),
            crate::operation::send_task_success::SendTaskSuccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::start_execution::StartExecutionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::start_execution::StartExecutionError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::start_execution::StartExecutionError> for Error {
    fn from(err: crate::operation::start_execution::StartExecutionError) -> Self {
        match err {
            crate::operation::start_execution::StartExecutionError::ExecutionAlreadyExists(inner) => Error::ExecutionAlreadyExists(inner),
            crate::operation::start_execution::StartExecutionError::ExecutionLimitExceeded(inner) => Error::ExecutionLimitExceeded(inner),
            crate::operation::start_execution::StartExecutionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::start_execution::StartExecutionError::InvalidExecutionInput(inner) => Error::InvalidExecutionInput(inner),
            crate::operation::start_execution::StartExecutionError::InvalidName(inner) => Error::InvalidName(inner),
            crate::operation::start_execution::StartExecutionError::StateMachineDeleting(inner) => Error::StateMachineDeleting(inner),
            crate::operation::start_execution::StartExecutionError::StateMachineDoesNotExist(inner) => Error::StateMachineDoesNotExist(inner),
            crate::operation::start_execution::StartExecutionError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::start_execution::StartExecutionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::start_sync_execution::StartSyncExecutionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::start_sync_execution::StartSyncExecutionError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::start_sync_execution::StartSyncExecutionError> for Error {
    fn from(err: crate::operation::start_sync_execution::StartSyncExecutionError) -> Self {
        match err {
            crate::operation::start_sync_execution::StartSyncExecutionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::start_sync_execution::StartSyncExecutionError::InvalidExecutionInput(inner) => Error::InvalidExecutionInput(inner),
            crate::operation::start_sync_execution::StartSyncExecutionError::InvalidName(inner) => Error::InvalidName(inner),
            crate::operation::start_sync_execution::StartSyncExecutionError::StateMachineDeleting(inner) => Error::StateMachineDeleting(inner),
            crate::operation::start_sync_execution::StartSyncExecutionError::StateMachineDoesNotExist(inner) => {
                Error::StateMachineDoesNotExist(inner)
            }
            crate::operation::start_sync_execution::StartSyncExecutionError::StateMachineTypeNotSupported(inner) => {
                Error::StateMachineTypeNotSupported(inner)
            }
            crate::operation::start_sync_execution::StartSyncExecutionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::stop_execution::StopExecutionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::stop_execution::StopExecutionError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::stop_execution::StopExecutionError> for Error {
    fn from(err: crate::operation::stop_execution::StopExecutionError) -> Self {
        match err {
            crate::operation::stop_execution::StopExecutionError::ExecutionDoesNotExist(inner) => Error::ExecutionDoesNotExist(inner),
            crate::operation::stop_execution::StopExecutionError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::stop_execution::StopExecutionError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::stop_execution::StopExecutionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::tag_resource::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::tag_resource::TagResourceError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::tag_resource::TagResourceError> for Error {
    fn from(err: crate::operation::tag_resource::TagResourceError) -> Self {
        match err {
            crate::operation::tag_resource::TagResourceError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::tag_resource::TagResourceError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::tag_resource::TagResourceError::TooManyTags(inner) => Error::TooManyTags(inner),
            crate::operation::tag_resource::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::test_state::TestStateError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::test_state::TestStateError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::test_state::TestStateError> for Error {
    fn from(err: crate::operation::test_state::TestStateError) -> Self {
        match err {
            crate::operation::test_state::TestStateError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::test_state::TestStateError::InvalidDefinition(inner) => Error::InvalidDefinition(inner),
            crate::operation::test_state::TestStateError::InvalidExecutionInput(inner) => Error::InvalidExecutionInput(inner),
            crate::operation::test_state::TestStateError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::test_state::TestStateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::untag_resource::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::untag_resource::UntagResourceError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::untag_resource::UntagResourceError> for Error {
    fn from(err: crate::operation::untag_resource::UntagResourceError) -> Self {
        match err {
            crate::operation::untag_resource::UntagResourceError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::untag_resource::UntagResourceError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::untag_resource::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::update_map_run::UpdateMapRunError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::update_map_run::UpdateMapRunError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::update_map_run::UpdateMapRunError> for Error {
    fn from(err: crate::operation::update_map_run::UpdateMapRunError) -> Self {
        match err {
            crate::operation::update_map_run::UpdateMapRunError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::update_map_run::UpdateMapRunError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::update_map_run::UpdateMapRunError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::update_map_run::UpdateMapRunError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::update_state_machine::UpdateStateMachineError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::update_state_machine::UpdateStateMachineError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::update_state_machine::UpdateStateMachineError> for Error {
    fn from(err: crate::operation::update_state_machine::UpdateStateMachineError) -> Self {
        match err {
            crate::operation::update_state_machine::UpdateStateMachineError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::update_state_machine::UpdateStateMachineError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::update_state_machine::UpdateStateMachineError::InvalidDefinition(inner) => Error::InvalidDefinition(inner),
            crate::operation::update_state_machine::UpdateStateMachineError::InvalidLoggingConfiguration(inner) => {
                Error::InvalidLoggingConfiguration(inner)
            }
            crate::operation::update_state_machine::UpdateStateMachineError::InvalidTracingConfiguration(inner) => {
                Error::InvalidTracingConfiguration(inner)
            }
            crate::operation::update_state_machine::UpdateStateMachineError::MissingRequiredParameter(inner) => {
                Error::MissingRequiredParameter(inner)
            }
            crate::operation::update_state_machine::UpdateStateMachineError::ServiceQuotaExceededException(inner) => {
                Error::ServiceQuotaExceededException(inner)
            }
            crate::operation::update_state_machine::UpdateStateMachineError::StateMachineDeleting(inner) => Error::StateMachineDeleting(inner),
            crate::operation::update_state_machine::UpdateStateMachineError::StateMachineDoesNotExist(inner) => {
                Error::StateMachineDoesNotExist(inner)
            }
            crate::operation::update_state_machine::UpdateStateMachineError::ValidationException(inner) => Error::ValidationException(inner),
            crate::operation::update_state_machine::UpdateStateMachineError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::update_state_machine_alias::UpdateStateMachineAliasError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::update_state_machine_alias::UpdateStateMachineAliasError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::update_state_machine_alias::UpdateStateMachineAliasError> for Error {
    fn from(err: crate::operation::update_state_machine_alias::UpdateStateMachineAliasError) -> Self {
        match err {
            crate::operation::update_state_machine_alias::UpdateStateMachineAliasError::ConflictException(inner) => Error::ConflictException(inner),
            crate::operation::update_state_machine_alias::UpdateStateMachineAliasError::InvalidArn(inner) => Error::InvalidArn(inner),
            crate::operation::update_state_machine_alias::UpdateStateMachineAliasError::ResourceNotFound(inner) => Error::ResourceNotFound(inner),
            crate::operation::update_state_machine_alias::UpdateStateMachineAliasError::StateMachineDeleting(inner) => {
                Error::StateMachineDeleting(inner)
            }
            crate::operation::update_state_machine_alias::UpdateStateMachineAliasError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::operation::update_state_machine_alias::UpdateStateMachineAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl ::std::error::Error for Error {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Error::ActivityDoesNotExist(inner) => inner.source(),
            Error::ActivityLimitExceeded(inner) => inner.source(),
            Error::ActivityWorkerLimitExceeded(inner) => inner.source(),
            Error::ConflictException(inner) => inner.source(),
            Error::ExecutionAlreadyExists(inner) => inner.source(),
            Error::ExecutionDoesNotExist(inner) => inner.source(),
            Error::ExecutionLimitExceeded(inner) => inner.source(),
            Error::ExecutionNotRedrivable(inner) => inner.source(),
            Error::InvalidArn(inner) => inner.source(),
            Error::InvalidDefinition(inner) => inner.source(),
            Error::InvalidExecutionInput(inner) => inner.source(),
            Error::InvalidLoggingConfiguration(inner) => inner.source(),
            Error::InvalidName(inner) => inner.source(),
            Error::InvalidOutput(inner) => inner.source(),
            Error::InvalidToken(inner) => inner.source(),
            Error::InvalidTracingConfiguration(inner) => inner.source(),
            Error::MissingRequiredParameter(inner) => inner.source(),
            Error::ResourceNotFound(inner) => inner.source(),
            Error::ServiceQuotaExceededException(inner) => inner.source(),
            Error::StateMachineAlreadyExists(inner) => inner.source(),
            Error::StateMachineDeleting(inner) => inner.source(),
            Error::StateMachineDoesNotExist(inner) => inner.source(),
            Error::StateMachineLimitExceeded(inner) => inner.source(),
            Error::StateMachineTypeNotSupported(inner) => inner.source(),
            Error::TaskDoesNotExist(inner) => inner.source(),
            Error::TaskTimedOut(inner) => inner.source(),
            Error::TooManyTags(inner) => inner.source(),
            Error::ValidationException(inner) => inner.source(),
            Error::Unhandled(inner) => ::std::option::Option::Some(&*inner.source),
        }
    }
}
impl ::aws_types::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::ActivityDoesNotExist(e) => e.request_id(),
            Self::ActivityLimitExceeded(e) => e.request_id(),
            Self::ActivityWorkerLimitExceeded(e) => e.request_id(),
            Self::ConflictException(e) => e.request_id(),
            Self::ExecutionAlreadyExists(e) => e.request_id(),
            Self::ExecutionDoesNotExist(e) => e.request_id(),
            Self::ExecutionLimitExceeded(e) => e.request_id(),
            Self::ExecutionNotRedrivable(e) => e.request_id(),
            Self::InvalidArn(e) => e.request_id(),
            Self::InvalidDefinition(e) => e.request_id(),
            Self::InvalidExecutionInput(e) => e.request_id(),
            Self::InvalidLoggingConfiguration(e) => e.request_id(),
            Self::InvalidName(e) => e.request_id(),
            Self::InvalidOutput(e) => e.request_id(),
            Self::InvalidToken(e) => e.request_id(),
            Self::InvalidTracingConfiguration(e) => e.request_id(),
            Self::MissingRequiredParameter(e) => e.request_id(),
            Self::ResourceNotFound(e) => e.request_id(),
            Self::ServiceQuotaExceededException(e) => e.request_id(),
            Self::StateMachineAlreadyExists(e) => e.request_id(),
            Self::StateMachineDeleting(e) => e.request_id(),
            Self::StateMachineDoesNotExist(e) => e.request_id(),
            Self::StateMachineLimitExceeded(e) => e.request_id(),
            Self::StateMachineTypeNotSupported(e) => e.request_id(),
            Self::TaskDoesNotExist(e) => e.request_id(),
            Self::TaskTimedOut(e) => e.request_id(),
            Self::TooManyTags(e) => e.request_id(),
            Self::ValidationException(e) => e.request_id(),
            Self::Unhandled(e) => e.meta.request_id(),
        }
    }
}
