// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Field {
    /// <p>An array of values.</p>
    #[serde(rename = "arrayValue")]
    ArrayValue(crate::model::ArrayValue),
    /// <p>A value of BLOB data type.</p>
    #[serde(rename = "blobValue")]
    #[serde(deserialize_with = "crate::serde_util::smithytypesblob_deser")]
    BlobValue(smithy_types::Blob),
    /// <p>A value of Boolean data type.</p>
    #[serde(rename = "booleanValue")]
    BooleanValue(bool),
    /// <p>A value of double data type.</p>
    #[serde(rename = "doubleValue")]
    DoubleValue(f64),
    /// <p>A NULL value.</p>
    #[serde(rename = "isNull")]
    IsNull(bool),
    /// <p>A value of long data type.</p>
    #[serde(rename = "longValue")]
    LongValue(i64),
    /// <p>A value of string data type.</p>
    #[serde(rename = "stringValue")]
    StringValue(std::string::String),
}
impl Field {
    pub fn as_array_value(&self) -> Option<&crate::model::ArrayValue> {
        if let Field::ArrayValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_array_value(&self) -> bool {
        self.as_array_value().is_some()
    }
    pub fn as_blob_value(&self) -> Option<&smithy_types::Blob> {
        if let Field::BlobValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_blob_value(&self) -> bool {
        self.as_blob_value().is_some()
    }
    pub fn as_boolean_value(&self) -> Option<&bool> {
        if let Field::BooleanValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_boolean_value(&self) -> bool {
        self.as_boolean_value().is_some()
    }
    pub fn as_double_value(&self) -> Option<&f64> {
        if let Field::DoubleValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_double_value(&self) -> bool {
        self.as_double_value().is_some()
    }
    pub fn as_is_null(&self) -> Option<&bool> {
        if let Field::IsNull(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_is_null(&self) -> bool {
        self.as_is_null().is_some()
    }
    pub fn as_long_value(&self) -> Option<&i64> {
        if let Field::LongValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_long_value(&self) -> bool {
        self.as_long_value().is_some()
    }
    pub fn as_string_value(&self) -> Option<&std::string::String> {
        if let Field::StringValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_some()
    }
}

#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum ArrayValue {
    /// <p>An array of arrays.</p>
    #[serde(rename = "arrayValues")]
    ArrayValues(std::vec::Vec<crate::model::ArrayValue>),
    /// <p>An array of Boolean values.</p>
    #[serde(rename = "booleanValues")]
    BooleanValues(std::vec::Vec<bool>),
    /// <p>An array of integers.</p>
    #[serde(rename = "doubleValues")]
    DoubleValues(std::vec::Vec<f64>),
    /// <p>An array of floating point numbers.</p>
    #[serde(rename = "longValues")]
    LongValues(std::vec::Vec<i64>),
    /// <p>An array of strings.</p>
    #[serde(rename = "stringValues")]
    StringValues(std::vec::Vec<std::string::String>),
}
impl ArrayValue {
    pub fn as_array_values(&self) -> Option<&std::vec::Vec<crate::model::ArrayValue>> {
        if let ArrayValue::ArrayValues(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_array_values(&self) -> bool {
        self.as_array_values().is_some()
    }
    pub fn as_boolean_values(&self) -> Option<&std::vec::Vec<bool>> {
        if let ArrayValue::BooleanValues(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_boolean_values(&self) -> bool {
        self.as_boolean_values().is_some()
    }
    pub fn as_double_values(&self) -> Option<&std::vec::Vec<f64>> {
        if let ArrayValue::DoubleValues(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_double_values(&self) -> bool {
        self.as_double_values().is_some()
    }
    pub fn as_long_values(&self) -> Option<&std::vec::Vec<i64>> {
        if let ArrayValue::LongValues(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_long_values(&self) -> bool {
        self.as_long_values().is_some()
    }
    pub fn as_string_values(&self) -> Option<&std::vec::Vec<std::string::String>> {
        if let ArrayValue::StringValues(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_string_values(&self) -> bool {
        self.as_string_values().is_some()
    }
}

/// <p>Contains the metadata for a column.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ColumnMetadata {
    /// <p>The name of the column.</p>
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the column.</p>
    #[serde(rename = "type")]
    #[serde(default)]
    pub r#type: i32,
    /// <p>The database-specific data type of the column.</p>
    #[serde(rename = "typeName")]
    #[serde(default)]
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The label for the column.</p>
    #[serde(rename = "label")]
    #[serde(default)]
    pub label: std::option::Option<std::string::String>,
    /// <p>The name of the schema that owns the table that includes the column.</p>
    #[serde(rename = "schemaName")]
    #[serde(default)]
    pub schema_name: std::option::Option<std::string::String>,
    /// <p>The name of the table that includes the column.</p>
    #[serde(rename = "tableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A value that indicates whether the column increments automatically.</p>
    #[serde(rename = "isAutoIncrement")]
    #[serde(default)]
    pub is_auto_increment: bool,
    /// <p>A value that indicates whether an integer column is signed.</p>
    #[serde(rename = "isSigned")]
    #[serde(default)]
    pub is_signed: bool,
    /// <p>A value that indicates whether the column contains currency values.</p>
    #[serde(rename = "isCurrency")]
    #[serde(default)]
    pub is_currency: bool,
    /// <p>A value that indicates whether the column is case-sensitive.</p>
    #[serde(rename = "isCaseSensitive")]
    #[serde(default)]
    pub is_case_sensitive: bool,
    /// <p>A value that indicates whether the column is nullable.</p>
    #[serde(rename = "nullable")]
    #[serde(default)]
    pub nullable: i32,
    /// <p>The precision value of a decimal number column.</p>
    #[serde(rename = "precision")]
    #[serde(default)]
    pub precision: i32,
    /// <p>The scale value of a decimal number column.</p>
    #[serde(rename = "scale")]
    #[serde(default)]
    pub scale: i32,
    /// <p>The type of the column.</p>
    #[serde(rename = "arrayBaseColumnType")]
    #[serde(default)]
    pub array_base_column_type: i32,
}
impl std::fmt::Debug for ColumnMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ColumnMetadata");
        formatter.field("name", &self.name);
        formatter.field("r#type", &self.r#type);
        formatter.field("type_name", &self.type_name);
        formatter.field("label", &self.label);
        formatter.field("schema_name", &self.schema_name);
        formatter.field("table_name", &self.table_name);
        formatter.field("is_auto_increment", &self.is_auto_increment);
        formatter.field("is_signed", &self.is_signed);
        formatter.field("is_currency", &self.is_currency);
        formatter.field("is_case_sensitive", &self.is_case_sensitive);
        formatter.field("nullable", &self.nullable);
        formatter.field("precision", &self.precision);
        formatter.field("scale", &self.scale);
        formatter.field("array_base_column_type", &self.array_base_column_type);
        formatter.finish()
    }
}
/// See [`ColumnMetadata`](crate::model::ColumnMetadata)
pub mod column_metadata {
    /// A builder for [`ColumnMetadata`](crate::model::ColumnMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<i32>,
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) label: std::option::Option<std::string::String>,
        pub(crate) schema_name: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) is_auto_increment: std::option::Option<bool>,
        pub(crate) is_signed: std::option::Option<bool>,
        pub(crate) is_currency: std::option::Option<bool>,
        pub(crate) is_case_sensitive: std::option::Option<bool>,
        pub(crate) nullable: std::option::Option<i32>,
        pub(crate) precision: std::option::Option<i32>,
        pub(crate) scale: std::option::Option<i32>,
        pub(crate) array_base_column_type: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the column.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>The type of the column.</p>
        pub fn r#type(mut self, inp: i32) -> Self {
            self.r#type = Some(inp);
            self
        }
        pub fn set_type(mut self, inp: i32) -> Self {
            self.r#type = Some(inp);
            self
        }
        /// <p>The database-specific data type of the column.</p>
        pub fn type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.type_name = Some(inp.into());
            self
        }
        pub fn set_type_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.type_name = inp;
            self
        }
        /// <p>The label for the column.</p>
        pub fn label(mut self, inp: impl Into<std::string::String>) -> Self {
            self.label = Some(inp.into());
            self
        }
        pub fn set_label(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.label = inp;
            self
        }
        /// <p>The name of the schema that owns the table that includes the column.</p>
        pub fn schema_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.schema_name = Some(inp.into());
            self
        }
        pub fn set_schema_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.schema_name = inp;
            self
        }
        /// <p>The name of the table that includes the column.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>A value that indicates whether the column increments automatically.</p>
        pub fn is_auto_increment(mut self, inp: bool) -> Self {
            self.is_auto_increment = Some(inp);
            self
        }
        pub fn set_is_auto_increment(mut self, inp: bool) -> Self {
            self.is_auto_increment = Some(inp);
            self
        }
        /// <p>A value that indicates whether an integer column is signed.</p>
        pub fn is_signed(mut self, inp: bool) -> Self {
            self.is_signed = Some(inp);
            self
        }
        pub fn set_is_signed(mut self, inp: bool) -> Self {
            self.is_signed = Some(inp);
            self
        }
        /// <p>A value that indicates whether the column contains currency values.</p>
        pub fn is_currency(mut self, inp: bool) -> Self {
            self.is_currency = Some(inp);
            self
        }
        pub fn set_is_currency(mut self, inp: bool) -> Self {
            self.is_currency = Some(inp);
            self
        }
        /// <p>A value that indicates whether the column is case-sensitive.</p>
        pub fn is_case_sensitive(mut self, inp: bool) -> Self {
            self.is_case_sensitive = Some(inp);
            self
        }
        pub fn set_is_case_sensitive(mut self, inp: bool) -> Self {
            self.is_case_sensitive = Some(inp);
            self
        }
        /// <p>A value that indicates whether the column is nullable.</p>
        pub fn nullable(mut self, inp: i32) -> Self {
            self.nullable = Some(inp);
            self
        }
        pub fn set_nullable(mut self, inp: i32) -> Self {
            self.nullable = Some(inp);
            self
        }
        /// <p>The precision value of a decimal number column.</p>
        pub fn precision(mut self, inp: i32) -> Self {
            self.precision = Some(inp);
            self
        }
        pub fn set_precision(mut self, inp: i32) -> Self {
            self.precision = Some(inp);
            self
        }
        /// <p>The scale value of a decimal number column.</p>
        pub fn scale(mut self, inp: i32) -> Self {
            self.scale = Some(inp);
            self
        }
        pub fn set_scale(mut self, inp: i32) -> Self {
            self.scale = Some(inp);
            self
        }
        /// <p>The type of the column.</p>
        pub fn array_base_column_type(mut self, inp: i32) -> Self {
            self.array_base_column_type = Some(inp);
            self
        }
        pub fn set_array_base_column_type(mut self, inp: i32) -> Self {
            self.array_base_column_type = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`ColumnMetadata`](crate::model::ColumnMetadata)
        pub fn build(self) -> crate::model::ColumnMetadata {
            crate::model::ColumnMetadata {
                name: self.name,
                r#type: self.r#type.unwrap_or_default(),
                type_name: self.type_name,
                label: self.label,
                schema_name: self.schema_name,
                table_name: self.table_name,
                is_auto_increment: self.is_auto_increment.unwrap_or_default(),
                is_signed: self.is_signed.unwrap_or_default(),
                is_currency: self.is_currency.unwrap_or_default(),
                is_case_sensitive: self.is_case_sensitive.unwrap_or_default(),
                nullable: self.nullable.unwrap_or_default(),
                precision: self.precision.unwrap_or_default(),
                scale: self.scale.unwrap_or_default(),
                array_base_column_type: self.array_base_column_type.unwrap_or_default(),
            }
        }
    }
}
impl ColumnMetadata {
    /// Creates a new builder-style object to manufacture [`ColumnMetadata`](crate::model::ColumnMetadata)
    pub fn builder() -> crate::model::column_metadata::Builder {
        crate::model::column_metadata::Builder::default()
    }
}

/// <p>Options that control how the result set is returned.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultSetOptions {
    /// <p>A value that indicates how a field of <code>DECIMAL</code> type is represented
    /// in the response. The value of <code>STRING</code>, the default, specifies that
    /// it is converted to a String value. The value of <code>DOUBLE_OR_LONG</code>
    /// specifies that it is converted to a Long value if its scale is 0, or to a Double
    /// value otherwise.</p>
    /// <important>
    /// <p>Conversion to Double or Long can result in roundoff errors due to precision loss.
    /// We recommend converting to String, especially when working with currency values.</p>
    /// </important>
    #[serde(rename = "decimalReturnType")]
    #[serde(default)]
    pub decimal_return_type: std::option::Option<crate::model::DecimalReturnType>,
}
impl std::fmt::Debug for ResultSetOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultSetOptions");
        formatter.field("decimal_return_type", &self.decimal_return_type);
        formatter.finish()
    }
}
/// See [`ResultSetOptions`](crate::model::ResultSetOptions)
pub mod result_set_options {
    /// A builder for [`ResultSetOptions`](crate::model::ResultSetOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) decimal_return_type: std::option::Option<crate::model::DecimalReturnType>,
    }
    impl Builder {
        /// <p>A value that indicates how a field of <code>DECIMAL</code> type is represented
        /// in the response. The value of <code>STRING</code>, the default, specifies that
        /// it is converted to a String value. The value of <code>DOUBLE_OR_LONG</code>
        /// specifies that it is converted to a Long value if its scale is 0, or to a Double
        /// value otherwise.</p>
        /// <important>
        /// <p>Conversion to Double or Long can result in roundoff errors due to precision loss.
        /// We recommend converting to String, especially when working with currency values.</p>
        /// </important>
        pub fn decimal_return_type(mut self, inp: crate::model::DecimalReturnType) -> Self {
            self.decimal_return_type = Some(inp);
            self
        }
        pub fn set_decimal_return_type(
            mut self,
            inp: std::option::Option<crate::model::DecimalReturnType>,
        ) -> Self {
            self.decimal_return_type = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResultSetOptions`](crate::model::ResultSetOptions)
        pub fn build(self) -> crate::model::ResultSetOptions {
            crate::model::ResultSetOptions {
                decimal_return_type: self.decimal_return_type,
            }
        }
    }
}
impl ResultSetOptions {
    /// Creates a new builder-style object to manufacture [`ResultSetOptions`](crate::model::ResultSetOptions)
    pub fn builder() -> crate::model::result_set_options::Builder {
        crate::model::result_set_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DecimalReturnType {
    DoubleOrLong,
    String,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DecimalReturnType {
    fn from(s: &str) -> Self {
        match s {
            "DOUBLE_OR_LONG" => DecimalReturnType::DoubleOrLong,
            "STRING" => DecimalReturnType::String,
            other => DecimalReturnType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DecimalReturnType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DecimalReturnType::from(s))
    }
}
impl DecimalReturnType {
    pub fn as_str(&self) -> &str {
        match self {
            DecimalReturnType::DoubleOrLong => "DOUBLE_OR_LONG",
            DecimalReturnType::String => "STRING",
            DecimalReturnType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DecimalReturnType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DecimalReturnType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A parameter used in a SQL statement.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlParameter {
    /// <p>The name of the parameter.</p>
    #[serde(rename = "name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the parameter.</p>
    #[serde(rename = "value")]
    #[serde(default)]
    pub value: std::option::Option<crate::model::Field>,
    /// <p>A hint that specifies the correct object type for data type mapping. Possible values
    /// are as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DATE</code> - The corresponding <code>String</code> parameter value is sent as an object
    /// of <code>DATE</code> type to the database. The accepted format is <code>YYYY-MM-DD</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DECIMAL</code> - The corresponding <code>String</code> parameter value is sent as an object
    /// of <code>DECIMAL</code> type to the database.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>JSON</code> - The corresponding <code>String</code> parameter value is sent as an
    /// object of <code>JSON</code> type to the database.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TIME</code> - The corresponding <code>String</code> parameter value is sent as an object
    /// of <code>TIME</code> type to the database. The accepted format is <code>HH:MM:SS[.FFF]</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TIMESTAMP</code> - The corresponding <code>String</code> parameter value is sent as an object
    /// of <code>TIMESTAMP</code> type to the database. The accepted format is <code>YYYY-MM-DD HH:MM:SS[.FFF]</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UUID</code> - The corresponding <code>String</code> parameter value is sent as an object of
    /// <code>UUID</code> type to the database.
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "typeHint")]
    #[serde(default)]
    pub type_hint: std::option::Option<crate::model::TypeHint>,
}
impl std::fmt::Debug for SqlParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlParameter");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.field("type_hint", &self.type_hint);
        formatter.finish()
    }
}
/// See [`SqlParameter`](crate::model::SqlParameter)
pub mod sql_parameter {
    /// A builder for [`SqlParameter`](crate::model::SqlParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::Field>,
        pub(crate) type_hint: std::option::Option<crate::model::TypeHint>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>The value of the parameter.</p>
        pub fn value(mut self, inp: crate::model::Field) -> Self {
            self.value = Some(inp);
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<crate::model::Field>) -> Self {
            self.value = inp;
            self
        }
        /// <p>A hint that specifies the correct object type for data type mapping. Possible values
        /// are as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DATE</code> - The corresponding <code>String</code> parameter value is sent as an object
        /// of <code>DATE</code> type to the database. The accepted format is <code>YYYY-MM-DD</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DECIMAL</code> - The corresponding <code>String</code> parameter value is sent as an object
        /// of <code>DECIMAL</code> type to the database.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>JSON</code> - The corresponding <code>String</code> parameter value is sent as an
        /// object of <code>JSON</code> type to the database.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TIME</code> - The corresponding <code>String</code> parameter value is sent as an object
        /// of <code>TIME</code> type to the database. The accepted format is <code>HH:MM:SS[.FFF]</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TIMESTAMP</code> - The corresponding <code>String</code> parameter value is sent as an object
        /// of <code>TIMESTAMP</code> type to the database. The accepted format is <code>YYYY-MM-DD HH:MM:SS[.FFF]</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UUID</code> - The corresponding <code>String</code> parameter value is sent as an object of
        /// <code>UUID</code> type to the database.
        /// </p>
        /// </li>
        /// </ul>
        pub fn type_hint(mut self, inp: crate::model::TypeHint) -> Self {
            self.type_hint = Some(inp);
            self
        }
        pub fn set_type_hint(mut self, inp: std::option::Option<crate::model::TypeHint>) -> Self {
            self.type_hint = inp;
            self
        }
        /// Consumes the builder and constructs a [`SqlParameter`](crate::model::SqlParameter)
        pub fn build(self) -> crate::model::SqlParameter {
            crate::model::SqlParameter {
                name: self.name,
                value: self.value,
                type_hint: self.type_hint,
            }
        }
    }
}
impl SqlParameter {
    /// Creates a new builder-style object to manufacture [`SqlParameter`](crate::model::SqlParameter)
    pub fn builder() -> crate::model::sql_parameter::Builder {
        crate::model::sql_parameter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TypeHint {
    Date,
    Decimal,
    Json,
    Time,
    Timestamp,
    Uuid,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TypeHint {
    fn from(s: &str) -> Self {
        match s {
            "DATE" => TypeHint::Date,
            "DECIMAL" => TypeHint::Decimal,
            "JSON" => TypeHint::Json,
            "TIME" => TypeHint::Time,
            "TIMESTAMP" => TypeHint::Timestamp,
            "UUID" => TypeHint::Uuid,
            other => TypeHint::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TypeHint {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(TypeHint::from(s))
    }
}
impl TypeHint {
    pub fn as_str(&self) -> &str {
        match self {
            TypeHint::Date => "DATE",
            TypeHint::Decimal => "DECIMAL",
            TypeHint::Json => "JSON",
            TypeHint::Time => "TIME",
            TypeHint::Timestamp => "TIMESTAMP",
            TypeHint::Uuid => "UUID",
            TypeHint::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TypeHint {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for TypeHint {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The result of a SQL statement.</p>
/// <important>
/// <p>This data type is deprecated.</p>
/// </important>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SqlStatementResult {
    /// <p>The result set of the SQL statement.</p>
    #[serde(rename = "resultFrame")]
    #[serde(default)]
    pub result_frame: std::option::Option<crate::model::ResultFrame>,
    /// <p>The number of records updated by a SQL statement.</p>
    #[serde(rename = "numberOfRecordsUpdated")]
    #[serde(default)]
    pub number_of_records_updated: i64,
}
impl std::fmt::Debug for SqlStatementResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SqlStatementResult");
        formatter.field("result_frame", &self.result_frame);
        formatter.field("number_of_records_updated", &self.number_of_records_updated);
        formatter.finish()
    }
}
/// See [`SqlStatementResult`](crate::model::SqlStatementResult)
pub mod sql_statement_result {
    /// A builder for [`SqlStatementResult`](crate::model::SqlStatementResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_frame: std::option::Option<crate::model::ResultFrame>,
        pub(crate) number_of_records_updated: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The result set of the SQL statement.</p>
        pub fn result_frame(mut self, inp: crate::model::ResultFrame) -> Self {
            self.result_frame = Some(inp);
            self
        }
        pub fn set_result_frame(
            mut self,
            inp: std::option::Option<crate::model::ResultFrame>,
        ) -> Self {
            self.result_frame = inp;
            self
        }
        /// <p>The number of records updated by a SQL statement.</p>
        pub fn number_of_records_updated(mut self, inp: i64) -> Self {
            self.number_of_records_updated = Some(inp);
            self
        }
        pub fn set_number_of_records_updated(mut self, inp: i64) -> Self {
            self.number_of_records_updated = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`SqlStatementResult`](crate::model::SqlStatementResult)
        pub fn build(self) -> crate::model::SqlStatementResult {
            crate::model::SqlStatementResult {
                result_frame: self.result_frame,
                number_of_records_updated: self.number_of_records_updated.unwrap_or_default(),
            }
        }
    }
}
impl SqlStatementResult {
    /// Creates a new builder-style object to manufacture [`SqlStatementResult`](crate::model::SqlStatementResult)
    pub fn builder() -> crate::model::sql_statement_result::Builder {
        crate::model::sql_statement_result::Builder::default()
    }
}

/// <p>The result set returned by a SQL statement.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultFrame {
    /// <p>The result-set metadata in the result set.</p>
    #[serde(rename = "resultSetMetadata")]
    #[serde(default)]
    pub result_set_metadata: std::option::Option<crate::model::ResultSetMetadata>,
    /// <p>The records in the result set.</p>
    #[serde(rename = "records")]
    #[serde(default)]
    pub records: std::option::Option<std::vec::Vec<crate::model::Record>>,
}
impl std::fmt::Debug for ResultFrame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultFrame");
        formatter.field("result_set_metadata", &self.result_set_metadata);
        formatter.field("records", &self.records);
        formatter.finish()
    }
}
/// See [`ResultFrame`](crate::model::ResultFrame)
pub mod result_frame {
    /// A builder for [`ResultFrame`](crate::model::ResultFrame)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_set_metadata: std::option::Option<crate::model::ResultSetMetadata>,
        pub(crate) records: std::option::Option<std::vec::Vec<crate::model::Record>>,
    }
    impl Builder {
        /// <p>The result-set metadata in the result set.</p>
        pub fn result_set_metadata(mut self, inp: crate::model::ResultSetMetadata) -> Self {
            self.result_set_metadata = Some(inp);
            self
        }
        pub fn set_result_set_metadata(
            mut self,
            inp: std::option::Option<crate::model::ResultSetMetadata>,
        ) -> Self {
            self.result_set_metadata = inp;
            self
        }
        pub fn records(mut self, inp: impl Into<crate::model::Record>) -> Self {
            let mut v = self.records.unwrap_or_default();
            v.push(inp.into());
            self.records = Some(v);
            self
        }
        pub fn set_records(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Record>>,
        ) -> Self {
            self.records = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResultFrame`](crate::model::ResultFrame)
        pub fn build(self) -> crate::model::ResultFrame {
            crate::model::ResultFrame {
                result_set_metadata: self.result_set_metadata,
                records: self.records,
            }
        }
    }
}
impl ResultFrame {
    /// Creates a new builder-style object to manufacture [`ResultFrame`](crate::model::ResultFrame)
    pub fn builder() -> crate::model::result_frame::Builder {
        crate::model::result_frame::Builder::default()
    }
}

/// <p>A record returned by a call.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Record {
    /// <p>The values returned in the record.</p>
    #[serde(rename = "values")]
    #[serde(default)]
    pub values: std::option::Option<std::vec::Vec<crate::model::Value>>,
}
impl std::fmt::Debug for Record {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Record");
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Record`](crate::model::Record)
pub mod record {
    /// A builder for [`Record`](crate::model::Record)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::Value>>,
    }
    impl Builder {
        pub fn values(mut self, inp: impl Into<crate::model::Value>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(inp.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Value>>,
        ) -> Self {
            self.values = inp;
            self
        }
        /// Consumes the builder and constructs a [`Record`](crate::model::Record)
        pub fn build(self) -> crate::model::Record {
            crate::model::Record {
                values: self.values,
            }
        }
    }
}
impl Record {
    /// Creates a new builder-style object to manufacture [`Record`](crate::model::Record)
    pub fn builder() -> crate::model::record::Builder {
        crate::model::record::Builder::default()
    }
}

#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Value {
    /// <p>An array of column values.</p>
    #[serde(rename = "arrayValues")]
    ArrayValues(std::vec::Vec<crate::model::Value>),
    /// <p>A value for a column of big integer data type.</p>
    #[serde(rename = "bigIntValue")]
    BigIntValue(i64),
    /// <p>A value for a column of BIT data type.</p>
    #[serde(rename = "bitValue")]
    BitValue(bool),
    /// <p>A value for a column of BLOB data type.</p>
    #[serde(rename = "blobValue")]
    #[serde(deserialize_with = "crate::serde_util::smithytypesblob_deser")]
    BlobValue(smithy_types::Blob),
    /// <p>A value for a column of double data type.</p>
    #[serde(rename = "doubleValue")]
    DoubleValue(f64),
    /// <p>A value for a column of integer data type.</p>
    #[serde(rename = "intValue")]
    IntValue(i32),
    /// <p>A NULL value.</p>
    #[serde(rename = "isNull")]
    IsNull(bool),
    /// <p>A value for a column of real data type.</p>
    #[serde(rename = "realValue")]
    RealValue(f32),
    /// <p>A value for a column of string data type.</p>
    #[serde(rename = "stringValue")]
    StringValue(std::string::String),
    /// <p>A value for a column of STRUCT data type.</p>
    #[serde(rename = "structValue")]
    StructValue(crate::model::StructValue),
}
impl Value {
    pub fn as_array_values(&self) -> Option<&std::vec::Vec<crate::model::Value>> {
        if let Value::ArrayValues(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_array_values(&self) -> bool {
        self.as_array_values().is_some()
    }
    pub fn as_big_int_value(&self) -> Option<&i64> {
        if let Value::BigIntValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_big_int_value(&self) -> bool {
        self.as_big_int_value().is_some()
    }
    pub fn as_bit_value(&self) -> Option<&bool> {
        if let Value::BitValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_bit_value(&self) -> bool {
        self.as_bit_value().is_some()
    }
    pub fn as_blob_value(&self) -> Option<&smithy_types::Blob> {
        if let Value::BlobValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_blob_value(&self) -> bool {
        self.as_blob_value().is_some()
    }
    pub fn as_double_value(&self) -> Option<&f64> {
        if let Value::DoubleValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_double_value(&self) -> bool {
        self.as_double_value().is_some()
    }
    pub fn as_int_value(&self) -> Option<&i32> {
        if let Value::IntValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_int_value(&self) -> bool {
        self.as_int_value().is_some()
    }
    pub fn as_is_null(&self) -> Option<&bool> {
        if let Value::IsNull(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_is_null(&self) -> bool {
        self.as_is_null().is_some()
    }
    pub fn as_real_value(&self) -> Option<&f32> {
        if let Value::RealValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_real_value(&self) -> bool {
        self.as_real_value().is_some()
    }
    pub fn as_string_value(&self) -> Option<&std::string::String> {
        if let Value::StringValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_some()
    }
    pub fn as_struct_value(&self) -> Option<&crate::model::StructValue> {
        if let Value::StructValue(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_struct_value(&self) -> bool {
        self.as_struct_value().is_some()
    }
}

/// <p>A structure value returned by a call.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StructValue {
    /// <p>The attributes returned in the record.</p>
    #[serde(rename = "attributes")]
    #[serde(default)]
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Value>>,
}
impl std::fmt::Debug for StructValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StructValue");
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
/// See [`StructValue`](crate::model::StructValue)
pub mod struct_value {
    /// A builder for [`StructValue`](crate::model::StructValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Value>>,
    }
    impl Builder {
        pub fn attributes(mut self, inp: impl Into<crate::model::Value>) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(inp.into());
            self.attributes = Some(v);
            self
        }
        pub fn set_attributes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Value>>,
        ) -> Self {
            self.attributes = inp;
            self
        }
        /// Consumes the builder and constructs a [`StructValue`](crate::model::StructValue)
        pub fn build(self) -> crate::model::StructValue {
            crate::model::StructValue {
                attributes: self.attributes,
            }
        }
    }
}
impl StructValue {
    /// Creates a new builder-style object to manufacture [`StructValue`](crate::model::StructValue)
    pub fn builder() -> crate::model::struct_value::Builder {
        crate::model::struct_value::Builder::default()
    }
}

/// <p>The metadata of the result set returned by a SQL statement.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultSetMetadata {
    /// <p>The number of columns in the result set.</p>
    #[serde(rename = "columnCount")]
    #[serde(default)]
    pub column_count: i64,
    /// <p>The metadata of the columns in the result set.</p>
    #[serde(rename = "columnMetadata")]
    #[serde(default)]
    pub column_metadata: std::option::Option<std::vec::Vec<crate::model::ColumnMetadata>>,
}
impl std::fmt::Debug for ResultSetMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultSetMetadata");
        formatter.field("column_count", &self.column_count);
        formatter.field("column_metadata", &self.column_metadata);
        formatter.finish()
    }
}
/// See [`ResultSetMetadata`](crate::model::ResultSetMetadata)
pub mod result_set_metadata {
    /// A builder for [`ResultSetMetadata`](crate::model::ResultSetMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) column_count: std::option::Option<i64>,
        pub(crate) column_metadata:
            std::option::Option<std::vec::Vec<crate::model::ColumnMetadata>>,
    }
    impl Builder {
        /// <p>The number of columns in the result set.</p>
        pub fn column_count(mut self, inp: i64) -> Self {
            self.column_count = Some(inp);
            self
        }
        pub fn set_column_count(mut self, inp: i64) -> Self {
            self.column_count = Some(inp);
            self
        }
        pub fn column_metadata(mut self, inp: impl Into<crate::model::ColumnMetadata>) -> Self {
            let mut v = self.column_metadata.unwrap_or_default();
            v.push(inp.into());
            self.column_metadata = Some(v);
            self
        }
        pub fn set_column_metadata(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ColumnMetadata>>,
        ) -> Self {
            self.column_metadata = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResultSetMetadata`](crate::model::ResultSetMetadata)
        pub fn build(self) -> crate::model::ResultSetMetadata {
            crate::model::ResultSetMetadata {
                column_count: self.column_count.unwrap_or_default(),
                column_metadata: self.column_metadata,
            }
        }
    }
}
impl ResultSetMetadata {
    /// Creates a new builder-style object to manufacture [`ResultSetMetadata`](crate::model::ResultSetMetadata)
    pub fn builder() -> crate::model::result_set_metadata::Builder {
        crate::model::result_set_metadata::Builder::default()
    }
}

/// <p>The response elements represent the results of an update.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateResult {
    /// <p>Values for fields generated during the request.</p>
    #[serde(rename = "generatedFields")]
    #[serde(default)]
    pub generated_fields: std::option::Option<std::vec::Vec<crate::model::Field>>,
}
impl std::fmt::Debug for UpdateResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateResult");
        formatter.field("generated_fields", &self.generated_fields);
        formatter.finish()
    }
}
/// See [`UpdateResult`](crate::model::UpdateResult)
pub mod update_result {
    /// A builder for [`UpdateResult`](crate::model::UpdateResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) generated_fields: std::option::Option<std::vec::Vec<crate::model::Field>>,
    }
    impl Builder {
        pub fn generated_fields(mut self, inp: impl Into<crate::model::Field>) -> Self {
            let mut v = self.generated_fields.unwrap_or_default();
            v.push(inp.into());
            self.generated_fields = Some(v);
            self
        }
        pub fn set_generated_fields(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Field>>,
        ) -> Self {
            self.generated_fields = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateResult`](crate::model::UpdateResult)
        pub fn build(self) -> crate::model::UpdateResult {
            crate::model::UpdateResult {
                generated_fields: self.generated_fields,
            }
        }
    }
}
impl UpdateResult {
    /// Creates a new builder-style object to manufacture [`UpdateResult`](crate::model::UpdateResult)
    pub fn builder() -> crate::model::update_result::Builder {
        crate::model::update_result::Builder::default()
    }
}
