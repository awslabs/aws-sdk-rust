// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Fluent builder constructing a request to `BatchExecuteStatement`.
///
/// <p>Runs a batch SQL statement over an array of data.</p>
/// <p>You can run bulk update and insert operations for multiple records using a DML statement with different parameter sets. Bulk operations can provide a significant performance improvement over individual insert and update operations.</p> <note>
/// <p>If a call isn't part of a transaction because it doesn't include the <code>transactionID</code> parameter, changes that result from the call are committed automatically.</p>
/// <p>There isn't a fixed upper limit on the number of parameter sets. However, the maximum size of the HTTP request submitted through the Data API is 4 MiB. If the request exceeds this limit, the Data API returns an error and doesn't process the request. This 4-MiB limit includes the size of the HTTP headers and the JSON notation in the request. Thus, the number of parameter sets that you can include depends on a combination of factors, such as the size of the SQL statement and the size of each parameter set.</p>
/// <p>The response size limit is 1 MiB. If the call returns more than 1 MiB of response data, the call is terminated.</p>
/// </note>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct BatchExecuteStatement {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::input::batch_execute_statement_input::Builder,
}
impl BatchExecuteStatement {
    /// Creates a new `BatchExecuteStatement`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::operation::customize::CustomizableOperation<
            crate::operation::BatchExecuteStatement,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::error::BatchExecuteStatementError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::operation::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::output::BatchExecuteStatementOutput,
        aws_smithy_http::result::SdkError<crate::error::BatchExecuteStatementError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.resource_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_resource_arn(input);
        self
    }
    /// <p>The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret.</p>
    /// <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
    pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.secret_arn(input.into());
        self
    }
    /// <p>The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret.</p>
    /// <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
    pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_secret_arn(input);
        self
    }
    /// <p>The SQL statement to run. Don't include a semicolon (;) at the end of the SQL statement.</p>
    pub fn sql(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.sql(input.into());
        self
    }
    /// <p>The SQL statement to run. Don't include a semicolon (;) at the end of the SQL statement.</p>
    pub fn set_sql(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_sql(input);
        self
    }
    /// <p>The name of the database.</p>
    pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.database(input.into());
        self
    }
    /// <p>The name of the database.</p>
    pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_database(input);
        self
    }
    /// <p>The name of the database schema.</p> <note>
    /// <p>Currently, the <code>schema</code> parameter isn't supported.</p>
    /// </note>
    pub fn schema(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.schema(input.into());
        self
    }
    /// <p>The name of the database schema.</p> <note>
    /// <p>Currently, the <code>schema</code> parameter isn't supported.</p>
    /// </note>
    pub fn set_schema(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_schema(input);
        self
    }
    /// Appends an item to `parameterSets`.
    ///
    /// To override the contents of this collection use [`set_parameter_sets`](Self::set_parameter_sets).
    ///
    /// <p>The parameter set for the batch operation.</p>
    /// <p>The SQL statement is executed as many times as the number of parameter sets provided. To execute a SQL statement with no parameters, use one of the following options:</p>
    /// <ul>
    /// <li> <p>Specify one or more empty parameter sets.</p> </li>
    /// <li> <p>Use the <code>ExecuteStatement</code> operation instead of the <code>BatchExecuteStatement</code> operation.</p> </li>
    /// </ul> <note>
    /// <p>Array parameters are not supported.</p>
    /// </note>
    pub fn parameter_sets(mut self, input: std::vec::Vec<crate::model::SqlParameter>) -> Self {
        self.inner = self.inner.parameter_sets(input);
        self
    }
    /// <p>The parameter set for the batch operation.</p>
    /// <p>The SQL statement is executed as many times as the number of parameter sets provided. To execute a SQL statement with no parameters, use one of the following options:</p>
    /// <ul>
    /// <li> <p>Specify one or more empty parameter sets.</p> </li>
    /// <li> <p>Use the <code>ExecuteStatement</code> operation instead of the <code>BatchExecuteStatement</code> operation.</p> </li>
    /// </ul> <note>
    /// <p>Array parameters are not supported.</p>
    /// </note>
    pub fn set_parameter_sets(
        mut self,
        input: std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::SqlParameter>>>,
    ) -> Self {
        self.inner = self.inner.set_parameter_sets(input);
        self
    }
    /// <p>The identifier of a transaction that was started by using the <code>BeginTransaction</code> operation. Specify the transaction ID of the transaction that you want to include the SQL statement in.</p>
    /// <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
    pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.transaction_id(input.into());
        self
    }
    /// <p>The identifier of a transaction that was started by using the <code>BeginTransaction</code> operation. Specify the transaction ID of the transaction that you want to include the SQL statement in.</p>
    /// <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
    pub fn set_transaction_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_transaction_id(input);
        self
    }
}

/// Fluent builder constructing a request to `BeginTransaction`.
///
/// <p>Starts a SQL transaction.</p> <note>
/// <p>A transaction can run for a maximum of 24 hours. A transaction is terminated and rolled back automatically after 24 hours.</p>
/// <p>A transaction times out if no calls use its transaction ID in three minutes. If a transaction times out before it's committed, it's rolled back automatically.</p>
/// <p>DDL statements inside a transaction cause an implicit commit. We recommend that you run each DDL statement in a separate <code>ExecuteStatement</code> call with <code>continueAfterTimeout</code> enabled.</p>
/// </note>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct BeginTransaction {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::input::begin_transaction_input::Builder,
}
impl BeginTransaction {
    /// Creates a new `BeginTransaction`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::operation::customize::CustomizableOperation<
            crate::operation::BeginTransaction,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::error::BeginTransactionError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::operation::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::output::BeginTransactionOutput,
        aws_smithy_http::result::SdkError<crate::error::BeginTransactionError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.resource_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_resource_arn(input);
        self
    }
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.secret_arn(input.into());
        self
    }
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_secret_arn(input);
        self
    }
    /// <p>The name of the database.</p>
    pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.database(input.into());
        self
    }
    /// <p>The name of the database.</p>
    pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_database(input);
        self
    }
    /// <p>The name of the database schema.</p>
    pub fn schema(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.schema(input.into());
        self
    }
    /// <p>The name of the database schema.</p>
    pub fn set_schema(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_schema(input);
        self
    }
}

/// Fluent builder constructing a request to `CommitTransaction`.
///
/// <p>Ends a SQL transaction started with the <code>BeginTransaction</code> operation and commits the changes.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct CommitTransaction {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::input::commit_transaction_input::Builder,
}
impl CommitTransaction {
    /// Creates a new `CommitTransaction`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::operation::customize::CustomizableOperation<
            crate::operation::CommitTransaction,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::error::CommitTransactionError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::operation::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::output::CommitTransactionOutput,
        aws_smithy_http::result::SdkError<crate::error::CommitTransactionError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.resource_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_resource_arn(input);
        self
    }
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.secret_arn(input.into());
        self
    }
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_secret_arn(input);
        self
    }
    /// <p>The identifier of the transaction to end and commit.</p>
    pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.transaction_id(input.into());
        self
    }
    /// <p>The identifier of the transaction to end and commit.</p>
    pub fn set_transaction_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_transaction_id(input);
        self
    }
}

/// Fluent builder constructing a request to `ExecuteSql`.
///
/// <p>Runs one or more SQL statements.</p> <note>
/// <p>This operation is deprecated. Use the <code>BatchExecuteStatement</code> or <code>ExecuteStatement</code> operation.</p>
/// </note>
#[deprecated(
    note = "The ExecuteSql API is deprecated, please use the ExecuteStatement API.",
    since = "2019-03-21"
)]
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct ExecuteSql {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::input::execute_sql_input::Builder,
}
impl ExecuteSql {
    /// Creates a new `ExecuteSql`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::operation::customize::CustomizableOperation<
            crate::operation::ExecuteSql,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::error::ExecuteSqlError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::operation::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::output::ExecuteSqlOutput,
        aws_smithy_http::result::SdkError<crate::error::ExecuteSqlError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The ARN of the Aurora Serverless DB cluster.</p>
    pub fn db_cluster_or_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.db_cluster_or_instance_arn(input.into());
        self
    }
    /// <p>The ARN of the Aurora Serverless DB cluster.</p>
    pub fn set_db_cluster_or_instance_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.inner = self.inner.set_db_cluster_or_instance_arn(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret.</p>
    /// <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
    pub fn aws_secret_store_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.aws_secret_store_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret.</p>
    /// <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
    pub fn set_aws_secret_store_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.inner = self.inner.set_aws_secret_store_arn(input);
        self
    }
    /// <p>One or more SQL statements to run on the DB cluster.</p>
    /// <p>You can separate SQL statements from each other with a semicolon (;). Any valid SQL statement is permitted, including data definition, data manipulation, and commit statements. </p>
    pub fn sql_statements(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.sql_statements(input.into());
        self
    }
    /// <p>One or more SQL statements to run on the DB cluster.</p>
    /// <p>You can separate SQL statements from each other with a semicolon (;). Any valid SQL statement is permitted, including data definition, data manipulation, and commit statements. </p>
    pub fn set_sql_statements(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_sql_statements(input);
        self
    }
    /// <p>The name of the database.</p>
    pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.database(input.into());
        self
    }
    /// <p>The name of the database.</p>
    pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_database(input);
        self
    }
    /// <p>The name of the database schema.</p>
    pub fn schema(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.schema(input.into());
        self
    }
    /// <p>The name of the database schema.</p>
    pub fn set_schema(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_schema(input);
        self
    }
}

/// Fluent builder constructing a request to `ExecuteStatement`.
///
/// <p>Runs a SQL statement against a database.</p> <note>
/// <p>If a call isn't part of a transaction because it doesn't include the <code>transactionID</code> parameter, changes that result from the call are committed automatically.</p>
/// <p>If the binary response data from the database is more than 1 MB, the call is terminated.</p>
/// </note>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct ExecuteStatement {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::input::execute_statement_input::Builder,
}
impl ExecuteStatement {
    /// Creates a new `ExecuteStatement`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::operation::customize::CustomizableOperation<
            crate::operation::ExecuteStatement,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::error::ExecuteStatementError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::operation::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::output::ExecuteStatementOutput,
        aws_smithy_http::result::SdkError<crate::error::ExecuteStatementError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.resource_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_resource_arn(input);
        self
    }
    /// <p>The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret.</p>
    /// <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
    pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.secret_arn(input.into());
        self
    }
    /// <p>The ARN of the secret that enables access to the DB cluster. Enter the database user name and password for the credentials in the secret.</p>
    /// <p>For information about creating the secret, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/create_database_secret.html">Create a database secret</a>.</p>
    pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_secret_arn(input);
        self
    }
    /// <p>The SQL statement to run.</p>
    pub fn sql(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.sql(input.into());
        self
    }
    /// <p>The SQL statement to run.</p>
    pub fn set_sql(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_sql(input);
        self
    }
    /// <p>The name of the database.</p>
    pub fn database(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.database(input.into());
        self
    }
    /// <p>The name of the database.</p>
    pub fn set_database(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_database(input);
        self
    }
    /// <p>The name of the database schema.</p> <note>
    /// <p>Currently, the <code>schema</code> parameter isn't supported.</p>
    /// </note>
    pub fn schema(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.schema(input.into());
        self
    }
    /// <p>The name of the database schema.</p> <note>
    /// <p>Currently, the <code>schema</code> parameter isn't supported.</p>
    /// </note>
    pub fn set_schema(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_schema(input);
        self
    }
    /// Appends an item to `parameters`.
    ///
    /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
    ///
    /// <p>The parameters for the SQL statement.</p> <note>
    /// <p>Array parameters are not supported.</p>
    /// </note>
    pub fn parameters(mut self, input: crate::model::SqlParameter) -> Self {
        self.inner = self.inner.parameters(input);
        self
    }
    /// <p>The parameters for the SQL statement.</p> <note>
    /// <p>Array parameters are not supported.</p>
    /// </note>
    pub fn set_parameters(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::model::SqlParameter>>,
    ) -> Self {
        self.inner = self.inner.set_parameters(input);
        self
    }
    /// <p>The identifier of a transaction that was started by using the <code>BeginTransaction</code> operation. Specify the transaction ID of the transaction that you want to include the SQL statement in.</p>
    /// <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
    pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.transaction_id(input.into());
        self
    }
    /// <p>The identifier of a transaction that was started by using the <code>BeginTransaction</code> operation. Specify the transaction ID of the transaction that you want to include the SQL statement in.</p>
    /// <p>If the SQL statement is not part of a transaction, don't set this parameter.</p>
    pub fn set_transaction_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_transaction_id(input);
        self
    }
    /// <p>A value that indicates whether to include metadata in the results.</p>
    pub fn include_result_metadata(mut self, input: bool) -> Self {
        self.inner = self.inner.include_result_metadata(input);
        self
    }
    /// <p>A value that indicates whether to include metadata in the results.</p>
    pub fn set_include_result_metadata(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_include_result_metadata(input);
        self
    }
    /// <p>A value that indicates whether to continue running the statement after the call times out. By default, the statement stops running when the call times out.</p> <note>
    /// <p>For DDL statements, we recommend continuing to run the statement after the call times out. When a DDL statement terminates before it is finished running, it can result in errors and possibly corrupted data structures.</p>
    /// </note>
    pub fn continue_after_timeout(mut self, input: bool) -> Self {
        self.inner = self.inner.continue_after_timeout(input);
        self
    }
    /// <p>A value that indicates whether to continue running the statement after the call times out. By default, the statement stops running when the call times out.</p> <note>
    /// <p>For DDL statements, we recommend continuing to run the statement after the call times out. When a DDL statement terminates before it is finished running, it can result in errors and possibly corrupted data structures.</p>
    /// </note>
    pub fn set_continue_after_timeout(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_continue_after_timeout(input);
        self
    }
    /// <p>Options that control how the result set is returned.</p>
    pub fn result_set_options(mut self, input: crate::model::ResultSetOptions) -> Self {
        self.inner = self.inner.result_set_options(input);
        self
    }
    /// <p>Options that control how the result set is returned.</p>
    pub fn set_result_set_options(
        mut self,
        input: std::option::Option<crate::model::ResultSetOptions>,
    ) -> Self {
        self.inner = self.inner.set_result_set_options(input);
        self
    }
    /// <p>A value that indicates whether to format the result set as a single JSON string. This parameter only applies to <code>SELECT</code> statements and is ignored for other types of statements. Allowed values are <code>NONE</code> and <code>JSON</code>. The default value is <code>NONE</code>. The result is returned in the <code>formattedRecords</code> field.</p>
    /// <p>For usage information about the JSON format for result sets, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn format_records_as(mut self, input: crate::model::RecordsFormatType) -> Self {
        self.inner = self.inner.format_records_as(input);
        self
    }
    /// <p>A value that indicates whether to format the result set as a single JSON string. This parameter only applies to <code>SELECT</code> statements and is ignored for other types of statements. Allowed values are <code>NONE</code> and <code>JSON</code>. The default value is <code>NONE</code>. The result is returned in the <code>formattedRecords</code> field.</p>
    /// <p>For usage information about the JSON format for result sets, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API</a> in the <i>Amazon Aurora User Guide</i>.</p>
    pub fn set_format_records_as(
        mut self,
        input: std::option::Option<crate::model::RecordsFormatType>,
    ) -> Self {
        self.inner = self.inner.set_format_records_as(input);
        self
    }
}

/// Fluent builder constructing a request to `RollbackTransaction`.
///
/// <p>Performs a rollback of a transaction. Rolling back a transaction cancels its changes.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct RollbackTransaction {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::input::rollback_transaction_input::Builder,
}
impl RollbackTransaction {
    /// Creates a new `RollbackTransaction`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::operation::customize::CustomizableOperation<
            crate::operation::RollbackTransaction,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<crate::error::RollbackTransactionError>,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::operation::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::output::RollbackTransactionOutput,
        aws_smithy_http::result::SdkError<crate::error::RollbackTransactionError>,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.resource_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.</p>
    pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_resource_arn(input);
        self
    }
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.secret_arn(input.into());
        self
    }
    /// <p>The name or ARN of the secret that enables access to the DB cluster.</p>
    pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_secret_arn(input);
        self
    }
    /// <p>The identifier of the transaction to roll back.</p>
    pub fn transaction_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.transaction_id(input.into());
        self
    }
    /// <p>The identifier of the transaction to roll back.</p>
    pub fn set_transaction_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_transaction_id(input);
        self
    }
}
