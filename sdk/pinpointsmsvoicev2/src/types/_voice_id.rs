// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `VoiceId`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let voiceid = unimplemented!();
/// match voiceid {
///     VoiceId::Amy => { /* ... */ },
///     VoiceId::Astrid => { /* ... */ },
///     VoiceId::Bianca => { /* ... */ },
///     VoiceId::Brian => { /* ... */ },
///     VoiceId::Camila => { /* ... */ },
///     VoiceId::Carla => { /* ... */ },
///     VoiceId::Carmen => { /* ... */ },
///     VoiceId::Celine => { /* ... */ },
///     VoiceId::Chantal => { /* ... */ },
///     VoiceId::Conchita => { /* ... */ },
///     VoiceId::Cristiano => { /* ... */ },
///     VoiceId::Dora => { /* ... */ },
///     VoiceId::Emma => { /* ... */ },
///     VoiceId::Enrique => { /* ... */ },
///     VoiceId::Ewa => { /* ... */ },
///     VoiceId::Filiz => { /* ... */ },
///     VoiceId::Geraint => { /* ... */ },
///     VoiceId::Giorgio => { /* ... */ },
///     VoiceId::Gwyneth => { /* ... */ },
///     VoiceId::Hans => { /* ... */ },
///     VoiceId::Ines => { /* ... */ },
///     VoiceId::Ivy => { /* ... */ },
///     VoiceId::Jacek => { /* ... */ },
///     VoiceId::Jan => { /* ... */ },
///     VoiceId::Joanna => { /* ... */ },
///     VoiceId::Joey => { /* ... */ },
///     VoiceId::Justin => { /* ... */ },
///     VoiceId::Karl => { /* ... */ },
///     VoiceId::Kendra => { /* ... */ },
///     VoiceId::Kimberly => { /* ... */ },
///     VoiceId::Lea => { /* ... */ },
///     VoiceId::Liv => { /* ... */ },
///     VoiceId::Lotte => { /* ... */ },
///     VoiceId::Lucia => { /* ... */ },
///     VoiceId::Lupe => { /* ... */ },
///     VoiceId::Mads => { /* ... */ },
///     VoiceId::Maja => { /* ... */ },
///     VoiceId::Marlene => { /* ... */ },
///     VoiceId::Mathieu => { /* ... */ },
///     VoiceId::Matthew => { /* ... */ },
///     VoiceId::Maxim => { /* ... */ },
///     VoiceId::Mia => { /* ... */ },
///     VoiceId::Miguel => { /* ... */ },
///     VoiceId::Mizuki => { /* ... */ },
///     VoiceId::Naja => { /* ... */ },
///     VoiceId::Nicole => { /* ... */ },
///     VoiceId::Penelope => { /* ... */ },
///     VoiceId::Raveena => { /* ... */ },
///     VoiceId::Ricardo => { /* ... */ },
///     VoiceId::Ruben => { /* ... */ },
///     VoiceId::Russell => { /* ... */ },
///     VoiceId::Salli => { /* ... */ },
///     VoiceId::Seoyeon => { /* ... */ },
///     VoiceId::Takumi => { /* ... */ },
///     VoiceId::Tatyana => { /* ... */ },
///     VoiceId::Vicki => { /* ... */ },
///     VoiceId::Vitoria => { /* ... */ },
///     VoiceId::Zeina => { /* ... */ },
///     VoiceId::Zhiyu => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `voiceid` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VoiceId::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VoiceId::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VoiceId::NewFeature` is defined.
/// Specifically, when `voiceid` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VoiceId::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum VoiceId {
    #[allow(missing_docs)] // documentation missing in model
    Amy,
    #[allow(missing_docs)] // documentation missing in model
    Astrid,
    #[allow(missing_docs)] // documentation missing in model
    Bianca,
    #[allow(missing_docs)] // documentation missing in model
    Brian,
    #[allow(missing_docs)] // documentation missing in model
    Camila,
    #[allow(missing_docs)] // documentation missing in model
    Carla,
    #[allow(missing_docs)] // documentation missing in model
    Carmen,
    #[allow(missing_docs)] // documentation missing in model
    Celine,
    #[allow(missing_docs)] // documentation missing in model
    Chantal,
    #[allow(missing_docs)] // documentation missing in model
    Conchita,
    #[allow(missing_docs)] // documentation missing in model
    Cristiano,
    #[allow(missing_docs)] // documentation missing in model
    Dora,
    #[allow(missing_docs)] // documentation missing in model
    Emma,
    #[allow(missing_docs)] // documentation missing in model
    Enrique,
    #[allow(missing_docs)] // documentation missing in model
    Ewa,
    #[allow(missing_docs)] // documentation missing in model
    Filiz,
    #[allow(missing_docs)] // documentation missing in model
    Geraint,
    #[allow(missing_docs)] // documentation missing in model
    Giorgio,
    #[allow(missing_docs)] // documentation missing in model
    Gwyneth,
    #[allow(missing_docs)] // documentation missing in model
    Hans,
    #[allow(missing_docs)] // documentation missing in model
    Ines,
    #[allow(missing_docs)] // documentation missing in model
    Ivy,
    #[allow(missing_docs)] // documentation missing in model
    Jacek,
    #[allow(missing_docs)] // documentation missing in model
    Jan,
    #[allow(missing_docs)] // documentation missing in model
    Joanna,
    #[allow(missing_docs)] // documentation missing in model
    Joey,
    #[allow(missing_docs)] // documentation missing in model
    Justin,
    #[allow(missing_docs)] // documentation missing in model
    Karl,
    #[allow(missing_docs)] // documentation missing in model
    Kendra,
    #[allow(missing_docs)] // documentation missing in model
    Kimberly,
    #[allow(missing_docs)] // documentation missing in model
    Lea,
    #[allow(missing_docs)] // documentation missing in model
    Liv,
    #[allow(missing_docs)] // documentation missing in model
    Lotte,
    #[allow(missing_docs)] // documentation missing in model
    Lucia,
    #[allow(missing_docs)] // documentation missing in model
    Lupe,
    #[allow(missing_docs)] // documentation missing in model
    Mads,
    #[allow(missing_docs)] // documentation missing in model
    Maja,
    #[allow(missing_docs)] // documentation missing in model
    Marlene,
    #[allow(missing_docs)] // documentation missing in model
    Mathieu,
    #[allow(missing_docs)] // documentation missing in model
    Matthew,
    #[allow(missing_docs)] // documentation missing in model
    Maxim,
    #[allow(missing_docs)] // documentation missing in model
    Mia,
    #[allow(missing_docs)] // documentation missing in model
    Miguel,
    #[allow(missing_docs)] // documentation missing in model
    Mizuki,
    #[allow(missing_docs)] // documentation missing in model
    Naja,
    #[allow(missing_docs)] // documentation missing in model
    Nicole,
    #[allow(missing_docs)] // documentation missing in model
    Penelope,
    #[allow(missing_docs)] // documentation missing in model
    Raveena,
    #[allow(missing_docs)] // documentation missing in model
    Ricardo,
    #[allow(missing_docs)] // documentation missing in model
    Ruben,
    #[allow(missing_docs)] // documentation missing in model
    Russell,
    #[allow(missing_docs)] // documentation missing in model
    Salli,
    #[allow(missing_docs)] // documentation missing in model
    Seoyeon,
    #[allow(missing_docs)] // documentation missing in model
    Takumi,
    #[allow(missing_docs)] // documentation missing in model
    Tatyana,
    #[allow(missing_docs)] // documentation missing in model
    Vicki,
    #[allow(missing_docs)] // documentation missing in model
    Vitoria,
    #[allow(missing_docs)] // documentation missing in model
    Zeina,
    #[allow(missing_docs)] // documentation missing in model
    Zhiyu,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::primitives::UnknownVariantValue)
}
impl std::convert::From<&str> for VoiceId {
                fn from(s: &str) -> Self {
                    match s {
                        "AMY" => VoiceId::Amy,
"ASTRID" => VoiceId::Astrid,
"BIANCA" => VoiceId::Bianca,
"BRIAN" => VoiceId::Brian,
"CAMILA" => VoiceId::Camila,
"CARLA" => VoiceId::Carla,
"CARMEN" => VoiceId::Carmen,
"CELINE" => VoiceId::Celine,
"CHANTAL" => VoiceId::Chantal,
"CONCHITA" => VoiceId::Conchita,
"CRISTIANO" => VoiceId::Cristiano,
"DORA" => VoiceId::Dora,
"EMMA" => VoiceId::Emma,
"ENRIQUE" => VoiceId::Enrique,
"EWA" => VoiceId::Ewa,
"FILIZ" => VoiceId::Filiz,
"GERAINT" => VoiceId::Geraint,
"GIORGIO" => VoiceId::Giorgio,
"GWYNETH" => VoiceId::Gwyneth,
"HANS" => VoiceId::Hans,
"INES" => VoiceId::Ines,
"IVY" => VoiceId::Ivy,
"JACEK" => VoiceId::Jacek,
"JAN" => VoiceId::Jan,
"JOANNA" => VoiceId::Joanna,
"JOEY" => VoiceId::Joey,
"JUSTIN" => VoiceId::Justin,
"KARL" => VoiceId::Karl,
"KENDRA" => VoiceId::Kendra,
"KIMBERLY" => VoiceId::Kimberly,
"LEA" => VoiceId::Lea,
"LIV" => VoiceId::Liv,
"LOTTE" => VoiceId::Lotte,
"LUCIA" => VoiceId::Lucia,
"LUPE" => VoiceId::Lupe,
"MADS" => VoiceId::Mads,
"MAJA" => VoiceId::Maja,
"MARLENE" => VoiceId::Marlene,
"MATHIEU" => VoiceId::Mathieu,
"MATTHEW" => VoiceId::Matthew,
"MAXIM" => VoiceId::Maxim,
"MIA" => VoiceId::Mia,
"MIGUEL" => VoiceId::Miguel,
"MIZUKI" => VoiceId::Mizuki,
"NAJA" => VoiceId::Naja,
"NICOLE" => VoiceId::Nicole,
"PENELOPE" => VoiceId::Penelope,
"RAVEENA" => VoiceId::Raveena,
"RICARDO" => VoiceId::Ricardo,
"RUBEN" => VoiceId::Ruben,
"RUSSELL" => VoiceId::Russell,
"SALLI" => VoiceId::Salli,
"SEOYEON" => VoiceId::Seoyeon,
"TAKUMI" => VoiceId::Takumi,
"TATYANA" => VoiceId::Tatyana,
"VICKI" => VoiceId::Vicki,
"VITORIA" => VoiceId::Vitoria,
"ZEINA" => VoiceId::Zeina,
"ZHIYU" => VoiceId::Zhiyu,
other => VoiceId::Unknown(crate::primitives::UnknownVariantValue(other.to_owned()))
                    }
                }
            }
impl std::str::FromStr for VoiceId {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(VoiceId::from(s))
                }
            }
impl VoiceId {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    VoiceId::Amy => "AMY",
    VoiceId::Astrid => "ASTRID",
    VoiceId::Bianca => "BIANCA",
    VoiceId::Brian => "BRIAN",
    VoiceId::Camila => "CAMILA",
    VoiceId::Carla => "CARLA",
    VoiceId::Carmen => "CARMEN",
    VoiceId::Celine => "CELINE",
    VoiceId::Chantal => "CHANTAL",
    VoiceId::Conchita => "CONCHITA",
    VoiceId::Cristiano => "CRISTIANO",
    VoiceId::Dora => "DORA",
    VoiceId::Emma => "EMMA",
    VoiceId::Enrique => "ENRIQUE",
    VoiceId::Ewa => "EWA",
    VoiceId::Filiz => "FILIZ",
    VoiceId::Geraint => "GERAINT",
    VoiceId::Giorgio => "GIORGIO",
    VoiceId::Gwyneth => "GWYNETH",
    VoiceId::Hans => "HANS",
    VoiceId::Ines => "INES",
    VoiceId::Ivy => "IVY",
    VoiceId::Jacek => "JACEK",
    VoiceId::Jan => "JAN",
    VoiceId::Joanna => "JOANNA",
    VoiceId::Joey => "JOEY",
    VoiceId::Justin => "JUSTIN",
    VoiceId::Karl => "KARL",
    VoiceId::Kendra => "KENDRA",
    VoiceId::Kimberly => "KIMBERLY",
    VoiceId::Lea => "LEA",
    VoiceId::Liv => "LIV",
    VoiceId::Lotte => "LOTTE",
    VoiceId::Lucia => "LUCIA",
    VoiceId::Lupe => "LUPE",
    VoiceId::Mads => "MADS",
    VoiceId::Maja => "MAJA",
    VoiceId::Marlene => "MARLENE",
    VoiceId::Mathieu => "MATHIEU",
    VoiceId::Matthew => "MATTHEW",
    VoiceId::Maxim => "MAXIM",
    VoiceId::Mia => "MIA",
    VoiceId::Miguel => "MIGUEL",
    VoiceId::Mizuki => "MIZUKI",
    VoiceId::Naja => "NAJA",
    VoiceId::Nicole => "NICOLE",
    VoiceId::Penelope => "PENELOPE",
    VoiceId::Raveena => "RAVEENA",
    VoiceId::Ricardo => "RICARDO",
    VoiceId::Ruben => "RUBEN",
    VoiceId::Russell => "RUSSELL",
    VoiceId::Salli => "SALLI",
    VoiceId::Seoyeon => "SEOYEON",
    VoiceId::Takumi => "TAKUMI",
    VoiceId::Tatyana => "TATYANA",
    VoiceId::Vicki => "VICKI",
    VoiceId::Vitoria => "VITORIA",
    VoiceId::Zeina => "ZEINA",
    VoiceId::Zhiyu => "ZHIYU",
    VoiceId::Unknown(value) => value.as_str()
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["AMY", "ASTRID", "BIANCA", "BRIAN", "CAMILA", "CARLA", "CARMEN", "CELINE", "CHANTAL", "CONCHITA", "CRISTIANO", "DORA", "EMMA", "ENRIQUE", "EWA", "FILIZ", "GERAINT", "GIORGIO", "GWYNETH", "HANS", "INES", "IVY", "JACEK", "JAN", "JOANNA", "JOEY", "JUSTIN", "KARL", "KENDRA", "KIMBERLY", "LEA", "LIV", "LOTTE", "LUCIA", "LUPE", "MADS", "MAJA", "MARLENE", "MATHIEU", "MATTHEW", "MAXIM", "MIA", "MIGUEL", "MIZUKI", "NAJA", "NICOLE", "PENELOPE", "RAVEENA", "RICARDO", "RUBEN", "RUSSELL", "SALLI", "SEOYEON", "TAKUMI", "TATYANA", "VICKI", "VITORIA", "ZEINA", "ZHIYU"]
                }
            }
impl AsRef<str> for VoiceId {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }

