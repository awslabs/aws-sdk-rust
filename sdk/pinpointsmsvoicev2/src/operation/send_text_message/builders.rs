// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::send_text_message::_send_text_message_output::SendTextMessageOutputBuilder;

pub use crate::operation::send_text_message::_send_text_message_input::SendTextMessageInputBuilder;

impl crate::operation::send_text_message::builders::SendTextMessageInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::send_text_message::SendTextMessageOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::send_text_message::SendTextMessageError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.send_text_message();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `SendTextMessage`.
///
/// <p>Creates a new text message and sends it to a recipient's phone number.</p>
/// <p>SMS throughput limits are measured in Message Parts per Second (MPS). Your MPS limit depends on the destination country of your messages, as well as the type of phone number (origination number) that you use to send the message. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-limitations-mps.html">Message Parts per Second (MPS) limits</a> in the <i>Amazon Pinpoint User Guide</i>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct SendTextMessageFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::send_text_message::builders::SendTextMessageInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::send_text_message::SendTextMessageOutput,
        crate::operation::send_text_message::SendTextMessageError,
    > for SendTextMessageFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::send_text_message::SendTextMessageOutput,
            crate::operation::send_text_message::SendTextMessageError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl SendTextMessageFluentBuilder {
    /// Creates a new `SendTextMessage`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the SendTextMessage as a reference.
    pub fn as_input(&self) -> &crate::operation::send_text_message::builders::SendTextMessageInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::send_text_message::SendTextMessageOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::send_text_message::SendTextMessageError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::send_text_message::SendTextMessage::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::send_text_message::SendTextMessage::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::send_text_message::SendTextMessageOutput,
        crate::operation::send_text_message::SendTextMessageError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The destination phone number in E.164 format.</p>
    pub fn destination_phone_number(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.destination_phone_number(input.into());
        self
    }
    /// <p>The destination phone number in E.164 format.</p>
    pub fn set_destination_phone_number(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_destination_phone_number(input);
        self
    }
    /// <p>The destination phone number in E.164 format.</p>
    pub fn get_destination_phone_number(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_destination_phone_number()
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p>
    pub fn origination_identity(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.origination_identity(input.into());
        self
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p>
    pub fn set_origination_identity(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_origination_identity(input);
        self
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p>
    pub fn get_origination_identity(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_origination_identity()
    }
    /// <p>The body of the text message.</p>
    pub fn message_body(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.message_body(input.into());
        self
    }
    /// <p>The body of the text message.</p>
    pub fn set_message_body(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_message_body(input);
        self
    }
    /// <p>The body of the text message.</p>
    pub fn get_message_body(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_message_body()
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn message_type(mut self, input: crate::types::MessageType) -> Self {
        self.inner = self.inner.message_type(input);
        self
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn set_message_type(mut self, input: ::std::option::Option<crate::types::MessageType>) -> Self {
        self.inner = self.inner.set_message_type(input);
        self
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn get_message_type(&self) -> &::std::option::Option<crate::types::MessageType> {
        self.inner.get_message_type()
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn keyword(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.keyword(input.into());
        self
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn set_keyword(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_keyword(input);
        self
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn get_keyword(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_keyword()
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn configuration_set_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.configuration_set_name(input.into());
        self
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn set_configuration_set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_configuration_set_name(input);
        self
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn get_configuration_set_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_configuration_set_name()
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.</p>
    pub fn max_price(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.max_price(input.into());
        self
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.</p>
    pub fn set_max_price(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_max_price(input);
        self
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message part. A text message can contain multiple parts.</p>
    pub fn get_max_price(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_max_price()
    }
    /// <p>How long the text message is valid for. By default this is 72 hours.</p>
    pub fn time_to_live(mut self, input: i32) -> Self {
        self.inner = self.inner.time_to_live(input);
        self
    }
    /// <p>How long the text message is valid for. By default this is 72 hours.</p>
    pub fn set_time_to_live(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_time_to_live(input);
        self
    }
    /// <p>How long the text message is valid for. By default this is 72 hours.</p>
    pub fn get_time_to_live(&self) -> &::std::option::Option<i32> {
        self.inner.get_time_to_live()
    }
    ///
    /// Adds a key-value pair to `Context`.
    ///
    /// To override the contents of this collection use [`set_context`](Self::set_context).
    ///
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn context(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.context(k.into(), v.into());
        self
    }
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn set_context(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_context(input);
        self
    }
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn get_context(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_context()
    }
    ///
    /// Adds a key-value pair to `DestinationCountryParameters`.
    ///
    /// To override the contents of this collection use [`set_destination_country_parameters`](Self::set_destination_country_parameters).
    ///
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    pub fn destination_country_parameters(
        mut self,
        k: crate::types::DestinationCountryParameterKey,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        self.inner = self.inner.destination_country_parameters(k, v.into());
        self
    }
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    pub fn set_destination_country_parameters(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>>,
    ) -> Self {
        self.inner = self.inner.set_destination_country_parameters(input);
        self
    }
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    pub fn get_destination_country_parameters(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>> {
        self.inner.get_destination_country_parameters()
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.inner = self.inner.dry_run(input);
        self
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient.</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_dry_run(input);
        self
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient.</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        self.inner.get_dry_run()
    }
}
