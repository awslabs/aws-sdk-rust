// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SendTextMessageInput {
    /// <p>The destination phone number in E.164 format.</p>
    pub destination_phone_number: ::std::option::Option<::std::string::String>,
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p><important>
    /// <p>If you are using a shared End User MessagingSMS resource then you must use the full Amazon Resource Name(ARN).</p>
    /// </important>
    pub origination_identity: ::std::option::Option<::std::string::String>,
    /// <p>The body of the text message.</p>
    pub message_body: ::std::option::Option<::std::string::String>,
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub message_type: ::std::option::Option<crate::types::MessageType>,
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub keyword: ::std::option::Option<::std::string::String>,
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub configuration_set_name: ::std::option::Option<::std::string::String>,
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than <code>MaxPrice</code>, the message is not sent and an error is returned.</p>
    pub max_price: ::std::option::Option<::std::string::String>,
    /// <p>How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return <code>TTL_EXPIRED</code> event.</p>
    pub time_to_live: ::std::option::Option<i32>,
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub context: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    /// <ul>
    /// <li>
    /// <p><code>IN_ENTITY_ID</code> The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.</p></li>
    /// <li>
    /// <p><code>IN_TEMPLATE_ID</code> The template ID that you received after completing the sender ID registration process.</p><important>
    /// <p>Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.</p>
    /// </important></li>
    /// </ul>
    pub destination_country_parameters:
        ::std::option::Option<::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>>,
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using <code>DryRun</code>.</p>
    /// <p>The Message Parts per Second (MPS) limit when using <code>DryRun</code> is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see <a href="https://docs.aws.amazon.com/sms-voice/latest/userguide/sms-limitations-mps.html">Message Parts per Second (MPS) limits</a> in the <i>End User MessagingSMS User Guide</i>..</p>
    pub dry_run: ::std::option::Option<bool>,
    /// <p>The unique identifier for the protect configuration.</p>
    pub protect_configuration_id: ::std::option::Option<::std::string::String>,
    /// <p>Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using <code>PutMessageFeedback</code>.</p>
    pub message_feedback_enabled: ::std::option::Option<bool>,
}
impl SendTextMessageInput {
    /// <p>The destination phone number in E.164 format.</p>
    pub fn destination_phone_number(&self) -> ::std::option::Option<&str> {
        self.destination_phone_number.as_deref()
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p><important>
    /// <p>If you are using a shared End User MessagingSMS resource then you must use the full Amazon Resource Name(ARN).</p>
    /// </important>
    pub fn origination_identity(&self) -> ::std::option::Option<&str> {
        self.origination_identity.as_deref()
    }
    /// <p>The body of the text message.</p>
    pub fn message_body(&self) -> ::std::option::Option<&str> {
        self.message_body.as_deref()
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn message_type(&self) -> ::std::option::Option<&crate::types::MessageType> {
        self.message_type.as_ref()
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn keyword(&self) -> ::std::option::Option<&str> {
        self.keyword.as_deref()
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn configuration_set_name(&self) -> ::std::option::Option<&str> {
        self.configuration_set_name.as_deref()
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than <code>MaxPrice</code>, the message is not sent and an error is returned.</p>
    pub fn max_price(&self) -> ::std::option::Option<&str> {
        self.max_price.as_deref()
    }
    /// <p>How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return <code>TTL_EXPIRED</code> event.</p>
    pub fn time_to_live(&self) -> ::std::option::Option<i32> {
        self.time_to_live
    }
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn context(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.context.as_ref()
    }
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    /// <ul>
    /// <li>
    /// <p><code>IN_ENTITY_ID</code> The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.</p></li>
    /// <li>
    /// <p><code>IN_TEMPLATE_ID</code> The template ID that you received after completing the sender ID registration process.</p><important>
    /// <p>Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.</p>
    /// </important></li>
    /// </ul>
    pub fn destination_country_parameters(
        &self,
    ) -> ::std::option::Option<&::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>> {
        self.destination_country_parameters.as_ref()
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using <code>DryRun</code>.</p>
    /// <p>The Message Parts per Second (MPS) limit when using <code>DryRun</code> is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see <a href="https://docs.aws.amazon.com/sms-voice/latest/userguide/sms-limitations-mps.html">Message Parts per Second (MPS) limits</a> in the <i>End User MessagingSMS User Guide</i>..</p>
    pub fn dry_run(&self) -> ::std::option::Option<bool> {
        self.dry_run
    }
    /// <p>The unique identifier for the protect configuration.</p>
    pub fn protect_configuration_id(&self) -> ::std::option::Option<&str> {
        self.protect_configuration_id.as_deref()
    }
    /// <p>Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using <code>PutMessageFeedback</code>.</p>
    pub fn message_feedback_enabled(&self) -> ::std::option::Option<bool> {
        self.message_feedback_enabled
    }
}
impl SendTextMessageInput {
    /// Creates a new builder-style object to manufacture [`SendTextMessageInput`](crate::operation::send_text_message::SendTextMessageInput).
    pub fn builder() -> crate::operation::send_text_message::builders::SendTextMessageInputBuilder {
        crate::operation::send_text_message::builders::SendTextMessageInputBuilder::default()
    }
}

/// A builder for [`SendTextMessageInput`](crate::operation::send_text_message::SendTextMessageInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct SendTextMessageInputBuilder {
    pub(crate) destination_phone_number: ::std::option::Option<::std::string::String>,
    pub(crate) origination_identity: ::std::option::Option<::std::string::String>,
    pub(crate) message_body: ::std::option::Option<::std::string::String>,
    pub(crate) message_type: ::std::option::Option<crate::types::MessageType>,
    pub(crate) keyword: ::std::option::Option<::std::string::String>,
    pub(crate) configuration_set_name: ::std::option::Option<::std::string::String>,
    pub(crate) max_price: ::std::option::Option<::std::string::String>,
    pub(crate) time_to_live: ::std::option::Option<i32>,
    pub(crate) context: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) destination_country_parameters:
        ::std::option::Option<::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>>,
    pub(crate) dry_run: ::std::option::Option<bool>,
    pub(crate) protect_configuration_id: ::std::option::Option<::std::string::String>,
    pub(crate) message_feedback_enabled: ::std::option::Option<bool>,
}
impl SendTextMessageInputBuilder {
    /// <p>The destination phone number in E.164 format.</p>
    /// This field is required.
    pub fn destination_phone_number(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.destination_phone_number = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The destination phone number in E.164 format.</p>
    pub fn set_destination_phone_number(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.destination_phone_number = input;
        self
    }
    /// <p>The destination phone number in E.164 format.</p>
    pub fn get_destination_phone_number(&self) -> &::std::option::Option<::std::string::String> {
        &self.destination_phone_number
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p><important>
    /// <p>If you are using a shared End User MessagingSMS resource then you must use the full Amazon Resource Name(ARN).</p>
    /// </important>
    pub fn origination_identity(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.origination_identity = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p><important>
    /// <p>If you are using a shared End User MessagingSMS resource then you must use the full Amazon Resource Name(ARN).</p>
    /// </important>
    pub fn set_origination_identity(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.origination_identity = input;
        self
    }
    /// <p>The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn.</p><important>
    /// <p>If you are using a shared End User MessagingSMS resource then you must use the full Amazon Resource Name(ARN).</p>
    /// </important>
    pub fn get_origination_identity(&self) -> &::std::option::Option<::std::string::String> {
        &self.origination_identity
    }
    /// <p>The body of the text message.</p>
    pub fn message_body(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message_body = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The body of the text message.</p>
    pub fn set_message_body(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message_body = input;
        self
    }
    /// <p>The body of the text message.</p>
    pub fn get_message_body(&self) -> &::std::option::Option<::std::string::String> {
        &self.message_body
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn message_type(mut self, input: crate::types::MessageType) -> Self {
        self.message_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn set_message_type(mut self, input: ::std::option::Option<crate::types::MessageType>) -> Self {
        self.message_type = input;
        self
    }
    /// <p>The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.</p>
    pub fn get_message_type(&self) -> &::std::option::Option<crate::types::MessageType> {
        &self.message_type
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn keyword(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.keyword = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn set_keyword(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.keyword = input;
        self
    }
    /// <p>When you register a short code in the US, you must specify a program name. If you don’t have a US short code, omit this attribute.</p>
    pub fn get_keyword(&self) -> &::std::option::Option<::std::string::String> {
        &self.keyword
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn configuration_set_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.configuration_set_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn set_configuration_set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.configuration_set_name = input;
        self
    }
    /// <p>The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.</p>
    pub fn get_configuration_set_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.configuration_set_name
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than <code>MaxPrice</code>, the message is not sent and an error is returned.</p>
    pub fn max_price(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.max_price = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than <code>MaxPrice</code>, the message is not sent and an error is returned.</p>
    pub fn set_max_price(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.max_price = input;
        self
    }
    /// <p>The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than <code>MaxPrice</code>, the message is not sent and an error is returned.</p>
    pub fn get_max_price(&self) -> &::std::option::Option<::std::string::String> {
        &self.max_price
    }
    /// <p>How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return <code>TTL_EXPIRED</code> event.</p>
    pub fn time_to_live(mut self, input: i32) -> Self {
        self.time_to_live = ::std::option::Option::Some(input);
        self
    }
    /// <p>How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return <code>TTL_EXPIRED</code> event.</p>
    pub fn set_time_to_live(mut self, input: ::std::option::Option<i32>) -> Self {
        self.time_to_live = input;
        self
    }
    /// <p>How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return <code>TTL_EXPIRED</code> event.</p>
    pub fn get_time_to_live(&self) -> &::std::option::Option<i32> {
        &self.time_to_live
    }
    /// Adds a key-value pair to `context`.
    ///
    /// To override the contents of this collection use [`set_context`](Self::set_context).
    ///
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn context(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.context.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.context = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn set_context(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.context = input;
        self
    }
    /// <p>You can specify custom data in this field. If you do, that data is logged to the event destination.</p>
    pub fn get_context(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.context
    }
    /// Adds a key-value pair to `destination_country_parameters`.
    ///
    /// To override the contents of this collection use [`set_destination_country_parameters`](Self::set_destination_country_parameters).
    ///
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    /// <ul>
    /// <li>
    /// <p><code>IN_ENTITY_ID</code> The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.</p></li>
    /// <li>
    /// <p><code>IN_TEMPLATE_ID</code> The template ID that you received after completing the sender ID registration process.</p><important>
    /// <p>Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.</p>
    /// </important></li>
    /// </ul>
    pub fn destination_country_parameters(
        mut self,
        k: crate::types::DestinationCountryParameterKey,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.destination_country_parameters.unwrap_or_default();
        hash_map.insert(k, v.into());
        self.destination_country_parameters = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    /// <ul>
    /// <li>
    /// <p><code>IN_ENTITY_ID</code> The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.</p></li>
    /// <li>
    /// <p><code>IN_TEMPLATE_ID</code> The template ID that you received after completing the sender ID registration process.</p><important>
    /// <p>Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.</p>
    /// </important></li>
    /// </ul>
    pub fn set_destination_country_parameters(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>>,
    ) -> Self {
        self.destination_country_parameters = input;
        self
    }
    /// <p>This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html">Special requirements for sending SMS messages to recipients in India</a>.</p>
    /// <ul>
    /// <li>
    /// <p><code>IN_ENTITY_ID</code> The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.</p></li>
    /// <li>
    /// <p><code>IN_TEMPLATE_ID</code> The template ID that you received after completing the sender ID registration process.</p><important>
    /// <p>Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.</p>
    /// </important></li>
    /// </ul>
    pub fn get_destination_country_parameters(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<crate::types::DestinationCountryParameterKey, ::std::string::String>> {
        &self.destination_country_parameters
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using <code>DryRun</code>.</p>
    /// <p>The Message Parts per Second (MPS) limit when using <code>DryRun</code> is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see <a href="https://docs.aws.amazon.com/sms-voice/latest/userguide/sms-limitations-mps.html">Message Parts per Second (MPS) limits</a> in the <i>End User MessagingSMS User Guide</i>..</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.dry_run = ::std::option::Option::Some(input);
        self
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using <code>DryRun</code>.</p>
    /// <p>The Message Parts per Second (MPS) limit when using <code>DryRun</code> is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see <a href="https://docs.aws.amazon.com/sms-voice/latest/userguide/sms-limitations-mps.html">Message Parts per Second (MPS) limits</a> in the <i>End User MessagingSMS User Guide</i>..</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.dry_run = input;
        self
    }
    /// <p>When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using <code>DryRun</code>.</p>
    /// <p>The Message Parts per Second (MPS) limit when using <code>DryRun</code> is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see <a href="https://docs.aws.amazon.com/sms-voice/latest/userguide/sms-limitations-mps.html">Message Parts per Second (MPS) limits</a> in the <i>End User MessagingSMS User Guide</i>..</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        &self.dry_run
    }
    /// <p>The unique identifier for the protect configuration.</p>
    pub fn protect_configuration_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.protect_configuration_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the protect configuration.</p>
    pub fn set_protect_configuration_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.protect_configuration_id = input;
        self
    }
    /// <p>The unique identifier for the protect configuration.</p>
    pub fn get_protect_configuration_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.protect_configuration_id
    }
    /// <p>Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using <code>PutMessageFeedback</code>.</p>
    pub fn message_feedback_enabled(mut self, input: bool) -> Self {
        self.message_feedback_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using <code>PutMessageFeedback</code>.</p>
    pub fn set_message_feedback_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.message_feedback_enabled = input;
        self
    }
    /// <p>Set to true to enable message feedback for the message. When a user receives the message you need to update the message status using <code>PutMessageFeedback</code>.</p>
    pub fn get_message_feedback_enabled(&self) -> &::std::option::Option<bool> {
        &self.message_feedback_enabled
    }
    /// Consumes the builder and constructs a [`SendTextMessageInput`](crate::operation::send_text_message::SendTextMessageInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::send_text_message::SendTextMessageInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::send_text_message::SendTextMessageInput {
            destination_phone_number: self.destination_phone_number,
            origination_identity: self.origination_identity,
            message_body: self.message_body,
            message_type: self.message_type,
            keyword: self.keyword,
            configuration_set_name: self.configuration_set_name,
            max_price: self.max_price,
            time_to_live: self.time_to_live,
            context: self.context,
            destination_country_parameters: self.destination_country_parameters,
            dry_run: self.dry_run,
            protect_configuration_id: self.protect_configuration_id,
            message_feedback_enabled: self.message_feedback_enabled,
        })
    }
}
