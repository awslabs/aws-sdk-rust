// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `SendMessageBatch`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct SendMessageBatch;
impl SendMessageBatch {
    /// Creates a new `SendMessageBatch`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::send_message_batch::SendMessageBatchInput,
    ) -> ::std::result::Result<
        crate::operation::send_message_batch::SendMessageBatchOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::send_message_batch::SendMessageBatchError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::send_message_batch::SendMessageBatchError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::send_message_batch::SendMessageBatchOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::send_message_batch::SendMessageBatchInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("sqs", "SendMessageBatch", input, runtime_plugins, stop_point).await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for SendMessageBatch {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("SendMessageBatch");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            SendMessageBatchRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            SendMessageBatchResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_http::operation::Metadata::new("SendMessageBatch", "sqs"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        #[allow(unused_mut)]
        let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("SendMessageBatch")
            .with_interceptor(
                ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::new(
                    ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptorKind::ResponseBody,
                ),
            )
            .with_interceptor(SendMessageBatchEndpointParamsInterceptor)
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                crate::operation::send_message_batch::SendMessageBatchError,
            >::new())
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                crate::operation::send_message_batch::SendMessageBatchError,
            >::new())
            .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                crate::operation::send_message_batch::SendMessageBatchError,
            >::new());

        ::std::borrow::Cow::Owned(rcb)
    }
}

#[derive(Debug)]
struct SendMessageBatchResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for SendMessageBatchResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_types::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_send_message_batch::de_send_message_batch_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_send_message_batch::de_send_message_batch_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct SendMessageBatchRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for SendMessageBatchRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::send_message_batch::SendMessageBatchInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::send_message_batch::SendMessageBatchInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::send_message_batch::SendMessageBatchInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.0");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "AmazonSQS.SendMessageBatch",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_send_message_batch::ser_send_message_batch_input(&input)?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct SendMessageBatchEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for SendMessageBatchEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "SendMessageBatchEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<SendMessageBatchInput>()
            .ok_or("failed to downcast to SendMessageBatchInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Error type for the `SendMessageBatchError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum SendMessageBatchError {
    /// <p>Two or more batch entries in the request have the same <code>Id</code>.</p>
    BatchEntryIdsNotDistinct(crate::types::error::BatchEntryIdsNotDistinct),
    /// <p>The length of all the messages put together is more than the limit.</p>
    BatchRequestTooLong(crate::types::error::BatchRequestTooLong),
    /// <p>The batch request doesn't contain any entries.</p>
    EmptyBatchRequest(crate::types::error::EmptyBatchRequest),
    /// <p>The <code>accountId</code> is invalid.</p>
    InvalidAddress(crate::types::error::InvalidAddress),
    /// <p>The <code>Id</code> of a batch entry in a batch request doesn't abide by the specification.</p>
    InvalidBatchEntryId(crate::types::error::InvalidBatchEntryId),
    /// <p>When the request to a queue is not HTTPS and SigV4.</p>
    InvalidSecurity(crate::types::error::InvalidSecurity),
    /// <p>The caller doesn't have the required KMS access.</p>
    KmsAccessDenied(crate::types::error::KmsAccessDenied),
    /// <p>The request was denied due to request throttling.</p>
    KmsDisabled(crate::types::error::KmsDisabled),
    /// <p>The request was rejected for one of the following reasons:</p>
    /// <ul>
    /// <li> <p>The KeyUsage value of the KMS key is incompatible with the API operation.</p> </li>
    /// <li> <p>The encryption algorithm or signing algorithm specified for the operation is incompatible with the type of key material in the KMS key (KeySpec).</p> </li>
    /// </ul>
    KmsInvalidKeyUsage(crate::types::error::KmsInvalidKeyUsage),
    /// <p>The request was rejected because the state of the specified resource is not valid for this request.</p>
    KmsInvalidState(crate::types::error::KmsInvalidState),
    /// <p>The request was rejected because the specified entity or resource could not be found. </p>
    KmsNotFound(crate::types::error::KmsNotFound),
    /// <p>The request was rejected because the specified key policy isn't syntactically or semantically correct.</p>
    KmsOptInRequired(crate::types::error::KmsOptInRequired),
    /// <p>Amazon Web Services KMS throttles requests for the following conditions.</p>
    KmsThrottled(crate::types::error::KmsThrottled),
    /// <p>The specified queue doesn't exist.</p>
    QueueDoesNotExist(crate::types::error::QueueDoesNotExist),
    /// <p>The request was denied due to request throttling.</p>
    /// <ul>
    /// <li> <p>The rate of requests per second exceeds the Amazon Web Services KMS request quota for an account and Region. </p> </li>
    /// <li> <p>A burst or sustained high rate of requests to change the state of the same KMS key. This condition is often known as a "hot key."</p> </li>
    /// <li> <p>Requests for operations on KMS keys in a Amazon Web Services CloudHSM key store might be throttled at a lower-than-expected rate when the Amazon Web Services CloudHSM cluster associated with the Amazon Web Services CloudHSM key store is processing numerous commands, including those unrelated to the Amazon Web Services CloudHSM key store.</p> </li>
    /// </ul>
    RequestThrottled(crate::types::error::RequestThrottled),
    /// <p>The batch request contains more entries than permissible.</p>
    TooManyEntriesInBatchRequest(crate::types::error::TooManyEntriesInBatchRequest),
    /// <p>Error code 400. Unsupported operation.</p>
    UnsupportedOperation(crate::types::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-SendMessageBatchError) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl SendMessageBatchError {
    /// Creates the `SendMessageBatchError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.into(),
            meta: ::std::default::Default::default(),
        })
    }

    /// Creates the `SendMessageBatchError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.clone().into(),
            meta: err,
        })
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchEntryIdsNotDistinct(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::BatchRequestTooLong(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EmptyBatchRequest(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidAddress(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidBatchEntryId(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidSecurity(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsAccessDenied(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsDisabled(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsInvalidKeyUsage(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsInvalidState(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsNotFound(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsOptInRequired(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::KmsThrottled(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::QueueDoesNotExist(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RequestThrottled(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::TooManyEntriesInBatchRequest(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::UnsupportedOperation(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::BatchEntryIdsNotDistinct`.
    pub fn is_batch_entry_ids_not_distinct(&self) -> bool {
        matches!(self, Self::BatchEntryIdsNotDistinct(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::BatchRequestTooLong`.
    pub fn is_batch_request_too_long(&self) -> bool {
        matches!(self, Self::BatchRequestTooLong(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::EmptyBatchRequest`.
    pub fn is_empty_batch_request(&self) -> bool {
        matches!(self, Self::EmptyBatchRequest(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::InvalidAddress`.
    pub fn is_invalid_address(&self) -> bool {
        matches!(self, Self::InvalidAddress(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::InvalidBatchEntryId`.
    pub fn is_invalid_batch_entry_id(&self) -> bool {
        matches!(self, Self::InvalidBatchEntryId(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::InvalidSecurity`.
    pub fn is_invalid_security(&self) -> bool {
        matches!(self, Self::InvalidSecurity(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsAccessDenied`.
    pub fn is_kms_access_denied(&self) -> bool {
        matches!(self, Self::KmsAccessDenied(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsDisabled`.
    pub fn is_kms_disabled(&self) -> bool {
        matches!(self, Self::KmsDisabled(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsInvalidKeyUsage`.
    pub fn is_kms_invalid_key_usage(&self) -> bool {
        matches!(self, Self::KmsInvalidKeyUsage(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsInvalidState`.
    pub fn is_kms_invalid_state(&self) -> bool {
        matches!(self, Self::KmsInvalidState(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsNotFound`.
    pub fn is_kms_not_found(&self) -> bool {
        matches!(self, Self::KmsNotFound(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsOptInRequired`.
    pub fn is_kms_opt_in_required(&self) -> bool {
        matches!(self, Self::KmsOptInRequired(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::KmsThrottled`.
    pub fn is_kms_throttled(&self) -> bool {
        matches!(self, Self::KmsThrottled(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::QueueDoesNotExist`.
    pub fn is_queue_does_not_exist(&self) -> bool {
        matches!(self, Self::QueueDoesNotExist(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::RequestThrottled`.
    pub fn is_request_throttled(&self) -> bool {
        matches!(self, Self::RequestThrottled(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::TooManyEntriesInBatchRequest`.
    pub fn is_too_many_entries_in_batch_request(&self) -> bool {
        matches!(self, Self::TooManyEntriesInBatchRequest(_))
    }
    /// Returns `true` if the error kind is `SendMessageBatchError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl ::std::error::Error for SendMessageBatchError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::BatchEntryIdsNotDistinct(_inner) => ::std::option::Option::Some(_inner),
            Self::BatchRequestTooLong(_inner) => ::std::option::Option::Some(_inner),
            Self::EmptyBatchRequest(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAddress(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidBatchEntryId(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidSecurity(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsAccessDenied(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsDisabled(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsInvalidKeyUsage(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsInvalidState(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsNotFound(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsOptInRequired(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsThrottled(_inner) => ::std::option::Option::Some(_inner),
            Self::QueueDoesNotExist(_inner) => ::std::option::Option::Some(_inner),
            Self::RequestThrottled(_inner) => ::std::option::Option::Some(_inner),
            Self::TooManyEntriesInBatchRequest(_inner) => ::std::option::Option::Some(_inner),
            Self::UnsupportedOperation(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
        }
    }
}
impl ::std::fmt::Display for SendMessageBatchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::BatchEntryIdsNotDistinct(_inner) => _inner.fmt(f),
            Self::BatchRequestTooLong(_inner) => _inner.fmt(f),
            Self::EmptyBatchRequest(_inner) => _inner.fmt(f),
            Self::InvalidAddress(_inner) => _inner.fmt(f),
            Self::InvalidBatchEntryId(_inner) => _inner.fmt(f),
            Self::InvalidSecurity(_inner) => _inner.fmt(f),
            Self::KmsAccessDenied(_inner) => _inner.fmt(f),
            Self::KmsDisabled(_inner) => _inner.fmt(f),
            Self::KmsInvalidKeyUsage(_inner) => _inner.fmt(f),
            Self::KmsInvalidState(_inner) => _inner.fmt(f),
            Self::KmsNotFound(_inner) => _inner.fmt(f),
            Self::KmsOptInRequired(_inner) => _inner.fmt(f),
            Self::KmsThrottled(_inner) => _inner.fmt(f),
            Self::QueueDoesNotExist(_inner) => _inner.fmt(f),
            Self::RequestThrottled(_inner) => _inner.fmt(f),
            Self::TooManyEntriesInBatchRequest(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for SendMessageBatchError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for SendMessageBatchError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchEntryIdsNotDistinct(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::BatchRequestTooLong(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EmptyBatchRequest(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAddress(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidBatchEntryId(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidSecurity(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsAccessDenied(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsDisabled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsInvalidKeyUsage(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsInvalidState(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsNotFound(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsOptInRequired(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsThrottled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::QueueDoesNotExist(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RequestThrottled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TooManyEntriesInBatchRequest(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::UnsupportedOperation(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => &_inner.meta,
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for SendMessageBatchError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source,
            meta: meta.unwrap_or_default(),
        })
    }
}
impl ::aws_types::request_id::RequestId for crate::operation::send_message_batch::SendMessageBatchError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}

pub use crate::operation::send_message_batch::_send_message_batch_output::SendMessageBatchOutput;

pub use crate::operation::send_message_batch::_send_message_batch_input::SendMessageBatchInput;

mod _send_message_batch_input;

mod _send_message_batch_output;

/// Builders
pub mod builders;
