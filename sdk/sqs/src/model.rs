// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueueAttributeName {
    All,
    ApproximateNumberOfMessages,
    ApproximateNumberOfMessagesDelayed,
    ApproximateNumberOfMessagesNotVisible,
    ContentBasedDeduplication,
    CreatedTimestamp,
    DeduplicationScope,
    DelaySeconds,
    FifoQueue,
    FifoThroughputLimit,
    KmsDataKeyReusePeriodSeconds,
    KmsMasterKeyId,
    LastModifiedTimestamp,
    MaximumMessageSize,
    MessageRetentionPeriod,
    Policy,
    QueueArn,
    ReceiveMessageWaitTimeSeconds,
    RedrivePolicy,
    VisibilityTimeout,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QueueAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "All" => QueueAttributeName::All,
            "ApproximateNumberOfMessages" => QueueAttributeName::ApproximateNumberOfMessages,
            "ApproximateNumberOfMessagesDelayed" => {
                QueueAttributeName::ApproximateNumberOfMessagesDelayed
            }
            "ApproximateNumberOfMessagesNotVisible" => {
                QueueAttributeName::ApproximateNumberOfMessagesNotVisible
            }
            "ContentBasedDeduplication" => QueueAttributeName::ContentBasedDeduplication,
            "CreatedTimestamp" => QueueAttributeName::CreatedTimestamp,
            "DeduplicationScope" => QueueAttributeName::DeduplicationScope,
            "DelaySeconds" => QueueAttributeName::DelaySeconds,
            "FifoQueue" => QueueAttributeName::FifoQueue,
            "FifoThroughputLimit" => QueueAttributeName::FifoThroughputLimit,
            "KmsDataKeyReusePeriodSeconds" => QueueAttributeName::KmsDataKeyReusePeriodSeconds,
            "KmsMasterKeyId" => QueueAttributeName::KmsMasterKeyId,
            "LastModifiedTimestamp" => QueueAttributeName::LastModifiedTimestamp,
            "MaximumMessageSize" => QueueAttributeName::MaximumMessageSize,
            "MessageRetentionPeriod" => QueueAttributeName::MessageRetentionPeriod,
            "Policy" => QueueAttributeName::Policy,
            "QueueArn" => QueueAttributeName::QueueArn,
            "ReceiveMessageWaitTimeSeconds" => QueueAttributeName::ReceiveMessageWaitTimeSeconds,
            "RedrivePolicy" => QueueAttributeName::RedrivePolicy,
            "VisibilityTimeout" => QueueAttributeName::VisibilityTimeout,
            other => QueueAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QueueAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueueAttributeName::from(s))
    }
}
impl QueueAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            QueueAttributeName::All => "All",
            QueueAttributeName::ApproximateNumberOfMessages => "ApproximateNumberOfMessages",
            QueueAttributeName::ApproximateNumberOfMessagesDelayed => {
                "ApproximateNumberOfMessagesDelayed"
            }
            QueueAttributeName::ApproximateNumberOfMessagesNotVisible => {
                "ApproximateNumberOfMessagesNotVisible"
            }
            QueueAttributeName::ContentBasedDeduplication => "ContentBasedDeduplication",
            QueueAttributeName::CreatedTimestamp => "CreatedTimestamp",
            QueueAttributeName::DeduplicationScope => "DeduplicationScope",
            QueueAttributeName::DelaySeconds => "DelaySeconds",
            QueueAttributeName::FifoQueue => "FifoQueue",
            QueueAttributeName::FifoThroughputLimit => "FifoThroughputLimit",
            QueueAttributeName::KmsDataKeyReusePeriodSeconds => "KmsDataKeyReusePeriodSeconds",
            QueueAttributeName::KmsMasterKeyId => "KmsMasterKeyId",
            QueueAttributeName::LastModifiedTimestamp => "LastModifiedTimestamp",
            QueueAttributeName::MaximumMessageSize => "MaximumMessageSize",
            QueueAttributeName::MessageRetentionPeriod => "MessageRetentionPeriod",
            QueueAttributeName::Policy => "Policy",
            QueueAttributeName::QueueArn => "QueueArn",
            QueueAttributeName::ReceiveMessageWaitTimeSeconds => "ReceiveMessageWaitTimeSeconds",
            QueueAttributeName::RedrivePolicy => "RedrivePolicy",
            QueueAttributeName::VisibilityTimeout => "VisibilityTimeout",
            QueueAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "All",
            "ApproximateNumberOfMessages",
            "ApproximateNumberOfMessagesDelayed",
            "ApproximateNumberOfMessagesNotVisible",
            "ContentBasedDeduplication",
            "CreatedTimestamp",
            "DeduplicationScope",
            "DelaySeconds",
            "FifoQueue",
            "FifoThroughputLimit",
            "KmsDataKeyReusePeriodSeconds",
            "KmsMasterKeyId",
            "LastModifiedTimestamp",
            "MaximumMessageSize",
            "MessageRetentionPeriod",
            "Policy",
            "QueueArn",
            "ReceiveMessageWaitTimeSeconds",
            "RedrivePolicy",
            "VisibilityTimeout",
        ]
    }
}
impl AsRef<str> for QueueAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Gives a detailed description of the result of an action on each entry in the
/// request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchResultErrorEntry {
    /// <p>The <code>Id</code> of an entry in a batch request.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the error happened due to the caller of the batch API action.</p>
    pub sender_fault: bool,
    /// <p>An error code representing why the action failed on this entry.</p>
    pub code: std::option::Option<std::string::String>,
    /// <p>A message explaining why the action failed on this entry.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BatchResultErrorEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchResultErrorEntry");
        formatter.field("id", &self.id);
        formatter.field("sender_fault", &self.sender_fault);
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`BatchResultErrorEntry`](crate::model::BatchResultErrorEntry)
pub mod batch_result_error_entry {
    /// A builder for [`BatchResultErrorEntry`](crate::model::BatchResultErrorEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) sender_fault: std::option::Option<bool>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>Id</code> of an entry in a batch request.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the error happened due to the caller of the batch API action.</p>
        pub fn sender_fault(mut self, input: bool) -> Self {
            self.sender_fault = Some(input);
            self
        }
        pub fn set_sender_fault(mut self, input: std::option::Option<bool>) -> Self {
            self.sender_fault = input;
            self
        }
        /// <p>An error code representing why the action failed on this entry.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A message explaining why the action failed on this entry.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchResultErrorEntry`](crate::model::BatchResultErrorEntry)
        pub fn build(self) -> crate::model::BatchResultErrorEntry {
            crate::model::BatchResultErrorEntry {
                id: self.id,
                sender_fault: self.sender_fault.unwrap_or_default(),
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BatchResultErrorEntry {
    /// Creates a new builder-style object to manufacture [`BatchResultErrorEntry`](crate::model::BatchResultErrorEntry)
    pub fn builder() -> crate::model::batch_result_error_entry::Builder {
        crate::model::batch_result_error_entry::Builder::default()
    }
}

/// <p>Encloses a <code>MessageId</code> for a successfully-enqueued message in a <code>
/// <a>SendMessageBatch</a>.</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendMessageBatchResultEntry {
    /// <p>An identifier for the message in this batch.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>An identifier for the message.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>An MD5 digest of the non-URL-encoded message body string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
    pub md5_of_message_body: std::option::Option<std::string::String>,
    /// <p>An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
    pub md5_of_message_attributes: std::option::Option<std::string::String>,
    /// <p>An MD5 digest of the non-URL-encoded message system attribute string. You can use this
    /// attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
    pub md5_of_message_system_attributes: std::option::Option<std::string::String>,
    /// <p>This parameter applies only to FIFO (first-in-first-out) queues.</p>
    /// <p>The large, non-consecutive number that Amazon SQS assigns to each message.</p>
    /// <p>The length of <code>SequenceNumber</code> is 128 bits. As <code>SequenceNumber</code> continues to increase for a particular <code>MessageGroupId</code>.</p>
    pub sequence_number: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendMessageBatchResultEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendMessageBatchResultEntry");
        formatter.field("id", &self.id);
        formatter.field("message_id", &self.message_id);
        formatter.field("md5_of_message_body", &self.md5_of_message_body);
        formatter.field("md5_of_message_attributes", &self.md5_of_message_attributes);
        formatter.field(
            "md5_of_message_system_attributes",
            &self.md5_of_message_system_attributes,
        );
        formatter.field("sequence_number", &self.sequence_number);
        formatter.finish()
    }
}
/// See [`SendMessageBatchResultEntry`](crate::model::SendMessageBatchResultEntry)
pub mod send_message_batch_result_entry {
    /// A builder for [`SendMessageBatchResultEntry`](crate::model::SendMessageBatchResultEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) md5_of_message_body: std::option::Option<std::string::String>,
        pub(crate) md5_of_message_attributes: std::option::Option<std::string::String>,
        pub(crate) md5_of_message_system_attributes: std::option::Option<std::string::String>,
        pub(crate) sequence_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for the message in this batch.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>An identifier for the message.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>An MD5 digest of the non-URL-encoded message body string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
        pub fn md5_of_message_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5_of_message_body = Some(input.into());
            self
        }
        pub fn set_md5_of_message_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.md5_of_message_body = input;
            self
        }
        /// <p>An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
        pub fn md5_of_message_attributes(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5_of_message_attributes = Some(input.into());
            self
        }
        pub fn set_md5_of_message_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.md5_of_message_attributes = input;
            self
        }
        /// <p>An MD5 digest of the non-URL-encoded message system attribute string. You can use this
        /// attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
        pub fn md5_of_message_system_attributes(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.md5_of_message_system_attributes = Some(input.into());
            self
        }
        pub fn set_md5_of_message_system_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.md5_of_message_system_attributes = input;
            self
        }
        /// <p>This parameter applies only to FIFO (first-in-first-out) queues.</p>
        /// <p>The large, non-consecutive number that Amazon SQS assigns to each message.</p>
        /// <p>The length of <code>SequenceNumber</code> is 128 bits. As <code>SequenceNumber</code> continues to increase for a particular <code>MessageGroupId</code>.</p>
        pub fn sequence_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_number = Some(input.into());
            self
        }
        pub fn set_sequence_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_number = input;
            self
        }
        /// Consumes the builder and constructs a [`SendMessageBatchResultEntry`](crate::model::SendMessageBatchResultEntry)
        pub fn build(self) -> crate::model::SendMessageBatchResultEntry {
            crate::model::SendMessageBatchResultEntry {
                id: self.id,
                message_id: self.message_id,
                md5_of_message_body: self.md5_of_message_body,
                md5_of_message_attributes: self.md5_of_message_attributes,
                md5_of_message_system_attributes: self.md5_of_message_system_attributes,
                sequence_number: self.sequence_number,
            }
        }
    }
}
impl SendMessageBatchResultEntry {
    /// Creates a new builder-style object to manufacture [`SendMessageBatchResultEntry`](crate::model::SendMessageBatchResultEntry)
    pub fn builder() -> crate::model::send_message_batch_result_entry::Builder {
        crate::model::send_message_batch_result_entry::Builder::default()
    }
}

/// <p>Contains the details of a single Amazon SQS message along with an <code>Id</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendMessageBatchRequestEntry {
    /// <p>An identifier for a message in this batch used to communicate the result.</p>
    /// <note>
    /// <p>The <code>Id</code>s of a batch request need to be unique within a request.</p>
    /// <p>This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).</p>
    /// </note>
    pub id: std::option::Option<std::string::String>,
    /// <p>The body of the message.</p>
    pub message_body: std::option::Option<std::string::String>,
    /// <p>The length of time, in seconds, for which a specific message is delayed. Valid values: 0 to 900. Maximum: 15 minutes. Messages with a positive <code>DelaySeconds</code> value become available for processing after the delay period is finished.
    /// If you don't specify a value, the default value for the queue is applied.
    /// </p>      
    /// <note>
    /// <p>When you set <code>FifoQueue</code>, you can't set <code>DelaySeconds</code> per message. You can set this parameter only on a queue level.</p>
    /// </note>
    pub delay_seconds: i32,
    /// <p>Each message attribute consists of a <code>Name</code>, <code>Type</code>,
    /// and <code>Value</code>. For more information, see
    /// <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes">Amazon SQS
    /// message attributes</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    pub message_attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
    >,
    /// <p>The message system attribute to send Each message system attribute consists of a <code>Name</code>, <code>Type</code>, and <code>Value</code>.</p>
    /// <important>
    /// <ul>
    /// <li>
    /// <p>Currently, the only supported message system attribute is <code>AWSTraceHeader</code>.
    /// Its type must be <code>String</code> and its value must be a correctly formatted
    /// X-Ray trace header string.</p>
    /// </li>
    /// <li>
    /// <p>The size of a message system attribute doesn't count towards the total size of a message.</p>
    /// </li>
    /// </ul>
    /// </important>
    pub message_system_attributes: std::option::Option<
        std::collections::HashMap<
            crate::model::MessageSystemAttributeNameForSends,
            crate::model::MessageSystemAttributeValue,
        >,
    >,
    /// <p>This parameter applies only to FIFO (first-in-first-out) queues.</p>
    /// <p>The token used for deduplication of messages within a 5-minute minimum deduplication interval. If a message with a particular
    /// <code>MessageDeduplicationId</code> is sent successfully, subsequent messages with the same <code>MessageDeduplicationId</code> are
    /// accepted successfully but aren't delivered. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-exactly-once-processing.html">
    /// Exactly-once processing</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    /// <ul>
    /// <li>
    /// <p>Every message must have a unique <code>MessageDeduplicationId</code>,</p>
    /// <ul>
    /// <li>
    /// <p>You may provide a <code>MessageDeduplicationId</code> explicitly.</p>
    /// </li>
    /// <li>
    /// <p>If you aren't able to provide a <code>MessageDeduplicationId</code> and you enable <code>ContentBasedDeduplication</code> for your queue,
    /// Amazon SQS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using the body of the message (but not the attributes of the message).
    /// </p>
    /// </li>
    /// <li>
    /// <p>If you don't provide a <code>MessageDeduplicationId</code> and the queue doesn't have <code>ContentBasedDeduplication</code> set,
    /// the action fails with an error.</p>
    /// </li>
    /// <li>
    /// <p>If the queue has <code>ContentBasedDeduplication</code> set, your <code>MessageDeduplicationId</code> overrides the generated one.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>When <code>ContentBasedDeduplication</code> is in effect, messages with identical content sent within the deduplication interval are treated as duplicates
    /// and only one copy of the message is delivered.</p>
    /// </li>
    /// <li>
    /// <p>If you send one message with <code>ContentBasedDeduplication</code> enabled and then another message with a <code>MessageDeduplicationId</code> that is the same
    /// as the one generated for the first <code>MessageDeduplicationId</code>, the two messages are treated as duplicates and only one copy of the message is delivered.
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The <code>MessageDeduplicationId</code> is available to the consumer of the
    /// message (this can be useful for troubleshooting delivery issues).</p>
    /// <p>If a message is sent successfully but the acknowledgement is lost and the message is resent with the same
    /// <code>MessageDeduplicationId</code> after the deduplication interval, Amazon SQS can't detect duplicate messages.</p>
    /// <p>Amazon SQS continues to keep track of the message deduplication ID even after the message is received and deleted.</p>
    /// </note>
    /// <p>The length of <code>MessageDeduplicationId</code> is 128 characters. <code>MessageDeduplicationId</code> can contain alphanumeric characters (<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>) and
    /// punctuation (<code>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</code>).</p>
    /// <p>For best practices of using <code>MessageDeduplicationId</code>, see
    /// <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the MessageDeduplicationId Property</a>
    /// in the <i>Amazon SQS Developer Guide</i>.</p>
    pub message_deduplication_id: std::option::Option<std::string::String>,
    /// <p>This parameter applies only to FIFO (first-in-first-out) queues.</p>
    /// <p>The tag that specifies that a message belongs to a specific message group. Messages
    /// that belong to the same message group are processed in a FIFO manner (however,
    /// messages in different message groups might be processed out of order). To interleave
    /// multiple ordered streams within a single queue, use <code>MessageGroupId</code> values
    /// (for example, session data for multiple users). In this scenario, multiple consumers can
    /// process the queue, but the session data of each user is processed in a FIFO
    /// fashion.</p>
    /// <ul>
    /// <li>
    /// <p>You must associate a non-empty <code>MessageGroupId</code> with a message. If you don't provide a <code>MessageGroupId</code>, the action fails.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReceiveMessage</code> might return messages with multiple <code>MessageGroupId</code> values. For each <code>MessageGroupId</code>, the messages are sorted by time sent. The caller can't
    /// specify a <code>MessageGroupId</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The length of <code>MessageGroupId</code> is 128 characters. Valid values: alphanumeric characters and punctuation <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
    /// <p>For best practices of using <code>MessageGroupId</code>, see
    /// <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagegroupid-property.html">Using the MessageGroupId Property</a>
    /// in the <i>Amazon SQS Developer Guide</i>.</p>
    /// <important>
    /// <p>
    /// <code>MessageGroupId</code> is required for FIFO queues. You can't use it for Standard queues.</p>
    /// </important>
    pub message_group_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendMessageBatchRequestEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendMessageBatchRequestEntry");
        formatter.field("id", &self.id);
        formatter.field("message_body", &self.message_body);
        formatter.field("delay_seconds", &self.delay_seconds);
        formatter.field("message_attributes", &self.message_attributes);
        formatter.field("message_system_attributes", &self.message_system_attributes);
        formatter.field("message_deduplication_id", &self.message_deduplication_id);
        formatter.field("message_group_id", &self.message_group_id);
        formatter.finish()
    }
}
/// See [`SendMessageBatchRequestEntry`](crate::model::SendMessageBatchRequestEntry)
pub mod send_message_batch_request_entry {
    /// A builder for [`SendMessageBatchRequestEntry`](crate::model::SendMessageBatchRequestEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) message_body: std::option::Option<std::string::String>,
        pub(crate) delay_seconds: std::option::Option<i32>,
        pub(crate) message_attributes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
        >,
        pub(crate) message_system_attributes: std::option::Option<
            std::collections::HashMap<
                crate::model::MessageSystemAttributeNameForSends,
                crate::model::MessageSystemAttributeValue,
            >,
        >,
        pub(crate) message_deduplication_id: std::option::Option<std::string::String>,
        pub(crate) message_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for a message in this batch used to communicate the result.</p>
        /// <note>
        /// <p>The <code>Id</code>s of a batch request need to be unique within a request.</p>
        /// <p>This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).</p>
        /// </note>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The body of the message.</p>
        pub fn message_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_body = Some(input.into());
            self
        }
        pub fn set_message_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_body = input;
            self
        }
        /// <p>The length of time, in seconds, for which a specific message is delayed. Valid values: 0 to 900. Maximum: 15 minutes. Messages with a positive <code>DelaySeconds</code> value become available for processing after the delay period is finished.
        /// If you don't specify a value, the default value for the queue is applied.
        /// </p>      
        /// <note>
        /// <p>When you set <code>FifoQueue</code>, you can't set <code>DelaySeconds</code> per message. You can set this parameter only on a queue level.</p>
        /// </note>
        pub fn delay_seconds(mut self, input: i32) -> Self {
            self.delay_seconds = Some(input);
            self
        }
        pub fn set_delay_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.delay_seconds = input;
            self
        }
        pub fn message_attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MessageAttributeValue>,
        ) -> Self {
            let mut hash_map = self.message_attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.message_attributes = Some(hash_map);
            self
        }
        pub fn set_message_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
            >,
        ) -> Self {
            self.message_attributes = input;
            self
        }
        pub fn message_system_attributes(
            mut self,
            k: impl Into<crate::model::MessageSystemAttributeNameForSends>,
            v: impl Into<crate::model::MessageSystemAttributeValue>,
        ) -> Self {
            let mut hash_map = self.message_system_attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.message_system_attributes = Some(hash_map);
            self
        }
        pub fn set_message_system_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::MessageSystemAttributeNameForSends,
                    crate::model::MessageSystemAttributeValue,
                >,
            >,
        ) -> Self {
            self.message_system_attributes = input;
            self
        }
        /// <p>This parameter applies only to FIFO (first-in-first-out) queues.</p>
        /// <p>The token used for deduplication of messages within a 5-minute minimum deduplication interval. If a message with a particular
        /// <code>MessageDeduplicationId</code> is sent successfully, subsequent messages with the same <code>MessageDeduplicationId</code> are
        /// accepted successfully but aren't delivered. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues-exactly-once-processing.html">
        /// Exactly-once processing</a> in the <i>Amazon SQS Developer Guide</i>.</p>
        /// <ul>
        /// <li>
        /// <p>Every message must have a unique <code>MessageDeduplicationId</code>,</p>
        /// <ul>
        /// <li>
        /// <p>You may provide a <code>MessageDeduplicationId</code> explicitly.</p>
        /// </li>
        /// <li>
        /// <p>If you aren't able to provide a <code>MessageDeduplicationId</code> and you enable <code>ContentBasedDeduplication</code> for your queue,
        /// Amazon SQS uses a SHA-256 hash to generate the <code>MessageDeduplicationId</code> using the body of the message (but not the attributes of the message).
        /// </p>
        /// </li>
        /// <li>
        /// <p>If you don't provide a <code>MessageDeduplicationId</code> and the queue doesn't have <code>ContentBasedDeduplication</code> set,
        /// the action fails with an error.</p>
        /// </li>
        /// <li>
        /// <p>If the queue has <code>ContentBasedDeduplication</code> set, your <code>MessageDeduplicationId</code> overrides the generated one.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>When <code>ContentBasedDeduplication</code> is in effect, messages with identical content sent within the deduplication interval are treated as duplicates
        /// and only one copy of the message is delivered.</p>
        /// </li>
        /// <li>
        /// <p>If you send one message with <code>ContentBasedDeduplication</code> enabled and then another message with a <code>MessageDeduplicationId</code> that is the same
        /// as the one generated for the first <code>MessageDeduplicationId</code>, the two messages are treated as duplicates and only one copy of the message is delivered.
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>The <code>MessageDeduplicationId</code> is available to the consumer of the
        /// message (this can be useful for troubleshooting delivery issues).</p>
        /// <p>If a message is sent successfully but the acknowledgement is lost and the message is resent with the same
        /// <code>MessageDeduplicationId</code> after the deduplication interval, Amazon SQS can't detect duplicate messages.</p>
        /// <p>Amazon SQS continues to keep track of the message deduplication ID even after the message is received and deleted.</p>
        /// </note>
        /// <p>The length of <code>MessageDeduplicationId</code> is 128 characters. <code>MessageDeduplicationId</code> can contain alphanumeric characters (<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>) and
        /// punctuation (<code>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</code>).</p>
        /// <p>For best practices of using <code>MessageDeduplicationId</code>, see
        /// <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the MessageDeduplicationId Property</a>
        /// in the <i>Amazon SQS Developer Guide</i>.</p>
        pub fn message_deduplication_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_deduplication_id = Some(input.into());
            self
        }
        pub fn set_message_deduplication_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.message_deduplication_id = input;
            self
        }
        /// <p>This parameter applies only to FIFO (first-in-first-out) queues.</p>
        /// <p>The tag that specifies that a message belongs to a specific message group. Messages
        /// that belong to the same message group are processed in a FIFO manner (however,
        /// messages in different message groups might be processed out of order). To interleave
        /// multiple ordered streams within a single queue, use <code>MessageGroupId</code> values
        /// (for example, session data for multiple users). In this scenario, multiple consumers can
        /// process the queue, but the session data of each user is processed in a FIFO
        /// fashion.</p>
        /// <ul>
        /// <li>
        /// <p>You must associate a non-empty <code>MessageGroupId</code> with a message. If you don't provide a <code>MessageGroupId</code>, the action fails.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReceiveMessage</code> might return messages with multiple <code>MessageGroupId</code> values. For each <code>MessageGroupId</code>, the messages are sorted by time sent. The caller can't
        /// specify a <code>MessageGroupId</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The length of <code>MessageGroupId</code> is 128 characters. Valid values: alphanumeric characters and punctuation <code>(!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)</code>.</p>
        /// <p>For best practices of using <code>MessageGroupId</code>, see
        /// <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagegroupid-property.html">Using the MessageGroupId Property</a>
        /// in the <i>Amazon SQS Developer Guide</i>.</p>
        /// <important>
        /// <p>
        /// <code>MessageGroupId</code> is required for FIFO queues. You can't use it for Standard queues.</p>
        /// </important>
        pub fn message_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_group_id = Some(input.into());
            self
        }
        pub fn set_message_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.message_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SendMessageBatchRequestEntry`](crate::model::SendMessageBatchRequestEntry)
        pub fn build(self) -> crate::model::SendMessageBatchRequestEntry {
            crate::model::SendMessageBatchRequestEntry {
                id: self.id,
                message_body: self.message_body,
                delay_seconds: self.delay_seconds.unwrap_or_default(),
                message_attributes: self.message_attributes,
                message_system_attributes: self.message_system_attributes,
                message_deduplication_id: self.message_deduplication_id,
                message_group_id: self.message_group_id,
            }
        }
    }
}
impl SendMessageBatchRequestEntry {
    /// Creates a new builder-style object to manufacture [`SendMessageBatchRequestEntry`](crate::model::SendMessageBatchRequestEntry)
    pub fn builder() -> crate::model::send_message_batch_request_entry::Builder {
        crate::model::send_message_batch_request_entry::Builder::default()
    }
}

/// <p>The user-specified message system attribute value. For string data types, the <code>Value</code> attribute has the same restrictions on the content as the message body. For more information, see <code>
/// <a>SendMessage</a>.</code>
/// </p>    
/// <p>
/// <code>Name</code>, <code>type</code>, <code>value</code> and the message body must not be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageSystemAttributeValue {
    /// <p>Strings are Unicode with UTF-8 binary encoding. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">ASCII Printable Characters</a>.</p>
    pub string_value: std::option::Option<std::string::String>,
    /// <p>Binary type attributes can store any binary data, such as compressed data, encrypted data, or images.</p>
    pub binary_value: std::option::Option<smithy_types::Blob>,
    /// <p>Not implemented. Reserved for future use.</p>
    pub string_list_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Not implemented. Reserved for future use.</p>
    pub binary_list_values: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
    /// <p>Amazon SQS supports the following logical data types: <code>String</code>, <code>Number</code>, and <code>Binary</code>. For the <code>Number</code> data type, you must use <code>StringValue</code>.</p>
    /// <p>You can also append custom labels. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes">Amazon SQS Message Attributes</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    pub data_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageSystemAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageSystemAttributeValue");
        formatter.field("string_value", &self.string_value);
        formatter.field("binary_value", &self.binary_value);
        formatter.field("string_list_values", &self.string_list_values);
        formatter.field("binary_list_values", &self.binary_list_values);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}
/// See [`MessageSystemAttributeValue`](crate::model::MessageSystemAttributeValue)
pub mod message_system_attribute_value {
    /// A builder for [`MessageSystemAttributeValue`](crate::model::MessageSystemAttributeValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_value: std::option::Option<std::string::String>,
        pub(crate) binary_value: std::option::Option<smithy_types::Blob>,
        pub(crate) string_list_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) binary_list_values: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
        pub(crate) data_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Strings are Unicode with UTF-8 binary encoding. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">ASCII Printable Characters</a>.</p>
        pub fn string_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.string_value = Some(input.into());
            self
        }
        pub fn set_string_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.string_value = input;
            self
        }
        /// <p>Binary type attributes can store any binary data, such as compressed data, encrypted data, or images.</p>
        pub fn binary_value(mut self, input: smithy_types::Blob) -> Self {
            self.binary_value = Some(input);
            self
        }
        pub fn set_binary_value(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.binary_value = input;
            self
        }
        pub fn string_list_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_list_values.unwrap_or_default();
            v.push(input.into());
            self.string_list_values = Some(v);
            self
        }
        pub fn set_string_list_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_list_values = input;
            self
        }
        pub fn binary_list_values(mut self, input: impl Into<smithy_types::Blob>) -> Self {
            let mut v = self.binary_list_values.unwrap_or_default();
            v.push(input.into());
            self.binary_list_values = Some(v);
            self
        }
        pub fn set_binary_list_values(
            mut self,
            input: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
        ) -> Self {
            self.binary_list_values = input;
            self
        }
        /// <p>Amazon SQS supports the following logical data types: <code>String</code>, <code>Number</code>, and <code>Binary</code>. For the <code>Number</code> data type, you must use <code>StringValue</code>.</p>
        /// <p>You can also append custom labels. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes">Amazon SQS Message Attributes</a> in the <i>Amazon SQS Developer Guide</i>.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageSystemAttributeValue`](crate::model::MessageSystemAttributeValue)
        pub fn build(self) -> crate::model::MessageSystemAttributeValue {
            crate::model::MessageSystemAttributeValue {
                string_value: self.string_value,
                binary_value: self.binary_value,
                string_list_values: self.string_list_values,
                binary_list_values: self.binary_list_values,
                data_type: self.data_type,
            }
        }
    }
}
impl MessageSystemAttributeValue {
    /// Creates a new builder-style object to manufacture [`MessageSystemAttributeValue`](crate::model::MessageSystemAttributeValue)
    pub fn builder() -> crate::model::message_system_attribute_value::Builder {
        crate::model::message_system_attribute_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MessageSystemAttributeNameForSends {
    AwsTraceHeader,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MessageSystemAttributeNameForSends {
    fn from(s: &str) -> Self {
        match s {
            "AWSTraceHeader" => MessageSystemAttributeNameForSends::AwsTraceHeader,
            other => MessageSystemAttributeNameForSends::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MessageSystemAttributeNameForSends {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MessageSystemAttributeNameForSends::from(s))
    }
}
impl MessageSystemAttributeNameForSends {
    pub fn as_str(&self) -> &str {
        match self {
            MessageSystemAttributeNameForSends::AwsTraceHeader => "AWSTraceHeader",
            MessageSystemAttributeNameForSends::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AWSTraceHeader"]
    }
}
impl AsRef<str> for MessageSystemAttributeNameForSends {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The user-specified message attribute value. For string data types, the <code>Value</code> attribute has the same restrictions on the content as the message body. For more information, see <code>
/// <a>SendMessage</a>.</code>
/// </p>    
/// <p>
/// <code>Name</code>, <code>type</code>, <code>value</code> and the message body must not be empty or null. All parts of the message attribute, including <code>Name</code>, <code>Type</code>, and <code>Value</code>, are part of the message size restriction (256 KB or 262,144 bytes).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageAttributeValue {
    /// <p>Strings are Unicode with UTF-8 binary encoding. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">ASCII Printable Characters</a>.</p>
    pub string_value: std::option::Option<std::string::String>,
    /// <p>Binary type attributes can store any binary data, such as compressed data, encrypted data, or images.</p>
    pub binary_value: std::option::Option<smithy_types::Blob>,
    /// <p>Not implemented. Reserved for future use.</p>
    pub string_list_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Not implemented. Reserved for future use.</p>
    pub binary_list_values: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
    /// <p>Amazon SQS supports the following logical data types: <code>String</code>, <code>Number</code>, and <code>Binary</code>. For the <code>Number</code> data type, you must use <code>StringValue</code>.</p>
    /// <p>You can also append custom labels. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes">Amazon SQS Message Attributes</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    pub data_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageAttributeValue");
        formatter.field("string_value", &self.string_value);
        formatter.field("binary_value", &self.binary_value);
        formatter.field("string_list_values", &self.string_list_values);
        formatter.field("binary_list_values", &self.binary_list_values);
        formatter.field("data_type", &self.data_type);
        formatter.finish()
    }
}
/// See [`MessageAttributeValue`](crate::model::MessageAttributeValue)
pub mod message_attribute_value {
    /// A builder for [`MessageAttributeValue`](crate::model::MessageAttributeValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) string_value: std::option::Option<std::string::String>,
        pub(crate) binary_value: std::option::Option<smithy_types::Blob>,
        pub(crate) string_list_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) binary_list_values: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
        pub(crate) data_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Strings are Unicode with UTF-8 binary encoding. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">ASCII Printable Characters</a>.</p>
        pub fn string_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.string_value = Some(input.into());
            self
        }
        pub fn set_string_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.string_value = input;
            self
        }
        /// <p>Binary type attributes can store any binary data, such as compressed data, encrypted data, or images.</p>
        pub fn binary_value(mut self, input: smithy_types::Blob) -> Self {
            self.binary_value = Some(input);
            self
        }
        pub fn set_binary_value(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.binary_value = input;
            self
        }
        pub fn string_list_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.string_list_values.unwrap_or_default();
            v.push(input.into());
            self.string_list_values = Some(v);
            self
        }
        pub fn set_string_list_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.string_list_values = input;
            self
        }
        pub fn binary_list_values(mut self, input: impl Into<smithy_types::Blob>) -> Self {
            let mut v = self.binary_list_values.unwrap_or_default();
            v.push(input.into());
            self.binary_list_values = Some(v);
            self
        }
        pub fn set_binary_list_values(
            mut self,
            input: std::option::Option<std::vec::Vec<smithy_types::Blob>>,
        ) -> Self {
            self.binary_list_values = input;
            self
        }
        /// <p>Amazon SQS supports the following logical data types: <code>String</code>, <code>Number</code>, and <code>Binary</code>. For the <code>Number</code> data type, you must use <code>StringValue</code>.</p>
        /// <p>You can also append custom labels. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes">Amazon SQS Message Attributes</a> in the <i>Amazon SQS Developer Guide</i>.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageAttributeValue`](crate::model::MessageAttributeValue)
        pub fn build(self) -> crate::model::MessageAttributeValue {
            crate::model::MessageAttributeValue {
                string_value: self.string_value,
                binary_value: self.binary_value,
                string_list_values: self.string_list_values,
                binary_list_values: self.binary_list_values,
                data_type: self.data_type,
            }
        }
    }
}
impl MessageAttributeValue {
    /// Creates a new builder-style object to manufacture [`MessageAttributeValue`](crate::model::MessageAttributeValue)
    pub fn builder() -> crate::model::message_attribute_value::Builder {
        crate::model::message_attribute_value::Builder::default()
    }
}

/// <p>An Amazon SQS message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Message {
    /// <p>A unique identifier for the message. A <code>MessageId</code>is considered unique across all accounts for an extended period of time.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>An identifier associated with the act of receiving the message. A new receipt handle is returned every time you receive a message. When deleting a message, you provide the last received receipt handle to delete the message.</p>
    pub receipt_handle: std::option::Option<std::string::String>,
    /// <p>An MD5 digest of the non-URL-encoded message body string.</p>
    pub md5_of_body: std::option::Option<std::string::String>,
    /// <p>The message's contents (not URL-encoded).</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>A map of the attributes requested in <code>
    /// <a>ReceiveMessage</a>
    /// </code> to their respective values.
    /// Supported attributes:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ApproximateReceiveCount</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ApproximateFirstReceiveTimestamp</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MessageDeduplicationId</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MessageGroupId</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SenderId</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SentTimestamp</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SequenceNumber</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>
    /// <code>ApproximateFirstReceiveTimestamp</code> and <code>SentTimestamp</code> are each returned as an integer representing the
    /// <a href="http://en.wikipedia.org/wiki/Unix_time">epoch time</a> in milliseconds.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<crate::model::MessageSystemAttributeName, std::string::String>,
    >,
    /// <p>An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
    pub md5_of_message_attributes: std::option::Option<std::string::String>,
    /// <p>Each message attribute consists of a <code>Name</code>, <code>Type</code>,
    /// and <code>Value</code>. For more information, see
    /// <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-message-metadata.html#sqs-message-attributes">Amazon SQS
    /// message attributes</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    pub message_attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
    >,
}
impl std::fmt::Debug for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Message");
        formatter.field("message_id", &self.message_id);
        formatter.field("receipt_handle", &self.receipt_handle);
        formatter.field("md5_of_body", &self.md5_of_body);
        formatter.field("body", &self.body);
        formatter.field("attributes", &self.attributes);
        formatter.field("md5_of_message_attributes", &self.md5_of_message_attributes);
        formatter.field("message_attributes", &self.message_attributes);
        formatter.finish()
    }
}
/// See [`Message`](crate::model::Message)
pub mod message {
    /// A builder for [`Message`](crate::model::Message)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) receipt_handle: std::option::Option<std::string::String>,
        pub(crate) md5_of_body: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<
                crate::model::MessageSystemAttributeName,
                std::string::String,
            >,
        >,
        pub(crate) md5_of_message_attributes: std::option::Option<std::string::String>,
        pub(crate) message_attributes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
        >,
    }
    impl Builder {
        /// <p>A unique identifier for the message. A <code>MessageId</code>is considered unique across all accounts for an extended period of time.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>An identifier associated with the act of receiving the message. A new receipt handle is returned every time you receive a message. When deleting a message, you provide the last received receipt handle to delete the message.</p>
        pub fn receipt_handle(mut self, input: impl Into<std::string::String>) -> Self {
            self.receipt_handle = Some(input.into());
            self
        }
        pub fn set_receipt_handle(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.receipt_handle = input;
            self
        }
        /// <p>An MD5 digest of the non-URL-encoded message body string.</p>
        pub fn md5_of_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5_of_body = Some(input.into());
            self
        }
        pub fn set_md5_of_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.md5_of_body = input;
            self
        }
        /// <p>The message's contents (not URL-encoded).</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<crate::model::MessageSystemAttributeName>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::MessageSystemAttributeName,
                    std::string::String,
                >,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>An MD5 digest of the non-URL-encoded message attribute string. You can use this attribute to verify that Amazon SQS received the message correctly. Amazon SQS URL-decodes the message before creating the MD5 digest. For information about MD5, see <a href="https://www.ietf.org/rfc/rfc1321.txt">RFC1321</a>.</p>
        pub fn md5_of_message_attributes(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5_of_message_attributes = Some(input.into());
            self
        }
        pub fn set_md5_of_message_attributes(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.md5_of_message_attributes = input;
            self
        }
        pub fn message_attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MessageAttributeValue>,
        ) -> Self {
            let mut hash_map = self.message_attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.message_attributes = Some(hash_map);
            self
        }
        pub fn set_message_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MessageAttributeValue>,
            >,
        ) -> Self {
            self.message_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`Message`](crate::model::Message)
        pub fn build(self) -> crate::model::Message {
            crate::model::Message {
                message_id: self.message_id,
                receipt_handle: self.receipt_handle,
                md5_of_body: self.md5_of_body,
                body: self.body,
                attributes: self.attributes,
                md5_of_message_attributes: self.md5_of_message_attributes,
                message_attributes: self.message_attributes,
            }
        }
    }
}
impl Message {
    /// Creates a new builder-style object to manufacture [`Message`](crate::model::Message)
    pub fn builder() -> crate::model::message::Builder {
        crate::model::message::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MessageSystemAttributeName {
    AwsTraceHeader,
    ApproximateFirstReceiveTimestamp,
    ApproximateReceiveCount,
    MessageDeduplicationId,
    MessageGroupId,
    SenderId,
    SentTimestamp,
    SequenceNumber,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MessageSystemAttributeName {
    fn from(s: &str) -> Self {
        match s {
            "AWSTraceHeader" => MessageSystemAttributeName::AwsTraceHeader,
            "ApproximateFirstReceiveTimestamp" => {
                MessageSystemAttributeName::ApproximateFirstReceiveTimestamp
            }
            "ApproximateReceiveCount" => MessageSystemAttributeName::ApproximateReceiveCount,
            "MessageDeduplicationId" => MessageSystemAttributeName::MessageDeduplicationId,
            "MessageGroupId" => MessageSystemAttributeName::MessageGroupId,
            "SenderId" => MessageSystemAttributeName::SenderId,
            "SentTimestamp" => MessageSystemAttributeName::SentTimestamp,
            "SequenceNumber" => MessageSystemAttributeName::SequenceNumber,
            other => MessageSystemAttributeName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MessageSystemAttributeName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MessageSystemAttributeName::from(s))
    }
}
impl MessageSystemAttributeName {
    pub fn as_str(&self) -> &str {
        match self {
            MessageSystemAttributeName::AwsTraceHeader => "AWSTraceHeader",
            MessageSystemAttributeName::ApproximateFirstReceiveTimestamp => {
                "ApproximateFirstReceiveTimestamp"
            }
            MessageSystemAttributeName::ApproximateReceiveCount => "ApproximateReceiveCount",
            MessageSystemAttributeName::MessageDeduplicationId => "MessageDeduplicationId",
            MessageSystemAttributeName::MessageGroupId => "MessageGroupId",
            MessageSystemAttributeName::SenderId => "SenderId",
            MessageSystemAttributeName::SentTimestamp => "SentTimestamp",
            MessageSystemAttributeName::SequenceNumber => "SequenceNumber",
            MessageSystemAttributeName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AWSTraceHeader",
            "ApproximateFirstReceiveTimestamp",
            "ApproximateReceiveCount",
            "MessageDeduplicationId",
            "MessageGroupId",
            "SenderId",
            "SentTimestamp",
            "SequenceNumber",
        ]
    }
}
impl AsRef<str> for MessageSystemAttributeName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Encloses the <code>Id</code> of an entry in <code>
/// <a>DeleteMessageBatch</a>.</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMessageBatchResultEntry {
    /// <p>Represents a successfully deleted message.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMessageBatchResultEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMessageBatchResultEntry");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`DeleteMessageBatchResultEntry`](crate::model::DeleteMessageBatchResultEntry)
pub mod delete_message_batch_result_entry {
    /// A builder for [`DeleteMessageBatchResultEntry`](crate::model::DeleteMessageBatchResultEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Represents a successfully deleted message.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMessageBatchResultEntry`](crate::model::DeleteMessageBatchResultEntry)
        pub fn build(self) -> crate::model::DeleteMessageBatchResultEntry {
            crate::model::DeleteMessageBatchResultEntry { id: self.id }
        }
    }
}
impl DeleteMessageBatchResultEntry {
    /// Creates a new builder-style object to manufacture [`DeleteMessageBatchResultEntry`](crate::model::DeleteMessageBatchResultEntry)
    pub fn builder() -> crate::model::delete_message_batch_result_entry::Builder {
        crate::model::delete_message_batch_result_entry::Builder::default()
    }
}

/// <p>Encloses a receipt handle and an identifier for it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMessageBatchRequestEntry {
    /// <p>An identifier for this particular receipt handle. This is used to communicate the result.</p>
    /// <note>
    /// <p>The <code>Id</code>s of a batch request need to be unique within a request.</p>
    /// <p>This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).</p>
    /// </note>
    pub id: std::option::Option<std::string::String>,
    /// <p>A receipt handle.</p>
    pub receipt_handle: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMessageBatchRequestEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMessageBatchRequestEntry");
        formatter.field("id", &self.id);
        formatter.field("receipt_handle", &self.receipt_handle);
        formatter.finish()
    }
}
/// See [`DeleteMessageBatchRequestEntry`](crate::model::DeleteMessageBatchRequestEntry)
pub mod delete_message_batch_request_entry {
    /// A builder for [`DeleteMessageBatchRequestEntry`](crate::model::DeleteMessageBatchRequestEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) receipt_handle: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for this particular receipt handle. This is used to communicate the result.</p>
        /// <note>
        /// <p>The <code>Id</code>s of a batch request need to be unique within a request.</p>
        /// <p>This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).</p>
        /// </note>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A receipt handle.</p>
        pub fn receipt_handle(mut self, input: impl Into<std::string::String>) -> Self {
            self.receipt_handle = Some(input.into());
            self
        }
        pub fn set_receipt_handle(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.receipt_handle = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMessageBatchRequestEntry`](crate::model::DeleteMessageBatchRequestEntry)
        pub fn build(self) -> crate::model::DeleteMessageBatchRequestEntry {
            crate::model::DeleteMessageBatchRequestEntry {
                id: self.id,
                receipt_handle: self.receipt_handle,
            }
        }
    }
}
impl DeleteMessageBatchRequestEntry {
    /// Creates a new builder-style object to manufacture [`DeleteMessageBatchRequestEntry`](crate::model::DeleteMessageBatchRequestEntry)
    pub fn builder() -> crate::model::delete_message_batch_request_entry::Builder {
        crate::model::delete_message_batch_request_entry::Builder::default()
    }
}

/// <p>Encloses the <code>Id</code> of an entry in <code>
/// <a>ChangeMessageVisibilityBatch</a>.</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeMessageVisibilityBatchResultEntry {
    /// <p>Represents a message whose visibility timeout has been changed successfully.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ChangeMessageVisibilityBatchResultEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeMessageVisibilityBatchResultEntry");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}
/// See [`ChangeMessageVisibilityBatchResultEntry`](crate::model::ChangeMessageVisibilityBatchResultEntry)
pub mod change_message_visibility_batch_result_entry {
    /// A builder for [`ChangeMessageVisibilityBatchResultEntry`](crate::model::ChangeMessageVisibilityBatchResultEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Represents a message whose visibility timeout has been changed successfully.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeMessageVisibilityBatchResultEntry`](crate::model::ChangeMessageVisibilityBatchResultEntry)
        pub fn build(self) -> crate::model::ChangeMessageVisibilityBatchResultEntry {
            crate::model::ChangeMessageVisibilityBatchResultEntry { id: self.id }
        }
    }
}
impl ChangeMessageVisibilityBatchResultEntry {
    /// Creates a new builder-style object to manufacture [`ChangeMessageVisibilityBatchResultEntry`](crate::model::ChangeMessageVisibilityBatchResultEntry)
    pub fn builder() -> crate::model::change_message_visibility_batch_result_entry::Builder {
        crate::model::change_message_visibility_batch_result_entry::Builder::default()
    }
}

/// <p>Encloses a receipt handle and an entry id for each message in <code>
/// <a>ChangeMessageVisibilityBatch</a>.</code>
/// </p>
/// <important>
/// <p>All of the following list parameters must be prefixed with <code>ChangeMessageVisibilityBatchRequestEntry.n</code>, where <code>n</code> is an integer value starting with <code>1</code>. For example, a parameter list for this action might look like this:</p>           
/// </important>
/// <p>
/// <code>&ChangeMessageVisibilityBatchRequestEntry.1.Id=change_visibility_msg_2</code>
/// </p>
/// <p>
/// <code>&ChangeMessageVisibilityBatchRequestEntry.1.ReceiptHandle=your_receipt_handle</code>
/// </p>
/// <p>
/// <code>&ChangeMessageVisibilityBatchRequestEntry.1.VisibilityTimeout=45</code>
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeMessageVisibilityBatchRequestEntry {
    /// <p>An identifier for this particular receipt handle used to communicate the result.</p>
    /// <note>
    /// <p>The <code>Id</code>s of a batch request need to be unique within a request.</p>
    /// <p>This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).</p>
    /// </note>
    pub id: std::option::Option<std::string::String>,
    /// <p>A receipt handle.</p>
    pub receipt_handle: std::option::Option<std::string::String>,
    /// <p>The new value (in seconds) for the message's visibility timeout.</p>
    pub visibility_timeout: i32,
}
impl std::fmt::Debug for ChangeMessageVisibilityBatchRequestEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeMessageVisibilityBatchRequestEntry");
        formatter.field("id", &self.id);
        formatter.field("receipt_handle", &self.receipt_handle);
        formatter.field("visibility_timeout", &self.visibility_timeout);
        formatter.finish()
    }
}
/// See [`ChangeMessageVisibilityBatchRequestEntry`](crate::model::ChangeMessageVisibilityBatchRequestEntry)
pub mod change_message_visibility_batch_request_entry {
    /// A builder for [`ChangeMessageVisibilityBatchRequestEntry`](crate::model::ChangeMessageVisibilityBatchRequestEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) receipt_handle: std::option::Option<std::string::String>,
        pub(crate) visibility_timeout: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>An identifier for this particular receipt handle used to communicate the result.</p>
        /// <note>
        /// <p>The <code>Id</code>s of a batch request need to be unique within a request.</p>
        /// <p>This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).</p>
        /// </note>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A receipt handle.</p>
        pub fn receipt_handle(mut self, input: impl Into<std::string::String>) -> Self {
            self.receipt_handle = Some(input.into());
            self
        }
        pub fn set_receipt_handle(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.receipt_handle = input;
            self
        }
        /// <p>The new value (in seconds) for the message's visibility timeout.</p>
        pub fn visibility_timeout(mut self, input: i32) -> Self {
            self.visibility_timeout = Some(input);
            self
        }
        pub fn set_visibility_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.visibility_timeout = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeMessageVisibilityBatchRequestEntry`](crate::model::ChangeMessageVisibilityBatchRequestEntry)
        pub fn build(self) -> crate::model::ChangeMessageVisibilityBatchRequestEntry {
            crate::model::ChangeMessageVisibilityBatchRequestEntry {
                id: self.id,
                receipt_handle: self.receipt_handle,
                visibility_timeout: self.visibility_timeout.unwrap_or_default(),
            }
        }
    }
}
impl ChangeMessageVisibilityBatchRequestEntry {
    /// Creates a new builder-style object to manufacture [`ChangeMessageVisibilityBatchRequestEntry`](crate::model::ChangeMessageVisibilityBatchRequestEntry)
    pub fn builder() -> crate::model::change_message_visibility_batch_request_entry::Builder {
        crate::model::change_message_visibility_batch_request_entry::Builder::default()
    }
}
