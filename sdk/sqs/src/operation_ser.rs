// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_crate_operation_add_permission(
    input: &crate::input::AddPermissionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddPermission", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_1 = writer.prefix("QueueUrl");
    if let Some(var_2) = &input.queue_url {
        scope_1.string(var_2);
    }
    #[allow(unused_mut)]
    let mut scope_3 = writer.prefix("Label");
    if let Some(var_4) = &input.label {
        scope_3.string(var_4);
    }
    #[allow(unused_mut)]
    let mut scope_5 = writer.prefix("AWSAccountId");
    if let Some(var_6) = &input.aws_account_ids {
        let mut list_8 = scope_5.start_list(true, None);
        for item_7 in var_6 {
            #[allow(unused_mut)]
            let mut entry_9 = list_8.entry();
            entry_9.string(item_7);
        }
        list_8.finish();
    }
    #[allow(unused_mut)]
    let mut scope_10 = writer.prefix("ActionName");
    if let Some(var_11) = &input.actions {
        let mut list_13 = scope_10.start_list(true, None);
        for item_12 in var_11 {
            #[allow(unused_mut)]
            let mut entry_14 = list_13.entry();
            entry_14.string(item_12);
        }
        list_13.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_change_message_visibility(
    input: &crate::input::ChangeMessageVisibilityInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ChangeMessageVisibility", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_15 = writer.prefix("QueueUrl");
    if let Some(var_16) = &input.queue_url {
        scope_15.string(var_16);
    }
    #[allow(unused_mut)]
    let mut scope_17 = writer.prefix("ReceiptHandle");
    if let Some(var_18) = &input.receipt_handle {
        scope_17.string(var_18);
    }
    #[allow(unused_mut)]
    let mut scope_19 = writer.prefix("VisibilityTimeout");
    {
        scope_19.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.visibility_timeout).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_change_message_visibility_batch(
    input: &crate::input::ChangeMessageVisibilityBatchInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ChangeMessageVisibilityBatch", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_20 = writer.prefix("QueueUrl");
    if let Some(var_21) = &input.queue_url {
        scope_20.string(var_21);
    }
    #[allow(unused_mut)]
    let mut scope_22 = writer.prefix("ChangeMessageVisibilityBatchRequestEntry");
    if let Some(var_23) = &input.entries {
        let mut list_25 = scope_22.start_list(true, None);
        for item_24 in var_23 {
            #[allow(unused_mut)]
            let mut entry_26 = list_25.entry();
            crate::query_ser::serialize_structure_crate_model_change_message_visibility_batch_request_entry(entry_26, item_24);
        }
        list_25.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_queue(
    input: &crate::input::CreateQueueInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateQueue", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_27 = writer.prefix("QueueName");
    if let Some(var_28) = &input.queue_name {
        scope_27.string(var_28);
    }
    #[allow(unused_mut)]
    let mut scope_29 = writer.prefix("Tag");
    if let Some(var_30) = &input.tags {
        let mut map_31 = scope_29.start_map(true, "Key", "Value");
        for (key_32, value_33) in var_30 {
            #[allow(unused_mut)]
            let mut entry_34 = map_31.entry(key_32);
            {
                entry_34.string(value_33);
            }
        }
        map_31.finish();
    }
    #[allow(unused_mut)]
    let mut scope_35 = writer.prefix("Attribute");
    if let Some(var_36) = &input.attributes {
        let mut map_37 = scope_35.start_map(true, "Name", "Value");
        for (key_38, value_39) in var_36 {
            #[allow(unused_mut)]
            let mut entry_40 = map_37.entry(key_38.as_str());
            {
                entry_40.string(value_39);
            }
        }
        map_37.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_message(
    input: &crate::input::DeleteMessageInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteMessage", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_41 = writer.prefix("QueueUrl");
    if let Some(var_42) = &input.queue_url {
        scope_41.string(var_42);
    }
    #[allow(unused_mut)]
    let mut scope_43 = writer.prefix("ReceiptHandle");
    if let Some(var_44) = &input.receipt_handle {
        scope_43.string(var_44);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_message_batch(
    input: &crate::input::DeleteMessageBatchInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteMessageBatch", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_45 = writer.prefix("QueueUrl");
    if let Some(var_46) = &input.queue_url {
        scope_45.string(var_46);
    }
    #[allow(unused_mut)]
    let mut scope_47 = writer.prefix("DeleteMessageBatchRequestEntry");
    if let Some(var_48) = &input.entries {
        let mut list_50 = scope_47.start_list(true, None);
        for item_49 in var_48 {
            #[allow(unused_mut)]
            let mut entry_51 = list_50.entry();
            crate::query_ser::serialize_structure_crate_model_delete_message_batch_request_entry(
                entry_51, item_49,
            );
        }
        list_50.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_queue(
    input: &crate::input::DeleteQueueInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteQueue", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_52 = writer.prefix("QueueUrl");
    if let Some(var_53) = &input.queue_url {
        scope_52.string(var_53);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_queue_attributes(
    input: &crate::input::GetQueueAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetQueueAttributes", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_54 = writer.prefix("QueueUrl");
    if let Some(var_55) = &input.queue_url {
        scope_54.string(var_55);
    }
    #[allow(unused_mut)]
    let mut scope_56 = writer.prefix("AttributeName");
    if let Some(var_57) = &input.attribute_names {
        let mut list_59 = scope_56.start_list(true, None);
        for item_58 in var_57 {
            #[allow(unused_mut)]
            let mut entry_60 = list_59.entry();
            entry_60.string(item_58.as_str());
        }
        list_59.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_queue_url(
    input: &crate::input::GetQueueUrlInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "GetQueueUrl", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_61 = writer.prefix("QueueName");
    if let Some(var_62) = &input.queue_name {
        scope_61.string(var_62);
    }
    #[allow(unused_mut)]
    let mut scope_63 = writer.prefix("QueueOwnerAWSAccountId");
    if let Some(var_64) = &input.queue_owner_aws_account_id {
        scope_63.string(var_64);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_dead_letter_source_queues(
    input: &crate::input::ListDeadLetterSourceQueuesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ListDeadLetterSourceQueues", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_65 = writer.prefix("QueueUrl");
    if let Some(var_66) = &input.queue_url {
        scope_65.string(var_66);
    }
    #[allow(unused_mut)]
    let mut scope_67 = writer.prefix("NextToken");
    if let Some(var_68) = &input.next_token {
        scope_67.string(var_68);
    }
    #[allow(unused_mut)]
    let mut scope_69 = writer.prefix("MaxResults");
    if let Some(var_70) = &input.max_results {
        scope_69.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_70).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_queues(
    input: &crate::input::ListQueuesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListQueues", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_71 = writer.prefix("QueueNamePrefix");
    if let Some(var_72) = &input.queue_name_prefix {
        scope_71.string(var_72);
    }
    #[allow(unused_mut)]
    let mut scope_73 = writer.prefix("NextToken");
    if let Some(var_74) = &input.next_token {
        scope_73.string(var_74);
    }
    #[allow(unused_mut)]
    let mut scope_75 = writer.prefix("MaxResults");
    if let Some(var_76) = &input.max_results {
        scope_75.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_76).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_list_queue_tags(
    input: &crate::input::ListQueueTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ListQueueTags", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_77 = writer.prefix("QueueUrl");
    if let Some(var_78) = &input.queue_url {
        scope_77.string(var_78);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_purge_queue(
    input: &crate::input::PurgeQueueInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PurgeQueue", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_79 = writer.prefix("QueueUrl");
    if let Some(var_80) = &input.queue_url {
        scope_79.string(var_80);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_receive_message(
    input: &crate::input::ReceiveMessageInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ReceiveMessage", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_81 = writer.prefix("QueueUrl");
    if let Some(var_82) = &input.queue_url {
        scope_81.string(var_82);
    }
    #[allow(unused_mut)]
    let mut scope_83 = writer.prefix("AttributeName");
    if let Some(var_84) = &input.attribute_names {
        let mut list_86 = scope_83.start_list(true, None);
        for item_85 in var_84 {
            #[allow(unused_mut)]
            let mut entry_87 = list_86.entry();
            entry_87.string(item_85.as_str());
        }
        list_86.finish();
    }
    #[allow(unused_mut)]
    let mut scope_88 = writer.prefix("MessageAttributeName");
    if let Some(var_89) = &input.message_attribute_names {
        let mut list_91 = scope_88.start_list(true, None);
        for item_90 in var_89 {
            #[allow(unused_mut)]
            let mut entry_92 = list_91.entry();
            entry_92.string(item_90);
        }
        list_91.finish();
    }
    #[allow(unused_mut)]
    let mut scope_93 = writer.prefix("MaxNumberOfMessages");
    if input.max_number_of_messages != 0 {
        scope_93.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.max_number_of_messages).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_94 = writer.prefix("VisibilityTimeout");
    if input.visibility_timeout != 0 {
        scope_94.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.visibility_timeout).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_95 = writer.prefix("WaitTimeSeconds");
    if input.wait_time_seconds != 0 {
        scope_95.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.wait_time_seconds).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_96 = writer.prefix("ReceiveRequestAttemptId");
    if let Some(var_97) = &input.receive_request_attempt_id {
        scope_96.string(var_97);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_remove_permission(
    input: &crate::input::RemovePermissionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RemovePermission", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_98 = writer.prefix("QueueUrl");
    if let Some(var_99) = &input.queue_url {
        scope_98.string(var_99);
    }
    #[allow(unused_mut)]
    let mut scope_100 = writer.prefix("Label");
    if let Some(var_101) = &input.label {
        scope_100.string(var_101);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_message(
    input: &crate::input::SendMessageInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SendMessage", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_102 = writer.prefix("QueueUrl");
    if let Some(var_103) = &input.queue_url {
        scope_102.string(var_103);
    }
    #[allow(unused_mut)]
    let mut scope_104 = writer.prefix("MessageBody");
    if let Some(var_105) = &input.message_body {
        scope_104.string(var_105);
    }
    #[allow(unused_mut)]
    let mut scope_106 = writer.prefix("DelaySeconds");
    if input.delay_seconds != 0 {
        scope_106.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.delay_seconds).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_107 = writer.prefix("MessageAttribute");
    if let Some(var_108) = &input.message_attributes {
        let mut map_109 = scope_107.start_map(true, "Name", "Value");
        for (key_110, value_111) in var_108 {
            #[allow(unused_mut)]
            let mut entry_112 = map_109.entry(key_110);
            {
                crate::query_ser::serialize_structure_crate_model_message_attribute_value(
                    entry_112, value_111,
                );
            }
        }
        map_109.finish();
    }
    #[allow(unused_mut)]
    let mut scope_113 = writer.prefix("MessageSystemAttribute");
    if let Some(var_114) = &input.message_system_attributes {
        let mut map_115 = scope_113.start_map(true, "Name", "Value");
        for (key_116, value_117) in var_114 {
            #[allow(unused_mut)]
            let mut entry_118 = map_115.entry(key_116.as_str());
            {
                crate::query_ser::serialize_structure_crate_model_message_system_attribute_value(
                    entry_118, value_117,
                );
            }
        }
        map_115.finish();
    }
    #[allow(unused_mut)]
    let mut scope_119 = writer.prefix("MessageDeduplicationId");
    if let Some(var_120) = &input.message_deduplication_id {
        scope_119.string(var_120);
    }
    #[allow(unused_mut)]
    let mut scope_121 = writer.prefix("MessageGroupId");
    if let Some(var_122) = &input.message_group_id {
        scope_121.string(var_122);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_send_message_batch(
    input: &crate::input::SendMessageBatchInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SendMessageBatch", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_123 = writer.prefix("QueueUrl");
    if let Some(var_124) = &input.queue_url {
        scope_123.string(var_124);
    }
    #[allow(unused_mut)]
    let mut scope_125 = writer.prefix("SendMessageBatchRequestEntry");
    if let Some(var_126) = &input.entries {
        let mut list_128 = scope_125.start_list(true, None);
        for item_127 in var_126 {
            #[allow(unused_mut)]
            let mut entry_129 = list_128.entry();
            crate::query_ser::serialize_structure_crate_model_send_message_batch_request_entry(
                entry_129, item_127,
            );
        }
        list_128.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_set_queue_attributes(
    input: &crate::input::SetQueueAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "SetQueueAttributes", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_130 = writer.prefix("QueueUrl");
    if let Some(var_131) = &input.queue_url {
        scope_130.string(var_131);
    }
    #[allow(unused_mut)]
    let mut scope_132 = writer.prefix("Attribute");
    if let Some(var_133) = &input.attributes {
        let mut map_134 = scope_132.start_map(true, "Name", "Value");
        for (key_135, value_136) in var_133 {
            #[allow(unused_mut)]
            let mut entry_137 = map_134.entry(key_135.as_str());
            {
                entry_137.string(value_136);
            }
        }
        map_134.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_tag_queue(
    input: &crate::input::TagQueueInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "TagQueue", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_138 = writer.prefix("QueueUrl");
    if let Some(var_139) = &input.queue_url {
        scope_138.string(var_139);
    }
    #[allow(unused_mut)]
    let mut scope_140 = writer.prefix("Tag");
    if let Some(var_141) = &input.tags {
        let mut map_142 = scope_140.start_map(true, "Key", "Value");
        for (key_143, value_144) in var_141 {
            #[allow(unused_mut)]
            let mut entry_145 = map_142.entry(key_143);
            {
                entry_145.string(value_144);
            }
        }
        map_142.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_untag_queue(
    input: &crate::input::UntagQueueInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UntagQueue", "2012-11-05");
    #[allow(unused_mut)]
    let mut scope_146 = writer.prefix("QueueUrl");
    if let Some(var_147) = &input.queue_url {
        scope_146.string(var_147);
    }
    #[allow(unused_mut)]
    let mut scope_148 = writer.prefix("TagKey");
    if let Some(var_149) = &input.tag_keys {
        let mut list_151 = scope_148.start_list(true, None);
        for item_150 in var_149 {
            #[allow(unused_mut)]
            let mut entry_152 = list_151.entry();
            entry_152.string(item_150);
        }
        list_151.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddPermissionOutput, crate::error::AddPermissionError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddPermissionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddPermissionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OverLimit" => crate::error::AddPermissionError {
            meta: generic,
            kind: crate::error::AddPermissionErrorKind::OverLimit({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::over_limit::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_over_limit_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddPermissionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddPermissionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddPermissionOutput, crate::error::AddPermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_message_visibility_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeMessageVisibilityOutput,
    crate::error::ChangeMessageVisibilityError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ChangeMessageVisibilityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ChangeMessageVisibilityError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.MessageNotInflight" => {
            crate::error::ChangeMessageVisibilityError {
                meta: generic,
                kind: crate::error::ChangeMessageVisibilityErrorKind::MessageNotInflight({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::message_not_inflight::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_message_not_inflight_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeMessageVisibilityError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ReceiptHandleIsInvalid" => crate::error::ChangeMessageVisibilityError {
            meta: generic,
            kind: crate::error::ChangeMessageVisibilityErrorKind::ReceiptHandleIsInvalid({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::receipt_handle_is_invalid::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_receipt_handle_is_invalid_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeMessageVisibilityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ChangeMessageVisibilityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_message_visibility_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeMessageVisibilityOutput,
    crate::error::ChangeMessageVisibilityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_message_visibility_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_message_visibility_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeMessageVisibilityBatchOutput,
    crate::error::ChangeMessageVisibilityBatchError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ChangeMessageVisibilityBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ChangeMessageVisibilityBatchError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.BatchEntryIdsNotDistinct" => crate::error::ChangeMessageVisibilityBatchError { meta: generic, kind: crate::error::ChangeMessageVisibilityBatchErrorKind::BatchEntryIdsNotDistinct({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::batch_entry_ids_not_distinct::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_batch_entry_ids_not_distinct_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeMessageVisibilityBatchError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AWS.SimpleQueueService.EmptyBatchRequest" => crate::error::ChangeMessageVisibilityBatchError { meta: generic, kind: crate::error::ChangeMessageVisibilityBatchErrorKind::EmptyBatchRequest({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::empty_batch_request::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_empty_batch_request_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeMessageVisibilityBatchError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AWS.SimpleQueueService.InvalidBatchEntryId" => crate::error::ChangeMessageVisibilityBatchError { meta: generic, kind: crate::error::ChangeMessageVisibilityBatchErrorKind::InvalidBatchEntryId({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_batch_entry_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_batch_entry_id_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeMessageVisibilityBatchError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AWS.SimpleQueueService.TooManyEntriesInBatchRequest" => crate::error::ChangeMessageVisibilityBatchError { meta: generic, kind: crate::error::ChangeMessageVisibilityBatchErrorKind::TooManyEntriesInBatchRequest({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::too_many_entries_in_batch_request::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_too_many_entries_in_batch_request_xml_err(response.body().as_ref(), output).map_err(crate::error::ChangeMessageVisibilityBatchError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ChangeMessageVisibilityBatchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_change_message_visibility_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ChangeMessageVisibilityBatchOutput,
    crate::error::ChangeMessageVisibilityBatchError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::change_message_visibility_batch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_change_message_visibility_batch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ChangeMessageVisibilityBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_queue_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateQueueOutput, crate::error::CreateQueueError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateQueueError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateQueueError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.QueueDeletedRecently" => crate::error::CreateQueueError {
            meta: generic,
            kind: crate::error::CreateQueueErrorKind::QueueDeletedRecently({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::queue_deleted_recently::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_queue_deleted_recently_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateQueueError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "QueueAlreadyExists" => {
            crate::error::CreateQueueError {
                meta: generic,
                kind: crate::error::CreateQueueErrorKind::QueueNameExists({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::queue_name_exists::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_queue_name_exists_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateQueueError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::CreateQueueError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_queue_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateQueueOutput, crate::error::CreateQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_queue_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_queue(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateQueueError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_message_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteMessageOutput, crate::error::DeleteMessageError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteMessageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteMessageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidIdFormat" => {
            crate::error::DeleteMessageError {
                meta: generic,
                kind: crate::error::DeleteMessageErrorKind::InvalidIdFormat({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_id_format::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_id_format_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMessageError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ReceiptHandleIsInvalid" => crate::error::DeleteMessageError {
            meta: generic,
            kind: crate::error::DeleteMessageErrorKind::ReceiptHandleIsInvalid({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::receipt_handle_is_invalid::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_receipt_handle_is_invalid_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMessageError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteMessageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_message_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteMessageOutput, crate::error::DeleteMessageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_message_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_message_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMessageBatchOutput,
    crate::error::DeleteMessageBatchError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteMessageBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteMessageBatchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.BatchEntryIdsNotDistinct" => {
            crate::error::DeleteMessageBatchError {
                meta: generic,
                kind: crate::error::DeleteMessageBatchErrorKind::BatchEntryIdsNotDistinct({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::batch_entry_ids_not_distinct::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_batch_entry_ids_not_distinct_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMessageBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "AWS.SimpleQueueService.EmptyBatchRequest" => {
            crate::error::DeleteMessageBatchError {
                meta: generic,
                kind: crate::error::DeleteMessageBatchErrorKind::EmptyBatchRequest({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::empty_batch_request::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_empty_batch_request_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMessageBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "AWS.SimpleQueueService.InvalidBatchEntryId" => crate::error::DeleteMessageBatchError {
            meta: generic,
            kind: crate::error::DeleteMessageBatchErrorKind::InvalidBatchEntryId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_batch_entry_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_batch_entry_id_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMessageBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AWS.SimpleQueueService.TooManyEntriesInBatchRequest" => {
            crate::error::DeleteMessageBatchError {
                meta: generic,
                kind: crate::error::DeleteMessageBatchErrorKind::TooManyEntriesInBatchRequest({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::too_many_entries_in_batch_request::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_too_many_entries_in_batch_request_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteMessageBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteMessageBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_message_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMessageBatchOutput,
    crate::error::DeleteMessageBatchError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_message_batch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_message_batch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteMessageBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_queue_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteQueueOutput, crate::error::DeleteQueueError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteQueueError::unhandled)?;
    Err(crate::error::DeleteQueueError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_queue_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteQueueOutput, crate::error::DeleteQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_queue_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_queue_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetQueueAttributesOutput,
    crate::error::GetQueueAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetQueueAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetQueueAttributesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidAttributeName" => crate::error::GetQueueAttributesError {
            meta: generic,
            kind: crate::error::GetQueueAttributesErrorKind::InvalidAttributeName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_attribute_name::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_attribute_name_xml_err(response.body().as_ref(), output).map_err(crate::error::GetQueueAttributesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetQueueAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_queue_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetQueueAttributesOutput,
    crate::error::GetQueueAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_queue_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_queue_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetQueueAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_queue_url_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetQueueUrlOutput, crate::error::GetQueueUrlError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetQueueUrlError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetQueueUrlError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.NonExistentQueue" => {
            crate::error::GetQueueUrlError {
                meta: generic,
                kind: crate::error::GetQueueUrlErrorKind::QueueDoesNotExist({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::queue_does_not_exist::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_queue_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::GetQueueUrlError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetQueueUrlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_queue_url_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetQueueUrlOutput, crate::error::GetQueueUrlError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_queue_url_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_queue_url(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetQueueUrlError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_dead_letter_source_queues_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeadLetterSourceQueuesOutput,
    crate::error::ListDeadLetterSourceQueuesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListDeadLetterSourceQueuesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDeadLetterSourceQueuesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.NonExistentQueue" => {
            crate::error::ListDeadLetterSourceQueuesError {
                meta: generic,
                kind: crate::error::ListDeadLetterSourceQueuesErrorKind::QueueDoesNotExist({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::queue_does_not_exist::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_queue_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::ListDeadLetterSourceQueuesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListDeadLetterSourceQueuesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_dead_letter_source_queues_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeadLetterSourceQueuesOutput,
    crate::error::ListDeadLetterSourceQueuesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_dead_letter_source_queues_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_dead_letter_source_queues(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeadLetterSourceQueuesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_queues_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListQueuesOutput, crate::error::ListQueuesError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListQueuesError::unhandled)?;
    Err(crate::error::ListQueuesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_queues_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListQueuesOutput, crate::error::ListQueuesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_queues_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_queues(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListQueuesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_queue_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListQueueTagsOutput, crate::error::ListQueueTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListQueueTagsError::unhandled)?;
    Err(crate::error::ListQueueTagsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_queue_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListQueueTagsOutput, crate::error::ListQueueTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_queue_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_queue_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListQueueTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purge_queue_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PurgeQueueOutput, crate::error::PurgeQueueError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PurgeQueueError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PurgeQueueError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.PurgeQueueInProgress" => crate::error::PurgeQueueError {
            meta: generic,
            kind: crate::error::PurgeQueueErrorKind::PurgeQueueInProgress({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::purge_queue_in_progress::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_purge_queue_in_progress_xml_err(response.body().as_ref(), output).map_err(crate::error::PurgeQueueError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AWS.SimpleQueueService.NonExistentQueue" => {
            crate::error::PurgeQueueError {
                meta: generic,
                kind: crate::error::PurgeQueueErrorKind::QueueDoesNotExist({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::queue_does_not_exist::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_queue_does_not_exist_xml_err(response.body().as_ref(), output).map_err(crate::error::PurgeQueueError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::PurgeQueueError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purge_queue_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PurgeQueueOutput, crate::error::PurgeQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purge_queue_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_receive_message_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReceiveMessageOutput, crate::error::ReceiveMessageError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ReceiveMessageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ReceiveMessageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OverLimit" => crate::error::ReceiveMessageError {
            meta: generic,
            kind: crate::error::ReceiveMessageErrorKind::OverLimit({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::over_limit::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_over_limit_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ReceiveMessageError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ReceiveMessageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_receive_message_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReceiveMessageOutput, crate::error::ReceiveMessageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::receive_message_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_receive_message(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ReceiveMessageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_permission_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RemovePermissionOutput, crate::error::RemovePermissionError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RemovePermissionError::unhandled)?;
    Err(crate::error::RemovePermissionError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_permission_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RemovePermissionOutput, crate::error::RemovePermissionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_message_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendMessageOutput, crate::error::SendMessageError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendMessageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendMessageError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidMessageContents" => crate::error::SendMessageError {
            meta: generic,
            kind: crate::error::SendMessageErrorKind::InvalidMessageContents({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_message_contents::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_message_contents_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AWS.SimpleQueueService.UnsupportedOperation" => crate::error::SendMessageError {
            meta: generic,
            kind: crate::error::SendMessageErrorKind::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendMessageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_message_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendMessageOutput, crate::error::SendMessageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_message_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_message(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendMessageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_message_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendMessageBatchOutput, crate::error::SendMessageBatchError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SendMessageBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendMessageBatchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AWS.SimpleQueueService.BatchEntryIdsNotDistinct" => crate::error::SendMessageBatchError {
            meta: generic,
            kind: crate::error::SendMessageBatchErrorKind::BatchEntryIdsNotDistinct({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::batch_entry_ids_not_distinct::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_batch_entry_ids_not_distinct_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AWS.SimpleQueueService.BatchRequestTooLong" => crate::error::SendMessageBatchError {
            meta: generic,
            kind: crate::error::SendMessageBatchErrorKind::BatchRequestTooLong({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::batch_request_too_long::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_batch_request_too_long_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AWS.SimpleQueueService.EmptyBatchRequest" => {
            crate::error::SendMessageBatchError {
                meta: generic,
                kind: crate::error::SendMessageBatchErrorKind::EmptyBatchRequest({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::empty_batch_request::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_empty_batch_request_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "AWS.SimpleQueueService.InvalidBatchEntryId" => crate::error::SendMessageBatchError {
            meta: generic,
            kind: crate::error::SendMessageBatchErrorKind::InvalidBatchEntryId({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_batch_entry_id::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_batch_entry_id_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AWS.SimpleQueueService.TooManyEntriesInBatchRequest" => {
            crate::error::SendMessageBatchError {
                meta: generic,
                kind: crate::error::SendMessageBatchErrorKind::TooManyEntriesInBatchRequest({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::too_many_entries_in_batch_request::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_too_many_entries_in_batch_request_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageBatchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "AWS.SimpleQueueService.UnsupportedOperation" => crate::error::SendMessageBatchError {
            meta: generic,
            kind: crate::error::SendMessageBatchErrorKind::UnsupportedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::SendMessageBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SendMessageBatchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_message_batch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendMessageBatchOutput, crate::error::SendMessageBatchError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_message_batch_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_send_message_batch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendMessageBatchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_queue_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetQueueAttributesOutput,
    crate::error::SetQueueAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::SetQueueAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SetQueueAttributesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidAttributeName" => crate::error::SetQueueAttributesError {
            meta: generic,
            kind: crate::error::SetQueueAttributesErrorKind::InvalidAttributeName({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_attribute_name::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_attribute_name_xml_err(response.body().as_ref(), output).map_err(crate::error::SetQueueAttributesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SetQueueAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_queue_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetQueueAttributesOutput,
    crate::error::SetQueueAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_queue_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_queue_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagQueueOutput, crate::error::TagQueueError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagQueueError::unhandled)?;
    Err(crate::error::TagQueueError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_queue_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagQueueOutput, crate::error::TagQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_queue_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_queue_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagQueueOutput, crate::error::UntagQueueError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagQueueError::unhandled)?;
    Err(crate::error::UntagQueueError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_queue_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagQueueOutput, crate::error::UntagQueueError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_queue_output::Builder::default();
        let _ = response;
        output.build()
    })
}
