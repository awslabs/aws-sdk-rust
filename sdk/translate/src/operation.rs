// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a parallel data resource in Amazon Translate by importing an input file from
/// Amazon S3. Parallel data files contain examples of source phrases and their translations from
/// your translation memory. By adding parallel data, you can influence the style, tone, and word
/// choice in your translation output.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateParallelData {
    _private: (),
}
impl CreateParallelData {
    /// Creates a new builder-style object to manufacture [`CreateParallelDataInput`](crate::input::CreateParallelDataInput)
    pub fn builder() -> crate::input::create_parallel_data_input::Builder {
        crate::input::create_parallel_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateParallelData {
    type Output = std::result::Result<
        crate::output::CreateParallelDataOutput,
        crate::error::CreateParallelDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_parallel_data_error(response)
        } else {
            crate::operation_deser::parse_create_parallel_data_response(response)
        }
    }
}

/// <p>Deletes a parallel data resource in Amazon Translate.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteParallelData {
    _private: (),
}
impl DeleteParallelData {
    /// Creates a new builder-style object to manufacture [`DeleteParallelDataInput`](crate::input::DeleteParallelDataInput)
    pub fn builder() -> crate::input::delete_parallel_data_input::Builder {
        crate::input::delete_parallel_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteParallelData {
    type Output = std::result::Result<
        crate::output::DeleteParallelDataOutput,
        crate::error::DeleteParallelDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_parallel_data_error(response)
        } else {
            crate::operation_deser::parse_delete_parallel_data_response(response)
        }
    }
}

/// <p>A synchronous action that deletes a custom terminology.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTerminology {
    _private: (),
}
impl DeleteTerminology {
    /// Creates a new builder-style object to manufacture [`DeleteTerminologyInput`](crate::input::DeleteTerminologyInput)
    pub fn builder() -> crate::input::delete_terminology_input::Builder {
        crate::input::delete_terminology_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTerminology {
    type Output = std::result::Result<
        crate::output::DeleteTerminologyOutput,
        crate::error::DeleteTerminologyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_terminology_error(response)
        } else {
            crate::operation_deser::parse_delete_terminology_response(response)
        }
    }
}

/// <p>Gets the properties associated with an asycnhronous batch translation job including name,
/// ID, status, source and target languages, input/output S3 buckets, and so on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTextTranslationJob {
    _private: (),
}
impl DescribeTextTranslationJob {
    /// Creates a new builder-style object to manufacture [`DescribeTextTranslationJobInput`](crate::input::DescribeTextTranslationJobInput)
    pub fn builder() -> crate::input::describe_text_translation_job_input::Builder {
        crate::input::describe_text_translation_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTextTranslationJob {
    type Output = std::result::Result<
        crate::output::DescribeTextTranslationJobOutput,
        crate::error::DescribeTextTranslationJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_text_translation_job_error(response)
        } else {
            crate::operation_deser::parse_describe_text_translation_job_response(response)
        }
    }
}

/// <p>Provides information about a parallel data resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetParallelData {
    _private: (),
}
impl GetParallelData {
    /// Creates a new builder-style object to manufacture [`GetParallelDataInput`](crate::input::GetParallelDataInput)
    pub fn builder() -> crate::input::get_parallel_data_input::Builder {
        crate::input::get_parallel_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetParallelData {
    type Output = std::result::Result<
        crate::output::GetParallelDataOutput,
        crate::error::GetParallelDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_parallel_data_error(response)
        } else {
            crate::operation_deser::parse_get_parallel_data_response(response)
        }
    }
}

/// <p>Retrieves a custom terminology.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTerminology {
    _private: (),
}
impl GetTerminology {
    /// Creates a new builder-style object to manufacture [`GetTerminologyInput`](crate::input::GetTerminologyInput)
    pub fn builder() -> crate::input::get_terminology_input::Builder {
        crate::input::get_terminology_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTerminology {
    type Output =
        std::result::Result<crate::output::GetTerminologyOutput, crate::error::GetTerminologyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_terminology_error(response)
        } else {
            crate::operation_deser::parse_get_terminology_response(response)
        }
    }
}

/// <p>Creates or updates a custom terminology, depending on whether or not one already exists
/// for the given terminology name. Importing a terminology with the same name as an existing one
/// will merge the terminologies based on the chosen merge strategy. Currently, the only supported
/// merge strategy is OVERWRITE, and so the imported terminology will overwrite an existing
/// terminology of the same name.</p>
/// <p>If you import a terminology that overwrites an existing one, the new terminology take up
/// to 10 minutes to fully propagate and be available for use in a translation due to cache
/// policies with the DataPlane service that performs the translations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportTerminology {
    _private: (),
}
impl ImportTerminology {
    /// Creates a new builder-style object to manufacture [`ImportTerminologyInput`](crate::input::ImportTerminologyInput)
    pub fn builder() -> crate::input::import_terminology_input::Builder {
        crate::input::import_terminology_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportTerminology {
    type Output = std::result::Result<
        crate::output::ImportTerminologyOutput,
        crate::error::ImportTerminologyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_terminology_error(response)
        } else {
            crate::operation_deser::parse_import_terminology_response(response)
        }
    }
}

/// <p>Provides a list of your parallel data resources in Amazon Translate.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListParallelData {
    _private: (),
}
impl ListParallelData {
    /// Creates a new builder-style object to manufacture [`ListParallelDataInput`](crate::input::ListParallelDataInput)
    pub fn builder() -> crate::input::list_parallel_data_input::Builder {
        crate::input::list_parallel_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListParallelData {
    type Output = std::result::Result<
        crate::output::ListParallelDataOutput,
        crate::error::ListParallelDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_parallel_data_error(response)
        } else {
            crate::operation_deser::parse_list_parallel_data_response(response)
        }
    }
}

/// <p>Provides a list of custom terminologies associated with your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTerminologies {
    _private: (),
}
impl ListTerminologies {
    /// Creates a new builder-style object to manufacture [`ListTerminologiesInput`](crate::input::ListTerminologiesInput)
    pub fn builder() -> crate::input::list_terminologies_input::Builder {
        crate::input::list_terminologies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTerminologies {
    type Output = std::result::Result<
        crate::output::ListTerminologiesOutput,
        crate::error::ListTerminologiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_terminologies_error(response)
        } else {
            crate::operation_deser::parse_list_terminologies_response(response)
        }
    }
}

/// <p>Gets a list of the batch translation jobs that you have submitted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTextTranslationJobs {
    _private: (),
}
impl ListTextTranslationJobs {
    /// Creates a new builder-style object to manufacture [`ListTextTranslationJobsInput`](crate::input::ListTextTranslationJobsInput)
    pub fn builder() -> crate::input::list_text_translation_jobs_input::Builder {
        crate::input::list_text_translation_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTextTranslationJobs {
    type Output = std::result::Result<
        crate::output::ListTextTranslationJobsOutput,
        crate::error::ListTextTranslationJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_text_translation_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_text_translation_jobs_response(response)
        }
    }
}

/// <p>Starts an asynchronous batch translation job. Batch translation jobs can be used to
/// translate large volumes of text across multiple documents at once. For more information, see
/// <a>async</a>.</p>
/// <p>Batch translation jobs can be described with the <a>DescribeTextTranslationJob</a> operation, listed with the <a>ListTextTranslationJobs</a> operation, and stopped with the <a>StopTextTranslationJob</a> operation.</p>
/// <note>
/// <p>Amazon Translate does not support batch translation of multiple source languages at once.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartTextTranslationJob {
    _private: (),
}
impl StartTextTranslationJob {
    /// Creates a new builder-style object to manufacture [`StartTextTranslationJobInput`](crate::input::StartTextTranslationJobInput)
    pub fn builder() -> crate::input::start_text_translation_job_input::Builder {
        crate::input::start_text_translation_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartTextTranslationJob {
    type Output = std::result::Result<
        crate::output::StartTextTranslationJobOutput,
        crate::error::StartTextTranslationJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_text_translation_job_error(response)
        } else {
            crate::operation_deser::parse_start_text_translation_job_response(response)
        }
    }
}

/// <p>Stops an asynchronous batch translation job that is in progress.</p>
/// <p>If the job's state is <code>IN_PROGRESS</code>, the job will be marked for termination and
/// put into the <code>STOP_REQUESTED</code> state. If the job completes before it can be stopped,
/// it is put into the <code>COMPLETED</code> state. Otherwise, the job is put into the
/// <code>STOPPED</code> state.</p>
/// <p>Asynchronous batch translation jobs are started with the <a>StartTextTranslationJob</a> operation. You can use the <a>DescribeTextTranslationJob</a> or <a>ListTextTranslationJobs</a>
/// operations to get a batch translation job's <code>JobId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopTextTranslationJob {
    _private: (),
}
impl StopTextTranslationJob {
    /// Creates a new builder-style object to manufacture [`StopTextTranslationJobInput`](crate::input::StopTextTranslationJobInput)
    pub fn builder() -> crate::input::stop_text_translation_job_input::Builder {
        crate::input::stop_text_translation_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopTextTranslationJob {
    type Output = std::result::Result<
        crate::output::StopTextTranslationJobOutput,
        crate::error::StopTextTranslationJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_text_translation_job_error(response)
        } else {
            crate::operation_deser::parse_stop_text_translation_job_response(response)
        }
    }
}

/// <p>Translates input text from the source language to the target language. For a list of
/// available languages and language codes, see <a>what-is-languages</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TranslateText {
    _private: (),
}
impl TranslateText {
    /// Creates a new builder-style object to manufacture [`TranslateTextInput`](crate::input::TranslateTextInput)
    pub fn builder() -> crate::input::translate_text_input::Builder {
        crate::input::translate_text_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TranslateText {
    type Output =
        std::result::Result<crate::output::TranslateTextOutput, crate::error::TranslateTextError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_translate_text_error(response)
        } else {
            crate::operation_deser::parse_translate_text_response(response)
        }
    }
}

/// <p>Updates a previously created parallel data resource by importing a new input file from
/// Amazon S3.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateParallelData {
    _private: (),
}
impl UpdateParallelData {
    /// Creates a new builder-style object to manufacture [`UpdateParallelDataInput`](crate::input::UpdateParallelDataInput)
    pub fn builder() -> crate::input::update_parallel_data_input::Builder {
        crate::input::update_parallel_data_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateParallelData {
    type Output = std::result::Result<
        crate::output::UpdateParallelDataOutput,
        crate::error::UpdateParallelDataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_parallel_data_error(response)
        } else {
            crate::operation_deser::parse_update_parallel_data_response(response)
        }
    }
}
