// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn activate_gateway(&self) -> fluent_builders::ActivateGateway<C> {
        fluent_builders::ActivateGateway::new(self.handle.clone())
    }
    pub fn add_cache(&self) -> fluent_builders::AddCache<C> {
        fluent_builders::AddCache::new(self.handle.clone())
    }
    pub fn add_tags_to_resource(&self) -> fluent_builders::AddTagsToResource<C> {
        fluent_builders::AddTagsToResource::new(self.handle.clone())
    }
    pub fn add_upload_buffer(&self) -> fluent_builders::AddUploadBuffer<C> {
        fluent_builders::AddUploadBuffer::new(self.handle.clone())
    }
    pub fn add_working_storage(&self) -> fluent_builders::AddWorkingStorage<C> {
        fluent_builders::AddWorkingStorage::new(self.handle.clone())
    }
    pub fn assign_tape_pool(&self) -> fluent_builders::AssignTapePool<C> {
        fluent_builders::AssignTapePool::new(self.handle.clone())
    }
    pub fn associate_file_system(&self) -> fluent_builders::AssociateFileSystem<C> {
        fluent_builders::AssociateFileSystem::new(self.handle.clone())
    }
    pub fn attach_volume(&self) -> fluent_builders::AttachVolume<C> {
        fluent_builders::AttachVolume::new(self.handle.clone())
    }
    pub fn cancel_archival(&self) -> fluent_builders::CancelArchival<C> {
        fluent_builders::CancelArchival::new(self.handle.clone())
    }
    pub fn cancel_retrieval(&self) -> fluent_builders::CancelRetrieval<C> {
        fluent_builders::CancelRetrieval::new(self.handle.clone())
    }
    pub fn create_cachedi_scsi_volume(&self) -> fluent_builders::CreateCachediSCSIVolume<C> {
        fluent_builders::CreateCachediSCSIVolume::new(self.handle.clone())
    }
    pub fn create_nfs_file_share(&self) -> fluent_builders::CreateNFSFileShare<C> {
        fluent_builders::CreateNFSFileShare::new(self.handle.clone())
    }
    pub fn create_smb_file_share(&self) -> fluent_builders::CreateSMBFileShare<C> {
        fluent_builders::CreateSMBFileShare::new(self.handle.clone())
    }
    pub fn create_snapshot(&self) -> fluent_builders::CreateSnapshot<C> {
        fluent_builders::CreateSnapshot::new(self.handle.clone())
    }
    pub fn create_snapshot_from_volume_recovery_point(
        &self,
    ) -> fluent_builders::CreateSnapshotFromVolumeRecoveryPoint<C> {
        fluent_builders::CreateSnapshotFromVolumeRecoveryPoint::new(self.handle.clone())
    }
    pub fn create_storedi_scsi_volume(&self) -> fluent_builders::CreateStorediSCSIVolume<C> {
        fluent_builders::CreateStorediSCSIVolume::new(self.handle.clone())
    }
    pub fn create_tape_pool(&self) -> fluent_builders::CreateTapePool<C> {
        fluent_builders::CreateTapePool::new(self.handle.clone())
    }
    pub fn create_tapes(&self) -> fluent_builders::CreateTapes<C> {
        fluent_builders::CreateTapes::new(self.handle.clone())
    }
    pub fn create_tape_with_barcode(&self) -> fluent_builders::CreateTapeWithBarcode<C> {
        fluent_builders::CreateTapeWithBarcode::new(self.handle.clone())
    }
    pub fn delete_automatic_tape_creation_policy(
        &self,
    ) -> fluent_builders::DeleteAutomaticTapeCreationPolicy<C> {
        fluent_builders::DeleteAutomaticTapeCreationPolicy::new(self.handle.clone())
    }
    pub fn delete_bandwidth_rate_limit(&self) -> fluent_builders::DeleteBandwidthRateLimit<C> {
        fluent_builders::DeleteBandwidthRateLimit::new(self.handle.clone())
    }
    pub fn delete_chap_credentials(&self) -> fluent_builders::DeleteChapCredentials<C> {
        fluent_builders::DeleteChapCredentials::new(self.handle.clone())
    }
    pub fn delete_file_share(&self) -> fluent_builders::DeleteFileShare<C> {
        fluent_builders::DeleteFileShare::new(self.handle.clone())
    }
    pub fn delete_gateway(&self) -> fluent_builders::DeleteGateway<C> {
        fluent_builders::DeleteGateway::new(self.handle.clone())
    }
    pub fn delete_snapshot_schedule(&self) -> fluent_builders::DeleteSnapshotSchedule<C> {
        fluent_builders::DeleteSnapshotSchedule::new(self.handle.clone())
    }
    pub fn delete_tape(&self) -> fluent_builders::DeleteTape<C> {
        fluent_builders::DeleteTape::new(self.handle.clone())
    }
    pub fn delete_tape_archive(&self) -> fluent_builders::DeleteTapeArchive<C> {
        fluent_builders::DeleteTapeArchive::new(self.handle.clone())
    }
    pub fn delete_tape_pool(&self) -> fluent_builders::DeleteTapePool<C> {
        fluent_builders::DeleteTapePool::new(self.handle.clone())
    }
    pub fn delete_volume(&self) -> fluent_builders::DeleteVolume<C> {
        fluent_builders::DeleteVolume::new(self.handle.clone())
    }
    pub fn describe_availability_monitor_test(
        &self,
    ) -> fluent_builders::DescribeAvailabilityMonitorTest<C> {
        fluent_builders::DescribeAvailabilityMonitorTest::new(self.handle.clone())
    }
    pub fn describe_bandwidth_rate_limit(&self) -> fluent_builders::DescribeBandwidthRateLimit<C> {
        fluent_builders::DescribeBandwidthRateLimit::new(self.handle.clone())
    }
    pub fn describe_bandwidth_rate_limit_schedule(
        &self,
    ) -> fluent_builders::DescribeBandwidthRateLimitSchedule<C> {
        fluent_builders::DescribeBandwidthRateLimitSchedule::new(self.handle.clone())
    }
    pub fn describe_cache(&self) -> fluent_builders::DescribeCache<C> {
        fluent_builders::DescribeCache::new(self.handle.clone())
    }
    pub fn describe_cachedi_scsi_volumes(&self) -> fluent_builders::DescribeCachediSCSIVolumes<C> {
        fluent_builders::DescribeCachediSCSIVolumes::new(self.handle.clone())
    }
    pub fn describe_chap_credentials(&self) -> fluent_builders::DescribeChapCredentials<C> {
        fluent_builders::DescribeChapCredentials::new(self.handle.clone())
    }
    pub fn describe_file_system_associations(
        &self,
    ) -> fluent_builders::DescribeFileSystemAssociations<C> {
        fluent_builders::DescribeFileSystemAssociations::new(self.handle.clone())
    }
    pub fn describe_gateway_information(&self) -> fluent_builders::DescribeGatewayInformation<C> {
        fluent_builders::DescribeGatewayInformation::new(self.handle.clone())
    }
    pub fn describe_maintenance_start_time(
        &self,
    ) -> fluent_builders::DescribeMaintenanceStartTime<C> {
        fluent_builders::DescribeMaintenanceStartTime::new(self.handle.clone())
    }
    pub fn describe_nfs_file_shares(&self) -> fluent_builders::DescribeNFSFileShares<C> {
        fluent_builders::DescribeNFSFileShares::new(self.handle.clone())
    }
    pub fn describe_smb_file_shares(&self) -> fluent_builders::DescribeSMBFileShares<C> {
        fluent_builders::DescribeSMBFileShares::new(self.handle.clone())
    }
    pub fn describe_smb_settings(&self) -> fluent_builders::DescribeSMBSettings<C> {
        fluent_builders::DescribeSMBSettings::new(self.handle.clone())
    }
    pub fn describe_snapshot_schedule(&self) -> fluent_builders::DescribeSnapshotSchedule<C> {
        fluent_builders::DescribeSnapshotSchedule::new(self.handle.clone())
    }
    pub fn describe_storedi_scsi_volumes(&self) -> fluent_builders::DescribeStorediSCSIVolumes<C> {
        fluent_builders::DescribeStorediSCSIVolumes::new(self.handle.clone())
    }
    pub fn describe_tape_archives(&self) -> fluent_builders::DescribeTapeArchives<C> {
        fluent_builders::DescribeTapeArchives::new(self.handle.clone())
    }
    pub fn describe_tape_recovery_points(&self) -> fluent_builders::DescribeTapeRecoveryPoints<C> {
        fluent_builders::DescribeTapeRecoveryPoints::new(self.handle.clone())
    }
    pub fn describe_tapes(&self) -> fluent_builders::DescribeTapes<C> {
        fluent_builders::DescribeTapes::new(self.handle.clone())
    }
    pub fn describe_upload_buffer(&self) -> fluent_builders::DescribeUploadBuffer<C> {
        fluent_builders::DescribeUploadBuffer::new(self.handle.clone())
    }
    pub fn describe_vtl_devices(&self) -> fluent_builders::DescribeVTLDevices<C> {
        fluent_builders::DescribeVTLDevices::new(self.handle.clone())
    }
    pub fn describe_working_storage(&self) -> fluent_builders::DescribeWorkingStorage<C> {
        fluent_builders::DescribeWorkingStorage::new(self.handle.clone())
    }
    pub fn detach_volume(&self) -> fluent_builders::DetachVolume<C> {
        fluent_builders::DetachVolume::new(self.handle.clone())
    }
    pub fn disable_gateway(&self) -> fluent_builders::DisableGateway<C> {
        fluent_builders::DisableGateway::new(self.handle.clone())
    }
    pub fn disassociate_file_system(&self) -> fluent_builders::DisassociateFileSystem<C> {
        fluent_builders::DisassociateFileSystem::new(self.handle.clone())
    }
    pub fn join_domain(&self) -> fluent_builders::JoinDomain<C> {
        fluent_builders::JoinDomain::new(self.handle.clone())
    }
    pub fn list_automatic_tape_creation_policies(
        &self,
    ) -> fluent_builders::ListAutomaticTapeCreationPolicies<C> {
        fluent_builders::ListAutomaticTapeCreationPolicies::new(self.handle.clone())
    }
    pub fn list_file_shares(&self) -> fluent_builders::ListFileShares<C> {
        fluent_builders::ListFileShares::new(self.handle.clone())
    }
    pub fn list_file_system_associations(&self) -> fluent_builders::ListFileSystemAssociations<C> {
        fluent_builders::ListFileSystemAssociations::new(self.handle.clone())
    }
    pub fn list_gateways(&self) -> fluent_builders::ListGateways<C> {
        fluent_builders::ListGateways::new(self.handle.clone())
    }
    pub fn list_local_disks(&self) -> fluent_builders::ListLocalDisks<C> {
        fluent_builders::ListLocalDisks::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_tape_pools(&self) -> fluent_builders::ListTapePools<C> {
        fluent_builders::ListTapePools::new(self.handle.clone())
    }
    pub fn list_tapes(&self) -> fluent_builders::ListTapes<C> {
        fluent_builders::ListTapes::new(self.handle.clone())
    }
    pub fn list_volume_initiators(&self) -> fluent_builders::ListVolumeInitiators<C> {
        fluent_builders::ListVolumeInitiators::new(self.handle.clone())
    }
    pub fn list_volume_recovery_points(&self) -> fluent_builders::ListVolumeRecoveryPoints<C> {
        fluent_builders::ListVolumeRecoveryPoints::new(self.handle.clone())
    }
    pub fn list_volumes(&self) -> fluent_builders::ListVolumes<C> {
        fluent_builders::ListVolumes::new(self.handle.clone())
    }
    pub fn notify_when_uploaded(&self) -> fluent_builders::NotifyWhenUploaded<C> {
        fluent_builders::NotifyWhenUploaded::new(self.handle.clone())
    }
    pub fn refresh_cache(&self) -> fluent_builders::RefreshCache<C> {
        fluent_builders::RefreshCache::new(self.handle.clone())
    }
    pub fn remove_tags_from_resource(&self) -> fluent_builders::RemoveTagsFromResource<C> {
        fluent_builders::RemoveTagsFromResource::new(self.handle.clone())
    }
    pub fn reset_cache(&self) -> fluent_builders::ResetCache<C> {
        fluent_builders::ResetCache::new(self.handle.clone())
    }
    pub fn retrieve_tape_archive(&self) -> fluent_builders::RetrieveTapeArchive<C> {
        fluent_builders::RetrieveTapeArchive::new(self.handle.clone())
    }
    pub fn retrieve_tape_recovery_point(&self) -> fluent_builders::RetrieveTapeRecoveryPoint<C> {
        fluent_builders::RetrieveTapeRecoveryPoint::new(self.handle.clone())
    }
    pub fn set_local_console_password(&self) -> fluent_builders::SetLocalConsolePassword<C> {
        fluent_builders::SetLocalConsolePassword::new(self.handle.clone())
    }
    pub fn set_smb_guest_password(&self) -> fluent_builders::SetSMBGuestPassword<C> {
        fluent_builders::SetSMBGuestPassword::new(self.handle.clone())
    }
    pub fn shutdown_gateway(&self) -> fluent_builders::ShutdownGateway<C> {
        fluent_builders::ShutdownGateway::new(self.handle.clone())
    }
    pub fn start_availability_monitor_test(
        &self,
    ) -> fluent_builders::StartAvailabilityMonitorTest<C> {
        fluent_builders::StartAvailabilityMonitorTest::new(self.handle.clone())
    }
    pub fn start_gateway(&self) -> fluent_builders::StartGateway<C> {
        fluent_builders::StartGateway::new(self.handle.clone())
    }
    pub fn update_automatic_tape_creation_policy(
        &self,
    ) -> fluent_builders::UpdateAutomaticTapeCreationPolicy<C> {
        fluent_builders::UpdateAutomaticTapeCreationPolicy::new(self.handle.clone())
    }
    pub fn update_bandwidth_rate_limit(&self) -> fluent_builders::UpdateBandwidthRateLimit<C> {
        fluent_builders::UpdateBandwidthRateLimit::new(self.handle.clone())
    }
    pub fn update_bandwidth_rate_limit_schedule(
        &self,
    ) -> fluent_builders::UpdateBandwidthRateLimitSchedule<C> {
        fluent_builders::UpdateBandwidthRateLimitSchedule::new(self.handle.clone())
    }
    pub fn update_chap_credentials(&self) -> fluent_builders::UpdateChapCredentials<C> {
        fluent_builders::UpdateChapCredentials::new(self.handle.clone())
    }
    pub fn update_file_system_association(
        &self,
    ) -> fluent_builders::UpdateFileSystemAssociation<C> {
        fluent_builders::UpdateFileSystemAssociation::new(self.handle.clone())
    }
    pub fn update_gateway_information(&self) -> fluent_builders::UpdateGatewayInformation<C> {
        fluent_builders::UpdateGatewayInformation::new(self.handle.clone())
    }
    pub fn update_gateway_software_now(&self) -> fluent_builders::UpdateGatewaySoftwareNow<C> {
        fluent_builders::UpdateGatewaySoftwareNow::new(self.handle.clone())
    }
    pub fn update_maintenance_start_time(&self) -> fluent_builders::UpdateMaintenanceStartTime<C> {
        fluent_builders::UpdateMaintenanceStartTime::new(self.handle.clone())
    }
    pub fn update_nfs_file_share(&self) -> fluent_builders::UpdateNFSFileShare<C> {
        fluent_builders::UpdateNFSFileShare::new(self.handle.clone())
    }
    pub fn update_smb_file_share(&self) -> fluent_builders::UpdateSMBFileShare<C> {
        fluent_builders::UpdateSMBFileShare::new(self.handle.clone())
    }
    pub fn update_smb_file_share_visibility(
        &self,
    ) -> fluent_builders::UpdateSMBFileShareVisibility<C> {
        fluent_builders::UpdateSMBFileShareVisibility::new(self.handle.clone())
    }
    pub fn update_smb_security_strategy(&self) -> fluent_builders::UpdateSMBSecurityStrategy<C> {
        fluent_builders::UpdateSMBSecurityStrategy::new(self.handle.clone())
    }
    pub fn update_snapshot_schedule(&self) -> fluent_builders::UpdateSnapshotSchedule<C> {
        fluent_builders::UpdateSnapshotSchedule::new(self.handle.clone())
    }
    pub fn update_vtl_device_type(&self) -> fluent_builders::UpdateVTLDeviceType<C> {
        fluent_builders::UpdateVTLDeviceType::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct ActivateGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::activate_gateway_input::Builder,
    }
    impl<C> ActivateGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ActivateGatewayOutput,
            smithy_http::result::SdkError<crate::error::ActivateGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Your gateway activation key. You can obtain the activation key by sending an HTTP GET
        /// request with redirects enabled to the gateway IP address (port 80). The redirect URL
        /// returned in the response provides you the activation key for your gateway in the query
        /// string parameter <code>activationKey</code>. It may also include other activation-related
        /// parameters, however, these are merely defaults -- the arguments you pass to the
        /// <code>ActivateGateway</code> API call determine the actual configuration of your
        /// gateway.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/get-activation-key.html">Getting activation
        /// key</a> in the <i>AWS Storage Gateway User Guide</i>.</p>
        pub fn activation_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.activation_key(input);
            self
        }
        pub fn set_activation_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_activation_key(input);
            self
        }
        /// <p>The name you configured for your gateway.</p>
        pub fn gateway_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_name(input);
            self
        }
        pub fn set_gateway_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_name(input);
            self
        }
        /// <p>A value that indicates the time zone you want to set for the gateway. The time zone is
        /// of the format "GMT-hr:mm" or "GMT+hr:mm". For example, GMT-4:00 indicates the time is 4
        /// hours behind GMT. GMT+2:00 indicates the time is 2 hours ahead of GMT. The time zone is
        /// used, for example, for scheduling snapshots and your gateway's maintenance
        /// schedule.</p>
        pub fn gateway_timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_timezone(input);
            self
        }
        pub fn set_gateway_timezone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_gateway_timezone(input);
            self
        }
        /// <p>A value that indicates the AWS Region where you want to store your data. The gateway AWS
        /// Region specified must be the same AWS Region as the AWS Region in your <code>Host</code>
        /// header in the request. For more information about available AWS Regions and endpoints for
        /// AWS Storage Gateway, see <a href="https://docs.aws.amazon.com/general/latest/gr/sg.html">AWS
        /// Storage Gateway endpoints and quotas</a> in the <i>AWS General
        /// Reference</i>.</p>
        /// <p>Valid Values: See <a href="https://docs.aws.amazon.com/general/latest/gr/sg.html">AWS
        /// Storage Gateway endpoints and quotas</a> in the <i>AWS General
        /// Reference</i>.
        /// </p>
        pub fn gateway_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_region(input);
            self
        }
        pub fn set_gateway_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_gateway_region(input);
            self
        }
        /// <p>A value that defines the type of gateway to activate. The type specified is critical to
        /// all later functions of the gateway and cannot be changed after activation. The default
        /// value is <code>CACHED</code>.</p>
        /// <p>Valid Values: <code>STORED</code> | <code>CACHED</code> | <code>VTL</code> |
        /// <code>FILE_S3</code>
        /// </p>
        pub fn gateway_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_type(input);
            self
        }
        pub fn set_gateway_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_type(input);
            self
        }
        /// <p>The value that indicates the type of tape drive to use for tape gateway. This field is
        /// optional.</p>
        /// <p>Valid Values: <code>IBM-ULT3580-TD5</code>
        /// </p>
        pub fn tape_drive_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_drive_type(input);
            self
        }
        pub fn set_tape_drive_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_tape_drive_type(input);
            self
        }
        /// <p>The value that indicates the type of medium changer to use for tape gateway. This field
        /// is optional.</p>
        /// <p>Valid Values: <code>STK-L700</code> | <code>AWS-Gateway-VTL</code> |
        /// <code>IBM-03584L32-0402</code>
        /// </p>
        pub fn medium_changer_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.medium_changer_type(input);
            self
        }
        pub fn set_medium_changer_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_medium_changer_type(input);
            self
        }
        /// <p>A list of up to 50 tags that you can assign to the gateway. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers that can be
        /// represented in UTF-8 format, and the following special characters: + - = . _ : / @. The
        /// maximum length of a tag's key is 128 characters, and the maximum length for a
        /// tag's value is 256 characters.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_cache_input::Builder,
    }
    impl<C> AddCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddCacheOutput,
            smithy_http::result::SdkError<crate::error::AddCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>An array of strings that identify disks that are to be configured as working storage.
        /// Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
        /// from the <a>ListLocalDisks</a> API.</p>
        pub fn disk_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_ids(inp);
            self
        }
        pub fn set_disk_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_disk_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_to_resource_input::Builder,
    }
    impl<C> AddTagsToResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToResourceOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource you want to add tags to.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The key-value pair that represents the tag you want to add to the resource. The value
        /// can be an empty string.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddUploadBuffer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_upload_buffer_input::Builder,
    }
    impl<C> AddUploadBuffer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddUploadBufferOutput,
            smithy_http::result::SdkError<crate::error::AddUploadBufferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>An array of strings that identify disks that are to be configured as working storage.
        /// Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
        /// from the <a>ListLocalDisks</a> API.</p>
        pub fn disk_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_ids(inp);
            self
        }
        pub fn set_disk_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_disk_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddWorkingStorage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_working_storage_input::Builder,
    }
    impl<C> AddWorkingStorage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddWorkingStorageOutput,
            smithy_http::result::SdkError<crate::error::AddWorkingStorageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>An array of strings that identify disks that are to be configured as working storage.
        /// Each string has a minimum length of 1 and maximum length of 300. You can get the disk IDs
        /// from the <a>ListLocalDisks</a> API.</p>
        pub fn disk_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_ids(inp);
            self
        }
        pub fn set_disk_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_disk_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssignTapePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::assign_tape_pool_input::Builder,
    }
    impl<C> AssignTapePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssignTapePoolOutput,
            smithy_http::result::SdkError<crate::error::AssignTapePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Amazon Resource Name (ARN) of the virtual tape that you want to add to the
        /// tape pool.</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
        /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
        /// pool is archived in the S3 storage class that is associated with the pool. When you use
        /// your backup application to eject the tape, the tape is archived directly into the storage
        /// class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
        /// <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
        /// </p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_id(input);
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_id(input);
            self
        }
        /// <p>Set permissions to bypass governance retention. If the lock type of the archived tape is
        /// <code>Governance</code>, the tape's archived age is not older than
        /// <code>RetentionLockInDays</code>, and the user does not already have
        /// <code>BypassGovernanceRetention</code>, setting this to TRUE enables the user to bypass
        /// the retention lock. This parameter is set to true by default for calls from the
        /// console.</p>
        /// <p>Valid values: <code>TRUE</code> | <code>FALSE</code>
        /// </p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.inner = self.inner.bypass_governance_retention(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_bypass_governance_retention(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateFileSystem<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_file_system_input::Builder,
    }
    impl<C> AssociateFileSystem<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateFileSystemOutput,
            smithy_http::result::SdkError<crate::error::AssociateFileSystemError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The user name of the user credential that has permission to access the root share D$ of
        /// the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin
        /// user group.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The password of the user credential.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>A unique string value that you supply that is used by the file gateway to ensure
        /// idempotent file system association creation.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon FSx file system to associate with the
        /// Amazon FSx file gateway.</p>
        pub fn location_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(input);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to the file system association. Each tag is a key-value pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the storage used for the audit logs.</p>
        pub fn audit_destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.audit_destination_arn(input);
            self
        }
        pub fn set_audit_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_audit_destination_arn(input);
            self
        }
        /// <p>The refresh cache information for the file share.</p>
        pub fn cache_attributes(mut self, input: crate::model::CacheAttributes) -> Self {
            self.inner = self.inner.cache_attributes(input);
            self
        }
        pub fn set_cache_attributes(
            mut self,
            input: std::option::Option<crate::model::CacheAttributes>,
        ) -> Self {
            self.inner = self.inner.set_cache_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_volume_input::Builder,
    }
    impl<C> AttachVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachVolumeOutput,
            smithy_http::result::SdkError<crate::error::AttachVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway that you want to attach the volume
        /// to.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
        /// suffix for the target ARN. For example, specifying <code>TargetName</code> as
        /// <i>myvolume</i> results in the target ARN of
        /// <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
        /// The target name must be unique across all volumes on a gateway.</p>
        /// <p>If you don't specify a value, Storage Gateway uses the value that was previously
        /// used for this volume as the new target name.</p>
        pub fn target_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_name(input);
            self
        }
        pub fn set_target_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the volume to attach to the specified gateway.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
        /// <p>The network interface of the gateway on which to expose the iSCSI target. Only IPv4
        /// addresses are accepted. Use <a>DescribeGatewayInformation</a> to get a list of
        /// the network interfaces available on a gateway.</p>
        /// <p>Valid Values: A valid IP address.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The unique device ID or other distinguishing data that identifies the local disk used to
        /// create the volume. This value is only required when you are attaching a stored
        /// volume.</p>
        pub fn disk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_id(input);
            self
        }
        pub fn set_disk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelArchival<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_archival_input::Builder,
    }
    impl<C> CancelArchival<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelArchivalOutput,
            smithy_http::result::SdkError<crate::error::CancelArchivalError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the virtual tape you want to cancel archiving
        /// for.</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelRetrieval<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_retrieval_input::Builder,
    }
    impl<C> CancelRetrieval<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelRetrievalOutput,
            smithy_http::result::SdkError<crate::error::CancelRetrievalError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the virtual tape you want to cancel retrieval
        /// for.</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCachediSCSIVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cachedi_scsi_volume_input::Builder,
    }
    impl<C> CreateCachediSCSIVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCachediScsiVolumeOutput,
            smithy_http::result::SdkError<crate::error::CreateCachediSCSIVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The size of the volume in bytes.</p>
        pub fn volume_size_in_bytes(mut self, input: i64) -> Self {
            self.inner = self.inner.volume_size_in_bytes(input);
            self
        }
        pub fn set_volume_size_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_volume_size_in_bytes(input);
            self
        }
        /// <p>The snapshot ID (e.g. "snap-1122aabb") of the snapshot to restore as the new cached
        /// volume. Specify this field if you want to create the iSCSI storage volume from a snapshot;
        /// otherwise, do not include this field. To list snapshots for your account use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a> in the <i>Amazon Elastic Compute Cloud API
        /// Reference</i>.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
        /// suffix for the target ARN. For example, specifying <code>TargetName</code> as
        /// <i>myvolume</i> results in the target ARN of
        /// <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
        /// The target name must be unique across all volumes on a gateway.</p>
        /// <p>If you don't specify a value, Storage Gateway uses the value that was previously
        /// used for this volume as the new target name.</p>
        pub fn target_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_name(input);
            self
        }
        pub fn set_target_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_name(input);
            self
        }
        /// <p>The ARN for an existing volume. Specifying this ARN makes the new volume into an exact
        /// copy of the specified existing volume's latest recovery point. The
        /// <code>VolumeSizeInBytes</code> value for this new volume must be equal to or larger than
        /// the size of the existing volume, in bytes.</p>
        pub fn source_volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_volume_arn(input);
            self
        }
        pub fn set_source_volume_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_volume_arn(input);
            self
        }
        /// <p>The network interface of the gateway on which to expose the iSCSI target. Only IPv4
        /// addresses are accepted. Use <a>DescribeGatewayInformation</a> to get a list of
        /// the network interfaces available on a gateway.</p>
        /// <p>Valid Values: A valid IP address.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>A unique identifier that you use to retry a request. If you retry a request, use the
        /// same <code>ClientToken</code> you specified in the initial request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>A list of up to 50 tags that you can assign to a cached volume. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers that you can
        /// represent in UTF-8 format, and the following special characters: + - = . _ : / @. The
        /// maximum length of a tag's key is 128 characters, and the maximum length for a
        /// tag's value is 256 characters.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNFSFileShare<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_nfs_file_share_input::Builder,
    }
    impl<C> CreateNFSFileShare<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNfsFileShareOutput,
            smithy_http::result::SdkError<crate::error::CreateNFSFileShareError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string value that you supply that is used by file gateway to ensure idempotent
        /// file share creation.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>File share default values. Optional.</p>
        pub fn nfs_file_share_defaults(
            mut self,
            input: crate::model::NfsFileShareDefaults,
        ) -> Self {
            self.inner = self.inner.nfs_file_share_defaults(input);
            self
        }
        pub fn set_nfs_file_share_defaults(
            mut self,
            input: std::option::Option<crate::model::NfsFileShareDefaults>,
        ) -> Self {
            self.inner = self.inner.set_nfs_file_share_defaults(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the file gateway on which you want to create a file
        /// share.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that a file gateway assumes
        /// when it accesses the underlying storage.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
        /// the S3 bucket name. It must end with a "/".</p>
        pub fn location_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(input);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
        /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
        /// The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
        /// <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
        /// <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
        /// </p>
        pub fn default_storage_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_storage_class(input);
            self
        }
        pub fn set_default_storage_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_storage_class(input);
            self
        }
        /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
        /// that a file gateway puts objects into. The default value is <code>private</code>.</p>
        pub fn object_acl(mut self, input: crate::model::ObjectAcl) -> Self {
            self.inner = self.inner.object_acl(input);
            self
        }
        pub fn set_object_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectAcl>,
        ) -> Self {
            self.inner = self.inner.set_object_acl(input);
            self
        }
        /// <p>The list of clients that are allowed to access the file gateway. The list must contain
        /// either valid IP addresses or valid CIDR blocks.</p>
        pub fn client_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_list(inp);
            self
        }
        pub fn set_client_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_client_list(input);
            self
        }
        /// <p>A value that maps a user to anonymous user.</p>
        /// <p>Valid values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>RootSquash</code>: Only root is mapped to anonymous user.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NoSquash</code>: No one is mapped to anonymous user.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AllSquash</code>: Everyone is mapped to anonymous user.</p>
        /// </li>
        /// </ul>
        pub fn squash(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.squash(input);
            self
        }
        pub fn set_squash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_squash(input);
            self
        }
        /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
        /// to set the write status to read-only, otherwise set to <code>false</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.inner = self.inner.read_only(input);
            self
        }
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_read_only(input);
            self
        }
        /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
        /// extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
        /// to <code>false</code>. The default value is <code>true</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn guess_mime_type_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.guess_mime_type_enabled(input);
            self
        }
        pub fn set_guess_mime_type_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_guess_mime_type_enabled(input);
            self
        }
        /// <p>A value that sets who pays the cost of the request and the cost associated with data
        /// download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
        /// the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
        /// the cost of storing data.</p>
        /// <note>
        /// <p>
        /// <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
        /// share, so make sure that the configuration on the file share is the same as the S3
        /// bucket configuration.</p>
        /// </note>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn requester_pays(mut self, input: bool) -> Self {
            self.inner = self.inner.requester_pays(input);
            self
        }
        pub fn set_requester_pays(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_requester_pays(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
        /// key-value pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The name of the file share. Optional.</p>
        /// <note>
        /// <p>
        /// <code>FileShareName</code> must be set if an S3 prefix name is set in
        /// <code>LocationARN</code>.</p>
        /// </note>
        pub fn file_share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_name(input);
            self
        }
        pub fn set_file_share_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_name(input);
            self
        }
        /// <p>Specifies refresh cache information for the file share.</p>
        pub fn cache_attributes(mut self, input: crate::model::CacheAttributes) -> Self {
            self.inner = self.inner.cache_attributes(input);
            self
        }
        pub fn set_cache_attributes(
            mut self,
            input: std::option::Option<crate::model::CacheAttributes>,
        ) -> Self {
            self.inner = self.inner.set_cache_attributes(input);
            self
        }
        /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
        /// the number of seconds to wait after the last point in time a client wrote to a file before
        /// generating an <code>ObjectUploaded</code> notification. Because clients can make many small
        /// writes to files, it's best to set this parameter for as long as possible to avoid
        /// generating multiple notifications for the same file in a small time period.</p>
        /// <note>
        /// <p>
        /// <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
        /// uploading to Amazon S3, only the timing of the notification.</p>
        /// </note>
        /// <p>The following example sets <code>NotificationPolicy</code> on with
        /// <code>SettlingTimeInSeconds</code> set to 60.</p>
        /// <p>
        /// <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
        /// </p>
        /// <p>The following example sets <code>NotificationPolicy</code> off.</p>
        /// <p>
        /// <code>{}</code>
        /// </p>
        pub fn notification_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_policy(input);
            self
        }
        pub fn set_notification_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSMBFileShare<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_smb_file_share_input::Builder,
    }
    impl<C> CreateSMBFileShare<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSmbFileShareOutput,
            smithy_http::result::SdkError<crate::error::CreateSMBFileShareError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique string value that you supply that is used by file gateway to ensure idempotent
        /// file share creation.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ARN of the file gateway on which you want to create a file share.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that a file gateway assumes
        /// when it accesses the underlying storage.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>The ARN of the backend storage used for storing file data. A prefix name can be added to
        /// the S3 bucket name. It must end with a "/".</p>
        pub fn location_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.location_arn(input);
            self
        }
        pub fn set_location_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_location_arn(input);
            self
        }
        /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
        /// The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
        /// <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
        /// <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
        /// </p>
        pub fn default_storage_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_storage_class(input);
            self
        }
        pub fn set_default_storage_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_storage_class(input);
            self
        }
        /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
        /// that a file gateway puts objects into. The default value is <code>private</code>.</p>
        pub fn object_acl(mut self, input: crate::model::ObjectAcl) -> Self {
            self.inner = self.inner.object_acl(input);
            self
        }
        pub fn set_object_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectAcl>,
        ) -> Self {
            self.inner = self.inner.set_object_acl(input);
            self
        }
        /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
        /// to set the write status to read-only, otherwise set to <code>false</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.inner = self.inner.read_only(input);
            self
        }
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_read_only(input);
            self
        }
        /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
        /// extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
        /// to <code>false</code>. The default value is <code>true</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn guess_mime_type_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.guess_mime_type_enabled(input);
            self
        }
        pub fn set_guess_mime_type_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_guess_mime_type_enabled(input);
            self
        }
        /// <p>A value that sets who pays the cost of the request and the cost associated with data
        /// download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
        /// the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
        /// the cost of storing data.</p>
        /// <note>
        /// <p>
        /// <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
        /// share, so make sure that the configuration on the file share is the same as the S3
        /// bucket configuration.</p>
        /// </note>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn requester_pays(mut self, input: bool) -> Self {
            self.inner = self.inner.requester_pays(input);
            self
        }
        pub fn set_requester_pays(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_requester_pays(input);
            self
        }
        /// <p>Set this value to <code>true</code> to enable access control list (ACL) on the SMB file
        /// share. Set it to <code>false</code> to map file and directory permissions to the POSIX
        /// permissions.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
        /// control access to an SMB file share</a> in the <i>AWS Storage Gateway User
        /// Guide</i>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn smbacl_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.smbacl_enabled(input);
            self
        }
        pub fn set_smbacl_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_smbacl_enabled(input);
            self
        }
        /// <p>The files and folders on this share will only be visible to users with read
        /// access.</p>
        pub fn access_based_enumeration(mut self, input: bool) -> Self {
            self.inner = self.inner.access_based_enumeration(input);
            self
        }
        pub fn set_access_based_enumeration(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_access_based_enumeration(input);
            self
        }
        /// <p>A list of users or groups in the Active Directory that will be granted administrator
        /// privileges on the file share. These users can do all file operations as the super-user.
        /// Acceptable formats include: <code>DOMAIN\User1</code>, <code>user1</code>,
        /// <code>@group1</code>, and <code>@DOMAIN\group1</code>.</p>
        /// <important>
        /// <p>Use this option very carefully, because any user in this list can do anything they
        /// like on the file share, regardless of file permissions.</p>
        /// </important>
        pub fn admin_user_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.admin_user_list(inp);
            self
        }
        pub fn set_admin_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_admin_user_list(input);
            self
        }
        /// <p>A list of users or groups in the Active Directory that are allowed to access the file
        /// <a href=""></a> share. A group must be prefixed with the @ character. Acceptable formats
        /// include: <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
        /// <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
        /// <code>ActiveDirectory</code>.</p>
        pub fn valid_user_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.valid_user_list(inp);
            self
        }
        pub fn set_valid_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_valid_user_list(input);
            self
        }
        /// <p>A list of users or groups in the Active Directory that are not allowed to access the
        /// file share. A group must be prefixed with the @ character. Acceptable formats include:
        /// <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
        /// <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
        /// <code>ActiveDirectory</code>.</p>
        pub fn invalid_user_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.invalid_user_list(inp);
            self
        }
        pub fn set_invalid_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_invalid_user_list(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the storage used for audit logs.</p>
        pub fn audit_destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.audit_destination_arn(input);
            self
        }
        pub fn set_audit_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_audit_destination_arn(input);
            self
        }
        /// <p>The authentication method that users use to access the file share. The default is
        /// <code>ActiveDirectory</code>.</p>
        /// <p>Valid Values: <code>ActiveDirectory</code> | <code>GuestAccess</code>
        /// </p>
        pub fn authentication(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.authentication(input);
            self
        }
        pub fn set_authentication(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_authentication(input);
            self
        }
        /// <p>The case of an object name in an Amazon S3 bucket. For <code>ClientSpecified</code>, the
        /// client determines the case sensitivity. For <code>CaseSensitive</code>, the gateway
        /// determines the case sensitivity. The default value is <code>ClientSpecified</code>.</p>
        pub fn case_sensitivity(mut self, input: crate::model::CaseSensitivity) -> Self {
            self.inner = self.inner.case_sensitivity(input);
            self
        }
        pub fn set_case_sensitivity(
            mut self,
            input: std::option::Option<crate::model::CaseSensitivity>,
        ) -> Self {
            self.inner = self.inner.set_case_sensitivity(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to the NFS file share. Each tag is a
        /// key-value pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The name of the file share. Optional.</p>
        /// <note>
        /// <p>
        /// <code>FileShareName</code> must be set if an S3 prefix name is set in
        /// <code>LocationARN</code>.</p>
        /// </note>
        pub fn file_share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_name(input);
            self
        }
        pub fn set_file_share_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_name(input);
            self
        }
        /// <p>Specifies refresh cache information for the file share.</p>
        pub fn cache_attributes(mut self, input: crate::model::CacheAttributes) -> Self {
            self.inner = self.inner.cache_attributes(input);
            self
        }
        pub fn set_cache_attributes(
            mut self,
            input: std::option::Option<crate::model::CacheAttributes>,
        ) -> Self {
            self.inner = self.inner.set_cache_attributes(input);
            self
        }
        /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
        /// the number of seconds to wait after the last point in time a client wrote to a file before
        /// generating an <code>ObjectUploaded</code> notification. Because clients can make many small
        /// writes to files, it's best to set this parameter for as long as possible to avoid
        /// generating multiple notifications for the same file in a small time period.</p>
        /// <note>
        /// <p>
        /// <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
        /// uploading to Amazon S3, only the timing of the notification.</p>
        /// </note>
        /// <p>The following example sets <code>NotificationPolicy</code> on with
        /// <code>SettlingTimeInSeconds</code> set to 60.</p>
        /// <p>
        /// <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
        /// </p>
        /// <p>The following example sets <code>NotificationPolicy</code> off.</p>
        /// <p>
        /// <code>{}</code>
        /// </p>
        pub fn notification_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_policy(input);
            self
        }
        pub fn set_notification_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_snapshot_input::Builder,
    }
    impl<C> CreateSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
        /// operation to return a list of gateway volumes.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
        /// <p>Textual description of the snapshot that appears in the Amazon EC2 console, Elastic
        /// Block Store snapshots panel in the <b>Description</b> field, and
        /// in the AWS Storage Gateway snapshot <b>Details</b> pane,
        /// <b>Description</b> field.</p>
        pub fn snapshot_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_description(input);
            self
        }
        pub fn set_snapshot_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_description(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSnapshotFromVolumeRecoveryPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_snapshot_from_volume_recovery_point_input::Builder,
    }
    impl<C> CreateSnapshotFromVolumeRecoveryPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSnapshotFromVolumeRecoveryPointOutput,
            smithy_http::result::SdkError<crate::error::CreateSnapshotFromVolumeRecoveryPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
        /// specified VolumeARN.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
        /// <p>Textual description of the snapshot that appears in the Amazon EC2 console, Elastic
        /// Block Store snapshots panel in the <b>Description</b> field, and
        /// in the AWS Storage Gateway snapshot <b>Details</b> pane,
        /// <b>Description</b> field.</p>
        pub fn snapshot_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_description(input);
            self
        }
        pub fn set_snapshot_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_description(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStorediSCSIVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_storedi_scsi_volume_input::Builder,
    }
    impl<C> CreateStorediSCSIVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStorediScsiVolumeOutput,
            smithy_http::result::SdkError<crate::error::CreateStorediSCSIVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The unique identifier for the gateway local disk that is configured as a stored volume.
        /// Use <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/API_ListLocalDisks.html">ListLocalDisks</a> to
        /// list disk IDs for a gateway.</p>
        pub fn disk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.disk_id(input);
            self
        }
        pub fn set_disk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_disk_id(input);
            self
        }
        /// <p>The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as the new stored
        /// volume. Specify this field if you want to create the iSCSI storage volume from a snapshot;
        /// otherwise, do not include this field. To list snapshots for your account use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a> in the <i>Amazon Elastic Compute Cloud API
        /// Reference</i>.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>Set to <code>true</code> if you want to preserve the data on the local disk. Otherwise,
        /// set to <code>false</code> to create an empty volume.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn preserve_existing_data(mut self, input: bool) -> Self {
            self.inner = self.inner.preserve_existing_data(input);
            self
        }
        pub fn set_preserve_existing_data(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_preserve_existing_data(input);
            self
        }
        /// <p>The name of the iSCSI target used by an initiator to connect to a volume and used as a
        /// suffix for the target ARN. For example, specifying <code>TargetName</code> as
        /// <i>myvolume</i> results in the target ARN of
        /// <code>arn:aws:storagegateway:us-east-2:111122223333:gateway/sgw-12A3456B/target/iqn.1997-05.com.amazon:myvolume</code>.
        /// The target name must be unique across all volumes on a gateway.</p>
        /// <p>If you don't specify a value, Storage Gateway uses the value that was previously
        /// used for this volume as the new target name.</p>
        pub fn target_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_name(input);
            self
        }
        pub fn set_target_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_name(input);
            self
        }
        /// <p>The network interface of the gateway on which to expose the iSCSI target. Only IPv4
        /// addresses are accepted. Use <a>DescribeGatewayInformation</a> to get a list of
        /// the network interfaces available on a gateway.</p>
        /// <p>Valid Values: A valid IP address.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to a stored volume. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTapePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tape_pool_input::Builder,
    }
    impl<C> CreateTapePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTapePoolOutput,
            smithy_http::result::SdkError<crate::error::CreateTapePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the new custom tape pool.</p>
        pub fn pool_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_name(input);
            self
        }
        pub fn set_pool_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_name(input);
            self
        }
        /// <p>The storage class that is associated with the new custom pool. When you use your backup
        /// application to eject the tape, the tape is archived directly into the storage class (S3
        /// Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
        pub fn storage_class(mut self, input: crate::model::TapeStorageClass) -> Self {
            self.inner = self.inner.storage_class(input);
            self
        }
        pub fn set_storage_class(
            mut self,
            input: std::option::Option<crate::model::TapeStorageClass>,
        ) -> Self {
            self.inner = self.inner.set_storage_class(input);
            self
        }
        /// <p>Tape retention lock can be configured in two modes. When configured in governance mode,
        /// AWS accounts with specific IAM permissions are authorized to remove the tape retention lock
        /// from archived virtual tapes. When configured in compliance mode, the tape retention lock
        /// cannot be removed by any user, including the root AWS account.</p>
        pub fn retention_lock_type(mut self, input: crate::model::RetentionLockType) -> Self {
            self.inner = self.inner.retention_lock_type(input);
            self
        }
        pub fn set_retention_lock_type(
            mut self,
            input: std::option::Option<crate::model::RetentionLockType>,
        ) -> Self {
            self.inner = self.inner.set_retention_lock_type(input);
            self
        }
        /// <p>Tape retention lock time is set in days. Tape retention lock can be enabled for up to
        /// 100 years (36,500 days).</p>
        pub fn retention_lock_time_in_days(mut self, input: i32) -> Self {
            self.inner = self.inner.retention_lock_time_in_days(input);
            self
        }
        pub fn set_retention_lock_time_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_lock_time_in_days(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to tape pool. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTapes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tapes_input::Builder,
    }
    impl<C> CreateTapes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTapesOutput,
            smithy_http::result::SdkError<crate::error::CreateTapesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Amazon Resource Name (ARN) that represents the gateway to associate the
        /// virtual tapes with. Use the <a>ListGateways</a> operation to return a list of
        /// gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The size, in bytes, of the virtual tapes that you want to create.</p>
        /// <note>
        /// <p>The size must be aligned by gigabyte (1024*1024*1024 bytes).</p>
        /// </note>
        pub fn tape_size_in_bytes(mut self, input: i64) -> Self {
            self.inner = self.inner.tape_size_in_bytes(input);
            self
        }
        pub fn set_tape_size_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_tape_size_in_bytes(input);
            self
        }
        /// <p>A unique identifier that you use to retry a request. If you retry a request, use the
        /// same <code>ClientToken</code> you specified in the initial request.</p>
        /// <note>
        /// <p>Using the same <code>ClientToken</code> prevents creating the tape multiple
        /// times.</p>
        /// </note>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The number of virtual tapes that you want to create.</p>
        pub fn num_tapes_to_create(mut self, input: i32) -> Self {
            self.inner = self.inner.num_tapes_to_create(input);
            self
        }
        pub fn set_num_tapes_to_create(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_num_tapes_to_create(input);
            self
        }
        /// <p>A prefix that you append to the barcode of the virtual tape you are creating. This
        /// prefix makes the barcode unique.</p>
        /// <note>
        /// <p>The prefix must be 1-4 characters in length and must be one of the uppercase letters
        /// from A to Z.</p>
        /// </note>
        pub fn tape_barcode_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_barcode_prefix(input);
            self
        }
        pub fn set_tape_barcode_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_tape_barcode_prefix(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
        /// pool is archived in the S3 storage class that is associated with the pool. When you use
        /// your backup application to eject the tape, the tape is archived directly into the storage
        /// class (S3 Glacier or S3 Glacier Deep Archive) that corresponds to the pool.</p>
        /// <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
        /// </p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_id(input);
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_id(input);
            self
        }
        /// <p>Set to <code>TRUE</code> if the tape you are creating is to be configured as a
        /// write-once-read-many (WORM) tape.</p>
        pub fn worm(mut self, input: bool) -> Self {
            self.inner = self.inner.worm(input);
            self
        }
        pub fn set_worm(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_worm(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTapeWithBarcode<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tape_with_barcode_input::Builder,
    }
    impl<C> CreateTapeWithBarcode<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTapeWithBarcodeOutput,
            smithy_http::result::SdkError<crate::error::CreateTapeWithBarcodeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Amazon Resource Name (ARN) that represents the gateway to associate the
        /// virtual tape with. Use the <a>ListGateways</a> operation to return a list of
        /// gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The size, in bytes, of the virtual tape that you want to create.</p>
        /// <note>
        /// <p>The size must be aligned by gigabyte (1024*1024*1024 bytes).</p>
        /// </note>
        pub fn tape_size_in_bytes(mut self, input: i64) -> Self {
            self.inner = self.inner.tape_size_in_bytes(input);
            self
        }
        pub fn set_tape_size_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_tape_size_in_bytes(input);
            self
        }
        /// <p>The barcode that you want to assign to the tape.</p>
        /// <note>
        /// <p>Barcodes cannot be reused. This includes barcodes used for tapes that have been
        /// deleted.</p>
        /// </note>
        pub fn tape_barcode(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_barcode(input);
            self
        }
        pub fn set_tape_barcode(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_barcode(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>The ID of the pool that you want to add your tape to for archiving. The tape in this
        /// pool is archived in the S3 storage class that is associated with the pool. When you use
        /// your backup application to eject the tape, the tape is archived directly into the storage
        /// class (S3 Glacier or S3 Deep Archive) that corresponds to the pool.</p>
        /// <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
        /// </p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_id(input);
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_id(input);
            self
        }
        /// <p>Set to <code>TRUE</code> if the tape you are creating is to be configured as a
        /// write-once-read-many (WORM) tape.</p>
        pub fn worm(mut self, input: bool) -> Self {
            self.inner = self.inner.worm(input);
            self
        }
        pub fn set_worm(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_worm(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to a virtual tape that has a barcode. Each
        /// tag is a key-value pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAutomaticTapeCreationPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_automatic_tape_creation_policy_input::Builder,
    }
    impl<C> DeleteAutomaticTapeCreationPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAutomaticTapeCreationPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteAutomaticTapeCreationPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBandwidthRateLimit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bandwidth_rate_limit_input::Builder,
    }
    impl<C> DeleteBandwidthRateLimit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBandwidthRateLimitOutput,
            smithy_http::result::SdkError<crate::error::DeleteBandwidthRateLimitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>One of the BandwidthType values that indicates the gateway bandwidth rate limit to
        /// delete.</p>
        /// <p>Valid Values: <code>UPLOAD</code> | <code>DOWNLOAD</code> | <code>ALL</code>
        /// </p>
        pub fn bandwidth_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bandwidth_type(input);
            self
        }
        pub fn set_bandwidth_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_bandwidth_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteChapCredentials<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_chap_credentials_input::Builder,
    }
    impl<C> DeleteChapCredentials<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteChapCredentialsOutput,
            smithy_http::result::SdkError<crate::error::DeleteChapCredentialsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
        /// specified VolumeARN.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_arn(input);
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_arn(input);
            self
        }
        /// <p>The iSCSI initiator that connects to the target.</p>
        pub fn initiator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.initiator_name(input);
            self
        }
        pub fn set_initiator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_initiator_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFileShare<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_file_share_input::Builder,
    }
    impl<C> DeleteFileShare<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFileShareOutput,
            smithy_http::result::SdkError<crate::error::DeleteFileShareError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file share to be deleted.</p>
        pub fn file_share_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn(input);
            self
        }
        pub fn set_file_share_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn(input);
            self
        }
        /// <p>If this value is set to <code>true</code>, the operation deletes a file share
        /// immediately and aborts all data uploads to AWS. Otherwise, the file share is not deleted
        /// until all data is uploaded to AWS. This process aborts the data upload process, and the
        /// file share enters the <code>FORCE_DELETING</code> status.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete(input);
            self
        }
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_gateway_input::Builder,
    }
    impl<C> DeleteGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSnapshotSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_snapshot_schedule_input::Builder,
    }
    impl<C> DeleteSnapshotSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSnapshotScheduleOutput,
            smithy_http::result::SdkError<crate::error::DeleteSnapshotScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The volume which snapshot schedule to delete.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTape<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tape_input::Builder,
    }
    impl<C> DeleteTape<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTapeOutput,
            smithy_http::result::SdkError<crate::error::DeleteTapeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is
        /// associated with. Use the <a>ListGateways</a> operation to return a list of
        /// gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the virtual tape to delete.</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
        /// <p>Set to <code>TRUE</code> to delete an archived tape that belongs to a custom pool with
        /// tape retention lock. Only archived tapes with tape retention lock set to
        /// <code>governance</code> can be deleted. Archived tapes with tape retention lock set to
        /// <code>compliance</code> can't be deleted.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.inner = self.inner.bypass_governance_retention(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_bypass_governance_retention(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTapeArchive<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tape_archive_input::Builder,
    }
    impl<C> DeleteTapeArchive<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTapeArchiveOutput,
            smithy_http::result::SdkError<crate::error::DeleteTapeArchiveError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the virtual tape to delete from the virtual tape shelf
        /// (VTS).</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
        /// <p>Set to <code>TRUE</code> to delete an archived tape that belongs to a custom pool with
        /// tape retention lock. Only archived tapes with tape retention lock set to
        /// <code>governance</code> can be deleted. Archived tapes with tape retention lock set to
        /// <code>compliance</code> can't be deleted.</p>
        pub fn bypass_governance_retention(mut self, input: bool) -> Self {
            self.inner = self.inner.bypass_governance_retention(input);
            self
        }
        pub fn set_bypass_governance_retention(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_bypass_governance_retention(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTapePool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tape_pool_input::Builder,
    }
    impl<C> DeleteTapePool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTapePoolOutput,
            smithy_http::result::SdkError<crate::error::DeleteTapePoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the custom tape pool to delete.</p>
        pub fn pool_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_arn(input);
            self
        }
        pub fn set_pool_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_volume_input::Builder,
    }
    impl<C> DeleteVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVolumeOutput,
            smithy_http::result::SdkError<crate::error::DeleteVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
        /// operation to return a list of gateway volumes.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAvailabilityMonitorTest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_availability_monitor_test_input::Builder,
    }
    impl<C> DescribeAvailabilityMonitorTest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAvailabilityMonitorTestOutput,
            smithy_http::result::SdkError<crate::error::DescribeAvailabilityMonitorTestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBandwidthRateLimit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_bandwidth_rate_limit_input::Builder,
    }
    impl<C> DescribeBandwidthRateLimit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBandwidthRateLimitOutput,
            smithy_http::result::SdkError<crate::error::DescribeBandwidthRateLimitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBandwidthRateLimitSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_bandwidth_rate_limit_schedule_input::Builder,
    }
    impl<C> DescribeBandwidthRateLimitSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBandwidthRateLimitScheduleOutput,
            smithy_http::result::SdkError<crate::error::DescribeBandwidthRateLimitScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cache_input::Builder,
    }
    impl<C> DescribeCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCacheOutput,
            smithy_http::result::SdkError<crate::error::DescribeCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCachediSCSIVolumes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cachedi_scsi_volumes_input::Builder,
    }
    impl<C> DescribeCachediSCSIVolumes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCachediScsiVolumesOutput,
            smithy_http::result::SdkError<crate::error::DescribeCachediSCSIVolumesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of strings where each string represents the Amazon Resource Name (ARN) of a
        /// cached volume. All of the specified cached volumes must be from the same gateway. Use <a>ListVolumes</a> to get volume ARNs for a gateway.</p>
        pub fn volume_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_ar_ns(inp);
            self
        }
        pub fn set_volume_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_volume_ar_ns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeChapCredentials<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_chap_credentials_input::Builder,
    }
    impl<C> DescribeChapCredentials<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeChapCredentialsOutput,
            smithy_http::result::SdkError<crate::error::DescribeChapCredentialsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return to retrieve the TargetARN for
        /// specified VolumeARN.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_arn(input);
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFileSystemAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_file_system_associations_input::Builder,
    }
    impl<C> DescribeFileSystemAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFileSystemAssociationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeFileSystemAssociationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array containing the Amazon Resource Name (ARN) of each file system association to be described.</p>
        pub fn file_system_association_arn_list(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.file_system_association_arn_list(inp);
            self
        }
        pub fn set_file_system_association_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_file_system_association_arn_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeGatewayInformation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_gateway_information_input::Builder,
    }
    impl<C> DescribeGatewayInformation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeGatewayInformationOutput,
            smithy_http::result::SdkError<crate::error::DescribeGatewayInformationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMaintenanceStartTime<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_maintenance_start_time_input::Builder,
    }
    impl<C> DescribeMaintenanceStartTime<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMaintenanceStartTimeOutput,
            smithy_http::result::SdkError<crate::error::DescribeMaintenanceStartTimeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNFSFileShares<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_nfs_file_shares_input::Builder,
    }
    impl<C> DescribeNFSFileShares<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNfsFileSharesOutput,
            smithy_http::result::SdkError<crate::error::DescribeNFSFileSharesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array containing the Amazon Resource Name (ARN) of each file share to be
        /// described.</p>
        pub fn file_share_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn_list(inp);
            self
        }
        pub fn set_file_share_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSMBFileShares<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_smb_file_shares_input::Builder,
    }
    impl<C> DescribeSMBFileShares<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSmbFileSharesOutput,
            smithy_http::result::SdkError<crate::error::DescribeSMBFileSharesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array containing the Amazon Resource Name (ARN) of each file share to be
        /// described.</p>
        pub fn file_share_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn_list(inp);
            self
        }
        pub fn set_file_share_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSMBSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_smb_settings_input::Builder,
    }
    impl<C> DescribeSMBSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSmbSettingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSMBSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSnapshotSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_snapshot_schedule_input::Builder,
    }
    impl<C> DescribeSnapshotSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSnapshotScheduleOutput,
            smithy_http::result::SdkError<crate::error::DescribeSnapshotScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
        /// operation to return a list of gateway volumes.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStorediSCSIVolumes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_storedi_scsi_volumes_input::Builder,
    }
    impl<C> DescribeStorediSCSIVolumes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStorediScsiVolumesOutput,
            smithy_http::result::SdkError<crate::error::DescribeStorediSCSIVolumesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of strings where each string represents the Amazon Resource Name (ARN) of a
        /// stored volume. All of the specified stored volumes must be from the same gateway. Use <a>ListVolumes</a> to get volume ARNs for a gateway.</p>
        pub fn volume_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_ar_ns(inp);
            self
        }
        pub fn set_volume_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_volume_ar_ns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTapeArchives<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tape_archives_input::Builder,
    }
    impl<C> DescribeTapeArchives<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTapeArchivesOutput,
            smithy_http::result::SdkError<crate::error::DescribeTapeArchivesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual
        /// tapes you want to describe.</p>
        pub fn tape_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_ar_ns(inp);
            self
        }
        pub fn set_tape_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tape_ar_ns(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin describing virtual
        /// tapes.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the number of virtual tapes described be limited to the specified
        /// number.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTapeRecoveryPoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tape_recovery_points_input::Builder,
    }
    impl<C> DescribeTapeRecoveryPoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTapeRecoveryPointsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTapeRecoveryPointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin describing the virtual
        /// tape recovery points.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the number of virtual tape recovery points that are described be limited
        /// to the specified number.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTapes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tapes_input::Builder,
    }
    impl<C> DescribeTapes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTapesOutput,
            smithy_http::result::SdkError<crate::error::DescribeTapesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>Specifies one or more unique Amazon Resource Names (ARNs) that represent the virtual
        /// tapes you want to describe. If this parameter is not specified, Tape gateway returns a
        /// description of all virtual tapes associated with the specified gateway.</p>
        pub fn tape_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_ar_ns(inp);
            self
        }
        pub fn set_tape_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tape_ar_ns(input);
            self
        }
        /// <p>A marker value, obtained in a previous call to <code>DescribeTapes</code>. This marker
        /// indicates which page of results to retrieve.</p>
        /// <p>If not specified, the first page of results is retrieved.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the number of virtual tapes described be limited to the specified
        /// number.</p>
        /// <note>
        /// <p>Amazon Web Services may impose its own limit, if this field is not set.</p>
        /// </note>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeUploadBuffer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_upload_buffer_input::Builder,
    }
    impl<C> DescribeUploadBuffer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeUploadBufferOutput,
            smithy_http::result::SdkError<crate::error::DescribeUploadBufferError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVTLDevices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vtl_devices_input::Builder,
    }
    impl<C> DescribeVTLDevices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVtlDevicesOutput,
            smithy_http::result::SdkError<crate::error::DescribeVTLDevicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>An array of strings, where each string represents the Amazon Resource Name (ARN) of a
        /// VTL device.</p>
        /// <note>
        /// <p>All of the specified VTL devices must be from the same gateway. If no VTL devices are
        /// specified, the result will contain all devices on the specified gateway.</p>
        /// </note>
        pub fn vtl_device_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vtl_device_ar_ns(inp);
            self
        }
        pub fn set_vtl_device_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vtl_device_ar_ns(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin describing the VTL
        /// devices.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the number of VTL devices described be limited to the specified
        /// number.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeWorkingStorage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_working_storage_input::Builder,
    }
    impl<C> DescribeWorkingStorage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWorkingStorageOutput,
            smithy_http::result::SdkError<crate::error::DescribeWorkingStorageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_volume_input::Builder,
    }
    impl<C> DetachVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachVolumeOutput,
            smithy_http::result::SdkError<crate::error::DetachVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the volume to detach from the gateway.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
        /// <p>Set to <code>true</code> to forcibly remove the iSCSI connection of the target volume
        /// and detach the volume. The default is <code>false</code>. If this value is set to
        /// <code>false</code>, you must manually disconnect the iSCSI connection from the target
        /// volume.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn force_detach(mut self, input: bool) -> Self {
            self.inner = self.inner.force_detach(input);
            self
        }
        pub fn set_force_detach(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_detach(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_gateway_input::Builder,
    }
    impl<C> DisableGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableGatewayOutput,
            smithy_http::result::SdkError<crate::error::DisableGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateFileSystem<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_file_system_input::Builder,
    }
    impl<C> DisassociateFileSystem<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateFileSystemOutput,
            smithy_http::result::SdkError<crate::error::DisassociateFileSystemError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file system association to be deleted.</p>
        pub fn file_system_association_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.file_system_association_arn(input);
            self
        }
        pub fn set_file_system_association_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_association_arn(input);
            self
        }
        /// <p>If this value is set to true, the operation disassociates an Amazon FSx file system
        /// immediately. It ends all data uploads to the file system, and the file system association
        /// enters the <code>FORCE_DELETING</code> status. If this value is set to false, the Amazon
        /// FSx file system does not disassociate until all data is uploaded.</p>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete(input);
            self
        }
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct JoinDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::join_domain_input::Builder,
    }
    impl<C> JoinDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::JoinDomainOutput,
            smithy_http::result::SdkError<crate::error::JoinDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <code>ListGateways</code>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The name of the domain that you want the gateway to join.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>The organizational unit (OU) is a container in an Active Directory that can hold users,
        /// groups, computers, and other OUs and this parameter specifies the OU that the gateway will
        /// join within the AD domain.</p>
        pub fn organizational_unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.organizational_unit(input);
            self
        }
        pub fn set_organizational_unit(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_organizational_unit(input);
            self
        }
        /// <p>List of IPv4 addresses, NetBIOS names, or host names of your domain server. If you need
        /// to specify the port number include it after the colon (:). For example,
        /// <code>mydc.mydomain.com:389</code>.</p>
        pub fn domain_controllers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_controllers(inp);
            self
        }
        pub fn set_domain_controllers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_domain_controllers(input);
            self
        }
        /// <p>Specifies the time in seconds, in which the <code>JoinDomain</code> operation must
        /// complete. The default is 20 seconds.</p>
        pub fn timeout_in_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.timeout_in_seconds(input);
            self
        }
        pub fn set_timeout_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_timeout_in_seconds(input);
            self
        }
        /// <p>Sets the user name of user who has permission to add the gateway to the Active Directory
        /// domain. The domain user account should be enabled to join computers to the domain. For
        /// example, you can use the domain administrator account or an account with delegated
        /// permissions to join computers to the domain.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>Sets the password of the user who has permission to add the gateway to the Active
        /// Directory domain.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAutomaticTapeCreationPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_automatic_tape_creation_policies_input::Builder,
    }
    impl<C> ListAutomaticTapeCreationPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAutomaticTapeCreationPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListAutomaticTapeCreationPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFileShares<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_file_shares_input::Builder,
    }
    impl<C> ListFileShares<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFileSharesOutput,
            smithy_http::result::SdkError<crate::error::ListFileSharesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway whose file shares you want to list. If
        /// this field is not present, all file shares under your account are listed.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The maximum number of file shares to return in the response. The value must be an
        /// integer with a value greater than zero. Optional.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>Opaque pagination token returned from a previous ListFileShares operation. If present,
        /// <code>Marker</code> specifies where to continue the list from after a previous call to
        /// ListFileShares. Optional.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFileSystemAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_file_system_associations_input::Builder,
    }
    impl<C> ListFileSystemAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFileSystemAssociationsOutput,
            smithy_http::result::SdkError<crate::error::ListFileSystemAssociationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The maximum number of file system associations to return in the response. If present, <code>Limit</code> must be an integer with a value greater than zero. Optional.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>Opaque pagination token returned from a previous <code>ListFileSystemAssociations</code> operation. If present, <code>Marker</code> specifies where to continue the list from after a previous call to <code>ListFileSystemAssociations</code>. Optional.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_gateways_input::Builder,
    }
    impl<C> ListGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGatewaysOutput,
            smithy_http::result::SdkError<crate::error::ListGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An opaque string that indicates the position at which to begin the returned list of
        /// gateways.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the list of gateways returned be limited to the specified number of
        /// items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLocalDisks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_local_disks_input::Builder,
    }
    impl<C> ListLocalDisks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLocalDisksOutput,
            smithy_http::result::SdkError<crate::error::ListLocalDisksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource for which you want to list tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>An opaque string that indicates the position at which to begin returning the list of
        /// tags.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the list of tags returned be limited to the specified number of
        /// items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTapePools<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tape_pools_input::Builder,
    }
    impl<C> ListTapePools<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTapePoolsOutput,
            smithy_http::result::SdkError<crate::error::ListTapePoolsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of each of the custom tape pools you want to list. If you
        /// don't specify a custom tape pool ARN, the response lists all custom tape pools. </p>
        pub fn pool_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_ar_ns(inp);
            self
        }
        pub fn set_pool_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_pool_ar_ns(input);
            self
        }
        /// <p>A string that indicates the position at which to begin the returned list of tape
        /// pools.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>An optional number limit for the tape pools in the list returned by this call.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTapes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tapes_input::Builder,
    }
    impl<C> ListTapes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTapesOutput,
            smithy_http::result::SdkError<crate::error::ListTapesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of each of the tapes you want to list. If you don't
        /// specify a tape ARN, the response lists all tapes in both your VTL and VTS.</p>
        pub fn tape_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_ar_ns(inp);
            self
        }
        pub fn set_tape_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tape_ar_ns(input);
            self
        }
        /// <p>A string that indicates the position at which to begin the returned list of
        /// tapes.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>An optional number limit for the tapes in the list returned by this call.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVolumeInitiators<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_volume_initiators_input::Builder,
    }
    impl<C> ListVolumeInitiators<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVolumeInitiatorsOutput,
            smithy_http::result::SdkError<crate::error::ListVolumeInitiatorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
        /// operation to return a list of gateway volumes for the gateway.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVolumeRecoveryPoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_volume_recovery_points_input::Builder,
    }
    impl<C> ListVolumeRecoveryPoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVolumeRecoveryPointsOutput,
            smithy_http::result::SdkError<crate::error::ListVolumeRecoveryPointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListVolumes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_volumes_input::Builder,
    }
    impl<C> ListVolumes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListVolumesOutput,
            smithy_http::result::SdkError<crate::error::ListVolumesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>A string that indicates the position at which to begin the returned list of volumes.
        /// Obtain the marker from the response of a previous List iSCSI Volumes request.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>Specifies that the list of volumes returned be limited to the specified number of
        /// items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct NotifyWhenUploaded<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::notify_when_uploaded_input::Builder,
    }
    impl<C> NotifyWhenUploaded<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::NotifyWhenUploadedOutput,
            smithy_http::result::SdkError<crate::error::NotifyWhenUploadedError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file share.</p>
        pub fn file_share_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn(input);
            self
        }
        pub fn set_file_share_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RefreshCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::refresh_cache_input::Builder,
    }
    impl<C> RefreshCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RefreshCacheOutput,
            smithy_http::result::SdkError<crate::error::RefreshCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file share you want to refresh.</p>
        pub fn file_share_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn(input);
            self
        }
        pub fn set_file_share_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn(input);
            self
        }
        /// <p>A comma-separated list of the paths of folders to refresh in the cache. The default is
        /// [<code>"/"</code>]. The default refreshes objects and folders at the root of the Amazon
        /// S3 bucket. If <code>Recursive</code> is set to <code>true</code>, the entire S3 bucket that
        /// the file share has access to is refreshed.</p>
        pub fn folder_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.folder_list(inp);
            self
        }
        pub fn set_folder_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_folder_list(input);
            self
        }
        /// <p>A value that specifies whether to recursively refresh folders in the cache. The refresh
        /// includes folders that were in the cache the last time the gateway listed the folder's
        /// contents. If this value set to <code>true</code>, each folder that is listed in
        /// <code>FolderList</code> is recursively updated. Otherwise, subfolders listed in
        /// <code>FolderList</code> are not refreshed. Only objects that are in folders listed
        /// directly under <code>FolderList</code> are found and used for the update. The default is
        /// <code>true</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn recursive(mut self, input: bool) -> Self {
            self.inner = self.inner.recursive(input);
            self
        }
        pub fn set_recursive(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_recursive(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_from_resource_input::Builder,
    }
    impl<C> RemoveTagsFromResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromResourceOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource you want to remove the tags from.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The keys of the tags you want to remove from the specified resource. A tag is composed
        /// of a key-value pair.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_cache_input::Builder,
    }
    impl<C> ResetCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetCacheOutput,
            smithy_http::result::SdkError<crate::error::ResetCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RetrieveTapeArchive<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::retrieve_tape_archive_input::Builder,
    }
    impl<C> RetrieveTapeArchive<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RetrieveTapeArchiveOutput,
            smithy_http::result::SdkError<crate::error::RetrieveTapeArchiveError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the virtual tape you want to retrieve from the virtual
        /// tape shelf (VTS).</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway you want to retrieve the virtual tape to.
        /// Use the <a>ListGateways</a> operation to return a list of gateways for your
        /// account and AWS Region.</p>
        /// <p>You retrieve archived virtual tapes to only one gateway and the gateway must be a tape
        /// gateway.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RetrieveTapeRecoveryPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::retrieve_tape_recovery_point_input::Builder,
    }
    impl<C> RetrieveTapeRecoveryPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RetrieveTapeRecoveryPointOutput,
            smithy_http::result::SdkError<crate::error::RetrieveTapeRecoveryPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the virtual tape for which you want to retrieve the
        /// recovery point.</p>
        pub fn tape_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tape_arn(input);
            self
        }
        pub fn set_tape_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tape_arn(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetLocalConsolePassword<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_local_console_password_input::Builder,
    }
    impl<C> SetLocalConsolePassword<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetLocalConsolePasswordOutput,
            smithy_http::result::SdkError<crate::error::SetLocalConsolePasswordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The password you want to set for your VM local console.</p>
        pub fn local_console_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.local_console_password(input);
            self
        }
        pub fn set_local_console_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_console_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSMBGuestPassword<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_smb_guest_password_input::Builder,
    }
    impl<C> SetSMBGuestPassword<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSmbGuestPasswordOutput,
            smithy_http::result::SdkError<crate::error::SetSMBGuestPasswordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file gateway the SMB file share is associated
        /// with.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The password that you want to set for your SMB server.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ShutdownGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::shutdown_gateway_input::Builder,
    }
    impl<C> ShutdownGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ShutdownGatewayOutput,
            smithy_http::result::SdkError<crate::error::ShutdownGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartAvailabilityMonitorTest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_availability_monitor_test_input::Builder,
    }
    impl<C> StartAvailabilityMonitorTest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartAvailabilityMonitorTestOutput,
            smithy_http::result::SdkError<crate::error::StartAvailabilityMonitorTestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_gateway_input::Builder,
    }
    impl<C> StartGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartGatewayOutput,
            smithy_http::result::SdkError<crate::error::StartGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAutomaticTapeCreationPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_automatic_tape_creation_policy_input::Builder,
    }
    impl<C> UpdateAutomaticTapeCreationPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAutomaticTapeCreationPolicyOutput,
            smithy_http::result::SdkError<crate::error::UpdateAutomaticTapeCreationPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An automatic tape creation policy consists of a list of automatic tape creation rules.
        /// The rules determine when and how to automatically create new tapes.</p>
        pub fn automatic_tape_creation_rules(
            mut self,
            inp: impl Into<crate::model::AutomaticTapeCreationRule>,
        ) -> Self {
            self.inner = self.inner.automatic_tape_creation_rules(inp);
            self
        }
        pub fn set_automatic_tape_creation_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AutomaticTapeCreationRule>>,
        ) -> Self {
            self.inner = self.inner.set_automatic_tape_creation_rules(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBandwidthRateLimit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_bandwidth_rate_limit_input::Builder,
    }
    impl<C> UpdateBandwidthRateLimit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBandwidthRateLimitOutput,
            smithy_http::result::SdkError<crate::error::UpdateBandwidthRateLimitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The average upload bandwidth rate limit in bits per second.</p>
        pub fn average_upload_rate_limit_in_bits_per_sec(mut self, input: i64) -> Self {
            self.inner = self.inner.average_upload_rate_limit_in_bits_per_sec(input);
            self
        }
        pub fn set_average_upload_rate_limit_in_bits_per_sec(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self
                .inner
                .set_average_upload_rate_limit_in_bits_per_sec(input);
            self
        }
        /// <p>The average download bandwidth rate limit in bits per second.</p>
        pub fn average_download_rate_limit_in_bits_per_sec(mut self, input: i64) -> Self {
            self.inner = self
                .inner
                .average_download_rate_limit_in_bits_per_sec(input);
            self
        }
        pub fn set_average_download_rate_limit_in_bits_per_sec(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self
                .inner
                .set_average_download_rate_limit_in_bits_per_sec(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBandwidthRateLimitSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_bandwidth_rate_limit_schedule_input::Builder,
    }
    impl<C> UpdateBandwidthRateLimitSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBandwidthRateLimitScheduleOutput,
            smithy_http::result::SdkError<crate::error::UpdateBandwidthRateLimitScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>
        /// An array containing bandwidth rate limit schedule intervals for a gateway.
        /// When no bandwidth rate limit intervals have been scheduled, the array is empty.
        /// </p>
        pub fn bandwidth_rate_limit_intervals(
            mut self,
            inp: impl Into<crate::model::BandwidthRateLimitInterval>,
        ) -> Self {
            self.inner = self.inner.bandwidth_rate_limit_intervals(inp);
            self
        }
        pub fn set_bandwidth_rate_limit_intervals(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BandwidthRateLimitInterval>>,
        ) -> Self {
            self.inner = self.inner.set_bandwidth_rate_limit_intervals(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateChapCredentials<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_chap_credentials_input::Builder,
    }
    impl<C> UpdateChapCredentials<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateChapCredentialsOutput,
            smithy_http::result::SdkError<crate::error::UpdateChapCredentialsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the iSCSI volume target. Use the <a>DescribeStorediSCSIVolumes</a> operation to return the TargetARN for specified
        /// VolumeARN.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_arn(input);
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_arn(input);
            self
        }
        /// <p>The secret key that the initiator (for example, the Windows client) must provide to
        /// participate in mutual CHAP with the target.</p>
        /// <note>
        /// <p>The secret key must be between 12 and 16 bytes when encoded in UTF-8.</p>
        /// </note>
        pub fn secret_to_authenticate_initiator(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.secret_to_authenticate_initiator(input);
            self
        }
        pub fn set_secret_to_authenticate_initiator(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_secret_to_authenticate_initiator(input);
            self
        }
        /// <p>The iSCSI initiator that connects to the target.</p>
        pub fn initiator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.initiator_name(input);
            self
        }
        pub fn set_initiator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_initiator_name(input);
            self
        }
        /// <p>The secret key that the target must provide to participate in mutual CHAP with the
        /// initiator (e.g. Windows client).</p>
        /// <p>Byte constraints: Minimum bytes of 12. Maximum bytes of 16.</p>
        /// <note>
        /// <p>The secret key must be between 12 and 16 bytes when encoded in UTF-8.</p>
        /// </note>
        pub fn secret_to_authenticate_target(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.secret_to_authenticate_target(input);
            self
        }
        pub fn set_secret_to_authenticate_target(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_secret_to_authenticate_target(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFileSystemAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_file_system_association_input::Builder,
    }
    impl<C> UpdateFileSystemAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFileSystemAssociationOutput,
            smithy_http::result::SdkError<crate::error::UpdateFileSystemAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file system association that you want to update.</p>
        pub fn file_system_association_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.file_system_association_arn(input);
            self
        }
        pub fn set_file_system_association_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_association_arn(input);
            self
        }
        /// <p>The user name of the user credential that has permission to access the root share D$ of
        /// the Amazon FSx file system. The user account must belong to the Amazon FSx delegated admin
        /// user group.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The password of the user credential.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.password(input);
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_password(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the storage used for the audit logs.</p>
        pub fn audit_destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.audit_destination_arn(input);
            self
        }
        pub fn set_audit_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_audit_destination_arn(input);
            self
        }
        /// <p>The refresh cache information for the file share.</p>
        pub fn cache_attributes(mut self, input: crate::model::CacheAttributes) -> Self {
            self.inner = self.inner.cache_attributes(input);
            self
        }
        pub fn set_cache_attributes(
            mut self,
            input: std::option::Option<crate::model::CacheAttributes>,
        ) -> Self {
            self.inner = self.inner.set_cache_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGatewayInformation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_gateway_information_input::Builder,
    }
    impl<C> UpdateGatewayInformation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGatewayInformationOutput,
            smithy_http::result::SdkError<crate::error::UpdateGatewayInformationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The name you configured for your gateway.</p>
        pub fn gateway_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_name(input);
            self
        }
        pub fn set_gateway_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_name(input);
            self
        }
        /// <p>A value that indicates the time zone of the gateway.</p>
        pub fn gateway_timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_timezone(input);
            self
        }
        pub fn set_gateway_timezone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_gateway_timezone(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon CloudWatch log group that you want to use
        /// to monitor and log events in the gateway.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html">What is Amazon CloudWatch
        /// Logs?</a>
        /// </p>
        pub fn cloud_watch_log_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cloud_watch_log_group_arn(input);
            self
        }
        pub fn set_cloud_watch_log_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cloud_watch_log_group_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGatewaySoftwareNow<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_gateway_software_now_input::Builder,
    }
    impl<C> UpdateGatewaySoftwareNow<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGatewaySoftwareNowOutput,
            smithy_http::result::SdkError<crate::error::UpdateGatewaySoftwareNowError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMaintenanceStartTime<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_maintenance_start_time_input::Builder,
    }
    impl<C> UpdateMaintenanceStartTime<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMaintenanceStartTimeOutput,
            smithy_http::result::SdkError<crate::error::UpdateMaintenanceStartTimeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The hour component of the maintenance start time represented as <i>hh</i>,
        /// where <i>hh</i> is the hour (00 to 23). The hour of the day is in the time
        /// zone of the gateway.</p>
        pub fn hour_of_day(mut self, input: i32) -> Self {
            self.inner = self.inner.hour_of_day(input);
            self
        }
        pub fn set_hour_of_day(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_hour_of_day(input);
            self
        }
        /// <p>The minute component of the maintenance start time represented as
        /// <i>mm</i>, where <i>mm</i> is the minute (00 to 59). The
        /// minute of the hour is in the time zone of the gateway.</p>
        pub fn minute_of_hour(mut self, input: i32) -> Self {
            self.inner = self.inner.minute_of_hour(input);
            self
        }
        pub fn set_minute_of_hour(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_minute_of_hour(input);
            self
        }
        /// <p>The day of the week component of the maintenance start time week represented as an
        /// ordinal number from 0 to 6, where 0 represents Sunday and 6 Saturday.</p>
        pub fn day_of_week(mut self, input: i32) -> Self {
            self.inner = self.inner.day_of_week(input);
            self
        }
        pub fn set_day_of_week(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_day_of_week(input);
            self
        }
        /// <p>The day of the month component of the maintenance start time represented as an ordinal
        /// number from 1 to 28, where 1 represents the first day of the month and 28 represents the
        /// last day of the month.</p>
        pub fn day_of_month(mut self, input: i32) -> Self {
            self.inner = self.inner.day_of_month(input);
            self
        }
        pub fn set_day_of_month(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_day_of_month(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateNFSFileShare<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_nfs_file_share_input::Builder,
    }
    impl<C> UpdateNFSFileShare<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateNfsFileShareOutput,
            smithy_http::result::SdkError<crate::error::UpdateNFSFileShareError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the file share to be updated.</p>
        pub fn file_share_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn(input);
            self
        }
        pub fn set_file_share_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>The default values for the file share. Optional.</p>
        pub fn nfs_file_share_defaults(
            mut self,
            input: crate::model::NfsFileShareDefaults,
        ) -> Self {
            self.inner = self.inner.nfs_file_share_defaults(input);
            self
        }
        pub fn set_nfs_file_share_defaults(
            mut self,
            input: std::option::Option<crate::model::NfsFileShareDefaults>,
        ) -> Self {
            self.inner = self.inner.set_nfs_file_share_defaults(input);
            self
        }
        /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
        /// The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
        /// <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
        /// <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
        /// </p>
        pub fn default_storage_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_storage_class(input);
            self
        }
        pub fn set_default_storage_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_storage_class(input);
            self
        }
        /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
        /// that a file gateway puts objects into. The default value is <code>private</code>.</p>
        pub fn object_acl(mut self, input: crate::model::ObjectAcl) -> Self {
            self.inner = self.inner.object_acl(input);
            self
        }
        pub fn set_object_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectAcl>,
        ) -> Self {
            self.inner = self.inner.set_object_acl(input);
            self
        }
        /// <p>The list of clients that are allowed to access the file gateway. The list must contain
        /// either valid IP addresses or valid CIDR blocks.</p>
        pub fn client_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_list(inp);
            self
        }
        pub fn set_client_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_client_list(input);
            self
        }
        /// <p>The user mapped to anonymous user.</p>
        /// <p>Valid values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>RootSquash</code>: Only root is mapped to anonymous user.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NoSquash</code>: No one is mapped to anonymous user.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AllSquash</code>: Everyone is mapped to anonymous user.</p>
        /// </li>
        /// </ul>
        pub fn squash(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.squash(input);
            self
        }
        pub fn set_squash(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_squash(input);
            self
        }
        /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
        /// to set the write status to read-only, otherwise set to <code>false</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.inner = self.inner.read_only(input);
            self
        }
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_read_only(input);
            self
        }
        /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
        /// extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
        /// to <code>false</code>. The default value is <code>true</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn guess_mime_type_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.guess_mime_type_enabled(input);
            self
        }
        pub fn set_guess_mime_type_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_guess_mime_type_enabled(input);
            self
        }
        /// <p>A value that sets who pays the cost of the request and the cost associated with data
        /// download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
        /// the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
        /// the cost of storing data.</p>
        /// <note>
        /// <p>
        /// <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
        /// share, so make sure that the configuration on the file share is the same as the S3
        /// bucket configuration.</p>
        /// </note>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn requester_pays(mut self, input: bool) -> Self {
            self.inner = self.inner.requester_pays(input);
            self
        }
        pub fn set_requester_pays(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_requester_pays(input);
            self
        }
        /// <p>The name of the file share. Optional.</p>
        /// <note>
        /// <p>
        /// <code>FileShareName</code> must be set if an S3 prefix name is set in
        /// <code>LocationARN</code>.</p>
        /// </note>
        pub fn file_share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_name(input);
            self
        }
        pub fn set_file_share_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_name(input);
            self
        }
        /// <p>specifies refresh cache information for the file share.</p>
        pub fn cache_attributes(mut self, input: crate::model::CacheAttributes) -> Self {
            self.inner = self.inner.cache_attributes(input);
            self
        }
        pub fn set_cache_attributes(
            mut self,
            input: std::option::Option<crate::model::CacheAttributes>,
        ) -> Self {
            self.inner = self.inner.set_cache_attributes(input);
            self
        }
        /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
        /// the number of seconds to wait after the last point in time a client wrote to a file before
        /// generating an <code>ObjectUploaded</code> notification. Because clients can make many small
        /// writes to files, it's best to set this parameter for as long as possible to avoid
        /// generating multiple notifications for the same file in a small time period.</p>
        /// <note>
        /// <p>
        /// <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
        /// uploading to Amazon S3, only the timing of the notification.</p>
        /// </note>
        /// <p>The following example sets <code>NotificationPolicy</code> on with
        /// <code>SettlingTimeInSeconds</code> set to 60.</p>
        /// <p>
        /// <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
        /// </p>
        /// <p>The following example sets <code>NotificationPolicy</code> off.</p>
        /// <p>
        /// <code>{}</code>
        /// </p>
        pub fn notification_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_policy(input);
            self
        }
        pub fn set_notification_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSMBFileShare<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_smb_file_share_input::Builder,
    }
    impl<C> UpdateSMBFileShare<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSmbFileShareOutput,
            smithy_http::result::SdkError<crate::error::UpdateSMBFileShareError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the SMB file share that you want to update.</p>
        pub fn file_share_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_arn(input);
            self
        }
        pub fn set_file_share_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_arn(input);
            self
        }
        /// <p>Set to <code>true</code> to use Amazon S3 server-side encryption with your own AWS KMS
        /// key, or <code>false</code> to use a key managed by Amazon S3. Optional.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn kms_encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.kms_encrypted(input);
            self
        }
        pub fn set_kms_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_kms_encrypted(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon
        /// S3 server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can
        /// only be set when <code>KMSEncrypted</code> is <code>true</code>. Optional.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key(input);
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key(input);
            self
        }
        /// <p>The default storage class for objects put into an Amazon S3 bucket by the file gateway.
        /// The default value is <code>S3_INTELLIGENT_TIERING</code>. Optional.</p>
        /// <p>Valid Values: <code>S3_STANDARD</code> | <code>S3_INTELLIGENT_TIERING</code> |
        /// <code>S3_STANDARD_IA</code> | <code>S3_ONEZONE_IA</code>
        /// </p>
        pub fn default_storage_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_storage_class(input);
            self
        }
        pub fn set_default_storage_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_storage_class(input);
            self
        }
        /// <p>A value that sets the access control list (ACL) permission for objects in the S3 bucket
        /// that a file gateway puts objects into. The default value is <code>private</code>.</p>
        pub fn object_acl(mut self, input: crate::model::ObjectAcl) -> Self {
            self.inner = self.inner.object_acl(input);
            self
        }
        pub fn set_object_acl(
            mut self,
            input: std::option::Option<crate::model::ObjectAcl>,
        ) -> Self {
            self.inner = self.inner.set_object_acl(input);
            self
        }
        /// <p>A value that sets the write status of a file share. Set this value to <code>true</code>
        /// to set write status to read-only, otherwise set to <code>false</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn read_only(mut self, input: bool) -> Self {
            self.inner = self.inner.read_only(input);
            self
        }
        pub fn set_read_only(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_read_only(input);
            self
        }
        /// <p>A value that enables guessing of the MIME type for uploaded objects based on file
        /// extensions. Set this value to <code>true</code> to enable MIME type guessing, otherwise set
        /// to <code>false</code>. The default value is <code>true</code>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn guess_mime_type_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.guess_mime_type_enabled(input);
            self
        }
        pub fn set_guess_mime_type_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_guess_mime_type_enabled(input);
            self
        }
        /// <p>A value that sets who pays the cost of the request and the cost associated with data
        /// download from the S3 bucket. If this value is set to <code>true</code>, the requester pays
        /// the costs; otherwise, the S3 bucket owner pays. However, the S3 bucket owner always pays
        /// the cost of storing data.</p>
        /// <note>
        /// <p>
        /// <code>RequesterPays</code> is a configuration for the S3 bucket that backs the file
        /// share, so make sure that the configuration on the file share is the same as the S3
        /// bucket configuration.</p>
        /// </note>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn requester_pays(mut self, input: bool) -> Self {
            self.inner = self.inner.requester_pays(input);
            self
        }
        pub fn set_requester_pays(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_requester_pays(input);
            self
        }
        /// <p>Set this value to <code>true</code> to enable access control list (ACL) on the SMB file
        /// share. Set it to <code>false</code> to map file and directory permissions to the POSIX
        /// permissions.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/smb-acl.html">Using Microsoft Windows ACLs to
        /// control access to an SMB file share</a> in the <i>AWS Storage Gateway User
        /// Guide</i>.</p>
        /// <p>Valid Values: <code>true</code> | <code>false</code>
        /// </p>
        pub fn smbacl_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.smbacl_enabled(input);
            self
        }
        pub fn set_smbacl_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_smbacl_enabled(input);
            self
        }
        /// <p>The files and folders on this share will only be visible to users with read
        /// access.</p>
        pub fn access_based_enumeration(mut self, input: bool) -> Self {
            self.inner = self.inner.access_based_enumeration(input);
            self
        }
        pub fn set_access_based_enumeration(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_access_based_enumeration(input);
            self
        }
        /// <p>A list of users or groups in the Active Directory that have administrator rights to the
        /// file share. A group must be prefixed with the @ character. Acceptable formats include:
        /// <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
        /// <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
        /// <code>ActiveDirectory</code>.</p>
        pub fn admin_user_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.admin_user_list(inp);
            self
        }
        pub fn set_admin_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_admin_user_list(input);
            self
        }
        /// <p>A list of users or groups in the Active Directory that are allowed to access the file
        /// share. A group must be prefixed with the @ character. Acceptable formats include:
        /// <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
        /// <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
        /// <code>ActiveDirectory</code>.</p>
        pub fn valid_user_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.valid_user_list(inp);
            self
        }
        pub fn set_valid_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_valid_user_list(input);
            self
        }
        /// <p>A list of users or groups in the Active Directory that are not allowed to access the
        /// file share. A group must be prefixed with the @ character. Acceptable formats include:
        /// <code>DOMAIN\User1</code>, <code>user1</code>, <code>@group1</code>, and
        /// <code>@DOMAIN\group1</code>. Can only be set if Authentication is set to
        /// <code>ActiveDirectory</code>.</p>
        pub fn invalid_user_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.invalid_user_list(inp);
            self
        }
        pub fn set_invalid_user_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_invalid_user_list(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the storage used for audit logs.</p>
        pub fn audit_destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.audit_destination_arn(input);
            self
        }
        pub fn set_audit_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_audit_destination_arn(input);
            self
        }
        /// <p>The case of an object name in an Amazon S3 bucket. For <code>ClientSpecified</code>, the
        /// client determines the case sensitivity. For <code>CaseSensitive</code>, the gateway
        /// determines the case sensitivity. The default value is <code>ClientSpecified</code>.</p>
        pub fn case_sensitivity(mut self, input: crate::model::CaseSensitivity) -> Self {
            self.inner = self.inner.case_sensitivity(input);
            self
        }
        pub fn set_case_sensitivity(
            mut self,
            input: std::option::Option<crate::model::CaseSensitivity>,
        ) -> Self {
            self.inner = self.inner.set_case_sensitivity(input);
            self
        }
        /// <p>The name of the file share. Optional.</p>
        /// <note>
        /// <p>
        /// <code>FileShareName</code> must be set if an S3 prefix name is set in
        /// <code>LocationARN</code>.</p>
        /// </note>
        pub fn file_share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_share_name(input);
            self
        }
        pub fn set_file_share_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_share_name(input);
            self
        }
        /// <p>Specifies refresh cache information for the file share.</p>
        pub fn cache_attributes(mut self, input: crate::model::CacheAttributes) -> Self {
            self.inner = self.inner.cache_attributes(input);
            self
        }
        pub fn set_cache_attributes(
            mut self,
            input: std::option::Option<crate::model::CacheAttributes>,
        ) -> Self {
            self.inner = self.inner.set_cache_attributes(input);
            self
        }
        /// <p>The notification policy of the file share. <code>SettlingTimeInSeconds</code> controls
        /// the number of seconds to wait after the last point in time a client wrote to a file before
        /// generating an <code>ObjectUploaded</code> notification. Because clients can make many small
        /// writes to files, it's best to set this parameter for as long as possible to avoid
        /// generating multiple notifications for the same file in a small time period.</p>
        /// <note>
        /// <p>
        /// <code>SettlingTimeInSeconds</code> has no effect on the timing of the object
        /// uploading to Amazon S3, only the timing of the notification.</p>
        /// </note>
        /// <p>The following example sets <code>NotificationPolicy</code> on with
        /// <code>SettlingTimeInSeconds</code> set to 60.</p>
        /// <p>
        /// <code>{\"Upload\": {\"SettlingTimeInSeconds\": 60}}</code>
        /// </p>
        /// <p>The following example sets <code>NotificationPolicy</code> off.</p>
        /// <p>
        /// <code>{}</code>
        /// </p>
        pub fn notification_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_policy(input);
            self
        }
        pub fn set_notification_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSMBFileShareVisibility<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_smb_file_share_visibility_input::Builder,
    }
    impl<C> UpdateSMBFileShareVisibility<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSmbFileShareVisibilityOutput,
            smithy_http::result::SdkError<crate::error::UpdateSMBFileShareVisibilityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>The shares on this gateway appear when listing shares.</p>
        pub fn file_shares_visible(mut self, input: bool) -> Self {
            self.inner = self.inner.file_shares_visible(input);
            self
        }
        pub fn set_file_shares_visible(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_file_shares_visible(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSMBSecurityStrategy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_smb_security_strategy_input::Builder,
    }
    impl<C> UpdateSMBSecurityStrategy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSmbSecurityStrategyOutput,
            smithy_http::result::SdkError<crate::error::UpdateSMBSecurityStrategyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the gateway. Use the <a>ListGateways</a>
        /// operation to return a list of gateways for your account and AWS Region.</p>
        pub fn gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_arn(input);
            self
        }
        pub fn set_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_arn(input);
            self
        }
        /// <p>Specifies the type of security strategy.</p>
        /// <p>ClientSpecified: if you use this option, requests are established based on what is
        /// negotiated by the client. This option is recommended when you want to maximize
        /// compatibility across different clients in your environment.</p>
        /// <p>MandatorySigning: if you use this option, file gateway only allows connections from
        /// SMBv2 or SMBv3 clients that have signing enabled. This option works with SMB clients on
        /// Microsoft Windows Vista, Windows Server 2008 or newer.</p>
        /// <p>MandatoryEncryption: if you use this option, file gateway only allows connections from
        /// SMBv3 clients that have encryption enabled. This option is highly recommended for
        /// environments that handle sensitive data. This option works with SMB clients on Microsoft
        /// Windows 8, Windows Server 2012 or newer.</p>
        pub fn smb_security_strategy(mut self, input: crate::model::SmbSecurityStrategy) -> Self {
            self.inner = self.inner.smb_security_strategy(input);
            self
        }
        pub fn set_smb_security_strategy(
            mut self,
            input: std::option::Option<crate::model::SmbSecurityStrategy>,
        ) -> Self {
            self.inner = self.inner.set_smb_security_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSnapshotSchedule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_snapshot_schedule_input::Builder,
    }
    impl<C> UpdateSnapshotSchedule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSnapshotScheduleOutput,
            smithy_http::result::SdkError<crate::error::UpdateSnapshotScheduleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the volume. Use the <a>ListVolumes</a>
        /// operation to return a list of gateway volumes.</p>
        pub fn volume_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_arn(input);
            self
        }
        pub fn set_volume_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_arn(input);
            self
        }
        /// <p>The hour of the day at which the snapshot schedule begins represented as
        /// <i>hh</i>, where <i>hh</i> is the hour (0 to 23). The hour
        /// of the day is in the time zone of the gateway.</p>
        pub fn start_at(mut self, input: i32) -> Self {
            self.inner = self.inner.start_at(input);
            self
        }
        pub fn set_start_at(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_start_at(input);
            self
        }
        /// <p>Frequency of snapshots. Specify the number of hours between snapshots.</p>
        pub fn recurrence_in_hours(mut self, input: i32) -> Self {
            self.inner = self.inner.recurrence_in_hours(input);
            self
        }
        pub fn set_recurrence_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_recurrence_in_hours(input);
            self
        }
        /// <p>Optional description of the snapshot that overwrites the existing description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A list of up to 50 tags that can be assigned to a snapshot. Each tag is a key-value
        /// pair.</p>
        /// <note>
        /// <p>Valid characters for key and value are letters, spaces, and numbers representable in
        /// UTF-8 format, and the following special characters: + - = . _ : / @. The maximum length
        /// of a tag's key is 128 characters, and the maximum length for a tag's value is
        /// 256.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateVTLDeviceType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_vtl_device_type_input::Builder,
    }
    impl<C> UpdateVTLDeviceType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateVtlDeviceTypeOutput,
            smithy_http::result::SdkError<crate::error::UpdateVTLDeviceTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the medium changer you want to select.</p>
        pub fn vtl_device_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vtl_device_arn(input);
            self
        }
        pub fn set_vtl_device_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vtl_device_arn(input);
            self
        }
        /// <p>The type of medium changer you want to select.</p>
        /// <p>Valid Values: <code>STK-L700</code> | <code>AWS-Gateway-VTL</code> |
        /// <code>IBM-03584L32-0402</code>
        /// </p>
        pub fn device_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_type(input);
            self
        }
        pub fn set_device_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_type(input);
            self
        }
    }
}
