// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::start_cache_report::_start_cache_report_input::StartCacheReportInputBuilder;

pub use crate::operation::start_cache_report::_start_cache_report_output::StartCacheReportOutputBuilder;

impl crate::operation::start_cache_report::builders::StartCacheReportInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::start_cache_report::StartCacheReportOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_cache_report::StartCacheReportError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.start_cache_report();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `StartCacheReport`.
///
/// <p>Starts generating a report of the file metadata currently cached by an S3 File Gateway for a specific file share. You can use this report to identify and resolve issues if you have files failing upload from your gateway to Amazon S3. The report is a CSV file containing a list of files which match the set of filter parameters you specify in the request.</p><note>
/// <p>The <b>Files Failing Upload</b> flag is reset every 24 hours and during gateway reboot. If this report captures the files after the reset, but before they become flagged again, they will not be reported as <b>Files Failing Upload</b>.</p>
/// </note>
/// <p>The following requirements must be met to successfully generate a cache report:</p>
/// <ul>
/// <li>
/// <p>You must have <code>s3:PutObject</code> and <code>s3:AbortMultipartUpload</code> permissions for the Amazon S3 bucket where you want to store the cache report.</p></li>
/// <li>
/// <p>No other cache reports can currently be in-progress for the specified file share.</p></li>
/// <li>
/// <p>There must be fewer than 10 existing cache reports for the specified file share.</p></li>
/// <li>
/// <p>The gateway must be online and connected to Amazon Web Services.</p></li>
/// <li>
/// <p>The root disk must have at least 20GB of free space when report generation starts.</p></li>
/// <li>
/// <p>You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in the request.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct StartCacheReportFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::start_cache_report::builders::StartCacheReportInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::start_cache_report::StartCacheReportOutput,
        crate::operation::start_cache_report::StartCacheReportError,
    > for StartCacheReportFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::start_cache_report::StartCacheReportOutput,
            crate::operation::start_cache_report::StartCacheReportError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl StartCacheReportFluentBuilder {
    /// Creates a new `StartCacheReportFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the StartCacheReport as a reference.
    pub fn as_input(&self) -> &crate::operation::start_cache_report::builders::StartCacheReportInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::start_cache_report::StartCacheReportOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_cache_report::StartCacheReportError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::start_cache_report::StartCacheReport::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::start_cache_report::StartCacheReport::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::start_cache_report::StartCacheReportOutput,
        crate::operation::start_cache_report::StartCacheReportError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    pub fn file_share_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.file_share_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    pub fn set_file_share_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_file_share_arn(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the file share.</p>
    pub fn get_file_share_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_file_share_arn()
    }
    /// <p>The ARN of the IAM role used when saving the cache report to Amazon S3.</p>
    pub fn role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.role(input.into());
        self
    }
    /// <p>The ARN of the IAM role used when saving the cache report to Amazon S3.</p>
    pub fn set_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_role(input);
        self
    }
    /// <p>The ARN of the IAM role used when saving the cache report to Amazon S3.</p>
    pub fn get_role(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_role()
    }
    /// <p>The ARN of the Amazon S3 bucket where you want to save the cache report.</p><note>
    /// <p>We do not recommend saving the cache report to the same Amazon S3 bucket for which you are generating the report.</p>
    /// <p>This field does not accept access point ARNs.</p>
    /// </note>
    pub fn location_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.location_arn(input.into());
        self
    }
    /// <p>The ARN of the Amazon S3 bucket where you want to save the cache report.</p><note>
    /// <p>We do not recommend saving the cache report to the same Amazon S3 bucket for which you are generating the report.</p>
    /// <p>This field does not accept access point ARNs.</p>
    /// </note>
    pub fn set_location_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_location_arn(input);
        self
    }
    /// <p>The ARN of the Amazon S3 bucket where you want to save the cache report.</p><note>
    /// <p>We do not recommend saving the cache report to the same Amazon S3 bucket for which you are generating the report.</p>
    /// <p>This field does not accept access point ARNs.</p>
    /// </note>
    pub fn get_location_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_location_arn()
    }
    /// <p>The Amazon Web Services Region of the Amazon S3 bucket where you want to save the cache report.</p>
    pub fn bucket_region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.bucket_region(input.into());
        self
    }
    /// <p>The Amazon Web Services Region of the Amazon S3 bucket where you want to save the cache report.</p>
    pub fn set_bucket_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_bucket_region(input);
        self
    }
    /// <p>The Amazon Web Services Region of the Amazon S3 bucket where you want to save the cache report.</p>
    pub fn get_bucket_region(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_bucket_region()
    }
    /// <p>The DNS name of the VPC endpoint associated with the Amazon S3 where you want to save the cache report. Optional.</p>
    pub fn vpc_endpoint_dns_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.vpc_endpoint_dns_name(input.into());
        self
    }
    /// <p>The DNS name of the VPC endpoint associated with the Amazon S3 where you want to save the cache report. Optional.</p>
    pub fn set_vpc_endpoint_dns_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_vpc_endpoint_dns_name(input);
        self
    }
    /// <p>The DNS name of the VPC endpoint associated with the Amazon S3 where you want to save the cache report. Optional.</p>
    pub fn get_vpc_endpoint_dns_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_vpc_endpoint_dns_name()
    }
    ///
    /// Appends an item to `InclusionFilters`.
    ///
    /// To override the contents of this collection use [`set_inclusion_filters`](Self::set_inclusion_filters).
    ///
    /// <p>The list of filters and parameters that determine which files are included in the report. You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in a <code>StartCacheReport</code> request.</p>
    pub fn inclusion_filters(mut self, input: crate::types::CacheReportFilter) -> Self {
        self.inner = self.inner.inclusion_filters(input);
        self
    }
    /// <p>The list of filters and parameters that determine which files are included in the report. You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in a <code>StartCacheReport</code> request.</p>
    pub fn set_inclusion_filters(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CacheReportFilter>>) -> Self {
        self.inner = self.inner.set_inclusion_filters(input);
        self
    }
    /// <p>The list of filters and parameters that determine which files are included in the report. You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in a <code>StartCacheReport</code> request.</p>
    pub fn get_inclusion_filters(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CacheReportFilter>> {
        self.inner.get_inclusion_filters()
    }
    ///
    /// Appends an item to `ExclusionFilters`.
    ///
    /// To override the contents of this collection use [`set_exclusion_filters`](Self::set_exclusion_filters).
    ///
    /// <p>The list of filters and parameters that determine which files are excluded from the report. You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in a <code>StartCacheReport</code> request.</p>
    pub fn exclusion_filters(mut self, input: crate::types::CacheReportFilter) -> Self {
        self.inner = self.inner.exclusion_filters(input);
        self
    }
    /// <p>The list of filters and parameters that determine which files are excluded from the report. You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in a <code>StartCacheReport</code> request.</p>
    pub fn set_exclusion_filters(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CacheReportFilter>>) -> Self {
        self.inner = self.inner.set_exclusion_filters(input);
        self
    }
    /// <p>The list of filters and parameters that determine which files are excluded from the report. You must specify at least one value for <code>InclusionFilters</code> or <code>ExclusionFilters</code> in a <code>StartCacheReport</code> request.</p>
    pub fn get_exclusion_filters(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CacheReportFilter>> {
        self.inner.get_exclusion_filters()
    }
    /// <p>A unique identifier that you use to ensure idempotent report generation if you need to retry an unsuccessful <code>StartCacheReport</code> request. If you retry a request, use the same <code>ClientToken</code> you specified in the initial request.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique identifier that you use to ensure idempotent report generation if you need to retry an unsuccessful <code>StartCacheReport</code> request. If you retry a request, use the same <code>ClientToken</code> you specified in the initial request.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A unique identifier that you use to ensure idempotent report generation if you need to retry an unsuccessful <code>StartCacheReport</code> request. If you retry a request, use the same <code>ClientToken</code> you specified in the initial request.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
    ///
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of up to 50 key/value tags that you can assign to the cache report. Using tags can help you categorize your reports and more easily locate them in search results.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>A list of up to 50 key/value tags that you can assign to the cache report. Using tags can help you categorize your reports and more easily locate them in search results.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A list of up to 50 key/value tags that you can assign to the cache report. Using tags can help you categorize your reports and more easily locate them in search results.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        self.inner.get_tags()
    }
}
