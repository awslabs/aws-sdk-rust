// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::evict_files_failing_upload::_evict_files_failing_upload_input::EvictFilesFailingUploadInputBuilder;

pub use crate::operation::evict_files_failing_upload::_evict_files_failing_upload_output::EvictFilesFailingUploadOutputBuilder;

impl crate::operation::evict_files_failing_upload::builders::EvictFilesFailingUploadInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::evict_files_failing_upload::EvictFilesFailingUploadOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::evict_files_failing_upload::EvictFilesFailingUploadError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.evict_files_failing_upload();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `EvictFilesFailingUpload`.
///
/// <p>Starts a process that cleans the specified file share's cache of file entries that are failing upload to Amazon S3. This API operation reports success if the request is received with valid arguments, and there are no other cache clean operations currently in-progress for the specified file share. After a successful request, the cache clean operation occurs asynchronously and reports progress using CloudWatch logs and notifications.</p><important>
/// <p>If <code>ForceRemove</code> is set to <code>True</code>, the cache clean operation will delete file data from the gateway which might otherwise be recoverable. We recommend using this operation only after all other methods to clear files failing upload have been exhausted, and if your business need outweighs the potential data loss.</p>
/// </important>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct EvictFilesFailingUploadFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::evict_files_failing_upload::builders::EvictFilesFailingUploadInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::evict_files_failing_upload::EvictFilesFailingUploadOutput,
        crate::operation::evict_files_failing_upload::EvictFilesFailingUploadError,
    > for EvictFilesFailingUploadFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::evict_files_failing_upload::EvictFilesFailingUploadOutput,
            crate::operation::evict_files_failing_upload::EvictFilesFailingUploadError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl EvictFilesFailingUploadFluentBuilder {
    /// Creates a new `EvictFilesFailingUploadFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the EvictFilesFailingUpload as a reference.
    pub fn as_input(&self) -> &crate::operation::evict_files_failing_upload::builders::EvictFilesFailingUploadInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::evict_files_failing_upload::EvictFilesFailingUploadOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::evict_files_failing_upload::EvictFilesFailingUploadError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::evict_files_failing_upload::EvictFilesFailingUpload::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::evict_files_failing_upload::EvictFilesFailingUpload::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::evict_files_failing_upload::EvictFilesFailingUploadOutput,
        crate::operation::evict_files_failing_upload::EvictFilesFailingUploadError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the file share for which you want to start the cache clean operation.</p>
    pub fn file_share_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.file_share_arn(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the file share for which you want to start the cache clean operation.</p>
    pub fn set_file_share_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_file_share_arn(input);
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the file share for which you want to start the cache clean operation.</p>
    pub fn get_file_share_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_file_share_arn()
    }
    /// <p>Specifies whether cache entries with full or partial file data currently stored on the gateway will be forcibly removed by the cache clean operation.</p>
    /// <p>Valid arguments:</p>
    /// <ul>
    /// <li>
    /// <p><code>False</code> - The cache clean operation skips cache entries failing upload if they are associated with data currently stored on the gateway. This preserves the cached data.</p></li>
    /// <li>
    /// <p><code>True</code> - The cache clean operation removes cache entries failing upload even if they are associated with data currently stored on the gateway. This deletes the cached data.</p><important>
    /// <p>If <code>ForceRemove</code> is set to <code>True</code>, the cache clean operation will delete file data from the gateway which might otherwise be recoverable.</p>
    /// </important></li>
    /// </ul>
    pub fn force_remove(mut self, input: bool) -> Self {
        self.inner = self.inner.force_remove(input);
        self
    }
    /// <p>Specifies whether cache entries with full or partial file data currently stored on the gateway will be forcibly removed by the cache clean operation.</p>
    /// <p>Valid arguments:</p>
    /// <ul>
    /// <li>
    /// <p><code>False</code> - The cache clean operation skips cache entries failing upload if they are associated with data currently stored on the gateway. This preserves the cached data.</p></li>
    /// <li>
    /// <p><code>True</code> - The cache clean operation removes cache entries failing upload even if they are associated with data currently stored on the gateway. This deletes the cached data.</p><important>
    /// <p>If <code>ForceRemove</code> is set to <code>True</code>, the cache clean operation will delete file data from the gateway which might otherwise be recoverable.</p>
    /// </important></li>
    /// </ul>
    pub fn set_force_remove(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_force_remove(input);
        self
    }
    /// <p>Specifies whether cache entries with full or partial file data currently stored on the gateway will be forcibly removed by the cache clean operation.</p>
    /// <p>Valid arguments:</p>
    /// <ul>
    /// <li>
    /// <p><code>False</code> - The cache clean operation skips cache entries failing upload if they are associated with data currently stored on the gateway. This preserves the cached data.</p></li>
    /// <li>
    /// <p><code>True</code> - The cache clean operation removes cache entries failing upload even if they are associated with data currently stored on the gateway. This deletes the cached data.</p><important>
    /// <p>If <code>ForceRemove</code> is set to <code>True</code>, the cache clean operation will delete file data from the gateway which might otherwise be recoverable.</p>
    /// </important></li>
    /// </ul>
    pub fn get_force_remove(&self) -> &::std::option::Option<bool> {
        self.inner.get_force_remove()
    }
}
