// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Activates the gateway you previously deployed on your host. In the activation process,
/// you specify information such as the Region that you want to use for storing snapshots
/// or tapes, the time zone for scheduled snapshots the gateway snapshot schedule window, an
/// activation key, and a name for your gateway. The activation process also associates your
/// gateway with your account. For more information, see <a>UpdateGatewayInformation</a>.</p>
/// <note>
/// <p>You must turn on the gateway VM before you can activate your gateway.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ActivateGateway {
    _private: (),
}
impl ActivateGateway {
    /// Creates a new builder-style object to manufacture [`ActivateGatewayInput`](crate::input::ActivateGatewayInput)
    pub fn builder() -> crate::input::activate_gateway_input::Builder {
        crate::input::activate_gateway_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ActivateGateway {
    type Output = std::result::Result<
        crate::output::ActivateGatewayOutput,
        crate::error::ActivateGatewayError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_activate_gateway_error(response)
        } else {
            crate::operation_deser::parse_activate_gateway_response(response)
        }
    }
}

/// <p>Configures one or more gateway local disks as cache for a gateway. This operation is
/// only supported in the cached volume, tape, and file gateway type (see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/StorageGatewayConcepts.html">How Storage Gateway works (architecture)</a>.</p>
/// <p>In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to
/// add cache, and one or more disk IDs that you want to configure as cache.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddCache {
    _private: (),
}
impl AddCache {
    /// Creates a new builder-style object to manufacture [`AddCacheInput`](crate::input::AddCacheInput)
    pub fn builder() -> crate::input::add_cache_input::Builder {
        crate::input::add_cache_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddCache {
    type Output = std::result::Result<crate::output::AddCacheOutput, crate::error::AddCacheError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_cache_error(response)
        } else {
            crate::operation_deser::parse_add_cache_response(response)
        }
    }
}

/// <p>Adds one or more tags to the specified resource. You use tags to add metadata to
/// resources, which you can use to categorize these resources. For example, you can categorize
/// resources by purpose, owner, environment, or team. Each tag consists of a key and a value,
/// which you define. You can add tags to the following Storage Gateway resources:</p>
/// <ul>
/// <li>
/// <p>Storage gateways of all types</p>
/// </li>
/// <li>
/// <p>Storage volumes</p>
/// </li>
/// <li>
/// <p>Virtual tapes</p>
/// </li>
/// <li>
/// <p>NFS and SMB file shares</p>
/// </li>
/// <li>
/// <p>File System associations</p>
/// </li>
/// </ul>
/// <p>You can create a maximum of 50 tags for each resource. Virtual tapes and storage volumes
/// that are recovered to a new gateway maintain their tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddTagsToResource {
    _private: (),
}
impl AddTagsToResource {
    /// Creates a new builder-style object to manufacture [`AddTagsToResourceInput`](crate::input::AddTagsToResourceInput)
    pub fn builder() -> crate::input::add_tags_to_resource_input::Builder {
        crate::input::add_tags_to_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddTagsToResource {
    type Output = std::result::Result<
        crate::output::AddTagsToResourceOutput,
        crate::error::AddTagsToResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_tags_to_resource_error(response)
        } else {
            crate::operation_deser::parse_add_tags_to_resource_response(response)
        }
    }
}

/// <p>Configures one or more gateway local disks as upload buffer for a specified gateway.
/// This operation is supported for the stored volume, cached volume, and tape gateway
/// types.</p>
/// <p>In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to
/// add upload buffer, and one or more disk IDs that you want to configure as upload
/// buffer.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddUploadBuffer {
    _private: (),
}
impl AddUploadBuffer {
    /// Creates a new builder-style object to manufacture [`AddUploadBufferInput`](crate::input::AddUploadBufferInput)
    pub fn builder() -> crate::input::add_upload_buffer_input::Builder {
        crate::input::add_upload_buffer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddUploadBuffer {
    type Output = std::result::Result<
        crate::output::AddUploadBufferOutput,
        crate::error::AddUploadBufferError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_upload_buffer_error(response)
        } else {
            crate::operation_deser::parse_add_upload_buffer_response(response)
        }
    }
}

/// <p>Configures one or more gateway local disks as working storage for a gateway. This
/// operation is only supported in the stored volume gateway type. This operation is deprecated
/// in cached volume API version 20120630. Use <a>AddUploadBuffer</a>
/// instead.</p>
/// <note>
/// <p>Working storage is also referred to as upload buffer. You can also use the <a>AddUploadBuffer</a> operation to add upload buffer to a stored volume
/// gateway.</p>
/// </note>
/// <p>In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to
/// add working storage, and one or more disk IDs that you want to configure as working
/// storage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddWorkingStorage {
    _private: (),
}
impl AddWorkingStorage {
    /// Creates a new builder-style object to manufacture [`AddWorkingStorageInput`](crate::input::AddWorkingStorageInput)
    pub fn builder() -> crate::input::add_working_storage_input::Builder {
        crate::input::add_working_storage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddWorkingStorage {
    type Output = std::result::Result<
        crate::output::AddWorkingStorageOutput,
        crate::error::AddWorkingStorageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_working_storage_error(response)
        } else {
            crate::operation_deser::parse_add_working_storage_response(response)
        }
    }
}

/// <p>Assigns a tape to a tape pool for archiving. The tape assigned to a pool is archived in
/// the S3 storage class that is associated with the pool. When you use your backup application
/// to eject the tape, the tape is archived directly into the S3 storage class (S3 Glacier or
/// S3 Glacier Deep Archive) that corresponds to the pool.</p>
/// <p>Valid Values: <code>GLACIER</code> | <code>DEEP_ARCHIVE</code>
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssignTapePool {
    _private: (),
}
impl AssignTapePool {
    /// Creates a new builder-style object to manufacture [`AssignTapePoolInput`](crate::input::AssignTapePoolInput)
    pub fn builder() -> crate::input::assign_tape_pool_input::Builder {
        crate::input::assign_tape_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssignTapePool {
    type Output =
        std::result::Result<crate::output::AssignTapePoolOutput, crate::error::AssignTapePoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_assign_tape_pool_error(response)
        } else {
            crate::operation_deser::parse_assign_tape_pool_response(response)
        }
    }
}

/// <p>Associate an Amazon FSx file system with the FSx File Gateway. After the
/// association process is complete, the file shares on the Amazon FSx file system are
/// available for access through the gateway. This operation only supports the FSx File
/// Gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateFileSystem {
    _private: (),
}
impl AssociateFileSystem {
    /// Creates a new builder-style object to manufacture [`AssociateFileSystemInput`](crate::input::AssociateFileSystemInput)
    pub fn builder() -> crate::input::associate_file_system_input::Builder {
        crate::input::associate_file_system_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateFileSystem {
    type Output = std::result::Result<
        crate::output::AssociateFileSystemOutput,
        crate::error::AssociateFileSystemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_file_system_error(response)
        } else {
            crate::operation_deser::parse_associate_file_system_response(response)
        }
    }
}

/// <p>Connects a volume to an iSCSI connection and then attaches the volume to the specified
/// gateway. Detaching and attaching a volume enables you to recover your data from one gateway
/// to a different gateway without creating a snapshot. It also makes it easier to move your
/// volumes from an on-premises gateway to a gateway hosted on an Amazon EC2 instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachVolume {
    _private: (),
}
impl AttachVolume {
    /// Creates a new builder-style object to manufacture [`AttachVolumeInput`](crate::input::AttachVolumeInput)
    pub fn builder() -> crate::input::attach_volume_input::Builder {
        crate::input::attach_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachVolume {
    type Output =
        std::result::Result<crate::output::AttachVolumeOutput, crate::error::AttachVolumeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_volume_error(response)
        } else {
            crate::operation_deser::parse_attach_volume_response(response)
        }
    }
}

/// <p>Cancels archiving of a virtual tape to the virtual tape shelf (VTS) after the archiving
/// process is initiated. This operation is only supported in the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelArchival {
    _private: (),
}
impl CancelArchival {
    /// Creates a new builder-style object to manufacture [`CancelArchivalInput`](crate::input::CancelArchivalInput)
    pub fn builder() -> crate::input::cancel_archival_input::Builder {
        crate::input::cancel_archival_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelArchival {
    type Output =
        std::result::Result<crate::output::CancelArchivalOutput, crate::error::CancelArchivalError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_archival_error(response)
        } else {
            crate::operation_deser::parse_cancel_archival_response(response)
        }
    }
}

/// <p>Cancels retrieval of a virtual tape from the virtual tape shelf (VTS) to a gateway after
/// the retrieval process is initiated. The virtual tape is returned to the VTS. This operation
/// is only supported in the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelRetrieval {
    _private: (),
}
impl CancelRetrieval {
    /// Creates a new builder-style object to manufacture [`CancelRetrievalInput`](crate::input::CancelRetrievalInput)
    pub fn builder() -> crate::input::cancel_retrieval_input::Builder {
        crate::input::cancel_retrieval_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelRetrieval {
    type Output = std::result::Result<
        crate::output::CancelRetrievalOutput,
        crate::error::CancelRetrievalError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_retrieval_error(response)
        } else {
            crate::operation_deser::parse_cancel_retrieval_response(response)
        }
    }
}

/// <p>Creates a cached volume on a specified cached volume gateway. This operation is only
/// supported in the cached volume gateway type.</p>
/// <note>
/// <p>Cache storage must be allocated to the gateway before you can create a cached volume.
/// Use the <a>AddCache</a> operation to add cache storage to a gateway.</p>
/// </note>
/// <p>In the request, you must specify the gateway, size of the volume in bytes, the iSCSI
/// target name, an IP address on which to expose the target, and a unique client token. In
/// response, the gateway creates the volume and returns information about it. This information
/// includes the volume Amazon Resource Name (ARN), its size, and the iSCSI target ARN that
/// initiators can use to connect to the volume target.</p>
/// <p>Optionally, you can provide the ARN for an existing volume as the
/// <code>SourceVolumeARN</code> for this cached volume, which creates an exact copy of the
/// existing volume’s latest recovery point. The <code>VolumeSizeInBytes</code> value must be
/// equal to or larger than the size of the copied volume, in bytes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCachediSCSIVolume {
    _private: (),
}
impl CreateCachediSCSIVolume {
    /// Creates a new builder-style object to manufacture [`CreateCachediScsiVolumeInput`](crate::input::CreateCachediScsiVolumeInput)
    pub fn builder() -> crate::input::create_cachedi_scsi_volume_input::Builder {
        crate::input::create_cachedi_scsi_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCachediSCSIVolume {
    type Output = std::result::Result<
        crate::output::CreateCachediScsiVolumeOutput,
        crate::error::CreateCachediSCSIVolumeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_cachedi_scsi_volume_error(response)
        } else {
            crate::operation_deser::parse_create_cachedi_scsi_volume_response(response)
        }
    }
}

/// <p>Creates a Network File System (NFS) file share on an existing S3 File Gateway. In Storage
/// Gateway, a file share is a file system mount point backed by Amazon S3 cloud storage.
/// Storage Gateway exposes file shares using an NFS interface. This operation is only
/// supported for S3 File Gateways.</p>
/// <important>
/// <p>S3 File gateway requires Security Token Service (STS) to be activated to enable
/// you to create a file share. Make sure STS is activated in the Region you are
/// creating your S3 File Gateway in. If STS is not activated in the Region, activate
/// it. For information about how to activate STS, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
/// deactivating STS in an Region</a> in the
/// <i>Identity and Access Management User Guide</i>.</p>
/// <p>S3 File Gateways do not support creating hard or symbolic links on a file share.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateNFSFileShare {
    _private: (),
}
impl CreateNFSFileShare {
    /// Creates a new builder-style object to manufacture [`CreateNfsFileShareInput`](crate::input::CreateNfsFileShareInput)
    pub fn builder() -> crate::input::create_nfs_file_share_input::Builder {
        crate::input::create_nfs_file_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateNFSFileShare {
    type Output = std::result::Result<
        crate::output::CreateNfsFileShareOutput,
        crate::error::CreateNFSFileShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_nfs_file_share_error(response)
        } else {
            crate::operation_deser::parse_create_nfs_file_share_response(response)
        }
    }
}

/// <p>Creates a Server Message Block (SMB) file share on an existing S3 File Gateway. In Storage
/// Gateway, a file share is a file system mount point backed by Amazon S3 cloud storage.
/// Storage Gateway exposes file shares using an SMB interface. This operation is only
/// supported for S3 File Gateways.</p>
/// <important>
/// <p>S3 File Gateways require Security Token Service (STS) to be activated to enable
/// you to create a file share. Make sure that STS is activated in the Region you
/// are creating your S3 File Gateway in. If STS is not activated in this Region,
/// activate it. For information about how to activate STS, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
/// deactivating STS in an Region</a> in the
/// <i>Identity and Access Management User Guide</i>.</p>
/// <p>File gateways don't support creating hard or symbolic links on a file
/// share.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSMBFileShare {
    _private: (),
}
impl CreateSMBFileShare {
    /// Creates a new builder-style object to manufacture [`CreateSmbFileShareInput`](crate::input::CreateSmbFileShareInput)
    pub fn builder() -> crate::input::create_smb_file_share_input::Builder {
        crate::input::create_smb_file_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSMBFileShare {
    type Output = std::result::Result<
        crate::output::CreateSmbFileShareOutput,
        crate::error::CreateSMBFileShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_smb_file_share_error(response)
        } else {
            crate::operation_deser::parse_create_smb_file_share_response(response)
        }
    }
}

/// <p>Initiates a snapshot of a volume.</p>
/// <p>Storage Gateway provides the ability to back up point-in-time snapshots of your data
/// to Amazon Simple Storage (Amazon S3) for durable off-site recovery, and also import the
/// data to an Amazon Elastic Block Store (EBS) volume in Amazon Elastic Compute Cloud (EC2).
/// You can take snapshots of your gateway volume on a scheduled or ad hoc basis. This API
/// enables you to take an ad hoc snapshot. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/managing-volumes.html#SchedulingSnapshot">Editing a
/// snapshot schedule</a>.</p>
/// <p>In the <code>CreateSnapshot</code> request, you identify the volume by providing its
/// Amazon Resource Name (ARN). You must also provide description for the snapshot. When
/// Storage Gateway takes the snapshot of specified volume, the snapshot and description
/// appears in the Storage Gateway console. In response, Storage Gateway returns you a
/// snapshot ID. You can use this snapshot ID to check the snapshot progress or later use it
/// when you want to create a volume from a snapshot. This operation is only supported in
/// stored and cached volume gateway type.</p>
/// <note>
/// <p>To list or delete a snapshot, you must use the Amazon EC2 API. For more information,
/// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html">DescribeSnapshots</a>
/// or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteSnapshot.html">DeleteSnapshot</a> in the <i>Amazon Elastic Compute Cloud API
/// Reference</i>.</p>
/// </note>
/// <important>
/// <p>Volume and snapshot IDs are changing to a longer length ID format. For more
/// information, see the important note on the <a href="https://docs.aws.amazon.com/storagegateway/latest/APIReference/Welcome.html">Welcome</a> page.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSnapshot {
    _private: (),
}
impl CreateSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateSnapshotInput`](crate::input::CreateSnapshotInput)
    pub fn builder() -> crate::input::create_snapshot_input::Builder {
        crate::input::create_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSnapshot {
    type Output =
        std::result::Result<crate::output::CreateSnapshotOutput, crate::error::CreateSnapshotError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_snapshot_error(response)
        } else {
            crate::operation_deser::parse_create_snapshot_response(response)
        }
    }
}

/// <p>Initiates a snapshot of a gateway from a volume recovery point. This operation is only
/// supported in the cached volume gateway type.</p>
/// <p>A volume recovery point is a point in time at which all data of the volume is consistent
/// and from which you can create a snapshot. To get a list of volume recovery point for cached
/// volume gateway, use <a>ListVolumeRecoveryPoints</a>.</p>
/// <p>In the <code>CreateSnapshotFromVolumeRecoveryPoint</code> request, you identify the
/// volume by providing its Amazon Resource Name (ARN). You must also provide a description for
/// the snapshot. When the gateway takes a snapshot of the specified volume, the snapshot and
/// its description appear in the Storage Gateway console.
/// In response, the gateway returns
/// you a snapshot ID. You can use this snapshot ID to check the snapshot progress or later use
/// it when you want to create a volume from a snapshot.</p>
/// <note>
/// <p>To list or delete a snapshot, you must use the Amazon EC2 API. For more information,
/// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html">DescribeSnapshots</a>
/// or <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DeleteSnapshot.html">DeleteSnapshot</a> in the <i>Amazon Elastic Compute Cloud API
/// Reference</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSnapshotFromVolumeRecoveryPoint {
    _private: (),
}
impl CreateSnapshotFromVolumeRecoveryPoint {
    /// Creates a new builder-style object to manufacture [`CreateSnapshotFromVolumeRecoveryPointInput`](crate::input::CreateSnapshotFromVolumeRecoveryPointInput)
    pub fn builder() -> crate::input::create_snapshot_from_volume_recovery_point_input::Builder {
        crate::input::create_snapshot_from_volume_recovery_point_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSnapshotFromVolumeRecoveryPoint {
    type Output = std::result::Result<
        crate::output::CreateSnapshotFromVolumeRecoveryPointOutput,
        crate::error::CreateSnapshotFromVolumeRecoveryPointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_snapshot_from_volume_recovery_point_error(response)
        } else {
            crate::operation_deser::parse_create_snapshot_from_volume_recovery_point_response(
                response,
            )
        }
    }
}

/// <p>Creates a volume on a specified gateway. This operation is only supported in the stored
/// volume gateway type.</p>
/// <p>The size of the volume to create is inferred from the disk size. You can choose to
/// preserve existing data on the disk, create volume from an existing snapshot, or create an
/// empty volume. If you choose to create an empty gateway volume, then any existing data on
/// the disk is erased.</p>
/// <p>In the request, you must specify the gateway and the disk information on which you are
/// creating the volume. In response, the gateway creates the volume and returns volume
/// information such as the volume Amazon Resource Name (ARN), its size, and the iSCSI target
/// ARN that initiators can use to connect to the volume target.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStorediSCSIVolume {
    _private: (),
}
impl CreateStorediSCSIVolume {
    /// Creates a new builder-style object to manufacture [`CreateStorediScsiVolumeInput`](crate::input::CreateStorediScsiVolumeInput)
    pub fn builder() -> crate::input::create_storedi_scsi_volume_input::Builder {
        crate::input::create_storedi_scsi_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStorediSCSIVolume {
    type Output = std::result::Result<
        crate::output::CreateStorediScsiVolumeOutput,
        crate::error::CreateStorediSCSIVolumeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_storedi_scsi_volume_error(response)
        } else {
            crate::operation_deser::parse_create_storedi_scsi_volume_response(response)
        }
    }
}

/// <p>Creates a new custom tape pool. You can use custom tape pool to enable tape retention
/// lock on tapes that are archived in the custom pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTapePool {
    _private: (),
}
impl CreateTapePool {
    /// Creates a new builder-style object to manufacture [`CreateTapePoolInput`](crate::input::CreateTapePoolInput)
    pub fn builder() -> crate::input::create_tape_pool_input::Builder {
        crate::input::create_tape_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTapePool {
    type Output =
        std::result::Result<crate::output::CreateTapePoolOutput, crate::error::CreateTapePoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_tape_pool_error(response)
        } else {
            crate::operation_deser::parse_create_tape_pool_response(response)
        }
    }
}

/// <p>Creates one or more virtual tapes. You write data to the virtual tapes and then archive
/// the tapes. This operation is only supported in the tape gateway type.</p>
/// <note>
/// <p>Cache storage must be allocated to the gateway before you can create virtual tapes.
/// Use the <a>AddCache</a> operation to add cache storage to a gateway.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTapes {
    _private: (),
}
impl CreateTapes {
    /// Creates a new builder-style object to manufacture [`CreateTapesInput`](crate::input::CreateTapesInput)
    pub fn builder() -> crate::input::create_tapes_input::Builder {
        crate::input::create_tapes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTapes {
    type Output =
        std::result::Result<crate::output::CreateTapesOutput, crate::error::CreateTapesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_tapes_error(response)
        } else {
            crate::operation_deser::parse_create_tapes_response(response)
        }
    }
}

/// <p>Creates a virtual tape by using your own barcode. You write data to the virtual tape and
/// then archive the tape. A barcode is unique and cannot be reused if it has already been used
/// on a tape. This applies to barcodes used on deleted tapes. This operation is only supported
/// in the tape gateway type.</p>
/// <note>
/// <p>Cache storage must be allocated to the gateway before you can create a virtual tape.
/// Use the <a>AddCache</a> operation to add cache storage to a gateway.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTapeWithBarcode {
    _private: (),
}
impl CreateTapeWithBarcode {
    /// Creates a new builder-style object to manufacture [`CreateTapeWithBarcodeInput`](crate::input::CreateTapeWithBarcodeInput)
    pub fn builder() -> crate::input::create_tape_with_barcode_input::Builder {
        crate::input::create_tape_with_barcode_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTapeWithBarcode {
    type Output = std::result::Result<
        crate::output::CreateTapeWithBarcodeOutput,
        crate::error::CreateTapeWithBarcodeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_tape_with_barcode_error(response)
        } else {
            crate::operation_deser::parse_create_tape_with_barcode_response(response)
        }
    }
}

/// <p>Deletes the automatic tape creation policy of a gateway. If you delete this policy, new
/// virtual tapes must be created manually. Use the Amazon Resource Name (ARN) of the gateway
/// in your request to remove the policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAutomaticTapeCreationPolicy {
    _private: (),
}
impl DeleteAutomaticTapeCreationPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteAutomaticTapeCreationPolicyInput`](crate::input::DeleteAutomaticTapeCreationPolicyInput)
    pub fn builder() -> crate::input::delete_automatic_tape_creation_policy_input::Builder {
        crate::input::delete_automatic_tape_creation_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAutomaticTapeCreationPolicy {
    type Output = std::result::Result<
        crate::output::DeleteAutomaticTapeCreationPolicyOutput,
        crate::error::DeleteAutomaticTapeCreationPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_automatic_tape_creation_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_automatic_tape_creation_policy_response(response)
        }
    }
}

/// <p>Deletes the bandwidth rate limits of a gateway. You can delete either the upload and
/// download bandwidth rate limit, or you can delete both. If you delete only one of the
/// limits, the other limit remains unchanged. To specify which gateway to work with, use the
/// Amazon Resource Name (ARN) of the gateway in your request. This operation is supported for
/// the stored volume, cached volume and tape gateway types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBandwidthRateLimit {
    _private: (),
}
impl DeleteBandwidthRateLimit {
    /// Creates a new builder-style object to manufacture [`DeleteBandwidthRateLimitInput`](crate::input::DeleteBandwidthRateLimitInput)
    pub fn builder() -> crate::input::delete_bandwidth_rate_limit_input::Builder {
        crate::input::delete_bandwidth_rate_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBandwidthRateLimit {
    type Output = std::result::Result<
        crate::output::DeleteBandwidthRateLimitOutput,
        crate::error::DeleteBandwidthRateLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_bandwidth_rate_limit_error(response)
        } else {
            crate::operation_deser::parse_delete_bandwidth_rate_limit_response(response)
        }
    }
}

/// <p>Deletes Challenge-Handshake Authentication Protocol (CHAP) credentials for a specified
/// iSCSI target and initiator pair. This operation is supported in volume and tape gateway
/// types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteChapCredentials {
    _private: (),
}
impl DeleteChapCredentials {
    /// Creates a new builder-style object to manufacture [`DeleteChapCredentialsInput`](crate::input::DeleteChapCredentialsInput)
    pub fn builder() -> crate::input::delete_chap_credentials_input::Builder {
        crate::input::delete_chap_credentials_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteChapCredentials {
    type Output = std::result::Result<
        crate::output::DeleteChapCredentialsOutput,
        crate::error::DeleteChapCredentialsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_chap_credentials_error(response)
        } else {
            crate::operation_deser::parse_delete_chap_credentials_response(response)
        }
    }
}

/// <p>Deletes a file share from an S3 File Gateway. This operation is only supported for S3 File
/// Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFileShare {
    _private: (),
}
impl DeleteFileShare {
    /// Creates a new builder-style object to manufacture [`DeleteFileShareInput`](crate::input::DeleteFileShareInput)
    pub fn builder() -> crate::input::delete_file_share_input::Builder {
        crate::input::delete_file_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFileShare {
    type Output = std::result::Result<
        crate::output::DeleteFileShareOutput,
        crate::error::DeleteFileShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_file_share_error(response)
        } else {
            crate::operation_deser::parse_delete_file_share_response(response)
        }
    }
}

/// <p>Deletes a gateway. To specify which gateway to delete, use the Amazon Resource Name
/// (ARN) of the gateway in your request. The operation deletes the gateway; however, it does
/// not delete the gateway virtual machine (VM) from your host computer.</p>
/// <p>After you delete a gateway, you cannot reactivate it. Completed snapshots of the gateway
/// volumes are not deleted upon deleting the gateway, however, pending snapshots will not
/// complete. After you delete a gateway, your next step is to remove it from your
/// environment.</p>
/// <important>
/// <p>You no longer pay software charges after the gateway is deleted; however, your
/// existing Amazon EBS snapshots persist and you will continue to be billed for these
/// snapshots. You can choose to remove all remaining Amazon EBS snapshots by canceling your
/// Amazon EC2 subscription.  If you prefer not to cancel your Amazon EC2 subscription, you
/// can delete your snapshots using the Amazon EC2 console. For more information, see the
/// <a href="http://aws.amazon.com/storagegateway">Storage Gateway detail
/// page</a>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteGateway {
    _private: (),
}
impl DeleteGateway {
    /// Creates a new builder-style object to manufacture [`DeleteGatewayInput`](crate::input::DeleteGatewayInput)
    pub fn builder() -> crate::input::delete_gateway_input::Builder {
        crate::input::delete_gateway_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteGateway {
    type Output =
        std::result::Result<crate::output::DeleteGatewayOutput, crate::error::DeleteGatewayError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_gateway_error(response)
        } else {
            crate::operation_deser::parse_delete_gateway_response(response)
        }
    }
}

/// <p>Deletes a snapshot of a volume.</p>
/// <p>You can take snapshots of your gateway volumes on a scheduled or ad hoc basis. This API
/// action enables you to delete a snapshot schedule for a volume. For more information, see
/// <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/backing-up-volumes.html">Backing up your
/// volumes</a>. In the <code>DeleteSnapshotSchedule</code> request, you identify the
/// volume by providing its Amazon Resource Name (ARN). This operation is only supported in
/// stored and cached volume gateway types.</p>
/// <note>
/// <p>To list or delete a snapshot, you must use the Amazon EC2 API. For more information,
/// go to <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSnapshots.html">DescribeSnapshots</a>
/// in the <i>Amazon Elastic Compute Cloud API Reference</i>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSnapshotSchedule {
    _private: (),
}
impl DeleteSnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`DeleteSnapshotScheduleInput`](crate::input::DeleteSnapshotScheduleInput)
    pub fn builder() -> crate::input::delete_snapshot_schedule_input::Builder {
        crate::input::delete_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSnapshotSchedule {
    type Output = std::result::Result<
        crate::output::DeleteSnapshotScheduleOutput,
        crate::error::DeleteSnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_snapshot_schedule_error(response)
        } else {
            crate::operation_deser::parse_delete_snapshot_schedule_response(response)
        }
    }
}

/// <p>Deletes the specified virtual tape. This operation is only supported in the tape gateway
/// type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTape {
    _private: (),
}
impl DeleteTape {
    /// Creates a new builder-style object to manufacture [`DeleteTapeInput`](crate::input::DeleteTapeInput)
    pub fn builder() -> crate::input::delete_tape_input::Builder {
        crate::input::delete_tape_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTape {
    type Output =
        std::result::Result<crate::output::DeleteTapeOutput, crate::error::DeleteTapeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_tape_error(response)
        } else {
            crate::operation_deser::parse_delete_tape_response(response)
        }
    }
}

/// <p>Deletes the specified virtual tape from the virtual tape shelf (VTS). This operation is
/// only supported in the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTapeArchive {
    _private: (),
}
impl DeleteTapeArchive {
    /// Creates a new builder-style object to manufacture [`DeleteTapeArchiveInput`](crate::input::DeleteTapeArchiveInput)
    pub fn builder() -> crate::input::delete_tape_archive_input::Builder {
        crate::input::delete_tape_archive_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTapeArchive {
    type Output = std::result::Result<
        crate::output::DeleteTapeArchiveOutput,
        crate::error::DeleteTapeArchiveError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_tape_archive_error(response)
        } else {
            crate::operation_deser::parse_delete_tape_archive_response(response)
        }
    }
}

/// <p>Delete a custom tape pool. A custom tape pool can only be deleted if there are no tapes
/// in the pool and if there are no automatic tape creation policies that reference the custom
/// tape pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTapePool {
    _private: (),
}
impl DeleteTapePool {
    /// Creates a new builder-style object to manufacture [`DeleteTapePoolInput`](crate::input::DeleteTapePoolInput)
    pub fn builder() -> crate::input::delete_tape_pool_input::Builder {
        crate::input::delete_tape_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTapePool {
    type Output =
        std::result::Result<crate::output::DeleteTapePoolOutput, crate::error::DeleteTapePoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_tape_pool_error(response)
        } else {
            crate::operation_deser::parse_delete_tape_pool_response(response)
        }
    }
}

/// <p>Deletes the specified storage volume that you previously created using the <a>CreateCachediSCSIVolume</a> or <a>CreateStorediSCSIVolume</a> API.
/// This operation is only supported in the cached volume and stored volume types. For stored
/// volume gateways, the local disk that was configured as the storage volume is not deleted.
/// You can reuse the local disk to create another storage volume.</p>
/// <p>Before you delete a volume, make sure there are no iSCSI connections to the volume you
/// are deleting. You should also make sure there is no snapshot in progress. You can use the
/// Amazon Elastic Compute Cloud (Amazon EC2) API to query snapshots on the volume you are
/// deleting and check the snapshot status. For more information, go to <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a> in the <i>Amazon Elastic Compute Cloud API
/// Reference</i>.</p>
/// <p>In the request, you must provide the Amazon Resource Name (ARN) of the storage volume
/// you want to delete.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteVolume {
    _private: (),
}
impl DeleteVolume {
    /// Creates a new builder-style object to manufacture [`DeleteVolumeInput`](crate::input::DeleteVolumeInput)
    pub fn builder() -> crate::input::delete_volume_input::Builder {
        crate::input::delete_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteVolume {
    type Output =
        std::result::Result<crate::output::DeleteVolumeOutput, crate::error::DeleteVolumeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_volume_error(response)
        } else {
            crate::operation_deser::parse_delete_volume_response(response)
        }
    }
}

/// <p>Returns information about the most recent high availability monitoring test that was
/// performed on the host in a cluster. If a test isn't performed, the status and start
/// time in the response would be null.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAvailabilityMonitorTest {
    _private: (),
}
impl DescribeAvailabilityMonitorTest {
    /// Creates a new builder-style object to manufacture [`DescribeAvailabilityMonitorTestInput`](crate::input::DescribeAvailabilityMonitorTestInput)
    pub fn builder() -> crate::input::describe_availability_monitor_test_input::Builder {
        crate::input::describe_availability_monitor_test_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAvailabilityMonitorTest {
    type Output = std::result::Result<
        crate::output::DescribeAvailabilityMonitorTestOutput,
        crate::error::DescribeAvailabilityMonitorTestError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_availability_monitor_test_error(response)
        } else {
            crate::operation_deser::parse_describe_availability_monitor_test_response(response)
        }
    }
}

/// <p>Returns the bandwidth rate limits of a gateway. By default, these limits are not set,
/// which means no bandwidth rate limiting is in effect. This operation is supported for the
/// stored volume, cached volume, and tape gateway types.</p>
/// <p>This operation only returns a value for a bandwidth rate limit only if the limit is set.
/// If no limits are set for the gateway, then this operation returns only the gateway ARN in
/// the response body. To specify which gateway to describe, use the Amazon Resource Name (ARN)
/// of the gateway in your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBandwidthRateLimit {
    _private: (),
}
impl DescribeBandwidthRateLimit {
    /// Creates a new builder-style object to manufacture [`DescribeBandwidthRateLimitInput`](crate::input::DescribeBandwidthRateLimitInput)
    pub fn builder() -> crate::input::describe_bandwidth_rate_limit_input::Builder {
        crate::input::describe_bandwidth_rate_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBandwidthRateLimit {
    type Output = std::result::Result<
        crate::output::DescribeBandwidthRateLimitOutput,
        crate::error::DescribeBandwidthRateLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_bandwidth_rate_limit_error(response)
        } else {
            crate::operation_deser::parse_describe_bandwidth_rate_limit_response(response)
        }
    }
}

/// <p>
/// Returns information about the bandwidth rate limit schedule of a gateway. By default, gateways do
/// not have bandwidth rate limit schedules, which means no bandwidth rate limiting is in effect. This
/// operation is supported only in the volume and tape gateway types.
/// </p>
/// <p>This operation returns information about a gateway's bandwidth rate limit schedule. A bandwidth
/// rate limit schedule consists of one or more bandwidth rate limit intervals. A bandwidth rate limit
/// interval defines a period of time on one or more days of the week, during which bandwidth rate
/// limits are specified for uploading, downloading, or both.
/// </p>
/// <p>
/// A bandwidth rate limit interval consists of one or more days of the week, a start hour and minute,
/// an ending hour and minute, and bandwidth rate limits for uploading and downloading
/// </p>
/// <p>
/// If no bandwidth rate limit schedule intervals are set for the gateway, this operation returns an
/// empty response. To specify which gateway to describe, use the Amazon Resource Name (ARN)
/// of the gateway in your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBandwidthRateLimitSchedule {
    _private: (),
}
impl DescribeBandwidthRateLimitSchedule {
    /// Creates a new builder-style object to manufacture [`DescribeBandwidthRateLimitScheduleInput`](crate::input::DescribeBandwidthRateLimitScheduleInput)
    pub fn builder() -> crate::input::describe_bandwidth_rate_limit_schedule_input::Builder {
        crate::input::describe_bandwidth_rate_limit_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBandwidthRateLimitSchedule {
    type Output = std::result::Result<
        crate::output::DescribeBandwidthRateLimitScheduleOutput,
        crate::error::DescribeBandwidthRateLimitScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_bandwidth_rate_limit_schedule_error(response)
        } else {
            crate::operation_deser::parse_describe_bandwidth_rate_limit_schedule_response(response)
        }
    }
}

/// <p>Returns information about the cache of a gateway. This operation is only supported in
/// the cached volume, tape, and file gateway types.</p>
/// <p>The response includes disk IDs that are configured as cache, and it includes the amount
/// of cache allocated and used.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCache {
    _private: (),
}
impl DescribeCache {
    /// Creates a new builder-style object to manufacture [`DescribeCacheInput`](crate::input::DescribeCacheInput)
    pub fn builder() -> crate::input::describe_cache_input::Builder {
        crate::input::describe_cache_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCache {
    type Output =
        std::result::Result<crate::output::DescribeCacheOutput, crate::error::DescribeCacheError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_cache_error(response)
        } else {
            crate::operation_deser::parse_describe_cache_response(response)
        }
    }
}

/// <p>Returns a description of the gateway volumes specified in the request. This operation is
/// only supported in the cached volume gateway types.</p>
/// <p>The list of gateway volumes in the request must be from one gateway. In the response,
/// Storage Gateway returns volume information sorted by volume Amazon Resource Name
/// (ARN).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeCachediSCSIVolumes {
    _private: (),
}
impl DescribeCachediSCSIVolumes {
    /// Creates a new builder-style object to manufacture [`DescribeCachediScsiVolumesInput`](crate::input::DescribeCachediScsiVolumesInput)
    pub fn builder() -> crate::input::describe_cachedi_scsi_volumes_input::Builder {
        crate::input::describe_cachedi_scsi_volumes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeCachediSCSIVolumes {
    type Output = std::result::Result<
        crate::output::DescribeCachediScsiVolumesOutput,
        crate::error::DescribeCachediSCSIVolumesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_cachedi_scsi_volumes_error(response)
        } else {
            crate::operation_deser::parse_describe_cachedi_scsi_volumes_response(response)
        }
    }
}

/// <p>Returns an array of Challenge-Handshake Authentication Protocol (CHAP) credentials
/// information for a specified iSCSI target, one for each target-initiator pair. This
/// operation is supported in the volume and tape gateway types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeChapCredentials {
    _private: (),
}
impl DescribeChapCredentials {
    /// Creates a new builder-style object to manufacture [`DescribeChapCredentialsInput`](crate::input::DescribeChapCredentialsInput)
    pub fn builder() -> crate::input::describe_chap_credentials_input::Builder {
        crate::input::describe_chap_credentials_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeChapCredentials {
    type Output = std::result::Result<
        crate::output::DescribeChapCredentialsOutput,
        crate::error::DescribeChapCredentialsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_chap_credentials_error(response)
        } else {
            crate::operation_deser::parse_describe_chap_credentials_response(response)
        }
    }
}

/// <p>Gets the file system association information. This operation is only supported for
/// FSx File Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFileSystemAssociations {
    _private: (),
}
impl DescribeFileSystemAssociations {
    /// Creates a new builder-style object to manufacture [`DescribeFileSystemAssociationsInput`](crate::input::DescribeFileSystemAssociationsInput)
    pub fn builder() -> crate::input::describe_file_system_associations_input::Builder {
        crate::input::describe_file_system_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFileSystemAssociations {
    type Output = std::result::Result<
        crate::output::DescribeFileSystemAssociationsOutput,
        crate::error::DescribeFileSystemAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_file_system_associations_error(response)
        } else {
            crate::operation_deser::parse_describe_file_system_associations_response(response)
        }
    }
}

/// <p>Returns metadata about a gateway such as its name, network interfaces, configured time
/// zone, and the state (whether the gateway is running or not). To specify which gateway to
/// describe, use the Amazon Resource Name (ARN) of the gateway in your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeGatewayInformation {
    _private: (),
}
impl DescribeGatewayInformation {
    /// Creates a new builder-style object to manufacture [`DescribeGatewayInformationInput`](crate::input::DescribeGatewayInformationInput)
    pub fn builder() -> crate::input::describe_gateway_information_input::Builder {
        crate::input::describe_gateway_information_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeGatewayInformation {
    type Output = std::result::Result<
        crate::output::DescribeGatewayInformationOutput,
        crate::error::DescribeGatewayInformationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_gateway_information_error(response)
        } else {
            crate::operation_deser::parse_describe_gateway_information_response(response)
        }
    }
}

/// <p>Returns your gateway's weekly maintenance start time including the day and time of
/// the week. Note that values are in terms of the gateway's time zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMaintenanceStartTime {
    _private: (),
}
impl DescribeMaintenanceStartTime {
    /// Creates a new builder-style object to manufacture [`DescribeMaintenanceStartTimeInput`](crate::input::DescribeMaintenanceStartTimeInput)
    pub fn builder() -> crate::input::describe_maintenance_start_time_input::Builder {
        crate::input::describe_maintenance_start_time_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMaintenanceStartTime {
    type Output = std::result::Result<
        crate::output::DescribeMaintenanceStartTimeOutput,
        crate::error::DescribeMaintenanceStartTimeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_maintenance_start_time_error(response)
        } else {
            crate::operation_deser::parse_describe_maintenance_start_time_response(response)
        }
    }
}

/// <p>Gets a description for one or more Network File System (NFS) file shares from an S3 File
/// Gateway. This operation is only supported for S3 File Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeNFSFileShares {
    _private: (),
}
impl DescribeNFSFileShares {
    /// Creates a new builder-style object to manufacture [`DescribeNfsFileSharesInput`](crate::input::DescribeNfsFileSharesInput)
    pub fn builder() -> crate::input::describe_nfs_file_shares_input::Builder {
        crate::input::describe_nfs_file_shares_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeNFSFileShares {
    type Output = std::result::Result<
        crate::output::DescribeNfsFileSharesOutput,
        crate::error::DescribeNFSFileSharesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_nfs_file_shares_error(response)
        } else {
            crate::operation_deser::parse_describe_nfs_file_shares_response(response)
        }
    }
}

/// <p>Gets a description for one or more Server Message Block (SMB) file shares from a S3 File
/// Gateway. This operation is only supported for S3 File Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSMBFileShares {
    _private: (),
}
impl DescribeSMBFileShares {
    /// Creates a new builder-style object to manufacture [`DescribeSmbFileSharesInput`](crate::input::DescribeSmbFileSharesInput)
    pub fn builder() -> crate::input::describe_smb_file_shares_input::Builder {
        crate::input::describe_smb_file_shares_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSMBFileShares {
    type Output = std::result::Result<
        crate::output::DescribeSmbFileSharesOutput,
        crate::error::DescribeSMBFileSharesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_smb_file_shares_error(response)
        } else {
            crate::operation_deser::parse_describe_smb_file_shares_response(response)
        }
    }
}

/// <p>Gets a description of a Server Message Block (SMB) file share settings from a file
/// gateway. This operation is only supported for file gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSMBSettings {
    _private: (),
}
impl DescribeSMBSettings {
    /// Creates a new builder-style object to manufacture [`DescribeSmbSettingsInput`](crate::input::DescribeSmbSettingsInput)
    pub fn builder() -> crate::input::describe_smb_settings_input::Builder {
        crate::input::describe_smb_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSMBSettings {
    type Output = std::result::Result<
        crate::output::DescribeSmbSettingsOutput,
        crate::error::DescribeSMBSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_smb_settings_error(response)
        } else {
            crate::operation_deser::parse_describe_smb_settings_response(response)
        }
    }
}

/// <p>Describes the snapshot schedule for the specified gateway volume. The snapshot schedule
/// information includes intervals at which snapshots are automatically initiated on the
/// volume. This operation is only supported in the cached volume and stored volume
/// types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSnapshotSchedule {
    _private: (),
}
impl DescribeSnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`DescribeSnapshotScheduleInput`](crate::input::DescribeSnapshotScheduleInput)
    pub fn builder() -> crate::input::describe_snapshot_schedule_input::Builder {
        crate::input::describe_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSnapshotSchedule {
    type Output = std::result::Result<
        crate::output::DescribeSnapshotScheduleOutput,
        crate::error::DescribeSnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_snapshot_schedule_error(response)
        } else {
            crate::operation_deser::parse_describe_snapshot_schedule_response(response)
        }
    }
}

/// <p>Returns the description of the gateway volumes specified in the request. The list of
/// gateway volumes in the request must be from one gateway. In the response, Storage Gateway returns volume information sorted by volume ARNs. This operation is only supported
/// in stored volume gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStorediSCSIVolumes {
    _private: (),
}
impl DescribeStorediSCSIVolumes {
    /// Creates a new builder-style object to manufacture [`DescribeStorediScsiVolumesInput`](crate::input::DescribeStorediScsiVolumesInput)
    pub fn builder() -> crate::input::describe_storedi_scsi_volumes_input::Builder {
        crate::input::describe_storedi_scsi_volumes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStorediSCSIVolumes {
    type Output = std::result::Result<
        crate::output::DescribeStorediScsiVolumesOutput,
        crate::error::DescribeStorediSCSIVolumesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_storedi_scsi_volumes_error(response)
        } else {
            crate::operation_deser::parse_describe_storedi_scsi_volumes_response(response)
        }
    }
}

/// <p>Returns a description of specified virtual tapes in the virtual tape shelf (VTS). This
/// operation is only supported in the tape gateway type.</p>
/// <p>If a specific <code>TapeARN</code> is not specified, Storage Gateway returns a
/// description of all virtual tapes found in the VTS associated with your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTapeArchives {
    _private: (),
}
impl DescribeTapeArchives {
    /// Creates a new builder-style object to manufacture [`DescribeTapeArchivesInput`](crate::input::DescribeTapeArchivesInput)
    pub fn builder() -> crate::input::describe_tape_archives_input::Builder {
        crate::input::describe_tape_archives_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTapeArchives {
    type Output = std::result::Result<
        crate::output::DescribeTapeArchivesOutput,
        crate::error::DescribeTapeArchivesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_tape_archives_error(response)
        } else {
            crate::operation_deser::parse_describe_tape_archives_response(response)
        }
    }
}

/// <p>Returns a list of virtual tape recovery points that are available for the specified tape
/// gateway.</p>
/// <p>A recovery point is a point-in-time view of a virtual tape at which all the data on the
/// virtual tape is consistent. If your gateway crashes, virtual tapes that have recovery
/// points can be recovered to a new gateway. This operation is only supported in the tape
/// gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTapeRecoveryPoints {
    _private: (),
}
impl DescribeTapeRecoveryPoints {
    /// Creates a new builder-style object to manufacture [`DescribeTapeRecoveryPointsInput`](crate::input::DescribeTapeRecoveryPointsInput)
    pub fn builder() -> crate::input::describe_tape_recovery_points_input::Builder {
        crate::input::describe_tape_recovery_points_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTapeRecoveryPoints {
    type Output = std::result::Result<
        crate::output::DescribeTapeRecoveryPointsOutput,
        crate::error::DescribeTapeRecoveryPointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_tape_recovery_points_error(response)
        } else {
            crate::operation_deser::parse_describe_tape_recovery_points_response(response)
        }
    }
}

/// <p>Returns a description of the specified Amazon Resource Name (ARN) of virtual tapes. If a
/// <code>TapeARN</code> is not specified, returns a description of all virtual tapes
/// associated with the specified gateway. This operation is only supported in the tape gateway
/// type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTapes {
    _private: (),
}
impl DescribeTapes {
    /// Creates a new builder-style object to manufacture [`DescribeTapesInput`](crate::input::DescribeTapesInput)
    pub fn builder() -> crate::input::describe_tapes_input::Builder {
        crate::input::describe_tapes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTapes {
    type Output =
        std::result::Result<crate::output::DescribeTapesOutput, crate::error::DescribeTapesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_tapes_error(response)
        } else {
            crate::operation_deser::parse_describe_tapes_response(response)
        }
    }
}

/// <p>Returns information about the upload buffer of a gateway. This operation is supported
/// for the stored volume, cached volume, and tape gateway types.</p>
/// <p>The response includes disk IDs that are configured as upload buffer space, and it
/// includes the amount of upload buffer space allocated and used.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUploadBuffer {
    _private: (),
}
impl DescribeUploadBuffer {
    /// Creates a new builder-style object to manufacture [`DescribeUploadBufferInput`](crate::input::DescribeUploadBufferInput)
    pub fn builder() -> crate::input::describe_upload_buffer_input::Builder {
        crate::input::describe_upload_buffer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUploadBuffer {
    type Output = std::result::Result<
        crate::output::DescribeUploadBufferOutput,
        crate::error::DescribeUploadBufferError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_upload_buffer_error(response)
        } else {
            crate::operation_deser::parse_describe_upload_buffer_response(response)
        }
    }
}

/// <p>Returns a description of virtual tape library (VTL) devices for the specified tape
/// gateway. In the response, Storage Gateway returns VTL device information.</p>
/// <p>This operation is only supported in the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeVTLDevices {
    _private: (),
}
impl DescribeVTLDevices {
    /// Creates a new builder-style object to manufacture [`DescribeVtlDevicesInput`](crate::input::DescribeVtlDevicesInput)
    pub fn builder() -> crate::input::describe_vtl_devices_input::Builder {
        crate::input::describe_vtl_devices_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeVTLDevices {
    type Output = std::result::Result<
        crate::output::DescribeVtlDevicesOutput,
        crate::error::DescribeVTLDevicesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_vtl_devices_error(response)
        } else {
            crate::operation_deser::parse_describe_vtl_devices_response(response)
        }
    }
}

/// <p>Returns information about the working storage of a gateway. This operation is only
/// supported in the stored volumes gateway type. This operation is deprecated in cached
/// volumes API version (20120630). Use DescribeUploadBuffer instead.</p>
/// <note>
/// <p>Working storage is also referred to as upload buffer. You can also use the
/// DescribeUploadBuffer operation to add upload buffer to a stored volume gateway.</p>
/// </note>
/// <p>The response includes disk IDs that are configured as working storage, and it includes
/// the amount of working storage allocated and used.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkingStorage {
    _private: (),
}
impl DescribeWorkingStorage {
    /// Creates a new builder-style object to manufacture [`DescribeWorkingStorageInput`](crate::input::DescribeWorkingStorageInput)
    pub fn builder() -> crate::input::describe_working_storage_input::Builder {
        crate::input::describe_working_storage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkingStorage {
    type Output = std::result::Result<
        crate::output::DescribeWorkingStorageOutput,
        crate::error::DescribeWorkingStorageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_working_storage_error(response)
        } else {
            crate::operation_deser::parse_describe_working_storage_response(response)
        }
    }
}

/// <p>Disconnects a volume from an iSCSI connection and then detaches the volume from the
/// specified gateway. Detaching and attaching a volume enables you to recover your data from
/// one gateway to a different gateway without creating a snapshot. It also makes it easier to
/// move your volumes from an on-premises gateway to a gateway hosted on an Amazon EC2
/// instance. This operation is only supported in the volume gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachVolume {
    _private: (),
}
impl DetachVolume {
    /// Creates a new builder-style object to manufacture [`DetachVolumeInput`](crate::input::DetachVolumeInput)
    pub fn builder() -> crate::input::detach_volume_input::Builder {
        crate::input::detach_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachVolume {
    type Output =
        std::result::Result<crate::output::DetachVolumeOutput, crate::error::DetachVolumeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_volume_error(response)
        } else {
            crate::operation_deser::parse_detach_volume_response(response)
        }
    }
}

/// <p>Disables a tape gateway when the gateway is no longer functioning. For example, if your
/// gateway VM is damaged, you can disable the gateway so you can recover virtual tapes.</p>
/// <p>Use this operation for a tape gateway that is not reachable or not functioning. This
/// operation is only supported in the tape gateway type.</p>
/// <important>
/// <p>After a gateway is disabled, it cannot be enabled.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableGateway {
    _private: (),
}
impl DisableGateway {
    /// Creates a new builder-style object to manufacture [`DisableGatewayInput`](crate::input::DisableGatewayInput)
    pub fn builder() -> crate::input::disable_gateway_input::Builder {
        crate::input::disable_gateway_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableGateway {
    type Output =
        std::result::Result<crate::output::DisableGatewayOutput, crate::error::DisableGatewayError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_gateway_error(response)
        } else {
            crate::operation_deser::parse_disable_gateway_response(response)
        }
    }
}

/// <p>Disassociates an Amazon FSx file system from the specified gateway. After the
/// disassociation process finishes, the gateway can no longer access the Amazon FSx file
/// system. This operation is only supported in the FSx File Gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateFileSystem {
    _private: (),
}
impl DisassociateFileSystem {
    /// Creates a new builder-style object to manufacture [`DisassociateFileSystemInput`](crate::input::DisassociateFileSystemInput)
    pub fn builder() -> crate::input::disassociate_file_system_input::Builder {
        crate::input::disassociate_file_system_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateFileSystem {
    type Output = std::result::Result<
        crate::output::DisassociateFileSystemOutput,
        crate::error::DisassociateFileSystemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_file_system_error(response)
        } else {
            crate::operation_deser::parse_disassociate_file_system_response(response)
        }
    }
}

/// <p>Adds a file gateway to an Active Directory domain. This operation is only supported for
/// file gateways that support the SMB file protocol.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct JoinDomain {
    _private: (),
}
impl JoinDomain {
    /// Creates a new builder-style object to manufacture [`JoinDomainInput`](crate::input::JoinDomainInput)
    pub fn builder() -> crate::input::join_domain_input::Builder {
        crate::input::join_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for JoinDomain {
    type Output =
        std::result::Result<crate::output::JoinDomainOutput, crate::error::JoinDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_join_domain_error(response)
        } else {
            crate::operation_deser::parse_join_domain_response(response)
        }
    }
}

/// <p>Lists the automatic tape creation policies for a gateway. If there are no automatic tape
/// creation policies for the gateway, it returns an empty list.</p>
/// <p>This operation is only supported for tape gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAutomaticTapeCreationPolicies {
    _private: (),
}
impl ListAutomaticTapeCreationPolicies {
    /// Creates a new builder-style object to manufacture [`ListAutomaticTapeCreationPoliciesInput`](crate::input::ListAutomaticTapeCreationPoliciesInput)
    pub fn builder() -> crate::input::list_automatic_tape_creation_policies_input::Builder {
        crate::input::list_automatic_tape_creation_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAutomaticTapeCreationPolicies {
    type Output = std::result::Result<
        crate::output::ListAutomaticTapeCreationPoliciesOutput,
        crate::error::ListAutomaticTapeCreationPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_automatic_tape_creation_policies_error(response)
        } else {
            crate::operation_deser::parse_list_automatic_tape_creation_policies_response(response)
        }
    }
}

/// <p>Gets a list of the file shares for a specific S3 File Gateway, or the list of file shares
/// that belong to the calling user account. This operation is only supported for S3 File Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFileShares {
    _private: (),
}
impl ListFileShares {
    /// Creates a new builder-style object to manufacture [`ListFileSharesInput`](crate::input::ListFileSharesInput)
    pub fn builder() -> crate::input::list_file_shares_input::Builder {
        crate::input::list_file_shares_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFileShares {
    type Output =
        std::result::Result<crate::output::ListFileSharesOutput, crate::error::ListFileSharesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_file_shares_error(response)
        } else {
            crate::operation_deser::parse_list_file_shares_response(response)
        }
    }
}

/// <p>Gets a list of <code>FileSystemAssociationSummary</code> objects. Each object contains a
/// summary of a file system association. This operation is only supported for FSx File
/// Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFileSystemAssociations {
    _private: (),
}
impl ListFileSystemAssociations {
    /// Creates a new builder-style object to manufacture [`ListFileSystemAssociationsInput`](crate::input::ListFileSystemAssociationsInput)
    pub fn builder() -> crate::input::list_file_system_associations_input::Builder {
        crate::input::list_file_system_associations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFileSystemAssociations {
    type Output = std::result::Result<
        crate::output::ListFileSystemAssociationsOutput,
        crate::error::ListFileSystemAssociationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_file_system_associations_error(response)
        } else {
            crate::operation_deser::parse_list_file_system_associations_response(response)
        }
    }
}

/// <p>Lists gateways owned by an account in an Region specified in the request. The
/// returned list is ordered by gateway Amazon Resource Name (ARN).</p>
/// <p>By default, the operation returns a maximum of 100 gateways. This operation supports
/// pagination that allows you to optionally reduce the number of gateways returned in a
/// response.</p>
/// <p>If you have more gateways than are returned in a response (that is, the response returns
/// only a truncated list of your gateways), the response contains a marker that you can
/// specify in your next request to fetch the next page of gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGateways {
    _private: (),
}
impl ListGateways {
    /// Creates a new builder-style object to manufacture [`ListGatewaysInput`](crate::input::ListGatewaysInput)
    pub fn builder() -> crate::input::list_gateways_input::Builder {
        crate::input::list_gateways_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGateways {
    type Output =
        std::result::Result<crate::output::ListGatewaysOutput, crate::error::ListGatewaysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_gateways_error(response)
        } else {
            crate::operation_deser::parse_list_gateways_response(response)
        }
    }
}

/// <p>Returns a list of the gateway's local disks. To specify which gateway to describe,
/// you use the Amazon Resource Name (ARN) of the gateway in the body of the request.</p>
/// <p>The request returns a list of all disks, specifying which are configured as working
/// storage, cache storage, or stored volume or not configured at all. The response includes a
/// <code>DiskStatus</code> field. This field can have a value of present (the disk is
/// available to use), missing (the disk is no longer connected to the gateway), or mismatch
/// (the disk node is occupied by a disk that has incorrect metadata or the disk content is
/// corrupted).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListLocalDisks {
    _private: (),
}
impl ListLocalDisks {
    /// Creates a new builder-style object to manufacture [`ListLocalDisksInput`](crate::input::ListLocalDisksInput)
    pub fn builder() -> crate::input::list_local_disks_input::Builder {
        crate::input::list_local_disks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListLocalDisks {
    type Output =
        std::result::Result<crate::output::ListLocalDisksOutput, crate::error::ListLocalDisksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_local_disks_error(response)
        } else {
            crate::operation_deser::parse_list_local_disks_response(response)
        }
    }
}

/// <p>Lists the tags that have been added to the specified resource. This operation is
/// supported in storage gateways of all types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists custom tape pools. You specify custom tape pools to list by specifying one or more
/// custom tape pool Amazon Resource Names (ARNs). If you don't specify a custom tape pool ARN,
/// the operation lists all custom tape pools.</p>
/// <p>This operation supports pagination. You can optionally specify the <code>Limit</code>
/// parameter in the body to limit the number of tape pools in the response. If the number of
/// tape pools returned in the response is truncated, the response includes a
/// <code>Marker</code> element that you can use in your subsequent request to retrieve the
/// next set of tape pools.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTapePools {
    _private: (),
}
impl ListTapePools {
    /// Creates a new builder-style object to manufacture [`ListTapePoolsInput`](crate::input::ListTapePoolsInput)
    pub fn builder() -> crate::input::list_tape_pools_input::Builder {
        crate::input::list_tape_pools_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTapePools {
    type Output =
        std::result::Result<crate::output::ListTapePoolsOutput, crate::error::ListTapePoolsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tape_pools_error(response)
        } else {
            crate::operation_deser::parse_list_tape_pools_response(response)
        }
    }
}

/// <p>Lists virtual tapes in your virtual tape library (VTL) and your virtual tape shelf
/// (VTS). You specify the tapes to list by specifying one or more tape Amazon Resource Names
/// (ARNs). If you don't specify a tape ARN, the operation lists all virtual tapes in both
/// your VTL and VTS.</p>
/// <p>This operation supports pagination. By default, the operation returns a maximum of up to
/// 100 tapes. You can optionally specify the <code>Limit</code> parameter in the body to limit
/// the number of tapes in the response. If the number of tapes returned in the response is
/// truncated, the response includes a <code>Marker</code> element that you can use in your
/// subsequent request to retrieve the next set of tapes. This operation is only supported in
/// the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTapes {
    _private: (),
}
impl ListTapes {
    /// Creates a new builder-style object to manufacture [`ListTapesInput`](crate::input::ListTapesInput)
    pub fn builder() -> crate::input::list_tapes_input::Builder {
        crate::input::list_tapes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTapes {
    type Output = std::result::Result<crate::output::ListTapesOutput, crate::error::ListTapesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tapes_error(response)
        } else {
            crate::operation_deser::parse_list_tapes_response(response)
        }
    }
}

/// <p>Lists iSCSI initiators that are connected to a volume. You can use this operation to
/// determine whether a volume is being used or not. This operation is only supported in the
/// cached volume and stored volume gateway types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVolumeInitiators {
    _private: (),
}
impl ListVolumeInitiators {
    /// Creates a new builder-style object to manufacture [`ListVolumeInitiatorsInput`](crate::input::ListVolumeInitiatorsInput)
    pub fn builder() -> crate::input::list_volume_initiators_input::Builder {
        crate::input::list_volume_initiators_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVolumeInitiators {
    type Output = std::result::Result<
        crate::output::ListVolumeInitiatorsOutput,
        crate::error::ListVolumeInitiatorsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_volume_initiators_error(response)
        } else {
            crate::operation_deser::parse_list_volume_initiators_response(response)
        }
    }
}

/// <p>Lists the recovery points for a specified gateway. This operation is only supported in
/// the cached volume gateway type.</p>
/// <p>Each cache volume has one recovery point. A volume recovery point is a point in time at
/// which all data of the volume is consistent and from which you can create a snapshot or
/// clone a new cached volume from a source volume. To create a snapshot from a volume recovery
/// point use the <a>CreateSnapshotFromVolumeRecoveryPoint</a> operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVolumeRecoveryPoints {
    _private: (),
}
impl ListVolumeRecoveryPoints {
    /// Creates a new builder-style object to manufacture [`ListVolumeRecoveryPointsInput`](crate::input::ListVolumeRecoveryPointsInput)
    pub fn builder() -> crate::input::list_volume_recovery_points_input::Builder {
        crate::input::list_volume_recovery_points_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVolumeRecoveryPoints {
    type Output = std::result::Result<
        crate::output::ListVolumeRecoveryPointsOutput,
        crate::error::ListVolumeRecoveryPointsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_volume_recovery_points_error(response)
        } else {
            crate::operation_deser::parse_list_volume_recovery_points_response(response)
        }
    }
}

/// <p>Lists the iSCSI stored volumes of a gateway. Results are sorted by volume ARN. The
/// response includes only the volume ARNs. If you want additional volume information, use the
/// <a>DescribeStorediSCSIVolumes</a> or the <a>DescribeCachediSCSIVolumes</a> API.</p>
/// <p>The operation supports pagination. By default, the operation returns a maximum of up to
/// 100 volumes. You can optionally specify the <code>Limit</code> field in the body to limit
/// the number of volumes in the response. If the number of volumes returned in the response is
/// truncated, the response includes a Marker field. You can use this Marker value in your
/// subsequent request to retrieve the next set of volumes. This operation is only supported in
/// the cached volume and stored volume gateway types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListVolumes {
    _private: (),
}
impl ListVolumes {
    /// Creates a new builder-style object to manufacture [`ListVolumesInput`](crate::input::ListVolumesInput)
    pub fn builder() -> crate::input::list_volumes_input::Builder {
        crate::input::list_volumes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListVolumes {
    type Output =
        std::result::Result<crate::output::ListVolumesOutput, crate::error::ListVolumesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_volumes_error(response)
        } else {
            crate::operation_deser::parse_list_volumes_response(response)
        }
    }
}

/// <p>Sends you notification through CloudWatch Events when all files written to your file
/// share have been uploaded to Amazon S3.</p>
/// <p>Storage Gateway can send a notification through Amazon CloudWatch Events when all
/// files written to your file share up to that point in time have been uploaded to Amazon S3.
/// These files include files written to the file share up to the time that you make a request
/// for notification. When the upload is done, Storage Gateway sends you notification through
/// an Amazon CloudWatch Event. You can configure CloudWatch Events to send the notification
/// through event targets such as Amazon SNS or Lambda function.
/// This operation is only supported for S3 File Gateways.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-upload-notification">Getting file upload notification</a> in the <i>Storage Gateway User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct NotifyWhenUploaded {
    _private: (),
}
impl NotifyWhenUploaded {
    /// Creates a new builder-style object to manufacture [`NotifyWhenUploadedInput`](crate::input::NotifyWhenUploadedInput)
    pub fn builder() -> crate::input::notify_when_uploaded_input::Builder {
        crate::input::notify_when_uploaded_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for NotifyWhenUploaded {
    type Output = std::result::Result<
        crate::output::NotifyWhenUploadedOutput,
        crate::error::NotifyWhenUploadedError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_notify_when_uploaded_error(response)
        } else {
            crate::operation_deser::parse_notify_when_uploaded_response(response)
        }
    }
}

/// <p>Refreshes the cached inventory of objects for the specified file share. This operation
/// finds objects in the Amazon S3 bucket that were added, removed, or replaced since the
/// gateway last listed the bucket's contents and cached the results. This operation does
/// not import files into the S3 File Gateway cache storage. It only updates the cached inventory
/// to reflect changes in the inventory of the objects in the S3 bucket. This operation is only
/// supported in the S3 File Gateway types.</p>
/// <p>You can subscribe to be notified through an Amazon
/// CloudWatch event when your <code>RefreshCache</code> operation completes. For more
/// information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-notification">Getting notified about file operations</a> in the <i>Storage Gateway
/// User Guide</i>. This operation is Only supported for S3 File Gateways.</p>
/// <p>When this API is called, it only initiates the refresh operation. When the API call
/// completes and returns a success code, it doesn't necessarily mean that the file
/// refresh has completed. You should use the refresh-complete notification to determine that
/// the operation has completed before you check for new files on the gateway file share. You
/// can subscribe to be notified through a CloudWatch event when your <code>RefreshCache</code>
/// operation completes.</p>
/// <p>Throttle limit: This API is asynchronous, so the gateway will accept no more than two
/// refreshes at any time. We recommend using the refresh-complete CloudWatch event
/// notification before issuing additional requests. For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-notification">Getting notified about file operations</a> in the <i>Storage Gateway
/// User Guide</i>.</p>
/// <p>If you invoke the RefreshCache API when two requests are already being processed, any
/// new request will cause an <code>InvalidGatewayRequestException</code> error because too
/// many requests were sent to the server.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/monitoring-file-gateway.html#get-notification">Getting notified about file operations</a> in the <i>Storage Gateway
/// User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RefreshCache {
    _private: (),
}
impl RefreshCache {
    /// Creates a new builder-style object to manufacture [`RefreshCacheInput`](crate::input::RefreshCacheInput)
    pub fn builder() -> crate::input::refresh_cache_input::Builder {
        crate::input::refresh_cache_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RefreshCache {
    type Output =
        std::result::Result<crate::output::RefreshCacheOutput, crate::error::RefreshCacheError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_refresh_cache_error(response)
        } else {
            crate::operation_deser::parse_refresh_cache_response(response)
        }
    }
}

/// <p>Removes one or more tags from the specified resource. This operation is supported in
/// storage gateways of all types.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveTagsFromResource {
    _private: (),
}
impl RemoveTagsFromResource {
    /// Creates a new builder-style object to manufacture [`RemoveTagsFromResourceInput`](crate::input::RemoveTagsFromResourceInput)
    pub fn builder() -> crate::input::remove_tags_from_resource_input::Builder {
        crate::input::remove_tags_from_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveTagsFromResource {
    type Output = std::result::Result<
        crate::output::RemoveTagsFromResourceOutput,
        crate::error::RemoveTagsFromResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_tags_from_resource_error(response)
        } else {
            crate::operation_deser::parse_remove_tags_from_resource_response(response)
        }
    }
}

/// <p>Resets all cache disks that have encountered an error and makes the disks available for
/// reconfiguration as cache storage. If your cache disk encounters an error, the gateway
/// prevents read and write operations on virtual tapes in the gateway. For example, an error
/// can occur when a disk is corrupted or removed from the gateway. When a cache is reset, the
/// gateway loses its cache storage. At this point, you can reconfigure the disks as cache
/// disks. This operation is only supported in the cached volume and tape types.</p>
/// <important>
/// <p>If the cache disk you are resetting contains data that has not been uploaded to
/// Amazon S3 yet, that data can be lost. After you reset cache disks, there will be no
/// configured cache disks left in the gateway, so you must configure at least one new cache
/// disk for your gateway to function properly.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResetCache {
    _private: (),
}
impl ResetCache {
    /// Creates a new builder-style object to manufacture [`ResetCacheInput`](crate::input::ResetCacheInput)
    pub fn builder() -> crate::input::reset_cache_input::Builder {
        crate::input::reset_cache_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResetCache {
    type Output =
        std::result::Result<crate::output::ResetCacheOutput, crate::error::ResetCacheError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reset_cache_error(response)
        } else {
            crate::operation_deser::parse_reset_cache_response(response)
        }
    }
}

/// <p>Retrieves an archived virtual tape from the virtual tape shelf (VTS) to a tape gateway.
/// Virtual tapes archived in the VTS are not associated with any gateway. However after a tape
/// is retrieved, it is associated with a gateway, even though it is also listed in the VTS,
/// that is, archive. This operation is only supported in the tape gateway type.</p>
/// <p>Once a tape is successfully retrieved to a gateway, it cannot be retrieved again to
/// another gateway. You must archive the tape again before you can retrieve it to another
/// gateway. This operation is only supported in the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RetrieveTapeArchive {
    _private: (),
}
impl RetrieveTapeArchive {
    /// Creates a new builder-style object to manufacture [`RetrieveTapeArchiveInput`](crate::input::RetrieveTapeArchiveInput)
    pub fn builder() -> crate::input::retrieve_tape_archive_input::Builder {
        crate::input::retrieve_tape_archive_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RetrieveTapeArchive {
    type Output = std::result::Result<
        crate::output::RetrieveTapeArchiveOutput,
        crate::error::RetrieveTapeArchiveError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_retrieve_tape_archive_error(response)
        } else {
            crate::operation_deser::parse_retrieve_tape_archive_response(response)
        }
    }
}

/// <p>Retrieves the recovery point for the specified virtual tape. This operation is only
/// supported in the tape gateway type.</p>
/// <p>A recovery point is a point in time view of a virtual tape at which all the data on the
/// tape is consistent. If your gateway crashes, virtual tapes that have recovery points can be
/// recovered to a new gateway.</p>
/// <note>
/// <p>The virtual tape can be retrieved to only one gateway. The retrieved tape is
/// read-only. The virtual tape can be retrieved to only a tape gateway. There is no charge
/// for retrieving recovery points.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RetrieveTapeRecoveryPoint {
    _private: (),
}
impl RetrieveTapeRecoveryPoint {
    /// Creates a new builder-style object to manufacture [`RetrieveTapeRecoveryPointInput`](crate::input::RetrieveTapeRecoveryPointInput)
    pub fn builder() -> crate::input::retrieve_tape_recovery_point_input::Builder {
        crate::input::retrieve_tape_recovery_point_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RetrieveTapeRecoveryPoint {
    type Output = std::result::Result<
        crate::output::RetrieveTapeRecoveryPointOutput,
        crate::error::RetrieveTapeRecoveryPointError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_retrieve_tape_recovery_point_error(response)
        } else {
            crate::operation_deser::parse_retrieve_tape_recovery_point_response(response)
        }
    }
}

/// <p>Sets the password for your VM local console. When you log in to the local console for
/// the first time, you log in to the VM with the default credentials. We recommend that you
/// set a new password. You don't need to know the default password to set a new
/// password.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetLocalConsolePassword {
    _private: (),
}
impl SetLocalConsolePassword {
    /// Creates a new builder-style object to manufacture [`SetLocalConsolePasswordInput`](crate::input::SetLocalConsolePasswordInput)
    pub fn builder() -> crate::input::set_local_console_password_input::Builder {
        crate::input::set_local_console_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetLocalConsolePassword {
    type Output = std::result::Result<
        crate::output::SetLocalConsolePasswordOutput,
        crate::error::SetLocalConsolePasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_local_console_password_error(response)
        } else {
            crate::operation_deser::parse_set_local_console_password_response(response)
        }
    }
}

/// <p>Sets the password for the guest user <code>smbguest</code>. The <code>smbguest</code>
/// user is the user when the authentication method for the file share is set to
/// <code>GuestAccess</code>. This operation only supported for S3 File Gateways</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetSMBGuestPassword {
    _private: (),
}
impl SetSMBGuestPassword {
    /// Creates a new builder-style object to manufacture [`SetSmbGuestPasswordInput`](crate::input::SetSmbGuestPasswordInput)
    pub fn builder() -> crate::input::set_smb_guest_password_input::Builder {
        crate::input::set_smb_guest_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetSMBGuestPassword {
    type Output = std::result::Result<
        crate::output::SetSmbGuestPasswordOutput,
        crate::error::SetSMBGuestPasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_smb_guest_password_error(response)
        } else {
            crate::operation_deser::parse_set_smb_guest_password_response(response)
        }
    }
}

/// <p>Shuts down a gateway. To specify which gateway to shut down, use the Amazon Resource
/// Name (ARN) of the gateway in the body of your request.</p>
/// <p>The operation shuts down the gateway service component running in the gateway's
/// virtual machine (VM) and not the host VM.</p>
/// <note>
/// <p>If you want to shut down the VM, it is recommended that you first shut down the
/// gateway component in the VM to avoid unpredictable conditions.</p>
/// </note>
/// <p>After the gateway is shutdown, you cannot call any other API except <a>StartGateway</a>, <a>DescribeGatewayInformation</a>, and <a>ListGateways</a>. For more information, see <a>ActivateGateway</a>.
/// Your applications cannot read from or write to the gateway's storage volumes, and
/// there are no snapshots taken.</p>
/// <note>
/// <p>When you make a shutdown request, you will get a <code>200 OK</code> success response
/// immediately. However, it might take some time for the gateway to shut down. You can call
/// the <a>DescribeGatewayInformation</a> API to check the status. For more
/// information, see <a>ActivateGateway</a>.</p>
/// </note>
/// <p>If do not intend to use the gateway again, you must delete the gateway (using <a>DeleteGateway</a>) to no longer pay software charges associated with the
/// gateway.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ShutdownGateway {
    _private: (),
}
impl ShutdownGateway {
    /// Creates a new builder-style object to manufacture [`ShutdownGatewayInput`](crate::input::ShutdownGatewayInput)
    pub fn builder() -> crate::input::shutdown_gateway_input::Builder {
        crate::input::shutdown_gateway_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ShutdownGateway {
    type Output = std::result::Result<
        crate::output::ShutdownGatewayOutput,
        crate::error::ShutdownGatewayError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_shutdown_gateway_error(response)
        } else {
            crate::operation_deser::parse_shutdown_gateway_response(response)
        }
    }
}

/// <p>Start a test that verifies that the specified gateway is configured for High
/// Availability monitoring in your host environment. This request only initiates the test and
/// that a successful response only indicates that the test was started. It doesn't
/// indicate that the test passed. For the status of the test, invoke the
/// <code>DescribeAvailabilityMonitorTest</code> API.</p>
/// <note>
/// <p>Starting this test will cause your gateway to go offline for a brief period.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartAvailabilityMonitorTest {
    _private: (),
}
impl StartAvailabilityMonitorTest {
    /// Creates a new builder-style object to manufacture [`StartAvailabilityMonitorTestInput`](crate::input::StartAvailabilityMonitorTestInput)
    pub fn builder() -> crate::input::start_availability_monitor_test_input::Builder {
        crate::input::start_availability_monitor_test_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartAvailabilityMonitorTest {
    type Output = std::result::Result<
        crate::output::StartAvailabilityMonitorTestOutput,
        crate::error::StartAvailabilityMonitorTestError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_availability_monitor_test_error(response)
        } else {
            crate::operation_deser::parse_start_availability_monitor_test_response(response)
        }
    }
}

/// <p>Starts a gateway that you previously shut down (see <a>ShutdownGateway</a>).
/// After the gateway starts, you can then make other API calls, your applications can read
/// from or write to the gateway's storage volumes and you will be able to take snapshot
/// backups.</p>
/// <note>
/// <p>When you make a request, you will get a 200 OK success response immediately. However,
/// it might take some time for the gateway to be ready. You should call <a>DescribeGatewayInformation</a> and check the status before making any
/// additional API calls. For more information, see <a>ActivateGateway</a>.</p>
/// </note>
/// <p>To specify which gateway to start, use the Amazon Resource Name (ARN) of the gateway in
/// your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartGateway {
    _private: (),
}
impl StartGateway {
    /// Creates a new builder-style object to manufacture [`StartGatewayInput`](crate::input::StartGatewayInput)
    pub fn builder() -> crate::input::start_gateway_input::Builder {
        crate::input::start_gateway_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartGateway {
    type Output =
        std::result::Result<crate::output::StartGatewayOutput, crate::error::StartGatewayError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_gateway_error(response)
        } else {
            crate::operation_deser::parse_start_gateway_response(response)
        }
    }
}

/// <p>Updates the automatic tape creation policy of a gateway. Use this to update the policy
/// with a new set of automatic tape creation rules. This is only supported for tape
/// gateways.</p>
/// <p>By default, there is no automatic tape creation policy.</p>
/// <note>
/// <p>A gateway can have only one automatic tape creation policy.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAutomaticTapeCreationPolicy {
    _private: (),
}
impl UpdateAutomaticTapeCreationPolicy {
    /// Creates a new builder-style object to manufacture [`UpdateAutomaticTapeCreationPolicyInput`](crate::input::UpdateAutomaticTapeCreationPolicyInput)
    pub fn builder() -> crate::input::update_automatic_tape_creation_policy_input::Builder {
        crate::input::update_automatic_tape_creation_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAutomaticTapeCreationPolicy {
    type Output = std::result::Result<
        crate::output::UpdateAutomaticTapeCreationPolicyOutput,
        crate::error::UpdateAutomaticTapeCreationPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_automatic_tape_creation_policy_error(response)
        } else {
            crate::operation_deser::parse_update_automatic_tape_creation_policy_response(response)
        }
    }
}

/// <p>Updates the bandwidth rate limits of a gateway. You can update both the upload and
/// download bandwidth rate limit or specify only one of the two. If you don't set a
/// bandwidth rate limit, the existing rate limit remains. This operation is supported for the
/// stored volume, cached volume, and tape gateway types.</p>
/// <p>By default, a gateway's bandwidth rate limits are not set. If you don't set
/// any limit, the gateway does not have any limitations on its bandwidth usage and could
/// potentially use the maximum available bandwidth.</p>
/// <p>To specify which gateway to update, use the Amazon Resource Name (ARN) of the gateway in
/// your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBandwidthRateLimit {
    _private: (),
}
impl UpdateBandwidthRateLimit {
    /// Creates a new builder-style object to manufacture [`UpdateBandwidthRateLimitInput`](crate::input::UpdateBandwidthRateLimitInput)
    pub fn builder() -> crate::input::update_bandwidth_rate_limit_input::Builder {
        crate::input::update_bandwidth_rate_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBandwidthRateLimit {
    type Output = std::result::Result<
        crate::output::UpdateBandwidthRateLimitOutput,
        crate::error::UpdateBandwidthRateLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_bandwidth_rate_limit_error(response)
        } else {
            crate::operation_deser::parse_update_bandwidth_rate_limit_response(response)
        }
    }
}

/// <p>
/// Updates the bandwidth rate limit schedule for a specified gateway. By default, gateways do
/// not have bandwidth rate limit schedules, which means no bandwidth rate limiting is in effect.
/// Use this to initiate or update a gateway's bandwidth rate limit schedule.
/// This operation is supported in the volume and tape gateway types.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateBandwidthRateLimitSchedule {
    _private: (),
}
impl UpdateBandwidthRateLimitSchedule {
    /// Creates a new builder-style object to manufacture [`UpdateBandwidthRateLimitScheduleInput`](crate::input::UpdateBandwidthRateLimitScheduleInput)
    pub fn builder() -> crate::input::update_bandwidth_rate_limit_schedule_input::Builder {
        crate::input::update_bandwidth_rate_limit_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateBandwidthRateLimitSchedule {
    type Output = std::result::Result<
        crate::output::UpdateBandwidthRateLimitScheduleOutput,
        crate::error::UpdateBandwidthRateLimitScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_bandwidth_rate_limit_schedule_error(response)
        } else {
            crate::operation_deser::parse_update_bandwidth_rate_limit_schedule_response(response)
        }
    }
}

/// <p>Updates the Challenge-Handshake Authentication Protocol (CHAP) credentials for a
/// specified iSCSI target. By default, a gateway does not have CHAP enabled; however, for
/// added security, you might use it. This operation is supported in the volume and tape
/// gateway types.</p>
/// <important>
/// <p>When you update CHAP credentials, all existing connections on the target are closed
/// and initiators must reconnect with the new credentials.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateChapCredentials {
    _private: (),
}
impl UpdateChapCredentials {
    /// Creates a new builder-style object to manufacture [`UpdateChapCredentialsInput`](crate::input::UpdateChapCredentialsInput)
    pub fn builder() -> crate::input::update_chap_credentials_input::Builder {
        crate::input::update_chap_credentials_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateChapCredentials {
    type Output = std::result::Result<
        crate::output::UpdateChapCredentialsOutput,
        crate::error::UpdateChapCredentialsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_chap_credentials_error(response)
        } else {
            crate::operation_deser::parse_update_chap_credentials_response(response)
        }
    }
}

/// <p>Updates a file system association. This operation is only supported in the FSx File Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFileSystemAssociation {
    _private: (),
}
impl UpdateFileSystemAssociation {
    /// Creates a new builder-style object to manufacture [`UpdateFileSystemAssociationInput`](crate::input::UpdateFileSystemAssociationInput)
    pub fn builder() -> crate::input::update_file_system_association_input::Builder {
        crate::input::update_file_system_association_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFileSystemAssociation {
    type Output = std::result::Result<
        crate::output::UpdateFileSystemAssociationOutput,
        crate::error::UpdateFileSystemAssociationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_file_system_association_error(response)
        } else {
            crate::operation_deser::parse_update_file_system_association_response(response)
        }
    }
}

/// <p>Updates a gateway's metadata, which includes the gateway's name and time zone.
/// To specify which gateway to update, use the Amazon Resource Name (ARN) of the gateway in
/// your request.</p>
/// <note>
/// <p>For gateways activated after September 2, 2015, the gateway's ARN contains the
/// gateway ID rather than the gateway name. However, changing the name of the gateway has
/// no effect on the gateway's ARN.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateGatewayInformation {
    _private: (),
}
impl UpdateGatewayInformation {
    /// Creates a new builder-style object to manufacture [`UpdateGatewayInformationInput`](crate::input::UpdateGatewayInformationInput)
    pub fn builder() -> crate::input::update_gateway_information_input::Builder {
        crate::input::update_gateway_information_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateGatewayInformation {
    type Output = std::result::Result<
        crate::output::UpdateGatewayInformationOutput,
        crate::error::UpdateGatewayInformationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_gateway_information_error(response)
        } else {
            crate::operation_deser::parse_update_gateway_information_response(response)
        }
    }
}

/// <p>Updates the gateway virtual machine (VM) software. The request immediately triggers the
/// software update.</p>
/// <note>
/// <p>When you make this request, you get a <code>200 OK</code> success response
/// immediately. However, it might take some time for the update to complete. You can call
/// <a>DescribeGatewayInformation</a> to verify the gateway is in the
/// <code>STATE_RUNNING</code> state.</p>
/// </note>
/// <important>
/// <p>A software update forces a system restart of your gateway. You can minimize the
/// chance of any disruption to your applications by increasing your iSCSI Initiators'
/// timeouts. For more information about increasing iSCSI Initiator timeouts for Windows and
/// Linux, see <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/ConfiguringiSCSIClientInitiatorWindowsClient.html#CustomizeWindowsiSCSISettings">Customizing your Windows iSCSI settings</a> and <a href="https://docs.aws.amazon.com/storagegateway/latest/userguide/ConfiguringiSCSIClientInitiatorRedHatClient.html#CustomizeLinuxiSCSISettings">Customizing your Linux iSCSI settings</a>, respectively.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateGatewaySoftwareNow {
    _private: (),
}
impl UpdateGatewaySoftwareNow {
    /// Creates a new builder-style object to manufacture [`UpdateGatewaySoftwareNowInput`](crate::input::UpdateGatewaySoftwareNowInput)
    pub fn builder() -> crate::input::update_gateway_software_now_input::Builder {
        crate::input::update_gateway_software_now_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateGatewaySoftwareNow {
    type Output = std::result::Result<
        crate::output::UpdateGatewaySoftwareNowOutput,
        crate::error::UpdateGatewaySoftwareNowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_gateway_software_now_error(response)
        } else {
            crate::operation_deser::parse_update_gateway_software_now_response(response)
        }
    }
}

/// <p>Updates a gateway's weekly maintenance start time information, including day and
/// time of the week. The maintenance time is the time in your gateway's time zone.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateMaintenanceStartTime {
    _private: (),
}
impl UpdateMaintenanceStartTime {
    /// Creates a new builder-style object to manufacture [`UpdateMaintenanceStartTimeInput`](crate::input::UpdateMaintenanceStartTimeInput)
    pub fn builder() -> crate::input::update_maintenance_start_time_input::Builder {
        crate::input::update_maintenance_start_time_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateMaintenanceStartTime {
    type Output = std::result::Result<
        crate::output::UpdateMaintenanceStartTimeOutput,
        crate::error::UpdateMaintenanceStartTimeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_maintenance_start_time_error(response)
        } else {
            crate::operation_deser::parse_update_maintenance_start_time_response(response)
        }
    }
}

/// <p>Updates a Network File System (NFS) file share. This operation is only supported in S3 File Gateways.</p>
/// <note>
/// <p>To leave a file share field unchanged, set the corresponding input field to
/// null.</p>
/// </note>
/// <p>Updates the following file share settings:</p>
/// <ul>
/// <li>
/// <p>Default storage class for your S3 bucket</p>
/// </li>
/// <li>
/// <p>Metadata defaults for your S3 bucket</p>
/// </li>
/// <li>
/// <p>Allowed NFS clients for your file share</p>
/// </li>
/// <li>
/// <p>Squash settings</p>
/// </li>
/// <li>
/// <p>Write status of your file share</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateNFSFileShare {
    _private: (),
}
impl UpdateNFSFileShare {
    /// Creates a new builder-style object to manufacture [`UpdateNfsFileShareInput`](crate::input::UpdateNfsFileShareInput)
    pub fn builder() -> crate::input::update_nfs_file_share_input::Builder {
        crate::input::update_nfs_file_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateNFSFileShare {
    type Output = std::result::Result<
        crate::output::UpdateNfsFileShareOutput,
        crate::error::UpdateNFSFileShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_nfs_file_share_error(response)
        } else {
            crate::operation_deser::parse_update_nfs_file_share_response(response)
        }
    }
}

/// <p>Updates a Server Message Block (SMB) file share. This operation is only supported for
/// S3 File Gateways.</p>
/// <note>
/// <p>To leave a file share field unchanged, set the corresponding input field to
/// null.</p>
/// </note>
/// <important>
/// <p>File gateways require Security Token Service (STS) to be activated to enable
/// you to create a file share. Make sure that STS is activated in the Region you
/// are creating your file gateway in. If STS is not activated in this Region,
/// activate it. For information about how to activate STS, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
/// deactivating STS in an Region</a> in the <i>Identity and Access Management
/// User Guide</i>.</p>
/// <p>File gateways don't support creating hard or symbolic links on a file
/// share.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSMBFileShare {
    _private: (),
}
impl UpdateSMBFileShare {
    /// Creates a new builder-style object to manufacture [`UpdateSmbFileShareInput`](crate::input::UpdateSmbFileShareInput)
    pub fn builder() -> crate::input::update_smb_file_share_input::Builder {
        crate::input::update_smb_file_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSMBFileShare {
    type Output = std::result::Result<
        crate::output::UpdateSmbFileShareOutput,
        crate::error::UpdateSMBFileShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_smb_file_share_error(response)
        } else {
            crate::operation_deser::parse_update_smb_file_share_response(response)
        }
    }
}

/// <p>Controls whether the shares on an S3 File Gateway are visible in a net view or browse
/// list. The operation is only supported for S3 File Gateways.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSMBFileShareVisibility {
    _private: (),
}
impl UpdateSMBFileShareVisibility {
    /// Creates a new builder-style object to manufacture [`UpdateSmbFileShareVisibilityInput`](crate::input::UpdateSmbFileShareVisibilityInput)
    pub fn builder() -> crate::input::update_smb_file_share_visibility_input::Builder {
        crate::input::update_smb_file_share_visibility_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSMBFileShareVisibility {
    type Output = std::result::Result<
        crate::output::UpdateSmbFileShareVisibilityOutput,
        crate::error::UpdateSMBFileShareVisibilityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_smb_file_share_visibility_error(response)
        } else {
            crate::operation_deser::parse_update_smb_file_share_visibility_response(response)
        }
    }
}

/// <p>Updates the SMB security strategy on a file gateway. This action is only supported in
/// file gateways.</p>
/// <note>
/// <p>This API is called Security level in the User Guide.</p>
/// <p>A higher security level can affect performance of the gateway.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSMBSecurityStrategy {
    _private: (),
}
impl UpdateSMBSecurityStrategy {
    /// Creates a new builder-style object to manufacture [`UpdateSmbSecurityStrategyInput`](crate::input::UpdateSmbSecurityStrategyInput)
    pub fn builder() -> crate::input::update_smb_security_strategy_input::Builder {
        crate::input::update_smb_security_strategy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSMBSecurityStrategy {
    type Output = std::result::Result<
        crate::output::UpdateSmbSecurityStrategyOutput,
        crate::error::UpdateSMBSecurityStrategyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_smb_security_strategy_error(response)
        } else {
            crate::operation_deser::parse_update_smb_security_strategy_response(response)
        }
    }
}

/// <p>Updates a snapshot schedule configured for a gateway volume. This operation is only
/// supported in the cached volume and stored volume gateway types.</p>
/// <p>The default snapshot schedule for volume is once every 24 hours, starting at the
/// creation time of the volume. You can use this API to change the snapshot schedule
/// configured for the volume.</p>
/// <p>In the request you must identify the gateway volume whose snapshot schedule you want to
/// update, and the schedule information, including when you want the snapshot to begin on a
/// day and the frequency (in hours) of snapshots.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSnapshotSchedule {
    _private: (),
}
impl UpdateSnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`UpdateSnapshotScheduleInput`](crate::input::UpdateSnapshotScheduleInput)
    pub fn builder() -> crate::input::update_snapshot_schedule_input::Builder {
        crate::input::update_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSnapshotSchedule {
    type Output = std::result::Result<
        crate::output::UpdateSnapshotScheduleOutput,
        crate::error::UpdateSnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_snapshot_schedule_error(response)
        } else {
            crate::operation_deser::parse_update_snapshot_schedule_response(response)
        }
    }
}

/// <p>Updates the type of medium changer in a tape gateway. When you activate a tape gateway,
/// you select a medium changer type for the tape gateway. This operation enables you to select
/// a different type of medium changer after a tape gateway is activated. This operation is
/// only supported in the tape gateway type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateVTLDeviceType {
    _private: (),
}
impl UpdateVTLDeviceType {
    /// Creates a new builder-style object to manufacture [`UpdateVtlDeviceTypeInput`](crate::input::UpdateVtlDeviceTypeInput)
    pub fn builder() -> crate::input::update_vtl_device_type_input::Builder {
        crate::input::update_vtl_device_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateVTLDeviceType {
    type Output = std::result::Result<
        crate::output::UpdateVtlDeviceTypeOutput,
        crate::error::UpdateVTLDeviceTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_vtl_device_type_error(response)
        } else {
            crate::operation_deser::parse_update_vtl_device_type_response(response)
        }
    }
}
