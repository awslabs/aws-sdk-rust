// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ActivateGatewayError {
    pub kind: ActivateGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ActivateGatewayErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ActivateGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ActivateGatewayErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ActivateGatewayErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ActivateGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ActivateGatewayError {
    fn code(&self) -> Option<&str> {
        ActivateGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ActivateGatewayError {
    pub fn new(kind: ActivateGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ActivateGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ActivateGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ActivateGatewayErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivateGatewayErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ActivateGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ActivateGatewayErrorKind::InternalServerError(_inner) => Some(_inner),
            ActivateGatewayErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ActivateGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddCacheError {
    pub kind: AddCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddCacheErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddCacheErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddCacheErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AddCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddCacheError {
    fn code(&self) -> Option<&str> {
        AddCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddCacheError {
    pub fn new(kind: AddCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, AddCacheErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCacheErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AddCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddCacheErrorKind::InternalServerError(_inner) => Some(_inner),
            AddCacheErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AddCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsToResourceError {
    pub kind: AddTagsToResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsToResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        AddTagsToResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    pub fn new(kind: AddTagsToResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsToResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddUploadBufferError {
    pub kind: AddUploadBufferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddUploadBufferErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddUploadBufferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddUploadBufferErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddUploadBufferErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AddUploadBufferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddUploadBufferError {
    fn code(&self) -> Option<&str> {
        AddUploadBufferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddUploadBufferError {
    pub fn new(kind: AddUploadBufferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddUploadBufferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddUploadBufferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, AddUploadBufferErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddUploadBufferErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AddUploadBufferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddUploadBufferErrorKind::InternalServerError(_inner) => Some(_inner),
            AddUploadBufferErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AddUploadBufferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddWorkingStorageError {
    pub kind: AddWorkingStorageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddWorkingStorageErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddWorkingStorageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddWorkingStorageErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AddWorkingStorageErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AddWorkingStorageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddWorkingStorageError {
    fn code(&self) -> Option<&str> {
        AddWorkingStorageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddWorkingStorageError {
    pub fn new(kind: AddWorkingStorageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddWorkingStorageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddWorkingStorageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AddWorkingStorageErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddWorkingStorageErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AddWorkingStorageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddWorkingStorageErrorKind::InternalServerError(_inner) => Some(_inner),
            AddWorkingStorageErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AddWorkingStorageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssignTapePoolError {
    pub kind: AssignTapePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssignTapePoolErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssignTapePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssignTapePoolErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AssignTapePoolErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AssignTapePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssignTapePoolError {
    fn code(&self) -> Option<&str> {
        AssignTapePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssignTapePoolError {
    pub fn new(kind: AssignTapePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssignTapePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssignTapePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, AssignTapePoolErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssignTapePoolErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AssignTapePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssignTapePoolErrorKind::InternalServerError(_inner) => Some(_inner),
            AssignTapePoolErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AssignTapePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateFileSystemError {
    pub kind: AssociateFileSystemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateFileSystemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateFileSystemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AssociateFileSystemErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AssociateFileSystemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateFileSystemError {
    fn code(&self) -> Option<&str> {
        AssociateFileSystemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateFileSystemError {
    pub fn new(kind: AssociateFileSystemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateFileSystemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateFileSystemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFileSystemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFileSystemErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AssociateFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateFileSystemErrorKind::InternalServerError(_inner) => Some(_inner),
            AssociateFileSystemErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AssociateFileSystemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AttachVolumeError {
    pub kind: AttachVolumeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AttachVolumeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AttachVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AttachVolumeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AttachVolumeErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            AttachVolumeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AttachVolumeError {
    fn code(&self) -> Option<&str> {
        AttachVolumeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AttachVolumeError {
    pub fn new(kind: AttachVolumeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AttachVolumeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AttachVolumeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, AttachVolumeErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            AttachVolumeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for AttachVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AttachVolumeErrorKind::InternalServerError(_inner) => Some(_inner),
            AttachVolumeErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            AttachVolumeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelArchivalError {
    pub kind: CancelArchivalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelArchivalErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelArchivalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelArchivalErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CancelArchivalErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CancelArchivalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelArchivalError {
    fn code(&self) -> Option<&str> {
        CancelArchivalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelArchivalError {
    pub fn new(kind: CancelArchivalErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelArchivalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelArchivalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CancelArchivalErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelArchivalErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CancelArchivalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelArchivalErrorKind::InternalServerError(_inner) => Some(_inner),
            CancelArchivalErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CancelArchivalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelRetrievalError {
    pub kind: CancelRetrievalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelRetrievalErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelRetrievalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelRetrievalErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CancelRetrievalErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CancelRetrievalErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelRetrievalError {
    fn code(&self) -> Option<&str> {
        CancelRetrievalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelRetrievalError {
    pub fn new(kind: CancelRetrievalErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelRetrievalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelRetrievalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CancelRetrievalErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelRetrievalErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CancelRetrievalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelRetrievalErrorKind::InternalServerError(_inner) => Some(_inner),
            CancelRetrievalErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CancelRetrievalErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCachediSCSIVolumeError {
    pub kind: CreateCachediSCSIVolumeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCachediSCSIVolumeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCachediSCSIVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCachediSCSIVolumeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateCachediSCSIVolumeErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreateCachediSCSIVolumeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCachediSCSIVolumeError {
    fn code(&self) -> Option<&str> {
        CreateCachediSCSIVolumeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCachediSCSIVolumeError {
    pub fn new(kind: CreateCachediSCSIVolumeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCachediSCSIVolumeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCachediSCSIVolumeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCachediSCSIVolumeErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCachediSCSIVolumeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateCachediSCSIVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCachediSCSIVolumeErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateCachediSCSIVolumeErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            CreateCachediSCSIVolumeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateNFSFileShareError {
    pub kind: CreateNFSFileShareErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateNFSFileShareErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateNFSFileShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateNFSFileShareErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateNFSFileShareErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CreateNFSFileShareErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateNFSFileShareError {
    fn code(&self) -> Option<&str> {
        CreateNFSFileShareError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateNFSFileShareError {
    pub fn new(kind: CreateNFSFileShareErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateNFSFileShareErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateNFSFileShareErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateNFSFileShareErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNFSFileShareErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateNFSFileShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateNFSFileShareErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateNFSFileShareErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CreateNFSFileShareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSMBFileShareError {
    pub kind: CreateSMBFileShareErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSMBFileShareErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSMBFileShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSMBFileShareErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateSMBFileShareErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CreateSMBFileShareErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSMBFileShareError {
    fn code(&self) -> Option<&str> {
        CreateSMBFileShareError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSMBFileShareError {
    pub fn new(kind: CreateSMBFileShareErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSMBFileShareErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSMBFileShareErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSMBFileShareErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSMBFileShareErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateSMBFileShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSMBFileShareErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateSMBFileShareErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CreateSMBFileShareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSnapshotError {
    pub kind: CreateSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSnapshotErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotError {
    pub fn new(kind: CreateSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateSnapshotErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::InvalidGatewayRequestException(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for CreateSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSnapshotErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateSnapshotErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CreateSnapshotErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSnapshotFromVolumeRecoveryPointError {
    pub kind: CreateSnapshotFromVolumeRecoveryPointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotFromVolumeRecoveryPointErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSnapshotFromVolumeRecoveryPointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSnapshotFromVolumeRecoveryPointErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            CreateSnapshotFromVolumeRecoveryPointErrorKind::InvalidGatewayRequestException(
                _inner,
            ) => _inner.fmt(f),
            CreateSnapshotFromVolumeRecoveryPointErrorKind::ServiceUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            CreateSnapshotFromVolumeRecoveryPointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSnapshotFromVolumeRecoveryPointError {
    fn code(&self) -> Option<&str> {
        CreateSnapshotFromVolumeRecoveryPointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotFromVolumeRecoveryPointError {
    pub fn new(
        kind: CreateSnapshotFromVolumeRecoveryPointErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSnapshotFromVolumeRecoveryPointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSnapshotFromVolumeRecoveryPointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotFromVolumeRecoveryPointErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotFromVolumeRecoveryPointErrorKind::InvalidGatewayRequestException(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotFromVolumeRecoveryPointErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for CreateSnapshotFromVolumeRecoveryPointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSnapshotFromVolumeRecoveryPointErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            CreateSnapshotFromVolumeRecoveryPointErrorKind::InvalidGatewayRequestException(
                _inner,
            ) => Some(_inner),
            CreateSnapshotFromVolumeRecoveryPointErrorKind::ServiceUnavailableError(_inner) => {
                Some(_inner)
            }
            CreateSnapshotFromVolumeRecoveryPointErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStorediSCSIVolumeError {
    pub kind: CreateStorediSCSIVolumeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStorediSCSIVolumeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStorediSCSIVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStorediSCSIVolumeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateStorediSCSIVolumeErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreateStorediSCSIVolumeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStorediSCSIVolumeError {
    fn code(&self) -> Option<&str> {
        CreateStorediSCSIVolumeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStorediSCSIVolumeError {
    pub fn new(kind: CreateStorediSCSIVolumeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStorediSCSIVolumeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStorediSCSIVolumeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStorediSCSIVolumeErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStorediSCSIVolumeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateStorediSCSIVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStorediSCSIVolumeErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateStorediSCSIVolumeErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            CreateStorediSCSIVolumeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTapePoolError {
    pub kind: CreateTapePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTapePoolErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTapePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTapePoolErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateTapePoolErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CreateTapePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTapePoolError {
    fn code(&self) -> Option<&str> {
        CreateTapePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTapePoolError {
    pub fn new(kind: CreateTapePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTapePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTapePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateTapePoolErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTapePoolErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateTapePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTapePoolErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateTapePoolErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CreateTapePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTapesError {
    pub kind: CreateTapesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTapesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTapesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTapesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateTapesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CreateTapesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTapesError {
    fn code(&self) -> Option<&str> {
        CreateTapesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTapesError {
    pub fn new(kind: CreateTapesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTapesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTapesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateTapesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTapesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateTapesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTapesErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateTapesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CreateTapesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTapeWithBarcodeError {
    pub kind: CreateTapeWithBarcodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTapeWithBarcodeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTapeWithBarcodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTapeWithBarcodeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateTapeWithBarcodeErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            CreateTapeWithBarcodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTapeWithBarcodeError {
    fn code(&self) -> Option<&str> {
        CreateTapeWithBarcodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTapeWithBarcodeError {
    pub fn new(kind: CreateTapeWithBarcodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTapeWithBarcodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTapeWithBarcodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateTapeWithBarcodeErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTapeWithBarcodeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for CreateTapeWithBarcodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTapeWithBarcodeErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateTapeWithBarcodeErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            CreateTapeWithBarcodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAutomaticTapeCreationPolicyError {
    pub kind: DeleteAutomaticTapeCreationPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAutomaticTapeCreationPolicyErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAutomaticTapeCreationPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAutomaticTapeCreationPolicyErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DeleteAutomaticTapeCreationPolicyErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAutomaticTapeCreationPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAutomaticTapeCreationPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteAutomaticTapeCreationPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAutomaticTapeCreationPolicyError {
    pub fn new(
        kind: DeleteAutomaticTapeCreationPolicyErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAutomaticTapeCreationPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAutomaticTapeCreationPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutomaticTapeCreationPolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAutomaticTapeCreationPolicyErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteAutomaticTapeCreationPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAutomaticTapeCreationPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteAutomaticTapeCreationPolicyErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DeleteAutomaticTapeCreationPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBandwidthRateLimitError {
    pub kind: DeleteBandwidthRateLimitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBandwidthRateLimitErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBandwidthRateLimitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBandwidthRateLimitErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBandwidthRateLimitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBandwidthRateLimitError {
    fn code(&self) -> Option<&str> {
        DeleteBandwidthRateLimitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBandwidthRateLimitError {
    pub fn new(kind: DeleteBandwidthRateLimitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBandwidthRateLimitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBandwidthRateLimitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBandwidthRateLimitErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteBandwidthRateLimitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBandwidthRateLimitErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DeleteBandwidthRateLimitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChapCredentialsError {
    pub kind: DeleteChapCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChapCredentialsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChapCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChapCredentialsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteChapCredentialsErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteChapCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChapCredentialsError {
    fn code(&self) -> Option<&str> {
        DeleteChapCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChapCredentialsError {
    pub fn new(kind: DeleteChapCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChapCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChapCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChapCredentialsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChapCredentialsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteChapCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChapCredentialsErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteChapCredentialsErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteChapCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFileShareError {
    pub kind: DeleteFileShareErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileShareErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFileShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFileShareErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteFileShareErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteFileShareErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFileShareError {
    fn code(&self) -> Option<&str> {
        DeleteFileShareError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileShareError {
    pub fn new(kind: DeleteFileShareErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFileShareErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFileShareErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteFileShareErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileShareErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteFileShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFileShareErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteFileShareErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteFileShareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGatewayError {
    pub kind: DeleteGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGatewayErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGatewayErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteGatewayErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGatewayError {
    fn code(&self) -> Option<&str> {
        DeleteGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGatewayError {
    pub fn new(kind: DeleteGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteGatewayErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGatewayErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteGatewayErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSnapshotScheduleError {
    pub kind: DeleteSnapshotScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotScheduleErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSnapshotScheduleErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteSnapshotScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteSnapshotScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        DeleteSnapshotScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotScheduleError {
    pub fn new(kind: DeleteSnapshotScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSnapshotScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSnapshotScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSnapshotScheduleErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSnapshotScheduleErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteSnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSnapshotScheduleErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteSnapshotScheduleErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteSnapshotScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTapeError {
    pub kind: DeleteTapeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTapeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTapeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTapeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteTapeErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteTapeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTapeError {
    fn code(&self) -> Option<&str> {
        DeleteTapeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTapeError {
    pub fn new(kind: DeleteTapeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTapeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTapeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteTapeErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTapeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteTapeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTapeErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteTapeErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteTapeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTapeArchiveError {
    pub kind: DeleteTapeArchiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTapeArchiveErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTapeArchiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTapeArchiveErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteTapeArchiveErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteTapeArchiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTapeArchiveError {
    fn code(&self) -> Option<&str> {
        DeleteTapeArchiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTapeArchiveError {
    pub fn new(kind: DeleteTapeArchiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTapeArchiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTapeArchiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTapeArchiveErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTapeArchiveErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteTapeArchiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTapeArchiveErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteTapeArchiveErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteTapeArchiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTapePoolError {
    pub kind: DeleteTapePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTapePoolErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTapePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTapePoolErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteTapePoolErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteTapePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTapePoolError {
    fn code(&self) -> Option<&str> {
        DeleteTapePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTapePoolError {
    pub fn new(kind: DeleteTapePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTapePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTapePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteTapePoolErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTapePoolErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteTapePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTapePoolErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteTapePoolErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteTapePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVolumeError {
    pub kind: DeleteVolumeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVolumeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVolumeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteVolumeErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DeleteVolumeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVolumeError {
    fn code(&self) -> Option<&str> {
        DeleteVolumeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVolumeError {
    pub fn new(kind: DeleteVolumeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVolumeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVolumeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteVolumeErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVolumeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DeleteVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVolumeErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteVolumeErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DeleteVolumeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAvailabilityMonitorTestError {
    pub kind: DescribeAvailabilityMonitorTestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAvailabilityMonitorTestErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAvailabilityMonitorTestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAvailabilityMonitorTestErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeAvailabilityMonitorTestErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeAvailabilityMonitorTestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAvailabilityMonitorTestError {
    fn code(&self) -> Option<&str> {
        DescribeAvailabilityMonitorTestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAvailabilityMonitorTestError {
    pub fn new(kind: DescribeAvailabilityMonitorTestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAvailabilityMonitorTestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAvailabilityMonitorTestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAvailabilityMonitorTestErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAvailabilityMonitorTestErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeAvailabilityMonitorTestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAvailabilityMonitorTestErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeAvailabilityMonitorTestErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeAvailabilityMonitorTestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBandwidthRateLimitError {
    pub kind: DescribeBandwidthRateLimitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBandwidthRateLimitErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBandwidthRateLimitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBandwidthRateLimitErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeBandwidthRateLimitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBandwidthRateLimitError {
    fn code(&self) -> Option<&str> {
        DescribeBandwidthRateLimitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBandwidthRateLimitError {
    pub fn new(kind: DescribeBandwidthRateLimitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBandwidthRateLimitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBandwidthRateLimitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBandwidthRateLimitErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeBandwidthRateLimitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBandwidthRateLimitErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeBandwidthRateLimitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBandwidthRateLimitScheduleError {
    pub kind: DescribeBandwidthRateLimitScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBandwidthRateLimitScheduleErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBandwidthRateLimitScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBandwidthRateLimitScheduleErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeBandwidthRateLimitScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeBandwidthRateLimitScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBandwidthRateLimitScheduleError {
    fn code(&self) -> Option<&str> {
        DescribeBandwidthRateLimitScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBandwidthRateLimitScheduleError {
    pub fn new(
        kind: DescribeBandwidthRateLimitScheduleErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBandwidthRateLimitScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBandwidthRateLimitScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBandwidthRateLimitScheduleErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeBandwidthRateLimitScheduleErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeBandwidthRateLimitScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBandwidthRateLimitScheduleErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeBandwidthRateLimitScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeBandwidthRateLimitScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheError {
    pub kind: DescribeCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeCacheErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheError {
    fn code(&self) -> Option<&str> {
        DescribeCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheError {
    pub fn new(kind: DescribeCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DescribeCacheErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeCacheErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCachediSCSIVolumesError {
    pub kind: DescribeCachediSCSIVolumesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCachediSCSIVolumesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCachediSCSIVolumesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCachediSCSIVolumesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeCachediSCSIVolumesErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCachediSCSIVolumesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCachediSCSIVolumesError {
    fn code(&self) -> Option<&str> {
        DescribeCachediSCSIVolumesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCachediSCSIVolumesError {
    pub fn new(kind: DescribeCachediSCSIVolumesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCachediSCSIVolumesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCachediSCSIVolumesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCachediSCSIVolumesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCachediSCSIVolumesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeCachediSCSIVolumesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCachediSCSIVolumesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeCachediSCSIVolumesErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeCachediSCSIVolumesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChapCredentialsError {
    pub kind: DescribeChapCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChapCredentialsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChapCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChapCredentialsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeChapCredentialsErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeChapCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChapCredentialsError {
    fn code(&self) -> Option<&str> {
        DescribeChapCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChapCredentialsError {
    pub fn new(kind: DescribeChapCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChapCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChapCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChapCredentialsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChapCredentialsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeChapCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChapCredentialsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeChapCredentialsErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeChapCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFileSystemAssociationsError {
    pub kind: DescribeFileSystemAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFileSystemAssociationsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFileSystemAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFileSystemAssociationsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeFileSystemAssociationsErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeFileSystemAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFileSystemAssociationsError {
    fn code(&self) -> Option<&str> {
        DescribeFileSystemAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFileSystemAssociationsError {
    pub fn new(kind: DescribeFileSystemAssociationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFileSystemAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFileSystemAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemAssociationsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemAssociationsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeFileSystemAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFileSystemAssociationsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeFileSystemAssociationsErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeFileSystemAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGatewayInformationError {
    pub kind: DescribeGatewayInformationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGatewayInformationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGatewayInformationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGatewayInformationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeGatewayInformationErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeGatewayInformationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGatewayInformationError {
    fn code(&self) -> Option<&str> {
        DescribeGatewayInformationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGatewayInformationError {
    pub fn new(kind: DescribeGatewayInformationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGatewayInformationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGatewayInformationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayInformationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGatewayInformationErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeGatewayInformationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGatewayInformationErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeGatewayInformationErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeGatewayInformationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMaintenanceStartTimeError {
    pub kind: DescribeMaintenanceStartTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMaintenanceStartTimeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMaintenanceStartTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMaintenanceStartTimeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeMaintenanceStartTimeErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMaintenanceStartTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMaintenanceStartTimeError {
    fn code(&self) -> Option<&str> {
        DescribeMaintenanceStartTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMaintenanceStartTimeError {
    pub fn new(kind: DescribeMaintenanceStartTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMaintenanceStartTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMaintenanceStartTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceStartTimeErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMaintenanceStartTimeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeMaintenanceStartTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMaintenanceStartTimeErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeMaintenanceStartTimeErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeMaintenanceStartTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeNFSFileSharesError {
    pub kind: DescribeNFSFileSharesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeNFSFileSharesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeNFSFileSharesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeNFSFileSharesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeNFSFileSharesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeNFSFileSharesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeNFSFileSharesError {
    fn code(&self) -> Option<&str> {
        DescribeNFSFileSharesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeNFSFileSharesError {
    pub fn new(kind: DescribeNFSFileSharesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeNFSFileSharesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeNFSFileSharesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNFSFileSharesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeNFSFileSharesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeNFSFileSharesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeNFSFileSharesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeNFSFileSharesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeNFSFileSharesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSMBFileSharesError {
    pub kind: DescribeSMBFileSharesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSMBFileSharesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSMBFileSharesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSMBFileSharesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeSMBFileSharesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeSMBFileSharesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSMBFileSharesError {
    fn code(&self) -> Option<&str> {
        DescribeSMBFileSharesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSMBFileSharesError {
    pub fn new(kind: DescribeSMBFileSharesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSMBFileSharesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSMBFileSharesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSMBFileSharesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSMBFileSharesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeSMBFileSharesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSMBFileSharesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeSMBFileSharesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeSMBFileSharesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSMBSettingsError {
    pub kind: DescribeSMBSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSMBSettingsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSMBSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSMBSettingsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeSMBSettingsErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeSMBSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSMBSettingsError {
    fn code(&self) -> Option<&str> {
        DescribeSMBSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSMBSettingsError {
    pub fn new(kind: DescribeSMBSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSMBSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSMBSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSMBSettingsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSMBSettingsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeSMBSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSMBSettingsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeSMBSettingsErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeSMBSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSnapshotScheduleError {
    pub kind: DescribeSnapshotScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotScheduleErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSnapshotScheduleErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeSnapshotScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSnapshotScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        DescribeSnapshotScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotScheduleError {
    pub fn new(kind: DescribeSnapshotScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSnapshotScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSnapshotScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSnapshotScheduleErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSnapshotScheduleErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeSnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSnapshotScheduleErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeSnapshotScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeSnapshotScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStorediSCSIVolumesError {
    pub kind: DescribeStorediSCSIVolumesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStorediSCSIVolumesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStorediSCSIVolumesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStorediSCSIVolumesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeStorediSCSIVolumesErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeStorediSCSIVolumesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStorediSCSIVolumesError {
    fn code(&self) -> Option<&str> {
        DescribeStorediSCSIVolumesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStorediSCSIVolumesError {
    pub fn new(kind: DescribeStorediSCSIVolumesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStorediSCSIVolumesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStorediSCSIVolumesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStorediSCSIVolumesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStorediSCSIVolumesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeStorediSCSIVolumesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStorediSCSIVolumesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeStorediSCSIVolumesErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeStorediSCSIVolumesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTapeArchivesError {
    pub kind: DescribeTapeArchivesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTapeArchivesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTapeArchivesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTapeArchivesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTapeArchivesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeTapeArchivesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTapeArchivesError {
    fn code(&self) -> Option<&str> {
        DescribeTapeArchivesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTapeArchivesError {
    pub fn new(kind: DescribeTapeArchivesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTapeArchivesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTapeArchivesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTapeArchivesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTapeArchivesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeTapeArchivesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTapeArchivesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTapeArchivesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeTapeArchivesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTapeRecoveryPointsError {
    pub kind: DescribeTapeRecoveryPointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTapeRecoveryPointsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTapeRecoveryPointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTapeRecoveryPointsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTapeRecoveryPointsErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeTapeRecoveryPointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTapeRecoveryPointsError {
    fn code(&self) -> Option<&str> {
        DescribeTapeRecoveryPointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTapeRecoveryPointsError {
    pub fn new(kind: DescribeTapeRecoveryPointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTapeRecoveryPointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTapeRecoveryPointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTapeRecoveryPointsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTapeRecoveryPointsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeTapeRecoveryPointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTapeRecoveryPointsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTapeRecoveryPointsErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            DescribeTapeRecoveryPointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTapesError {
    pub kind: DescribeTapesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTapesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTapesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTapesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTapesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeTapesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTapesError {
    fn code(&self) -> Option<&str> {
        DescribeTapesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTapesError {
    pub fn new(kind: DescribeTapesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTapesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTapesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DescribeTapesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTapesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeTapesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTapesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTapesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeTapesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUploadBufferError {
    pub kind: DescribeUploadBufferErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUploadBufferErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUploadBufferError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUploadBufferErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeUploadBufferErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeUploadBufferErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUploadBufferError {
    fn code(&self) -> Option<&str> {
        DescribeUploadBufferError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUploadBufferError {
    pub fn new(kind: DescribeUploadBufferErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUploadBufferErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUploadBufferErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUploadBufferErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUploadBufferErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeUploadBufferError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUploadBufferErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeUploadBufferErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeUploadBufferErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVTLDevicesError {
    pub kind: DescribeVTLDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVTLDevicesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVTLDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVTLDevicesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeVTLDevicesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DescribeVTLDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVTLDevicesError {
    fn code(&self) -> Option<&str> {
        DescribeVTLDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeVTLDevicesError {
    pub fn new(kind: DescribeVTLDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVTLDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVTLDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVTLDevicesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVTLDevicesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeVTLDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVTLDevicesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeVTLDevicesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeVTLDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkingStorageError {
    pub kind: DescribeWorkingStorageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkingStorageErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkingStorageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkingStorageErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeWorkingStorageErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DescribeWorkingStorageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkingStorageError {
    fn code(&self) -> Option<&str> {
        DescribeWorkingStorageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkingStorageError {
    pub fn new(kind: DescribeWorkingStorageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkingStorageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkingStorageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkingStorageErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkingStorageErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DescribeWorkingStorageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkingStorageErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeWorkingStorageErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DescribeWorkingStorageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetachVolumeError {
    pub kind: DetachVolumeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetachVolumeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetachVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetachVolumeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DetachVolumeErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DetachVolumeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetachVolumeError {
    fn code(&self) -> Option<&str> {
        DetachVolumeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetachVolumeError {
    pub fn new(kind: DetachVolumeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetachVolumeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetachVolumeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DetachVolumeErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DetachVolumeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DetachVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetachVolumeErrorKind::InternalServerError(_inner) => Some(_inner),
            DetachVolumeErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DetachVolumeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableGatewayError {
    pub kind: DisableGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableGatewayErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableGatewayErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DisableGatewayErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            DisableGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableGatewayError {
    fn code(&self) -> Option<&str> {
        DisableGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableGatewayError {
    pub fn new(kind: DisableGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DisableGatewayErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableGatewayErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DisableGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableGatewayErrorKind::InternalServerError(_inner) => Some(_inner),
            DisableGatewayErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DisableGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateFileSystemError {
    pub kind: DisassociateFileSystemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateFileSystemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateFileSystemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DisassociateFileSystemErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateFileSystemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateFileSystemError {
    fn code(&self) -> Option<&str> {
        DisassociateFileSystemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateFileSystemError {
    pub fn new(kind: DisassociateFileSystemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateFileSystemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateFileSystemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFileSystemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFileSystemErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for DisassociateFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateFileSystemErrorKind::InternalServerError(_inner) => Some(_inner),
            DisassociateFileSystemErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            DisassociateFileSystemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct JoinDomainError {
    pub kind: JoinDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum JoinDomainErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for JoinDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            JoinDomainErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            JoinDomainErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            JoinDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for JoinDomainError {
    fn code(&self) -> Option<&str> {
        JoinDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl JoinDomainError {
    pub fn new(kind: JoinDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: JoinDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: JoinDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, JoinDomainErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            JoinDomainErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for JoinDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            JoinDomainErrorKind::InternalServerError(_inner) => Some(_inner),
            JoinDomainErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            JoinDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAutomaticTapeCreationPoliciesError {
    pub kind: ListAutomaticTapeCreationPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAutomaticTapeCreationPoliciesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAutomaticTapeCreationPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAutomaticTapeCreationPoliciesErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            ListAutomaticTapeCreationPoliciesErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListAutomaticTapeCreationPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAutomaticTapeCreationPoliciesError {
    fn code(&self) -> Option<&str> {
        ListAutomaticTapeCreationPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAutomaticTapeCreationPoliciesError {
    pub fn new(
        kind: ListAutomaticTapeCreationPoliciesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAutomaticTapeCreationPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAutomaticTapeCreationPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListAutomaticTapeCreationPoliciesErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAutomaticTapeCreationPoliciesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListAutomaticTapeCreationPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAutomaticTapeCreationPoliciesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListAutomaticTapeCreationPoliciesErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            ListAutomaticTapeCreationPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFileSharesError {
    pub kind: ListFileSharesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFileSharesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFileSharesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFileSharesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListFileSharesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListFileSharesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFileSharesError {
    fn code(&self) -> Option<&str> {
        ListFileSharesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFileSharesError {
    pub fn new(kind: ListFileSharesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFileSharesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFileSharesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListFileSharesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFileSharesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListFileSharesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFileSharesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListFileSharesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListFileSharesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFileSystemAssociationsError {
    pub kind: ListFileSystemAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFileSystemAssociationsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFileSystemAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFileSystemAssociationsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListFileSystemAssociationsErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListFileSystemAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFileSystemAssociationsError {
    fn code(&self) -> Option<&str> {
        ListFileSystemAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFileSystemAssociationsError {
    pub fn new(kind: ListFileSystemAssociationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFileSystemAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFileSystemAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListFileSystemAssociationsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFileSystemAssociationsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListFileSystemAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFileSystemAssociationsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListFileSystemAssociationsErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            ListFileSystemAssociationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGatewaysError {
    pub kind: ListGatewaysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGatewaysErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGatewaysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGatewaysErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListGatewaysErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListGatewaysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGatewaysError {
    fn code(&self) -> Option<&str> {
        ListGatewaysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGatewaysError {
    pub fn new(kind: ListGatewaysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGatewaysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGatewaysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListGatewaysErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGatewaysErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListGatewaysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGatewaysErrorKind::InternalServerError(_inner) => Some(_inner),
            ListGatewaysErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListGatewaysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLocalDisksError {
    pub kind: ListLocalDisksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLocalDisksErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLocalDisksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLocalDisksErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListLocalDisksErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListLocalDisksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLocalDisksError {
    fn code(&self) -> Option<&str> {
        ListLocalDisksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLocalDisksError {
    pub fn new(kind: ListLocalDisksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLocalDisksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLocalDisksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListLocalDisksErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLocalDisksErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListLocalDisksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLocalDisksErrorKind::InternalServerError(_inner) => Some(_inner),
            ListLocalDisksErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListLocalDisksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTapePoolsError {
    pub kind: ListTapePoolsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTapePoolsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTapePoolsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTapePoolsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTapePoolsErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListTapePoolsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTapePoolsError {
    fn code(&self) -> Option<&str> {
        ListTapePoolsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTapePoolsError {
    pub fn new(kind: ListTapePoolsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTapePoolsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTapePoolsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListTapePoolsErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTapePoolsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListTapePoolsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTapePoolsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTapePoolsErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListTapePoolsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTapesError {
    pub kind: ListTapesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTapesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTapesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTapesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTapesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListTapesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTapesError {
    fn code(&self) -> Option<&str> {
        ListTapesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTapesError {
    pub fn new(kind: ListTapesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTapesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTapesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListTapesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTapesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListTapesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTapesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTapesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListTapesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVolumeInitiatorsError {
    pub kind: ListVolumeInitiatorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVolumeInitiatorsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVolumeInitiatorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVolumeInitiatorsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListVolumeInitiatorsErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListVolumeInitiatorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVolumeInitiatorsError {
    fn code(&self) -> Option<&str> {
        ListVolumeInitiatorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVolumeInitiatorsError {
    pub fn new(kind: ListVolumeInitiatorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVolumeInitiatorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVolumeInitiatorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListVolumeInitiatorsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVolumeInitiatorsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListVolumeInitiatorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVolumeInitiatorsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListVolumeInitiatorsErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListVolumeInitiatorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVolumeRecoveryPointsError {
    pub kind: ListVolumeRecoveryPointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVolumeRecoveryPointsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVolumeRecoveryPointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVolumeRecoveryPointsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListVolumeRecoveryPointsErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListVolumeRecoveryPointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVolumeRecoveryPointsError {
    fn code(&self) -> Option<&str> {
        ListVolumeRecoveryPointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVolumeRecoveryPointsError {
    pub fn new(kind: ListVolumeRecoveryPointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVolumeRecoveryPointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVolumeRecoveryPointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListVolumeRecoveryPointsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVolumeRecoveryPointsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListVolumeRecoveryPointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVolumeRecoveryPointsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListVolumeRecoveryPointsErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            ListVolumeRecoveryPointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVolumesError {
    pub kind: ListVolumesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVolumesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVolumesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVolumesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListVolumesErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ListVolumesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVolumesError {
    fn code(&self) -> Option<&str> {
        ListVolumesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVolumesError {
    pub fn new(kind: ListVolumesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVolumesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVolumesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ListVolumesErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVolumesErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ListVolumesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVolumesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListVolumesErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ListVolumesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct NotifyWhenUploadedError {
    pub kind: NotifyWhenUploadedErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum NotifyWhenUploadedErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for NotifyWhenUploadedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            NotifyWhenUploadedErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            NotifyWhenUploadedErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            NotifyWhenUploadedErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for NotifyWhenUploadedError {
    fn code(&self) -> Option<&str> {
        NotifyWhenUploadedError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl NotifyWhenUploadedError {
    pub fn new(kind: NotifyWhenUploadedErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: NotifyWhenUploadedErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: NotifyWhenUploadedErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            NotifyWhenUploadedErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            NotifyWhenUploadedErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for NotifyWhenUploadedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            NotifyWhenUploadedErrorKind::InternalServerError(_inner) => Some(_inner),
            NotifyWhenUploadedErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            NotifyWhenUploadedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RefreshCacheError {
    pub kind: RefreshCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RefreshCacheErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RefreshCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RefreshCacheErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RefreshCacheErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            RefreshCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RefreshCacheError {
    fn code(&self) -> Option<&str> {
        RefreshCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RefreshCacheError {
    pub fn new(kind: RefreshCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RefreshCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RefreshCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, RefreshCacheErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RefreshCacheErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for RefreshCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RefreshCacheErrorKind::InternalServerError(_inner) => Some(_inner),
            RefreshCacheErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            RefreshCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsFromResourceError {
    pub kind: RemoveTagsFromResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        RemoveTagsFromResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    pub fn new(kind: RemoveTagsFromResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetCacheError {
    pub kind: ResetCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetCacheErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetCacheErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ResetCacheErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ResetCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetCacheError {
    fn code(&self) -> Option<&str> {
        ResetCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetCacheError {
    pub fn new(kind: ResetCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ResetCacheErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetCacheErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ResetCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetCacheErrorKind::InternalServerError(_inner) => Some(_inner),
            ResetCacheErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ResetCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RetrieveTapeArchiveError {
    pub kind: RetrieveTapeArchiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RetrieveTapeArchiveErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RetrieveTapeArchiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RetrieveTapeArchiveErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RetrieveTapeArchiveErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            RetrieveTapeArchiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RetrieveTapeArchiveError {
    fn code(&self) -> Option<&str> {
        RetrieveTapeArchiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RetrieveTapeArchiveError {
    pub fn new(kind: RetrieveTapeArchiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RetrieveTapeArchiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RetrieveTapeArchiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RetrieveTapeArchiveErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RetrieveTapeArchiveErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for RetrieveTapeArchiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RetrieveTapeArchiveErrorKind::InternalServerError(_inner) => Some(_inner),
            RetrieveTapeArchiveErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            RetrieveTapeArchiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RetrieveTapeRecoveryPointError {
    pub kind: RetrieveTapeRecoveryPointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RetrieveTapeRecoveryPointErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RetrieveTapeRecoveryPointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RetrieveTapeRecoveryPointErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RetrieveTapeRecoveryPointErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            RetrieveTapeRecoveryPointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RetrieveTapeRecoveryPointError {
    fn code(&self) -> Option<&str> {
        RetrieveTapeRecoveryPointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RetrieveTapeRecoveryPointError {
    pub fn new(kind: RetrieveTapeRecoveryPointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RetrieveTapeRecoveryPointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RetrieveTapeRecoveryPointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            RetrieveTapeRecoveryPointErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RetrieveTapeRecoveryPointErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for RetrieveTapeRecoveryPointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RetrieveTapeRecoveryPointErrorKind::InternalServerError(_inner) => Some(_inner),
            RetrieveTapeRecoveryPointErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            RetrieveTapeRecoveryPointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetLocalConsolePasswordError {
    pub kind: SetLocalConsolePasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetLocalConsolePasswordErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetLocalConsolePasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetLocalConsolePasswordErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SetLocalConsolePasswordErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            SetLocalConsolePasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetLocalConsolePasswordError {
    fn code(&self) -> Option<&str> {
        SetLocalConsolePasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetLocalConsolePasswordError {
    pub fn new(kind: SetLocalConsolePasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetLocalConsolePasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetLocalConsolePasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SetLocalConsolePasswordErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetLocalConsolePasswordErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for SetLocalConsolePasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetLocalConsolePasswordErrorKind::InternalServerError(_inner) => Some(_inner),
            SetLocalConsolePasswordErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            SetLocalConsolePasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetSMBGuestPasswordError {
    pub kind: SetSMBGuestPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetSMBGuestPasswordErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetSMBGuestPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetSMBGuestPasswordErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            SetSMBGuestPasswordErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            SetSMBGuestPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetSMBGuestPasswordError {
    fn code(&self) -> Option<&str> {
        SetSMBGuestPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetSMBGuestPasswordError {
    pub fn new(kind: SetSMBGuestPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetSMBGuestPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetSMBGuestPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            SetSMBGuestPasswordErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetSMBGuestPasswordErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for SetSMBGuestPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetSMBGuestPasswordErrorKind::InternalServerError(_inner) => Some(_inner),
            SetSMBGuestPasswordErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            SetSMBGuestPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ShutdownGatewayError {
    pub kind: ShutdownGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ShutdownGatewayErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ShutdownGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ShutdownGatewayErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ShutdownGatewayErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            ShutdownGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ShutdownGatewayError {
    fn code(&self) -> Option<&str> {
        ShutdownGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ShutdownGatewayError {
    pub fn new(kind: ShutdownGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ShutdownGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ShutdownGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, ShutdownGatewayErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ShutdownGatewayErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for ShutdownGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ShutdownGatewayErrorKind::InternalServerError(_inner) => Some(_inner),
            ShutdownGatewayErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            ShutdownGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartAvailabilityMonitorTestError {
    pub kind: StartAvailabilityMonitorTestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartAvailabilityMonitorTestErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartAvailabilityMonitorTestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartAvailabilityMonitorTestErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartAvailabilityMonitorTestErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            StartAvailabilityMonitorTestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartAvailabilityMonitorTestError {
    fn code(&self) -> Option<&str> {
        StartAvailabilityMonitorTestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartAvailabilityMonitorTestError {
    pub fn new(kind: StartAvailabilityMonitorTestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartAvailabilityMonitorTestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartAvailabilityMonitorTestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            StartAvailabilityMonitorTestErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartAvailabilityMonitorTestErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for StartAvailabilityMonitorTestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartAvailabilityMonitorTestErrorKind::InternalServerError(_inner) => Some(_inner),
            StartAvailabilityMonitorTestErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            StartAvailabilityMonitorTestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartGatewayError {
    pub kind: StartGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartGatewayErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartGatewayErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            StartGatewayErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            StartGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartGatewayError {
    fn code(&self) -> Option<&str> {
        StartGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartGatewayError {
    pub fn new(kind: StartGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, StartGatewayErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartGatewayErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for StartGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartGatewayErrorKind::InternalServerError(_inner) => Some(_inner),
            StartGatewayErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            StartGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAutomaticTapeCreationPolicyError {
    pub kind: UpdateAutomaticTapeCreationPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAutomaticTapeCreationPolicyErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAutomaticTapeCreationPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAutomaticTapeCreationPolicyErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            UpdateAutomaticTapeCreationPolicyErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAutomaticTapeCreationPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAutomaticTapeCreationPolicyError {
    fn code(&self) -> Option<&str> {
        UpdateAutomaticTapeCreationPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAutomaticTapeCreationPolicyError {
    pub fn new(
        kind: UpdateAutomaticTapeCreationPolicyErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAutomaticTapeCreationPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAutomaticTapeCreationPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAutomaticTapeCreationPolicyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAutomaticTapeCreationPolicyErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateAutomaticTapeCreationPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAutomaticTapeCreationPolicyErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateAutomaticTapeCreationPolicyErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateAutomaticTapeCreationPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBandwidthRateLimitError {
    pub kind: UpdateBandwidthRateLimitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBandwidthRateLimitErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBandwidthRateLimitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBandwidthRateLimitErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateBandwidthRateLimitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBandwidthRateLimitError {
    fn code(&self) -> Option<&str> {
        UpdateBandwidthRateLimitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBandwidthRateLimitError {
    pub fn new(kind: UpdateBandwidthRateLimitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBandwidthRateLimitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBandwidthRateLimitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBandwidthRateLimitErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateBandwidthRateLimitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBandwidthRateLimitErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateBandwidthRateLimitErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateBandwidthRateLimitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBandwidthRateLimitScheduleError {
    pub kind: UpdateBandwidthRateLimitScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBandwidthRateLimitScheduleErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBandwidthRateLimitScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBandwidthRateLimitScheduleErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateBandwidthRateLimitScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateBandwidthRateLimitScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBandwidthRateLimitScheduleError {
    fn code(&self) -> Option<&str> {
        UpdateBandwidthRateLimitScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBandwidthRateLimitScheduleError {
    pub fn new(kind: UpdateBandwidthRateLimitScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBandwidthRateLimitScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBandwidthRateLimitScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBandwidthRateLimitScheduleErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBandwidthRateLimitScheduleErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateBandwidthRateLimitScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBandwidthRateLimitScheduleErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateBandwidthRateLimitScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateBandwidthRateLimitScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateChapCredentialsError {
    pub kind: UpdateChapCredentialsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateChapCredentialsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateChapCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateChapCredentialsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateChapCredentialsErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            UpdateChapCredentialsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateChapCredentialsError {
    fn code(&self) -> Option<&str> {
        UpdateChapCredentialsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateChapCredentialsError {
    pub fn new(kind: UpdateChapCredentialsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateChapCredentialsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateChapCredentialsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChapCredentialsErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateChapCredentialsErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateChapCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateChapCredentialsErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateChapCredentialsErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            UpdateChapCredentialsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFileSystemAssociationError {
    pub kind: UpdateFileSystemAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFileSystemAssociationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFileSystemAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFileSystemAssociationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateFileSystemAssociationErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateFileSystemAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFileSystemAssociationError {
    fn code(&self) -> Option<&str> {
        UpdateFileSystemAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFileSystemAssociationError {
    pub fn new(kind: UpdateFileSystemAssociationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFileSystemAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFileSystemAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemAssociationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemAssociationErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateFileSystemAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFileSystemAssociationErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateFileSystemAssociationErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateFileSystemAssociationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGatewayInformationError {
    pub kind: UpdateGatewayInformationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGatewayInformationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGatewayInformationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGatewayInformationErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateGatewayInformationErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateGatewayInformationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGatewayInformationError {
    fn code(&self) -> Option<&str> {
        UpdateGatewayInformationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGatewayInformationError {
    pub fn new(kind: UpdateGatewayInformationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGatewayInformationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGatewayInformationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayInformationErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayInformationErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateGatewayInformationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGatewayInformationErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateGatewayInformationErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateGatewayInformationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGatewaySoftwareNowError {
    pub kind: UpdateGatewaySoftwareNowErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGatewaySoftwareNowErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGatewaySoftwareNowError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGatewaySoftwareNowErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateGatewaySoftwareNowErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateGatewaySoftwareNowErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGatewaySoftwareNowError {
    fn code(&self) -> Option<&str> {
        UpdateGatewaySoftwareNowError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGatewaySoftwareNowError {
    pub fn new(kind: UpdateGatewaySoftwareNowErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGatewaySoftwareNowErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGatewaySoftwareNowErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewaySoftwareNowErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewaySoftwareNowErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateGatewaySoftwareNowError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGatewaySoftwareNowErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateGatewaySoftwareNowErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateGatewaySoftwareNowErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMaintenanceStartTimeError {
    pub kind: UpdateMaintenanceStartTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMaintenanceStartTimeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMaintenanceStartTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMaintenanceStartTimeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateMaintenanceStartTimeErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateMaintenanceStartTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMaintenanceStartTimeError {
    fn code(&self) -> Option<&str> {
        UpdateMaintenanceStartTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMaintenanceStartTimeError {
    pub fn new(kind: UpdateMaintenanceStartTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMaintenanceStartTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMaintenanceStartTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceStartTimeErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMaintenanceStartTimeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateMaintenanceStartTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMaintenanceStartTimeErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateMaintenanceStartTimeErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateMaintenanceStartTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateNFSFileShareError {
    pub kind: UpdateNFSFileShareErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateNFSFileShareErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateNFSFileShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateNFSFileShareErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateNFSFileShareErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            UpdateNFSFileShareErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateNFSFileShareError {
    fn code(&self) -> Option<&str> {
        UpdateNFSFileShareError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateNFSFileShareError {
    pub fn new(kind: UpdateNFSFileShareErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateNFSFileShareErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateNFSFileShareErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNFSFileShareErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNFSFileShareErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateNFSFileShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateNFSFileShareErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateNFSFileShareErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            UpdateNFSFileShareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSMBFileShareError {
    pub kind: UpdateSMBFileShareErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSMBFileShareErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSMBFileShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSMBFileShareErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateSMBFileShareErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            UpdateSMBFileShareErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSMBFileShareError {
    fn code(&self) -> Option<&str> {
        UpdateSMBFileShareError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSMBFileShareError {
    pub fn new(kind: UpdateSMBFileShareErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSMBFileShareErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSMBFileShareErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSMBFileShareErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSMBFileShareErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateSMBFileShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSMBFileShareErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateSMBFileShareErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            UpdateSMBFileShareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSMBFileShareVisibilityError {
    pub kind: UpdateSMBFileShareVisibilityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSMBFileShareVisibilityErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSMBFileShareVisibilityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSMBFileShareVisibilityErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateSMBFileShareVisibilityErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSMBFileShareVisibilityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSMBFileShareVisibilityError {
    fn code(&self) -> Option<&str> {
        UpdateSMBFileShareVisibilityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSMBFileShareVisibilityError {
    pub fn new(kind: UpdateSMBFileShareVisibilityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSMBFileShareVisibilityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSMBFileShareVisibilityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSMBFileShareVisibilityErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSMBFileShareVisibilityErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateSMBFileShareVisibilityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSMBFileShareVisibilityErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateSMBFileShareVisibilityErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateSMBFileShareVisibilityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSMBSecurityStrategyError {
    pub kind: UpdateSMBSecurityStrategyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSMBSecurityStrategyErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSMBSecurityStrategyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSMBSecurityStrategyErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateSMBSecurityStrategyErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSMBSecurityStrategyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSMBSecurityStrategyError {
    fn code(&self) -> Option<&str> {
        UpdateSMBSecurityStrategyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSMBSecurityStrategyError {
    pub fn new(kind: UpdateSMBSecurityStrategyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSMBSecurityStrategyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSMBSecurityStrategyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSMBSecurityStrategyErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSMBSecurityStrategyErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateSMBSecurityStrategyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSMBSecurityStrategyErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateSMBSecurityStrategyErrorKind::InvalidGatewayRequestException(_inner) => {
                Some(_inner)
            }
            UpdateSMBSecurityStrategyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSnapshotScheduleError {
    pub kind: UpdateSnapshotScheduleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSnapshotScheduleErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSnapshotScheduleErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateSnapshotScheduleErrorKind::InvalidGatewayRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateSnapshotScheduleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        UpdateSnapshotScheduleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSnapshotScheduleError {
    pub fn new(kind: UpdateSnapshotScheduleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSnapshotScheduleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSnapshotScheduleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSnapshotScheduleErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSnapshotScheduleErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateSnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSnapshotScheduleErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateSnapshotScheduleErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            UpdateSnapshotScheduleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVTLDeviceTypeError {
    pub kind: UpdateVTLDeviceTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVTLDeviceTypeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidGatewayRequestException(crate::error::InvalidGatewayRequestException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVTLDeviceTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVTLDeviceTypeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateVTLDeviceTypeErrorKind::InvalidGatewayRequestException(_inner) => _inner.fmt(f),
            UpdateVTLDeviceTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVTLDeviceTypeError {
    fn code(&self) -> Option<&str> {
        UpdateVTLDeviceTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVTLDeviceTypeError {
    pub fn new(kind: UpdateVTLDeviceTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVTLDeviceTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVTLDeviceTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVTLDeviceTypeErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_gateway_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVTLDeviceTypeErrorKind::InvalidGatewayRequestException(_)
        )
    }
}
impl std::error::Error for UpdateVTLDeviceTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVTLDeviceTypeErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateVTLDeviceTypeErrorKind::InvalidGatewayRequestException(_inner) => Some(_inner),
            UpdateVTLDeviceTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>An exception occurred because an invalid gateway request was issued to the service. For
/// more information, see the error and message fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGatewayRequestException {
    /// <p>A human-readable message describing the error that occurred.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>A <a>StorageGatewayError</a> that provides more detail about the cause of the
    /// error.</p>
    pub error: std::option::Option<crate::model::StorageGatewayError>,
}
impl std::fmt::Debug for InvalidGatewayRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGatewayRequestException");
        formatter.field("message", &self.message);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
impl InvalidGatewayRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGatewayRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGatewayRequestException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGatewayRequestException {}
/// See [`InvalidGatewayRequestException`](crate::error::InvalidGatewayRequestException)
pub mod invalid_gateway_request_exception {
    /// A builder for [`InvalidGatewayRequestException`](crate::error::InvalidGatewayRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::StorageGatewayError>,
    }
    impl Builder {
        /// <p>A human-readable message describing the error that occurred.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>A <a>StorageGatewayError</a> that provides more detail about the cause of the
        /// error.</p>
        pub fn error(mut self, input: crate::model::StorageGatewayError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::StorageGatewayError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGatewayRequestException`](crate::error::InvalidGatewayRequestException)
        pub fn build(self) -> crate::error::InvalidGatewayRequestException {
            crate::error::InvalidGatewayRequestException {
                message: self.message,
                error: self.error,
            }
        }
    }
}
impl InvalidGatewayRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidGatewayRequestException`](crate::error::InvalidGatewayRequestException)
    pub fn builder() -> crate::error::invalid_gateway_request_exception::Builder {
        crate::error::invalid_gateway_request_exception::Builder::default()
    }
}

/// <p>An internal server error has occurred during the request. For more information, see the
/// error and message fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    /// <p>A human-readable message describing the error that occurred.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>A <a>StorageGatewayError</a> that provides more information about the cause
    /// of the error.</p>
    pub error: std::option::Option<crate::model::StorageGatewayError>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::StorageGatewayError>,
    }
    impl Builder {
        /// <p>A human-readable message describing the error that occurred.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>A <a>StorageGatewayError</a> that provides more information about the cause
        /// of the error.</p>
        pub fn error(mut self, input: crate::model::StorageGatewayError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::StorageGatewayError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
                error: self.error,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>An internal server error has occurred because the service is unavailable. For more
/// information, see the error and message fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableError {
    /// <p>A human-readable message describing the error that occurred.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>A <a>StorageGatewayError</a> that provides more information about the cause
    /// of the error.</p>
    pub error: std::option::Option<crate::model::StorageGatewayError>,
}
impl std::fmt::Debug for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableError");
        formatter.field("message", &self.message);
        formatter.field("error", &self.error);
        formatter.finish()
    }
}
impl ServiceUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableError {}
/// See [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
pub mod service_unavailable_error {
    /// A builder for [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<crate::model::StorageGatewayError>,
    }
    impl Builder {
        /// <p>A human-readable message describing the error that occurred.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>A <a>StorageGatewayError</a> that provides more information about the cause
        /// of the error.</p>
        pub fn error(mut self, input: crate::model::StorageGatewayError) -> Self {
            self.error = Some(input);
            self
        }
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::StorageGatewayError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
        pub fn build(self) -> crate::error::ServiceUnavailableError {
            crate::error::ServiceUnavailableError {
                message: self.message,
                error: self.error,
            }
        }
    }
}
impl ServiceUnavailableError {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    pub fn builder() -> crate::error::service_unavailable_error::Builder {
        crate::error::service_unavailable_error::Builder::default()
    }
}
