// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {
    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UndeprecateWorkflowTypeOutput {}
impl std::fmt::Debug for UndeprecateWorkflowTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UndeprecateWorkflowTypeOutput");
        formatter.finish()
    }
}
/// See [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput)
pub mod undeprecate_workflow_type_output {
    /// A builder for [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput)
        pub fn build(self) -> crate::output::UndeprecateWorkflowTypeOutput {
            crate::output::UndeprecateWorkflowTypeOutput {}
        }
    }
}
impl UndeprecateWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput)
    pub fn builder() -> crate::output::undeprecate_workflow_type_output::Builder {
        crate::output::undeprecate_workflow_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UndeprecateDomainOutput {}
impl std::fmt::Debug for UndeprecateDomainOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UndeprecateDomainOutput");
        formatter.finish()
    }
}
/// See [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput)
pub mod undeprecate_domain_output {
    /// A builder for [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput)
        pub fn build(self) -> crate::output::UndeprecateDomainOutput {
            crate::output::UndeprecateDomainOutput {}
        }
    }
}
impl UndeprecateDomainOutput {
    /// Creates a new builder-style object to manufacture [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput)
    pub fn builder() -> crate::output::undeprecate_domain_output::Builder {
        crate::output::undeprecate_domain_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UndeprecateActivityTypeOutput {}
impl std::fmt::Debug for UndeprecateActivityTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UndeprecateActivityTypeOutput");
        formatter.finish()
    }
}
/// See [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput)
pub mod undeprecate_activity_type_output {
    /// A builder for [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput)
        pub fn build(self) -> crate::output::UndeprecateActivityTypeOutput {
            crate::output::UndeprecateActivityTypeOutput {}
        }
    }
}
impl UndeprecateActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput)
    pub fn builder() -> crate::output::undeprecate_activity_type_output::Builder {
        crate::output::undeprecate_activity_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TerminateWorkflowExecutionOutput {}
impl std::fmt::Debug for TerminateWorkflowExecutionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TerminateWorkflowExecutionOutput");
        formatter.finish()
    }
}
/// See [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput)
pub mod terminate_workflow_execution_output {
    /// A builder for [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput)
        pub fn build(self) -> crate::output::TerminateWorkflowExecutionOutput {
            crate::output::TerminateWorkflowExecutionOutput {}
        }
    }
}
impl TerminateWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput)
    pub fn builder() -> crate::output::terminate_workflow_execution_output::Builder {
        crate::output::terminate_workflow_execution_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {
    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

/// <p>Specifies the <code>runId</code> of a workflow execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartWorkflowExecutionOutput {
    /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
    pub run_id: std::option::Option<std::string::String>,
}
impl StartWorkflowExecutionOutput {
    /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
}
impl std::fmt::Debug for StartWorkflowExecutionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartWorkflowExecutionOutput");
        formatter.field("run_id", &self.run_id);
        formatter.finish()
    }
}
/// See [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput)
pub mod start_workflow_execution_output {
    /// A builder for [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) run_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput)
        pub fn build(self) -> crate::output::StartWorkflowExecutionOutput {
            crate::output::StartWorkflowExecutionOutput {
                run_id: self.run_id,
            }
        }
    }
}
impl StartWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput)
    pub fn builder() -> crate::output::start_workflow_execution_output::Builder {
        crate::output::start_workflow_execution_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SignalWorkflowExecutionOutput {}
impl std::fmt::Debug for SignalWorkflowExecutionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SignalWorkflowExecutionOutput");
        formatter.finish()
    }
}
/// See [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput)
pub mod signal_workflow_execution_output {
    /// A builder for [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput)
        pub fn build(self) -> crate::output::SignalWorkflowExecutionOutput {
            crate::output::SignalWorkflowExecutionOutput {}
        }
    }
}
impl SignalWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput)
    pub fn builder() -> crate::output::signal_workflow_execution_output::Builder {
        crate::output::signal_workflow_execution_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RespondDecisionTaskCompletedOutput {}
impl std::fmt::Debug for RespondDecisionTaskCompletedOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RespondDecisionTaskCompletedOutput");
        formatter.finish()
    }
}
/// See [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput)
pub mod respond_decision_task_completed_output {
    /// A builder for [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput)
        pub fn build(self) -> crate::output::RespondDecisionTaskCompletedOutput {
            crate::output::RespondDecisionTaskCompletedOutput {}
        }
    }
}
impl RespondDecisionTaskCompletedOutput {
    /// Creates a new builder-style object to manufacture [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput)
    pub fn builder() -> crate::output::respond_decision_task_completed_output::Builder {
        crate::output::respond_decision_task_completed_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RespondActivityTaskFailedOutput {}
impl std::fmt::Debug for RespondActivityTaskFailedOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RespondActivityTaskFailedOutput");
        formatter.finish()
    }
}
/// See [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput)
pub mod respond_activity_task_failed_output {
    /// A builder for [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput)
        pub fn build(self) -> crate::output::RespondActivityTaskFailedOutput {
            crate::output::RespondActivityTaskFailedOutput {}
        }
    }
}
impl RespondActivityTaskFailedOutput {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput)
    pub fn builder() -> crate::output::respond_activity_task_failed_output::Builder {
        crate::output::respond_activity_task_failed_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RespondActivityTaskCompletedOutput {}
impl std::fmt::Debug for RespondActivityTaskCompletedOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RespondActivityTaskCompletedOutput");
        formatter.finish()
    }
}
/// See [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput)
pub mod respond_activity_task_completed_output {
    /// A builder for [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput)
        pub fn build(self) -> crate::output::RespondActivityTaskCompletedOutput {
            crate::output::RespondActivityTaskCompletedOutput {}
        }
    }
}
impl RespondActivityTaskCompletedOutput {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput)
    pub fn builder() -> crate::output::respond_activity_task_completed_output::Builder {
        crate::output::respond_activity_task_completed_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RespondActivityTaskCanceledOutput {}
impl std::fmt::Debug for RespondActivityTaskCanceledOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RespondActivityTaskCanceledOutput");
        formatter.finish()
    }
}
/// See [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput)
pub mod respond_activity_task_canceled_output {
    /// A builder for [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput)
        pub fn build(self) -> crate::output::RespondActivityTaskCanceledOutput {
            crate::output::RespondActivityTaskCanceledOutput {}
        }
    }
}
impl RespondActivityTaskCanceledOutput {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput)
    pub fn builder() -> crate::output::respond_activity_task_canceled_output::Builder {
        crate::output::respond_activity_task_canceled_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestCancelWorkflowExecutionOutput {}
impl std::fmt::Debug for RequestCancelWorkflowExecutionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestCancelWorkflowExecutionOutput");
        formatter.finish()
    }
}
/// See [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput)
pub mod request_cancel_workflow_execution_output {
    /// A builder for [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput)
        pub fn build(self) -> crate::output::RequestCancelWorkflowExecutionOutput {
            crate::output::RequestCancelWorkflowExecutionOutput {}
        }
    }
}
impl RequestCancelWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput)
    pub fn builder() -> crate::output::request_cancel_workflow_execution_output::Builder {
        crate::output::request_cancel_workflow_execution_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterWorkflowTypeOutput {}
impl std::fmt::Debug for RegisterWorkflowTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterWorkflowTypeOutput");
        formatter.finish()
    }
}
/// See [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput)
pub mod register_workflow_type_output {
    /// A builder for [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput)
        pub fn build(self) -> crate::output::RegisterWorkflowTypeOutput {
            crate::output::RegisterWorkflowTypeOutput {}
        }
    }
}
impl RegisterWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput)
    pub fn builder() -> crate::output::register_workflow_type_output::Builder {
        crate::output::register_workflow_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterDomainOutput {}
impl std::fmt::Debug for RegisterDomainOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterDomainOutput");
        formatter.finish()
    }
}
/// See [`RegisterDomainOutput`](crate::output::RegisterDomainOutput)
pub mod register_domain_output {
    /// A builder for [`RegisterDomainOutput`](crate::output::RegisterDomainOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RegisterDomainOutput`](crate::output::RegisterDomainOutput)
        pub fn build(self) -> crate::output::RegisterDomainOutput {
            crate::output::RegisterDomainOutput {}
        }
    }
}
impl RegisterDomainOutput {
    /// Creates a new builder-style object to manufacture [`RegisterDomainOutput`](crate::output::RegisterDomainOutput)
    pub fn builder() -> crate::output::register_domain_output::Builder {
        crate::output::register_domain_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterActivityTypeOutput {}
impl std::fmt::Debug for RegisterActivityTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterActivityTypeOutput");
        formatter.finish()
    }
}
/// See [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput)
pub mod register_activity_type_output {
    /// A builder for [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput)
        pub fn build(self) -> crate::output::RegisterActivityTypeOutput {
            crate::output::RegisterActivityTypeOutput {}
        }
    }
}
impl RegisterActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput)
    pub fn builder() -> crate::output::register_activity_type_output::Builder {
        crate::output::register_activity_type_output::Builder::default()
    }
}

/// <p>Status information about an activity task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecordActivityTaskHeartbeatOutput {
    /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
    pub cancel_requested: bool,
}
impl RecordActivityTaskHeartbeatOutput {
    /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
    pub fn cancel_requested(&self) -> bool {
        self.cancel_requested
    }
}
impl std::fmt::Debug for RecordActivityTaskHeartbeatOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecordActivityTaskHeartbeatOutput");
        formatter.field("cancel_requested", &self.cancel_requested);
        formatter.finish()
    }
}
/// See [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput)
pub mod record_activity_task_heartbeat_output {
    /// A builder for [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cancel_requested: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
        pub fn cancel_requested(mut self, input: bool) -> Self {
            self.cancel_requested = Some(input);
            self
        }
        /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
        pub fn set_cancel_requested(mut self, input: std::option::Option<bool>) -> Self {
            self.cancel_requested = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput)
        pub fn build(self) -> crate::output::RecordActivityTaskHeartbeatOutput {
            crate::output::RecordActivityTaskHeartbeatOutput {
                cancel_requested: self.cancel_requested.unwrap_or_default(),
            }
        }
    }
}
impl RecordActivityTaskHeartbeatOutput {
    /// Creates a new builder-style object to manufacture [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput)
    pub fn builder() -> crate::output::record_activity_task_heartbeat_output::Builder {
        crate::output::record_activity_task_heartbeat_output::Builder::default()
    }
}

/// <p>A structure that represents a decision task. Decision tasks are sent to deciders in order for them to make decisions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PollForDecisionTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    pub task_token: std::option::Option<std::string::String>,
    /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
    pub started_event_id: i64,
    /// <p>The workflow execution for which this decision task was created.</p>
    pub workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
    /// <p>The type of the workflow execution for which this decision task was created.</p>
    pub workflow_type: std::option::Option<crate::model::WorkflowType>,
    /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
    pub events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
    pub previous_started_event_id: i64,
}
impl PollForDecisionTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    pub fn task_token(&self) -> std::option::Option<&str> {
        self.task_token.as_deref()
    }
    /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
    pub fn started_event_id(&self) -> i64 {
        self.started_event_id
    }
    /// <p>The workflow execution for which this decision task was created.</p>
    pub fn workflow_execution(&self) -> std::option::Option<&crate::model::WorkflowExecution> {
        self.workflow_execution.as_ref()
    }
    /// <p>The type of the workflow execution for which this decision task was created.</p>
    pub fn workflow_type(&self) -> std::option::Option<&crate::model::WorkflowType> {
        self.workflow_type.as_ref()
    }
    /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
    pub fn events(&self) -> std::option::Option<&[crate::model::HistoryEvent]> {
        self.events.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
    pub fn previous_started_event_id(&self) -> i64 {
        self.previous_started_event_id
    }
}
impl std::fmt::Debug for PollForDecisionTaskOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PollForDecisionTaskOutput");
        formatter.field("task_token", &self.task_token);
        formatter.field("started_event_id", &self.started_event_id);
        formatter.field("workflow_execution", &self.workflow_execution);
        formatter.field("workflow_type", &self.workflow_type);
        formatter.field("events", &self.events);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.field("previous_started_event_id", &self.previous_started_event_id);
        formatter.finish()
    }
}
/// See [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput)
pub mod poll_for_decision_task_output {
    /// A builder for [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_token: std::option::Option<std::string::String>,
        pub(crate) started_event_id: std::option::Option<i64>,
        pub(crate) workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
        pub(crate) workflow_type: std::option::Option<crate::model::WorkflowType>,
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) previous_started_event_id: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_token = Some(input.into());
            self
        }
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_token = input;
            self
        }
        /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
        pub fn started_event_id(mut self, input: i64) -> Self {
            self.started_event_id = Some(input);
            self
        }
        /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
        pub fn set_started_event_id(mut self, input: std::option::Option<i64>) -> Self {
            self.started_event_id = input;
            self
        }
        /// <p>The workflow execution for which this decision task was created.</p>
        pub fn workflow_execution(mut self, input: crate::model::WorkflowExecution) -> Self {
            self.workflow_execution = Some(input);
            self
        }
        /// <p>The workflow execution for which this decision task was created.</p>
        pub fn set_workflow_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.workflow_execution = input;
            self
        }
        /// <p>The type of the workflow execution for which this decision task was created.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.workflow_type = Some(input);
            self
        }
        /// <p>The type of the workflow execution for which this decision task was created.</p>
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.workflow_type = input;
            self
        }
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
        pub fn events(mut self, input: crate::model::HistoryEvent) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
        pub fn previous_started_event_id(mut self, input: i64) -> Self {
            self.previous_started_event_id = Some(input);
            self
        }
        /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
        pub fn set_previous_started_event_id(mut self, input: std::option::Option<i64>) -> Self {
            self.previous_started_event_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput)
        pub fn build(self) -> crate::output::PollForDecisionTaskOutput {
            crate::output::PollForDecisionTaskOutput {
                task_token: self.task_token,
                started_event_id: self.started_event_id.unwrap_or_default(),
                workflow_execution: self.workflow_execution,
                workflow_type: self.workflow_type,
                events: self.events,
                next_page_token: self.next_page_token,
                previous_started_event_id: self.previous_started_event_id.unwrap_or_default(),
            }
        }
    }
}
impl PollForDecisionTaskOutput {
    /// Creates a new builder-style object to manufacture [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput)
    pub fn builder() -> crate::output::poll_for_decision_task_output::Builder {
        crate::output::poll_for_decision_task_output::Builder::default()
    }
}

/// <p>Unit of work sent to an activity worker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PollForActivityTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    pub task_token: std::option::Option<std::string::String>,
    /// <p>The unique ID of the task.</p>
    pub activity_id: std::option::Option<std::string::String>,
    /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
    pub started_event_id: i64,
    /// <p>The workflow execution that started this activity task.</p>
    pub workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
    /// <p>The type of this activity task.</p>
    pub activity_type: std::option::Option<crate::model::ActivityType>,
    /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
    pub input: std::option::Option<std::string::String>,
}
impl PollForActivityTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    pub fn task_token(&self) -> std::option::Option<&str> {
        self.task_token.as_deref()
    }
    /// <p>The unique ID of the task.</p>
    pub fn activity_id(&self) -> std::option::Option<&str> {
        self.activity_id.as_deref()
    }
    /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
    pub fn started_event_id(&self) -> i64 {
        self.started_event_id
    }
    /// <p>The workflow execution that started this activity task.</p>
    pub fn workflow_execution(&self) -> std::option::Option<&crate::model::WorkflowExecution> {
        self.workflow_execution.as_ref()
    }
    /// <p>The type of this activity task.</p>
    pub fn activity_type(&self) -> std::option::Option<&crate::model::ActivityType> {
        self.activity_type.as_ref()
    }
    /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
    pub fn input(&self) -> std::option::Option<&str> {
        self.input.as_deref()
    }
}
impl std::fmt::Debug for PollForActivityTaskOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PollForActivityTaskOutput");
        formatter.field("task_token", &self.task_token);
        formatter.field("activity_id", &self.activity_id);
        formatter.field("started_event_id", &self.started_event_id);
        formatter.field("workflow_execution", &self.workflow_execution);
        formatter.field("activity_type", &self.activity_type);
        formatter.field("input", &self.input);
        formatter.finish()
    }
}
/// See [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput)
pub mod poll_for_activity_task_output {
    /// A builder for [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_token: std::option::Option<std::string::String>,
        pub(crate) activity_id: std::option::Option<std::string::String>,
        pub(crate) started_event_id: std::option::Option<i64>,
        pub(crate) workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
        pub(crate) activity_type: std::option::Option<crate::model::ActivityType>,
        pub(crate) input: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_token = Some(input.into());
            self
        }
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_token = input;
            self
        }
        /// <p>The unique ID of the task.</p>
        pub fn activity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.activity_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the task.</p>
        pub fn set_activity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.activity_id = input;
            self
        }
        /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
        pub fn started_event_id(mut self, input: i64) -> Self {
            self.started_event_id = Some(input);
            self
        }
        /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
        pub fn set_started_event_id(mut self, input: std::option::Option<i64>) -> Self {
            self.started_event_id = input;
            self
        }
        /// <p>The workflow execution that started this activity task.</p>
        pub fn workflow_execution(mut self, input: crate::model::WorkflowExecution) -> Self {
            self.workflow_execution = Some(input);
            self
        }
        /// <p>The workflow execution that started this activity task.</p>
        pub fn set_workflow_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.workflow_execution = input;
            self
        }
        /// <p>The type of this activity task.</p>
        pub fn activity_type(mut self, input: crate::model::ActivityType) -> Self {
            self.activity_type = Some(input);
            self
        }
        /// <p>The type of this activity task.</p>
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.activity_type = input;
            self
        }
        /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.input = Some(input.into());
            self
        }
        /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input = input;
            self
        }
        /// Consumes the builder and constructs a [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput)
        pub fn build(self) -> crate::output::PollForActivityTaskOutput {
            crate::output::PollForActivityTaskOutput {
                task_token: self.task_token,
                activity_id: self.activity_id,
                started_event_id: self.started_event_id.unwrap_or_default(),
                workflow_execution: self.workflow_execution,
                activity_type: self.activity_type,
                input: self.input,
            }
        }
    }
}
impl PollForActivityTaskOutput {
    /// Creates a new builder-style object to manufacture [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput)
    pub fn builder() -> crate::output::poll_for_activity_task_output::Builder {
        crate::output::poll_for_activity_task_output::Builder::default()
    }
}

/// <p>Contains a paginated list of information structures about workflow types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListWorkflowTypesOutput {
    /// <p>The list of workflow type information.</p>
    pub type_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowTypeInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
}
impl ListWorkflowTypesOutput {
    /// <p>The list of workflow type information.</p>
    pub fn type_infos(&self) -> std::option::Option<&[crate::model::WorkflowTypeInfo]> {
        self.type_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl std::fmt::Debug for ListWorkflowTypesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListWorkflowTypesOutput");
        formatter.field("type_infos", &self.type_infos);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.finish()
    }
}
/// See [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput)
pub mod list_workflow_types_output {
    /// A builder for [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowTypeInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `type_infos`.
        ///
        /// To override the contents of this collection use [`set_type_infos`](Self::set_type_infos).
        ///
        /// <p>The list of workflow type information.</p>
        pub fn type_infos(mut self, input: crate::model::WorkflowTypeInfo) -> Self {
            let mut v = self.type_infos.unwrap_or_default();
            v.push(input);
            self.type_infos = Some(v);
            self
        }
        /// <p>The list of workflow type information.</p>
        pub fn set_type_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowTypeInfo>>,
        ) -> Self {
            self.type_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput)
        pub fn build(self) -> crate::output::ListWorkflowTypesOutput {
            crate::output::ListWorkflowTypesOutput {
                type_infos: self.type_infos,
                next_page_token: self.next_page_token,
            }
        }
    }
}
impl ListWorkflowTypesOutput {
    /// Creates a new builder-style object to manufacture [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput)
    pub fn builder() -> crate::output::list_workflow_types_output::Builder {
        crate::output::list_workflow_types_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>An array of tags associated with the domain.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
}
impl ListTagsForResourceOutput {
    /// <p>An array of tags associated with the domain.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {
    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    }
    impl Builder {
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An array of tags associated with the domain.</p>
        pub fn tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>An array of tags associated with the domain.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput { tags: self.tags }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

/// <p>Contains a paginated list of information about workflow executions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOpenWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    pub execution_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
}
impl ListOpenWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    pub fn execution_infos(&self) -> std::option::Option<&[crate::model::WorkflowExecutionInfo]> {
        self.execution_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl std::fmt::Debug for ListOpenWorkflowExecutionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOpenWorkflowExecutionsOutput");
        formatter.field("execution_infos", &self.execution_infos);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.finish()
    }
}
/// See [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput)
pub mod list_open_workflow_executions_output {
    /// A builder for [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_infos:
            std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `execution_infos`.
        ///
        /// To override the contents of this collection use [`set_execution_infos`](Self::set_execution_infos).
        ///
        /// <p>The list of workflow information structures.</p>
        pub fn execution_infos(mut self, input: crate::model::WorkflowExecutionInfo) -> Self {
            let mut v = self.execution_infos.unwrap_or_default();
            v.push(input);
            self.execution_infos = Some(v);
            self
        }
        /// <p>The list of workflow information structures.</p>
        pub fn set_execution_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        ) -> Self {
            self.execution_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput)
        pub fn build(self) -> crate::output::ListOpenWorkflowExecutionsOutput {
            crate::output::ListOpenWorkflowExecutionsOutput {
                execution_infos: self.execution_infos,
                next_page_token: self.next_page_token,
            }
        }
    }
}
impl ListOpenWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput)
    pub fn builder() -> crate::output::list_open_workflow_executions_output::Builder {
        crate::output::list_open_workflow_executions_output::Builder::default()
    }
}

/// <p>Contains a paginated collection of DomainInfo structures.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDomainsOutput {
    /// <p>A list of DomainInfo structures.</p>
    pub domain_infos: std::option::Option<std::vec::Vec<crate::model::DomainInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
}
impl ListDomainsOutput {
    /// <p>A list of DomainInfo structures.</p>
    pub fn domain_infos(&self) -> std::option::Option<&[crate::model::DomainInfo]> {
        self.domain_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl std::fmt::Debug for ListDomainsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDomainsOutput");
        formatter.field("domain_infos", &self.domain_infos);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.finish()
    }
}
/// See [`ListDomainsOutput`](crate::output::ListDomainsOutput)
pub mod list_domains_output {
    /// A builder for [`ListDomainsOutput`](crate::output::ListDomainsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_infos: std::option::Option<std::vec::Vec<crate::model::DomainInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `domain_infos`.
        ///
        /// To override the contents of this collection use [`set_domain_infos`](Self::set_domain_infos).
        ///
        /// <p>A list of DomainInfo structures.</p>
        pub fn domain_infos(mut self, input: crate::model::DomainInfo) -> Self {
            let mut v = self.domain_infos.unwrap_or_default();
            v.push(input);
            self.domain_infos = Some(v);
            self
        }
        /// <p>A list of DomainInfo structures.</p>
        pub fn set_domain_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DomainInfo>>,
        ) -> Self {
            self.domain_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDomainsOutput`](crate::output::ListDomainsOutput)
        pub fn build(self) -> crate::output::ListDomainsOutput {
            crate::output::ListDomainsOutput {
                domain_infos: self.domain_infos,
                next_page_token: self.next_page_token,
            }
        }
    }
}
impl ListDomainsOutput {
    /// Creates a new builder-style object to manufacture [`ListDomainsOutput`](crate::output::ListDomainsOutput)
    pub fn builder() -> crate::output::list_domains_output::Builder {
        crate::output::list_domains_output::Builder::default()
    }
}

/// <p>Contains a paginated list of information about workflow executions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListClosedWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    pub execution_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
}
impl ListClosedWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    pub fn execution_infos(&self) -> std::option::Option<&[crate::model::WorkflowExecutionInfo]> {
        self.execution_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl std::fmt::Debug for ListClosedWorkflowExecutionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListClosedWorkflowExecutionsOutput");
        formatter.field("execution_infos", &self.execution_infos);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.finish()
    }
}
/// See [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput)
pub mod list_closed_workflow_executions_output {
    /// A builder for [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_infos:
            std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `execution_infos`.
        ///
        /// To override the contents of this collection use [`set_execution_infos`](Self::set_execution_infos).
        ///
        /// <p>The list of workflow information structures.</p>
        pub fn execution_infos(mut self, input: crate::model::WorkflowExecutionInfo) -> Self {
            let mut v = self.execution_infos.unwrap_or_default();
            v.push(input);
            self.execution_infos = Some(v);
            self
        }
        /// <p>The list of workflow information structures.</p>
        pub fn set_execution_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        ) -> Self {
            self.execution_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput)
        pub fn build(self) -> crate::output::ListClosedWorkflowExecutionsOutput {
            crate::output::ListClosedWorkflowExecutionsOutput {
                execution_infos: self.execution_infos,
                next_page_token: self.next_page_token,
            }
        }
    }
}
impl ListClosedWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput)
    pub fn builder() -> crate::output::list_closed_workflow_executions_output::Builder {
        crate::output::list_closed_workflow_executions_output::Builder::default()
    }
}

/// <p>Contains a paginated list of activity type information structures.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListActivityTypesOutput {
    /// <p>List of activity type information.</p>
    pub type_infos: std::option::Option<std::vec::Vec<crate::model::ActivityTypeInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
}
impl ListActivityTypesOutput {
    /// <p>List of activity type information.</p>
    pub fn type_infos(&self) -> std::option::Option<&[crate::model::ActivityTypeInfo]> {
        self.type_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl std::fmt::Debug for ListActivityTypesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListActivityTypesOutput");
        formatter.field("type_infos", &self.type_infos);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.finish()
    }
}
/// See [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput)
pub mod list_activity_types_output {
    /// A builder for [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_infos: std::option::Option<std::vec::Vec<crate::model::ActivityTypeInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `type_infos`.
        ///
        /// To override the contents of this collection use [`set_type_infos`](Self::set_type_infos).
        ///
        /// <p>List of activity type information.</p>
        pub fn type_infos(mut self, input: crate::model::ActivityTypeInfo) -> Self {
            let mut v = self.type_infos.unwrap_or_default();
            v.push(input);
            self.type_infos = Some(v);
            self
        }
        /// <p>List of activity type information.</p>
        pub fn set_type_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ActivityTypeInfo>>,
        ) -> Self {
            self.type_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput)
        pub fn build(self) -> crate::output::ListActivityTypesOutput {
            crate::output::ListActivityTypesOutput {
                type_infos: self.type_infos,
                next_page_token: self.next_page_token,
            }
        }
    }
}
impl ListActivityTypesOutput {
    /// Creates a new builder-style object to manufacture [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput)
    pub fn builder() -> crate::output::list_activity_types_output::Builder {
        crate::output::list_activity_types_output::Builder::default()
    }
}

/// <p>Paginated representation of a workflow history for a workflow execution. This is the up to date, complete and authoritative record of the events related to all tasks and events in the life of the workflow execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetWorkflowExecutionHistoryOutput {
    /// <p>The list of history events.</p>
    pub events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetWorkflowExecutionHistoryOutput {
    /// <p>The list of history events.</p>
    pub fn events(&self) -> std::option::Option<&[crate::model::HistoryEvent]> {
        self.events.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl std::fmt::Debug for GetWorkflowExecutionHistoryOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetWorkflowExecutionHistoryOutput");
        formatter.field("events", &self.events);
        formatter.field("next_page_token", &self.next_page_token);
        formatter.finish()
    }
}
/// See [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput)
pub mod get_workflow_execution_history_output {
    /// A builder for [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The list of history events.</p>
        pub fn events(mut self, input: crate::model::HistoryEvent) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p>The list of history events.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput)
        pub fn build(self) -> crate::output::GetWorkflowExecutionHistoryOutput {
            crate::output::GetWorkflowExecutionHistoryOutput {
                events: self.events,
                next_page_token: self.next_page_token,
            }
        }
    }
}
impl GetWorkflowExecutionHistoryOutput {
    /// Creates a new builder-style object to manufacture [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput)
    pub fn builder() -> crate::output::get_workflow_execution_history_output::Builder {
        crate::output::get_workflow_execution_history_output::Builder::default()
    }
}

/// <p>Contains details about a workflow type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeWorkflowTypeOutput {
    /// <p>General information about the workflow type.</p>
    /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running.</p> </li>
    /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
    /// </ul>
    pub type_info: std::option::Option<crate::model::WorkflowTypeInfo>,
    /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
    pub configuration: std::option::Option<crate::model::WorkflowTypeConfiguration>,
}
impl DescribeWorkflowTypeOutput {
    /// <p>General information about the workflow type.</p>
    /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running.</p> </li>
    /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
    /// </ul>
    pub fn type_info(&self) -> std::option::Option<&crate::model::WorkflowTypeInfo> {
        self.type_info.as_ref()
    }
    /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::WorkflowTypeConfiguration> {
        self.configuration.as_ref()
    }
}
impl std::fmt::Debug for DescribeWorkflowTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeWorkflowTypeOutput");
        formatter.field("type_info", &self.type_info);
        formatter.field("configuration", &self.configuration);
        formatter.finish()
    }
}
/// See [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput)
pub mod describe_workflow_type_output {
    /// A builder for [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_info: std::option::Option<crate::model::WorkflowTypeInfo>,
        pub(crate) configuration: std::option::Option<crate::model::WorkflowTypeConfiguration>,
    }
    impl Builder {
        /// <p>General information about the workflow type.</p>
        /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running.</p> </li>
        /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
        /// </ul>
        pub fn type_info(mut self, input: crate::model::WorkflowTypeInfo) -> Self {
            self.type_info = Some(input);
            self
        }
        /// <p>General information about the workflow type.</p>
        /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running.</p> </li>
        /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
        /// </ul>
        pub fn set_type_info(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeInfo>,
        ) -> Self {
            self.type_info = input;
            self
        }
        /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
        pub fn configuration(mut self, input: crate::model::WorkflowTypeConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput)
        pub fn build(self) -> crate::output::DescribeWorkflowTypeOutput {
            crate::output::DescribeWorkflowTypeOutput {
                type_info: self.type_info,
                configuration: self.configuration,
            }
        }
    }
}
impl DescribeWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput)
    pub fn builder() -> crate::output::describe_workflow_type_output::Builder {
        crate::output::describe_workflow_type_output::Builder::default()
    }
}

/// <p>Contains details about a workflow execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeWorkflowExecutionOutput {
    /// <p>Information about the workflow execution.</p>
    pub execution_info: std::option::Option<crate::model::WorkflowExecutionInfo>,
    /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
    pub execution_configuration: std::option::Option<crate::model::WorkflowExecutionConfiguration>,
    /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
    pub open_counts: std::option::Option<crate::model::WorkflowExecutionOpenCounts>,
    /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
    pub latest_activity_task_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
    pub latest_execution_context: std::option::Option<std::string::String>,
}
impl DescribeWorkflowExecutionOutput {
    /// <p>Information about the workflow execution.</p>
    pub fn execution_info(&self) -> std::option::Option<&crate::model::WorkflowExecutionInfo> {
        self.execution_info.as_ref()
    }
    /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
    pub fn execution_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WorkflowExecutionConfiguration> {
        self.execution_configuration.as_ref()
    }
    /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
    pub fn open_counts(&self) -> std::option::Option<&crate::model::WorkflowExecutionOpenCounts> {
        self.open_counts.as_ref()
    }
    /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
    pub fn latest_activity_task_timestamp(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_activity_task_timestamp.as_ref()
    }
    /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
    pub fn latest_execution_context(&self) -> std::option::Option<&str> {
        self.latest_execution_context.as_deref()
    }
}
impl std::fmt::Debug for DescribeWorkflowExecutionOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeWorkflowExecutionOutput");
        formatter.field("execution_info", &self.execution_info);
        formatter.field("execution_configuration", &self.execution_configuration);
        formatter.field("open_counts", &self.open_counts);
        formatter.field(
            "latest_activity_task_timestamp",
            &self.latest_activity_task_timestamp,
        );
        formatter.field("latest_execution_context", &self.latest_execution_context);
        formatter.finish()
    }
}
/// See [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput)
pub mod describe_workflow_execution_output {
    /// A builder for [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_info: std::option::Option<crate::model::WorkflowExecutionInfo>,
        pub(crate) execution_configuration:
            std::option::Option<crate::model::WorkflowExecutionConfiguration>,
        pub(crate) open_counts: std::option::Option<crate::model::WorkflowExecutionOpenCounts>,
        pub(crate) latest_activity_task_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) latest_execution_context: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the workflow execution.</p>
        pub fn execution_info(mut self, input: crate::model::WorkflowExecutionInfo) -> Self {
            self.execution_info = Some(input);
            self
        }
        /// <p>Information about the workflow execution.</p>
        pub fn set_execution_info(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionInfo>,
        ) -> Self {
            self.execution_info = input;
            self
        }
        /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
        pub fn execution_configuration(
            mut self,
            input: crate::model::WorkflowExecutionConfiguration,
        ) -> Self {
            self.execution_configuration = Some(input);
            self
        }
        /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
        pub fn set_execution_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionConfiguration>,
        ) -> Self {
            self.execution_configuration = input;
            self
        }
        /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
        pub fn open_counts(mut self, input: crate::model::WorkflowExecutionOpenCounts) -> Self {
            self.open_counts = Some(input);
            self
        }
        /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
        pub fn set_open_counts(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionOpenCounts>,
        ) -> Self {
            self.open_counts = input;
            self
        }
        /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
        pub fn latest_activity_task_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_activity_task_timestamp = Some(input);
            self
        }
        /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
        pub fn set_latest_activity_task_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_activity_task_timestamp = input;
            self
        }
        /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
        pub fn latest_execution_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_execution_context = Some(input.into());
            self
        }
        /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
        pub fn set_latest_execution_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_execution_context = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput)
        pub fn build(self) -> crate::output::DescribeWorkflowExecutionOutput {
            crate::output::DescribeWorkflowExecutionOutput {
                execution_info: self.execution_info,
                execution_configuration: self.execution_configuration,
                open_counts: self.open_counts,
                latest_activity_task_timestamp: self.latest_activity_task_timestamp,
                latest_execution_context: self.latest_execution_context,
            }
        }
    }
}
impl DescribeWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput)
    pub fn builder() -> crate::output::describe_workflow_execution_output::Builder {
        crate::output::describe_workflow_execution_output::Builder::default()
    }
}

/// <p>Contains details of a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDomainOutput {
    /// <p>The basic information about a domain, such as its name, status, and description.</p>
    pub domain_info: std::option::Option<crate::model::DomainInfo>,
    /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
    pub configuration: std::option::Option<crate::model::DomainConfiguration>,
}
impl DescribeDomainOutput {
    /// <p>The basic information about a domain, such as its name, status, and description.</p>
    pub fn domain_info(&self) -> std::option::Option<&crate::model::DomainInfo> {
        self.domain_info.as_ref()
    }
    /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::DomainConfiguration> {
        self.configuration.as_ref()
    }
}
impl std::fmt::Debug for DescribeDomainOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDomainOutput");
        formatter.field("domain_info", &self.domain_info);
        formatter.field("configuration", &self.configuration);
        formatter.finish()
    }
}
/// See [`DescribeDomainOutput`](crate::output::DescribeDomainOutput)
pub mod describe_domain_output {
    /// A builder for [`DescribeDomainOutput`](crate::output::DescribeDomainOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_info: std::option::Option<crate::model::DomainInfo>,
        pub(crate) configuration: std::option::Option<crate::model::DomainConfiguration>,
    }
    impl Builder {
        /// <p>The basic information about a domain, such as its name, status, and description.</p>
        pub fn domain_info(mut self, input: crate::model::DomainInfo) -> Self {
            self.domain_info = Some(input);
            self
        }
        /// <p>The basic information about a domain, such as its name, status, and description.</p>
        pub fn set_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInfo>,
        ) -> Self {
            self.domain_info = input;
            self
        }
        /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
        pub fn configuration(mut self, input: crate::model::DomainConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::DomainConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDomainOutput`](crate::output::DescribeDomainOutput)
        pub fn build(self) -> crate::output::DescribeDomainOutput {
            crate::output::DescribeDomainOutput {
                domain_info: self.domain_info,
                configuration: self.configuration,
            }
        }
    }
}
impl DescribeDomainOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDomainOutput`](crate::output::DescribeDomainOutput)
    pub fn builder() -> crate::output::describe_domain_output::Builder {
        crate::output::describe_domain_output::Builder::default()
    }
}

/// <p>Detailed information about an activity type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeActivityTypeOutput {
    /// <p>General information about the activity type.</p>
    /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running. </p> </li>
    /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
    /// </ul>
    pub type_info: std::option::Option<crate::model::ActivityTypeInfo>,
    /// <p>The configuration settings registered with the activity type.</p>
    pub configuration: std::option::Option<crate::model::ActivityTypeConfiguration>,
}
impl DescribeActivityTypeOutput {
    /// <p>General information about the activity type.</p>
    /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running. </p> </li>
    /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
    /// </ul>
    pub fn type_info(&self) -> std::option::Option<&crate::model::ActivityTypeInfo> {
        self.type_info.as_ref()
    }
    /// <p>The configuration settings registered with the activity type.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::ActivityTypeConfiguration> {
        self.configuration.as_ref()
    }
}
impl std::fmt::Debug for DescribeActivityTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeActivityTypeOutput");
        formatter.field("type_info", &self.type_info);
        formatter.field("configuration", &self.configuration);
        formatter.finish()
    }
}
/// See [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput)
pub mod describe_activity_type_output {
    /// A builder for [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_info: std::option::Option<crate::model::ActivityTypeInfo>,
        pub(crate) configuration: std::option::Option<crate::model::ActivityTypeConfiguration>,
    }
    impl Builder {
        /// <p>General information about the activity type.</p>
        /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running. </p> </li>
        /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
        /// </ul>
        pub fn type_info(mut self, input: crate::model::ActivityTypeInfo) -> Self {
            self.type_info = Some(input);
            self
        }
        /// <p>General information about the activity type.</p>
        /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code> – The type is registered and available. Workers supporting this type should be running. </p> </li>
        /// <li> <p> <code>DEPRECATED</code> – The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
        /// </ul>
        pub fn set_type_info(
            mut self,
            input: std::option::Option<crate::model::ActivityTypeInfo>,
        ) -> Self {
            self.type_info = input;
            self
        }
        /// <p>The configuration settings registered with the activity type.</p>
        pub fn configuration(mut self, input: crate::model::ActivityTypeConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration settings registered with the activity type.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ActivityTypeConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput)
        pub fn build(self) -> crate::output::DescribeActivityTypeOutput {
            crate::output::DescribeActivityTypeOutput {
                type_info: self.type_info,
                configuration: self.configuration,
            }
        }
    }
}
impl DescribeActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput)
    pub fn builder() -> crate::output::describe_activity_type_output::Builder {
        crate::output::describe_activity_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeprecateWorkflowTypeOutput {}
impl std::fmt::Debug for DeprecateWorkflowTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeprecateWorkflowTypeOutput");
        formatter.finish()
    }
}
/// See [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput)
pub mod deprecate_workflow_type_output {
    /// A builder for [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput)
        pub fn build(self) -> crate::output::DeprecateWorkflowTypeOutput {
            crate::output::DeprecateWorkflowTypeOutput {}
        }
    }
}
impl DeprecateWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput)
    pub fn builder() -> crate::output::deprecate_workflow_type_output::Builder {
        crate::output::deprecate_workflow_type_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeprecateDomainOutput {}
impl std::fmt::Debug for DeprecateDomainOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeprecateDomainOutput");
        formatter.finish()
    }
}
/// See [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput)
pub mod deprecate_domain_output {
    /// A builder for [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput)
        pub fn build(self) -> crate::output::DeprecateDomainOutput {
            crate::output::DeprecateDomainOutput {}
        }
    }
}
impl DeprecateDomainOutput {
    /// Creates a new builder-style object to manufacture [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput)
    pub fn builder() -> crate::output::deprecate_domain_output::Builder {
        crate::output::deprecate_domain_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeprecateActivityTypeOutput {}
impl std::fmt::Debug for DeprecateActivityTypeOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeprecateActivityTypeOutput");
        formatter.finish()
    }
}
/// See [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput)
pub mod deprecate_activity_type_output {
    /// A builder for [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput)
        pub fn build(self) -> crate::output::DeprecateActivityTypeOutput {
            crate::output::DeprecateActivityTypeOutput {}
        }
    }
}
impl DeprecateActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput)
    pub fn builder() -> crate::output::deprecate_activity_type_output::Builder {
        crate::output::deprecate_activity_type_output::Builder::default()
    }
}

/// <p>Contains the count of tasks in a task list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CountPendingDecisionTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub truncated: bool,
}
impl CountPendingDecisionTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl std::fmt::Debug for CountPendingDecisionTasksOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CountPendingDecisionTasksOutput");
        formatter.field("count", &self.count);
        formatter.field("truncated", &self.truncated);
        formatter.finish()
    }
}
/// See [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput)
pub mod count_pending_decision_tasks_output {
    /// A builder for [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of tasks in the task list.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of tasks in the task list.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        /// Consumes the builder and constructs a [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput)
        pub fn build(self) -> crate::output::CountPendingDecisionTasksOutput {
            crate::output::CountPendingDecisionTasksOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
            }
        }
    }
}
impl CountPendingDecisionTasksOutput {
    /// Creates a new builder-style object to manufacture [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput)
    pub fn builder() -> crate::output::count_pending_decision_tasks_output::Builder {
        crate::output::count_pending_decision_tasks_output::Builder::default()
    }
}

/// <p>Contains the count of tasks in a task list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CountPendingActivityTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub truncated: bool,
}
impl CountPendingActivityTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl std::fmt::Debug for CountPendingActivityTasksOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CountPendingActivityTasksOutput");
        formatter.field("count", &self.count);
        formatter.field("truncated", &self.truncated);
        formatter.finish()
    }
}
/// See [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput)
pub mod count_pending_activity_tasks_output {
    /// A builder for [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of tasks in the task list.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of tasks in the task list.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        /// Consumes the builder and constructs a [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput)
        pub fn build(self) -> crate::output::CountPendingActivityTasksOutput {
            crate::output::CountPendingActivityTasksOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
            }
        }
    }
}
impl CountPendingActivityTasksOutput {
    /// Creates a new builder-style object to manufacture [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput)
    pub fn builder() -> crate::output::count_pending_activity_tasks_output::Builder {
        crate::output::count_pending_activity_tasks_output::Builder::default()
    }
}

/// <p>Contains the count of workflow executions returned from <code>CountOpenWorkflowExecutions</code> or <code>CountClosedWorkflowExecutions</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CountOpenWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub truncated: bool,
}
impl CountOpenWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl std::fmt::Debug for CountOpenWorkflowExecutionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CountOpenWorkflowExecutionsOutput");
        formatter.field("count", &self.count);
        formatter.field("truncated", &self.truncated);
        formatter.finish()
    }
}
/// See [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput)
pub mod count_open_workflow_executions_output {
    /// A builder for [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of workflow executions.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of workflow executions.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        /// Consumes the builder and constructs a [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput)
        pub fn build(self) -> crate::output::CountOpenWorkflowExecutionsOutput {
            crate::output::CountOpenWorkflowExecutionsOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
            }
        }
    }
}
impl CountOpenWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput)
    pub fn builder() -> crate::output::count_open_workflow_executions_output::Builder {
        crate::output::count_open_workflow_executions_output::Builder::default()
    }
}

/// <p>Contains the count of workflow executions returned from <code>CountOpenWorkflowExecutions</code> or <code>CountClosedWorkflowExecutions</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CountClosedWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub truncated: bool,
}
impl CountClosedWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl std::fmt::Debug for CountClosedWorkflowExecutionsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CountClosedWorkflowExecutionsOutput");
        formatter.field("count", &self.count);
        formatter.field("truncated", &self.truncated);
        formatter.finish()
    }
}
/// See [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput)
pub mod count_closed_workflow_executions_output {
    /// A builder for [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The number of workflow executions.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of workflow executions.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        /// Consumes the builder and constructs a [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput)
        pub fn build(self) -> crate::output::CountClosedWorkflowExecutionsOutput {
            crate::output::CountClosedWorkflowExecutionsOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
            }
        }
    }
}
impl CountClosedWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput)
    pub fn builder() -> crate::output::count_closed_workflow_executions_output::Builder {
        crate::output::count_closed_workflow_executions_output::Builder::default()
    }
}
