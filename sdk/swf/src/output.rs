// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for UntagResourceOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput).
pub mod untag_resource_output {

    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput).
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UndeprecateWorkflowTypeOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for UndeprecateWorkflowTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl UndeprecateWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput).
    pub fn builder() -> crate::output::undeprecate_workflow_type_output::Builder {
        crate::output::undeprecate_workflow_type_output::Builder::default()
    }
}

/// See [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput).
pub mod undeprecate_workflow_type_output {

    /// A builder for [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UndeprecateWorkflowTypeOutput`](crate::output::UndeprecateWorkflowTypeOutput).
        pub fn build(self) -> crate::output::UndeprecateWorkflowTypeOutput {
            crate::output::UndeprecateWorkflowTypeOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UndeprecateDomainOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for UndeprecateDomainOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl UndeprecateDomainOutput {
    /// Creates a new builder-style object to manufacture [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput).
    pub fn builder() -> crate::output::undeprecate_domain_output::Builder {
        crate::output::undeprecate_domain_output::Builder::default()
    }
}

/// See [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput).
pub mod undeprecate_domain_output {

    /// A builder for [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UndeprecateDomainOutput`](crate::output::UndeprecateDomainOutput).
        pub fn build(self) -> crate::output::UndeprecateDomainOutput {
            crate::output::UndeprecateDomainOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UndeprecateActivityTypeOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for UndeprecateActivityTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl UndeprecateActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput).
    pub fn builder() -> crate::output::undeprecate_activity_type_output::Builder {
        crate::output::undeprecate_activity_type_output::Builder::default()
    }
}

/// See [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput).
pub mod undeprecate_activity_type_output {

    /// A builder for [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`UndeprecateActivityTypeOutput`](crate::output::UndeprecateActivityTypeOutput).
        pub fn build(self) -> crate::output::UndeprecateActivityTypeOutput {
            crate::output::UndeprecateActivityTypeOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TerminateWorkflowExecutionOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for TerminateWorkflowExecutionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl TerminateWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput).
    pub fn builder() -> crate::output::terminate_workflow_execution_output::Builder {
        crate::output::terminate_workflow_execution_output::Builder::default()
    }
}

/// See [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput).
pub mod terminate_workflow_execution_output {

    /// A builder for [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`TerminateWorkflowExecutionOutput`](crate::output::TerminateWorkflowExecutionOutput).
        pub fn build(self) -> crate::output::TerminateWorkflowExecutionOutput {
            crate::output::TerminateWorkflowExecutionOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for TagResourceOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput).
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

/// See [`TagResourceOutput`](crate::output::TagResourceOutput).
pub mod tag_resource_output {

    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput).
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Specifies the <code>runId</code> of a workflow execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartWorkflowExecutionOutput {
    /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
    #[doc(hidden)]
    pub run_id: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl StartWorkflowExecutionOutput {
    /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
    pub fn run_id(&self) -> std::option::Option<&str> {
        self.run_id.as_deref()
    }
}
impl aws_http::request_id::RequestId for StartWorkflowExecutionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl StartWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput).
    pub fn builder() -> crate::output::start_workflow_execution_output::Builder {
        crate::output::start_workflow_execution_output::Builder::default()
    }
}

/// See [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput).
pub mod start_workflow_execution_output {

    /// A builder for [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) run_id: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.run_id = Some(input.into());
            self
        }
        /// <p>The <code>runId</code> of a workflow execution. This ID is generated by the service and can be used to uniquely identify the workflow execution within a domain.</p>
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.run_id = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`StartWorkflowExecutionOutput`](crate::output::StartWorkflowExecutionOutput).
        pub fn build(self) -> crate::output::StartWorkflowExecutionOutput {
            crate::output::StartWorkflowExecutionOutput {
                run_id: self.run_id,
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SignalWorkflowExecutionOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for SignalWorkflowExecutionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl SignalWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput).
    pub fn builder() -> crate::output::signal_workflow_execution_output::Builder {
        crate::output::signal_workflow_execution_output::Builder::default()
    }
}

/// See [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput).
pub mod signal_workflow_execution_output {

    /// A builder for [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`SignalWorkflowExecutionOutput`](crate::output::SignalWorkflowExecutionOutput).
        pub fn build(self) -> crate::output::SignalWorkflowExecutionOutput {
            crate::output::SignalWorkflowExecutionOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RespondDecisionTaskCompletedOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RespondDecisionTaskCompletedOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RespondDecisionTaskCompletedOutput {
    /// Creates a new builder-style object to manufacture [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput).
    pub fn builder() -> crate::output::respond_decision_task_completed_output::Builder {
        crate::output::respond_decision_task_completed_output::Builder::default()
    }
}

/// See [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput).
pub mod respond_decision_task_completed_output {

    /// A builder for [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RespondDecisionTaskCompletedOutput`](crate::output::RespondDecisionTaskCompletedOutput).
        pub fn build(self) -> crate::output::RespondDecisionTaskCompletedOutput {
            crate::output::RespondDecisionTaskCompletedOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RespondActivityTaskFailedOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RespondActivityTaskFailedOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RespondActivityTaskFailedOutput {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput).
    pub fn builder() -> crate::output::respond_activity_task_failed_output::Builder {
        crate::output::respond_activity_task_failed_output::Builder::default()
    }
}

/// See [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput).
pub mod respond_activity_task_failed_output {

    /// A builder for [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RespondActivityTaskFailedOutput`](crate::output::RespondActivityTaskFailedOutput).
        pub fn build(self) -> crate::output::RespondActivityTaskFailedOutput {
            crate::output::RespondActivityTaskFailedOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RespondActivityTaskCompletedOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RespondActivityTaskCompletedOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RespondActivityTaskCompletedOutput {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput).
    pub fn builder() -> crate::output::respond_activity_task_completed_output::Builder {
        crate::output::respond_activity_task_completed_output::Builder::default()
    }
}

/// See [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput).
pub mod respond_activity_task_completed_output {

    /// A builder for [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RespondActivityTaskCompletedOutput`](crate::output::RespondActivityTaskCompletedOutput).
        pub fn build(self) -> crate::output::RespondActivityTaskCompletedOutput {
            crate::output::RespondActivityTaskCompletedOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RespondActivityTaskCanceledOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RespondActivityTaskCanceledOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RespondActivityTaskCanceledOutput {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput).
    pub fn builder() -> crate::output::respond_activity_task_canceled_output::Builder {
        crate::output::respond_activity_task_canceled_output::Builder::default()
    }
}

/// See [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput).
pub mod respond_activity_task_canceled_output {

    /// A builder for [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RespondActivityTaskCanceledOutput`](crate::output::RespondActivityTaskCanceledOutput).
        pub fn build(self) -> crate::output::RespondActivityTaskCanceledOutput {
            crate::output::RespondActivityTaskCanceledOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RequestCancelWorkflowExecutionOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RequestCancelWorkflowExecutionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RequestCancelWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput).
    pub fn builder() -> crate::output::request_cancel_workflow_execution_output::Builder {
        crate::output::request_cancel_workflow_execution_output::Builder::default()
    }
}

/// See [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput).
pub mod request_cancel_workflow_execution_output {

    /// A builder for [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RequestCancelWorkflowExecutionOutput`](crate::output::RequestCancelWorkflowExecutionOutput).
        pub fn build(self) -> crate::output::RequestCancelWorkflowExecutionOutput {
            crate::output::RequestCancelWorkflowExecutionOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterWorkflowTypeOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RegisterWorkflowTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RegisterWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput).
    pub fn builder() -> crate::output::register_workflow_type_output::Builder {
        crate::output::register_workflow_type_output::Builder::default()
    }
}

/// See [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput).
pub mod register_workflow_type_output {

    /// A builder for [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RegisterWorkflowTypeOutput`](crate::output::RegisterWorkflowTypeOutput).
        pub fn build(self) -> crate::output::RegisterWorkflowTypeOutput {
            crate::output::RegisterWorkflowTypeOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterDomainOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RegisterDomainOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RegisterDomainOutput {
    /// Creates a new builder-style object to manufacture [`RegisterDomainOutput`](crate::output::RegisterDomainOutput).
    pub fn builder() -> crate::output::register_domain_output::Builder {
        crate::output::register_domain_output::Builder::default()
    }
}

/// See [`RegisterDomainOutput`](crate::output::RegisterDomainOutput).
pub mod register_domain_output {

    /// A builder for [`RegisterDomainOutput`](crate::output::RegisterDomainOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RegisterDomainOutput`](crate::output::RegisterDomainOutput).
        pub fn build(self) -> crate::output::RegisterDomainOutput {
            crate::output::RegisterDomainOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterActivityTypeOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for RegisterActivityTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RegisterActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput).
    pub fn builder() -> crate::output::register_activity_type_output::Builder {
        crate::output::register_activity_type_output::Builder::default()
    }
}

/// See [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput).
pub mod register_activity_type_output {

    /// A builder for [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RegisterActivityTypeOutput`](crate::output::RegisterActivityTypeOutput).
        pub fn build(self) -> crate::output::RegisterActivityTypeOutput {
            crate::output::RegisterActivityTypeOutput {
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Status information about an activity task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordActivityTaskHeartbeatOutput {
    /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
    #[doc(hidden)]
    pub cancel_requested: bool,
    _request_id: Option<String>,
}
impl RecordActivityTaskHeartbeatOutput {
    /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
    pub fn cancel_requested(&self) -> bool {
        self.cancel_requested
    }
}
impl aws_http::request_id::RequestId for RecordActivityTaskHeartbeatOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl RecordActivityTaskHeartbeatOutput {
    /// Creates a new builder-style object to manufacture [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput).
    pub fn builder() -> crate::output::record_activity_task_heartbeat_output::Builder {
        crate::output::record_activity_task_heartbeat_output::Builder::default()
    }
}

/// See [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput).
pub mod record_activity_task_heartbeat_output {

    /// A builder for [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cancel_requested: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
        pub fn cancel_requested(mut self, input: bool) -> Self {
            self.cancel_requested = Some(input);
            self
        }
        /// <p>Set to <code>true</code> if cancellation of the task is requested.</p>
        pub fn set_cancel_requested(mut self, input: std::option::Option<bool>) -> Self {
            self.cancel_requested = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`RecordActivityTaskHeartbeatOutput`](crate::output::RecordActivityTaskHeartbeatOutput).
        pub fn build(self) -> crate::output::RecordActivityTaskHeartbeatOutput {
            crate::output::RecordActivityTaskHeartbeatOutput {
                cancel_requested: self.cancel_requested.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>A structure that represents a decision task. Decision tasks are sent to deciders in order for them to make decisions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PollForDecisionTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    #[doc(hidden)]
    pub task_token: std::option::Option<std::string::String>,
    /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
    #[doc(hidden)]
    pub started_event_id: i64,
    /// <p>The workflow execution for which this decision task was created.</p>
    #[doc(hidden)]
    pub workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
    /// <p>The type of the workflow execution for which this decision task was created.</p>
    #[doc(hidden)]
    pub workflow_type: std::option::Option<crate::model::WorkflowType>,
    /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
    #[doc(hidden)]
    pub events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
    #[doc(hidden)]
    pub previous_started_event_id: i64,
    _request_id: Option<String>,
}
impl PollForDecisionTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    pub fn task_token(&self) -> std::option::Option<&str> {
        self.task_token.as_deref()
    }
    /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
    pub fn started_event_id(&self) -> i64 {
        self.started_event_id
    }
    /// <p>The workflow execution for which this decision task was created.</p>
    pub fn workflow_execution(&self) -> std::option::Option<&crate::model::WorkflowExecution> {
        self.workflow_execution.as_ref()
    }
    /// <p>The type of the workflow execution for which this decision task was created.</p>
    pub fn workflow_type(&self) -> std::option::Option<&crate::model::WorkflowType> {
        self.workflow_type.as_ref()
    }
    /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
    pub fn events(&self) -> std::option::Option<&[crate::model::HistoryEvent]> {
        self.events.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
    pub fn previous_started_event_id(&self) -> i64 {
        self.previous_started_event_id
    }
}
impl aws_http::request_id::RequestId for PollForDecisionTaskOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl PollForDecisionTaskOutput {
    /// Creates a new builder-style object to manufacture [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput).
    pub fn builder() -> crate::output::poll_for_decision_task_output::Builder {
        crate::output::poll_for_decision_task_output::Builder::default()
    }
}

/// See [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput).
pub mod poll_for_decision_task_output {

    /// A builder for [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_token: std::option::Option<std::string::String>,
        pub(crate) started_event_id: std::option::Option<i64>,
        pub(crate) workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
        pub(crate) workflow_type: std::option::Option<crate::model::WorkflowType>,
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) previous_started_event_id: std::option::Option<i64>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_token = Some(input.into());
            self
        }
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_token = input;
            self
        }
        /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
        pub fn started_event_id(mut self, input: i64) -> Self {
            self.started_event_id = Some(input);
            self
        }
        /// <p>The ID of the <code>DecisionTaskStarted</code> event recorded in the history.</p>
        pub fn set_started_event_id(mut self, input: std::option::Option<i64>) -> Self {
            self.started_event_id = input;
            self
        }
        /// <p>The workflow execution for which this decision task was created.</p>
        pub fn workflow_execution(mut self, input: crate::model::WorkflowExecution) -> Self {
            self.workflow_execution = Some(input);
            self
        }
        /// <p>The workflow execution for which this decision task was created.</p>
        pub fn set_workflow_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.workflow_execution = input;
            self
        }
        /// <p>The type of the workflow execution for which this decision task was created.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.workflow_type = Some(input);
            self
        }
        /// <p>The type of the workflow execution for which this decision task was created.</p>
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.workflow_type = input;
            self
        }
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
        pub fn events(mut self, input: crate::model::HistoryEvent) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p>A paginated list of history events of the workflow execution. The decider uses this during the processing of the decision task.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
        pub fn previous_started_event_id(mut self, input: i64) -> Self {
            self.previous_started_event_id = Some(input);
            self
        }
        /// <p>The ID of the DecisionTaskStarted event of the previous decision task of this workflow execution that was processed by the decider. This can be used to determine the events in the history new since the last decision task received by the decider.</p>
        pub fn set_previous_started_event_id(mut self, input: std::option::Option<i64>) -> Self {
            self.previous_started_event_id = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`PollForDecisionTaskOutput`](crate::output::PollForDecisionTaskOutput).
        pub fn build(self) -> crate::output::PollForDecisionTaskOutput {
            crate::output::PollForDecisionTaskOutput {
                task_token: self.task_token,
                started_event_id: self.started_event_id.unwrap_or_default(),
                workflow_execution: self.workflow_execution,
                workflow_type: self.workflow_type,
                events: self.events,
                next_page_token: self.next_page_token,
                previous_started_event_id: self.previous_started_event_id.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Unit of work sent to an activity worker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PollForActivityTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    #[doc(hidden)]
    pub task_token: std::option::Option<std::string::String>,
    /// <p>The unique ID of the task.</p>
    #[doc(hidden)]
    pub activity_id: std::option::Option<std::string::String>,
    /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
    #[doc(hidden)]
    pub started_event_id: i64,
    /// <p>The workflow execution that started this activity task.</p>
    #[doc(hidden)]
    pub workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
    /// <p>The type of this activity task.</p>
    #[doc(hidden)]
    pub activity_type: std::option::Option<crate::model::ActivityType>,
    /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
    #[doc(hidden)]
    pub input: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl PollForActivityTaskOutput {
    /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
    pub fn task_token(&self) -> std::option::Option<&str> {
        self.task_token.as_deref()
    }
    /// <p>The unique ID of the task.</p>
    pub fn activity_id(&self) -> std::option::Option<&str> {
        self.activity_id.as_deref()
    }
    /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
    pub fn started_event_id(&self) -> i64 {
        self.started_event_id
    }
    /// <p>The workflow execution that started this activity task.</p>
    pub fn workflow_execution(&self) -> std::option::Option<&crate::model::WorkflowExecution> {
        self.workflow_execution.as_ref()
    }
    /// <p>The type of this activity task.</p>
    pub fn activity_type(&self) -> std::option::Option<&crate::model::ActivityType> {
        self.activity_type.as_ref()
    }
    /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
    pub fn input(&self) -> std::option::Option<&str> {
        self.input.as_deref()
    }
}
impl aws_http::request_id::RequestId for PollForActivityTaskOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl PollForActivityTaskOutput {
    /// Creates a new builder-style object to manufacture [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput).
    pub fn builder() -> crate::output::poll_for_activity_task_output::Builder {
        crate::output::poll_for_activity_task_output::Builder::default()
    }
}

/// See [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput).
pub mod poll_for_activity_task_output {

    /// A builder for [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_token: std::option::Option<std::string::String>,
        pub(crate) activity_id: std::option::Option<std::string::String>,
        pub(crate) started_event_id: std::option::Option<i64>,
        pub(crate) workflow_execution: std::option::Option<crate::model::WorkflowExecution>,
        pub(crate) activity_type: std::option::Option<crate::model::ActivityType>,
        pub(crate) input: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_token = Some(input.into());
            self
        }
        /// <p>The opaque string used as a handle on the task. This token is used by workers to communicate progress and response information back to the system about the task.</p>
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_token = input;
            self
        }
        /// <p>The unique ID of the task.</p>
        pub fn activity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.activity_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the task.</p>
        pub fn set_activity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.activity_id = input;
            self
        }
        /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
        pub fn started_event_id(mut self, input: i64) -> Self {
            self.started_event_id = Some(input);
            self
        }
        /// <p>The ID of the <code>ActivityTaskStarted</code> event recorded in the history.</p>
        pub fn set_started_event_id(mut self, input: std::option::Option<i64>) -> Self {
            self.started_event_id = input;
            self
        }
        /// <p>The workflow execution that started this activity task.</p>
        pub fn workflow_execution(mut self, input: crate::model::WorkflowExecution) -> Self {
            self.workflow_execution = Some(input);
            self
        }
        /// <p>The workflow execution that started this activity task.</p>
        pub fn set_workflow_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.workflow_execution = input;
            self
        }
        /// <p>The type of this activity task.</p>
        pub fn activity_type(mut self, input: crate::model::ActivityType) -> Self {
            self.activity_type = Some(input);
            self
        }
        /// <p>The type of this activity task.</p>
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.activity_type = input;
            self
        }
        /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.input = Some(input.into());
            self
        }
        /// <p>The inputs provided when the activity task was scheduled. The form of the input is user defined and should be meaningful to the activity implementation.</p>
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`PollForActivityTaskOutput`](crate::output::PollForActivityTaskOutput).
        pub fn build(self) -> crate::output::PollForActivityTaskOutput {
            crate::output::PollForActivityTaskOutput {
                task_token: self.task_token,
                activity_id: self.activity_id,
                started_event_id: self.started_event_id.unwrap_or_default(),
                workflow_execution: self.workflow_execution,
                activity_type: self.activity_type,
                input: self.input,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains a paginated list of information structures about workflow types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListWorkflowTypesOutput {
    /// <p>The list of workflow type information.</p>
    #[doc(hidden)]
    pub type_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowTypeInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl ListWorkflowTypesOutput {
    /// <p>The list of workflow type information.</p>
    pub fn type_infos(&self) -> std::option::Option<&[crate::model::WorkflowTypeInfo]> {
        self.type_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListWorkflowTypesOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListWorkflowTypesOutput {
    /// Creates a new builder-style object to manufacture [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput).
    pub fn builder() -> crate::output::list_workflow_types_output::Builder {
        crate::output::list_workflow_types_output::Builder::default()
    }
}

/// See [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput).
pub mod list_workflow_types_output {

    /// A builder for [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowTypeInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `type_infos`.
        ///
        /// To override the contents of this collection use [`set_type_infos`](Self::set_type_infos).
        ///
        /// <p>The list of workflow type information.</p>
        pub fn type_infos(mut self, input: crate::model::WorkflowTypeInfo) -> Self {
            let mut v = self.type_infos.unwrap_or_default();
            v.push(input);
            self.type_infos = Some(v);
            self
        }
        /// <p>The list of workflow type information.</p>
        pub fn set_type_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowTypeInfo>>,
        ) -> Self {
            self.type_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListWorkflowTypesOutput`](crate::output::ListWorkflowTypesOutput).
        pub fn build(self) -> crate::output::ListWorkflowTypesOutput {
            crate::output::ListWorkflowTypesOutput {
                type_infos: self.type_infos,
                next_page_token: self.next_page_token,
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceOutput {
    /// <p>An array of tags associated with the domain.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    _request_id: Option<String>,
}
impl ListTagsForResourceOutput {
    /// <p>An array of tags associated with the domain.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.tags.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListTagsForResourceOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
pub mod list_tags_for_resource_output {

    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An array of tags associated with the domain.</p>
        pub fn tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>An array of tags associated with the domain.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput).
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                tags: self.tags,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains a paginated list of information about workflow executions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListOpenWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    #[doc(hidden)]
    pub execution_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl ListOpenWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    pub fn execution_infos(&self) -> std::option::Option<&[crate::model::WorkflowExecutionInfo]> {
        self.execution_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListOpenWorkflowExecutionsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListOpenWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput).
    pub fn builder() -> crate::output::list_open_workflow_executions_output::Builder {
        crate::output::list_open_workflow_executions_output::Builder::default()
    }
}

/// See [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput).
pub mod list_open_workflow_executions_output {

    /// A builder for [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_infos:
            std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `execution_infos`.
        ///
        /// To override the contents of this collection use [`set_execution_infos`](Self::set_execution_infos).
        ///
        /// <p>The list of workflow information structures.</p>
        pub fn execution_infos(mut self, input: crate::model::WorkflowExecutionInfo) -> Self {
            let mut v = self.execution_infos.unwrap_or_default();
            v.push(input);
            self.execution_infos = Some(v);
            self
        }
        /// <p>The list of workflow information structures.</p>
        pub fn set_execution_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        ) -> Self {
            self.execution_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListOpenWorkflowExecutionsOutput`](crate::output::ListOpenWorkflowExecutionsOutput).
        pub fn build(self) -> crate::output::ListOpenWorkflowExecutionsOutput {
            crate::output::ListOpenWorkflowExecutionsOutput {
                execution_infos: self.execution_infos,
                next_page_token: self.next_page_token,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains a paginated collection of DomainInfo structures.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDomainsOutput {
    /// <p>A list of DomainInfo structures.</p>
    #[doc(hidden)]
    pub domain_infos: std::option::Option<std::vec::Vec<crate::model::DomainInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl ListDomainsOutput {
    /// <p>A list of DomainInfo structures.</p>
    pub fn domain_infos(&self) -> std::option::Option<&[crate::model::DomainInfo]> {
        self.domain_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListDomainsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListDomainsOutput {
    /// Creates a new builder-style object to manufacture [`ListDomainsOutput`](crate::output::ListDomainsOutput).
    pub fn builder() -> crate::output::list_domains_output::Builder {
        crate::output::list_domains_output::Builder::default()
    }
}

/// See [`ListDomainsOutput`](crate::output::ListDomainsOutput).
pub mod list_domains_output {

    /// A builder for [`ListDomainsOutput`](crate::output::ListDomainsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_infos: std::option::Option<std::vec::Vec<crate::model::DomainInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `domain_infos`.
        ///
        /// To override the contents of this collection use [`set_domain_infos`](Self::set_domain_infos).
        ///
        /// <p>A list of DomainInfo structures.</p>
        pub fn domain_infos(mut self, input: crate::model::DomainInfo) -> Self {
            let mut v = self.domain_infos.unwrap_or_default();
            v.push(input);
            self.domain_infos = Some(v);
            self
        }
        /// <p>A list of DomainInfo structures.</p>
        pub fn set_domain_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DomainInfo>>,
        ) -> Self {
            self.domain_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListDomainsOutput`](crate::output::ListDomainsOutput).
        pub fn build(self) -> crate::output::ListDomainsOutput {
            crate::output::ListDomainsOutput {
                domain_infos: self.domain_infos,
                next_page_token: self.next_page_token,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains a paginated list of information about workflow executions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListClosedWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    #[doc(hidden)]
    pub execution_infos: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl ListClosedWorkflowExecutionsOutput {
    /// <p>The list of workflow information structures.</p>
    pub fn execution_infos(&self) -> std::option::Option<&[crate::model::WorkflowExecutionInfo]> {
        self.execution_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListClosedWorkflowExecutionsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListClosedWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput).
    pub fn builder() -> crate::output::list_closed_workflow_executions_output::Builder {
        crate::output::list_closed_workflow_executions_output::Builder::default()
    }
}

/// See [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput).
pub mod list_closed_workflow_executions_output {

    /// A builder for [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_infos:
            std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `execution_infos`.
        ///
        /// To override the contents of this collection use [`set_execution_infos`](Self::set_execution_infos).
        ///
        /// <p>The list of workflow information structures.</p>
        pub fn execution_infos(mut self, input: crate::model::WorkflowExecutionInfo) -> Self {
            let mut v = self.execution_infos.unwrap_or_default();
            v.push(input);
            self.execution_infos = Some(v);
            self
        }
        /// <p>The list of workflow information structures.</p>
        pub fn set_execution_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowExecutionInfo>>,
        ) -> Self {
            self.execution_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListClosedWorkflowExecutionsOutput`](crate::output::ListClosedWorkflowExecutionsOutput).
        pub fn build(self) -> crate::output::ListClosedWorkflowExecutionsOutput {
            crate::output::ListClosedWorkflowExecutionsOutput {
                execution_infos: self.execution_infos,
                next_page_token: self.next_page_token,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains a paginated list of activity type information structures.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListActivityTypesOutput {
    /// <p>List of activity type information.</p>
    #[doc(hidden)]
    pub type_infos: std::option::Option<std::vec::Vec<crate::model::ActivityTypeInfo>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl ListActivityTypesOutput {
    /// <p>List of activity type information.</p>
    pub fn type_infos(&self) -> std::option::Option<&[crate::model::ActivityTypeInfo]> {
        self.type_infos.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for ListActivityTypesOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl ListActivityTypesOutput {
    /// Creates a new builder-style object to manufacture [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput).
    pub fn builder() -> crate::output::list_activity_types_output::Builder {
        crate::output::list_activity_types_output::Builder::default()
    }
}

/// See [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput).
pub mod list_activity_types_output {

    /// A builder for [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_infos: std::option::Option<std::vec::Vec<crate::model::ActivityTypeInfo>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `type_infos`.
        ///
        /// To override the contents of this collection use [`set_type_infos`](Self::set_type_infos).
        ///
        /// <p>List of activity type information.</p>
        pub fn type_infos(mut self, input: crate::model::ActivityTypeInfo) -> Self {
            let mut v = self.type_infos.unwrap_or_default();
            v.push(input);
            self.type_infos = Some(v);
            self
        }
        /// <p>List of activity type information.</p>
        pub fn set_type_infos(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ActivityTypeInfo>>,
        ) -> Self {
            self.type_infos = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`ListActivityTypesOutput`](crate::output::ListActivityTypesOutput).
        pub fn build(self) -> crate::output::ListActivityTypesOutput {
            crate::output::ListActivityTypesOutput {
                type_infos: self.type_infos,
                next_page_token: self.next_page_token,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Paginated representation of a workflow history for a workflow execution. This is the up to date, complete and authoritative record of the events related to all tasks and events in the life of the workflow execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetWorkflowExecutionHistoryOutput {
    /// <p>The list of history events.</p>
    #[doc(hidden)]
    pub events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl GetWorkflowExecutionHistoryOutput {
    /// <p>The list of history events.</p>
    pub fn events(&self) -> std::option::Option<&[crate::model::HistoryEvent]> {
        self.events.as_deref()
    }
    /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl aws_http::request_id::RequestId for GetWorkflowExecutionHistoryOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetWorkflowExecutionHistoryOutput {
    /// Creates a new builder-style object to manufacture [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput).
    pub fn builder() -> crate::output::get_workflow_execution_history_output::Builder {
        crate::output::get_workflow_execution_history_output::Builder::default()
    }
}

/// See [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput).
pub mod get_workflow_execution_history_output {

    /// A builder for [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The list of history events.</p>
        pub fn events(mut self, input: crate::model::HistoryEvent) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p>The list of history events.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HistoryEvent>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If a <code>NextPageToken</code> was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in <code>nextPageToken</code>. Keep all other arguments unchanged.</p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`GetWorkflowExecutionHistoryOutput`](crate::output::GetWorkflowExecutionHistoryOutput).
        pub fn build(self) -> crate::output::GetWorkflowExecutionHistoryOutput {
            crate::output::GetWorkflowExecutionHistoryOutput {
                events: self.events,
                next_page_token: self.next_page_token,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains details about a workflow type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeWorkflowTypeOutput {
    /// <p>General information about the workflow type.</p>
    /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running.</p> </li>
    /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub type_info: std::option::Option<crate::model::WorkflowTypeInfo>,
    /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::WorkflowTypeConfiguration>,
    _request_id: Option<String>,
}
impl DescribeWorkflowTypeOutput {
    /// <p>General information about the workflow type.</p>
    /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running.</p> </li>
    /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
    /// </ul>
    pub fn type_info(&self) -> std::option::Option<&crate::model::WorkflowTypeInfo> {
        self.type_info.as_ref()
    }
    /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::WorkflowTypeConfiguration> {
        self.configuration.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeWorkflowTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput).
    pub fn builder() -> crate::output::describe_workflow_type_output::Builder {
        crate::output::describe_workflow_type_output::Builder::default()
    }
}

/// See [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput).
pub mod describe_workflow_type_output {

    /// A builder for [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_info: std::option::Option<crate::model::WorkflowTypeInfo>,
        pub(crate) configuration: std::option::Option<crate::model::WorkflowTypeConfiguration>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>General information about the workflow type.</p>
        /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running.</p> </li>
        /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
        /// </ul>
        pub fn type_info(mut self, input: crate::model::WorkflowTypeInfo) -> Self {
            self.type_info = Some(input);
            self
        }
        /// <p>General information about the workflow type.</p>
        /// <p>The status of the workflow type (returned in the WorkflowTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running.</p> </li>
        /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateWorkflowType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new workflow executions of this type.</p> </li>
        /// </ul>
        pub fn set_type_info(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeInfo>,
        ) -> Self {
            self.type_info = input;
            self
        }
        /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
        pub fn configuration(mut self, input: crate::model::WorkflowTypeConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>Configuration settings of the workflow type registered through <code>RegisterWorkflowType</code> </p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeWorkflowTypeOutput`](crate::output::DescribeWorkflowTypeOutput).
        pub fn build(self) -> crate::output::DescribeWorkflowTypeOutput {
            crate::output::DescribeWorkflowTypeOutput {
                type_info: self.type_info,
                configuration: self.configuration,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains details about a workflow execution.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeWorkflowExecutionOutput {
    /// <p>Information about the workflow execution.</p>
    #[doc(hidden)]
    pub execution_info: std::option::Option<crate::model::WorkflowExecutionInfo>,
    /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
    #[doc(hidden)]
    pub execution_configuration: std::option::Option<crate::model::WorkflowExecutionConfiguration>,
    /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
    #[doc(hidden)]
    pub open_counts: std::option::Option<crate::model::WorkflowExecutionOpenCounts>,
    /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
    #[doc(hidden)]
    pub latest_activity_task_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
    #[doc(hidden)]
    pub latest_execution_context: std::option::Option<std::string::String>,
    _request_id: Option<String>,
}
impl DescribeWorkflowExecutionOutput {
    /// <p>Information about the workflow execution.</p>
    pub fn execution_info(&self) -> std::option::Option<&crate::model::WorkflowExecutionInfo> {
        self.execution_info.as_ref()
    }
    /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
    pub fn execution_configuration(
        &self,
    ) -> std::option::Option<&crate::model::WorkflowExecutionConfiguration> {
        self.execution_configuration.as_ref()
    }
    /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
    pub fn open_counts(&self) -> std::option::Option<&crate::model::WorkflowExecutionOpenCounts> {
        self.open_counts.as_ref()
    }
    /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
    pub fn latest_activity_task_timestamp(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.latest_activity_task_timestamp.as_ref()
    }
    /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
    pub fn latest_execution_context(&self) -> std::option::Option<&str> {
        self.latest_execution_context.as_deref()
    }
}
impl aws_http::request_id::RequestId for DescribeWorkflowExecutionOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeWorkflowExecutionOutput {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput).
    pub fn builder() -> crate::output::describe_workflow_execution_output::Builder {
        crate::output::describe_workflow_execution_output::Builder::default()
    }
}

/// See [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput).
pub mod describe_workflow_execution_output {

    /// A builder for [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) execution_info: std::option::Option<crate::model::WorkflowExecutionInfo>,
        pub(crate) execution_configuration:
            std::option::Option<crate::model::WorkflowExecutionConfiguration>,
        pub(crate) open_counts: std::option::Option<crate::model::WorkflowExecutionOpenCounts>,
        pub(crate) latest_activity_task_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) latest_execution_context: std::option::Option<std::string::String>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>Information about the workflow execution.</p>
        pub fn execution_info(mut self, input: crate::model::WorkflowExecutionInfo) -> Self {
            self.execution_info = Some(input);
            self
        }
        /// <p>Information about the workflow execution.</p>
        pub fn set_execution_info(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionInfo>,
        ) -> Self {
            self.execution_info = input;
            self
        }
        /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
        pub fn execution_configuration(
            mut self,
            input: crate::model::WorkflowExecutionConfiguration,
        ) -> Self {
            self.execution_configuration = Some(input);
            self
        }
        /// <p>The configuration settings for this workflow execution including timeout values, tasklist etc.</p>
        pub fn set_execution_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionConfiguration>,
        ) -> Self {
            self.execution_configuration = input;
            self
        }
        /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
        pub fn open_counts(mut self, input: crate::model::WorkflowExecutionOpenCounts) -> Self {
            self.open_counts = Some(input);
            self
        }
        /// <p>The number of tasks for this workflow execution. This includes open and closed tasks of all types.</p>
        pub fn set_open_counts(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionOpenCounts>,
        ) -> Self {
            self.open_counts = input;
            self
        }
        /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
        pub fn latest_activity_task_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.latest_activity_task_timestamp = Some(input);
            self
        }
        /// <p>The time when the last activity task was scheduled for this workflow execution. You can use this information to determine if the workflow has not made progress for an unusually long period of time and might require a corrective action.</p>
        pub fn set_latest_activity_task_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.latest_activity_task_timestamp = input;
            self
        }
        /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
        pub fn latest_execution_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.latest_execution_context = Some(input.into());
            self
        }
        /// <p>The latest executionContext provided by the decider for this workflow execution. A decider can provide an executionContext (a free-form string) when closing a decision task using <code>RespondDecisionTaskCompleted</code>.</p>
        pub fn set_latest_execution_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_execution_context = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeWorkflowExecutionOutput`](crate::output::DescribeWorkflowExecutionOutput).
        pub fn build(self) -> crate::output::DescribeWorkflowExecutionOutput {
            crate::output::DescribeWorkflowExecutionOutput {
                execution_info: self.execution_info,
                execution_configuration: self.execution_configuration,
                open_counts: self.open_counts,
                latest_activity_task_timestamp: self.latest_activity_task_timestamp,
                latest_execution_context: self.latest_execution_context,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains details of a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeDomainOutput {
    /// <p>The basic information about a domain, such as its name, status, and description.</p>
    #[doc(hidden)]
    pub domain_info: std::option::Option<crate::model::DomainInfo>,
    /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::DomainConfiguration>,
    _request_id: Option<String>,
}
impl DescribeDomainOutput {
    /// <p>The basic information about a domain, such as its name, status, and description.</p>
    pub fn domain_info(&self) -> std::option::Option<&crate::model::DomainInfo> {
        self.domain_info.as_ref()
    }
    /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::DomainConfiguration> {
        self.configuration.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeDomainOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeDomainOutput {
    /// Creates a new builder-style object to manufacture [`DescribeDomainOutput`](crate::output::DescribeDomainOutput).
    pub fn builder() -> crate::output::describe_domain_output::Builder {
        crate::output::describe_domain_output::Builder::default()
    }
}

/// See [`DescribeDomainOutput`](crate::output::DescribeDomainOutput).
pub mod describe_domain_output {

    /// A builder for [`DescribeDomainOutput`](crate::output::DescribeDomainOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_info: std::option::Option<crate::model::DomainInfo>,
        pub(crate) configuration: std::option::Option<crate::model::DomainConfiguration>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The basic information about a domain, such as its name, status, and description.</p>
        pub fn domain_info(mut self, input: crate::model::DomainInfo) -> Self {
            self.domain_info = Some(input);
            self
        }
        /// <p>The basic information about a domain, such as its name, status, and description.</p>
        pub fn set_domain_info(
            mut self,
            input: std::option::Option<crate::model::DomainInfo>,
        ) -> Self {
            self.domain_info = input;
            self
        }
        /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
        pub fn configuration(mut self, input: crate::model::DomainConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The domain configuration. Currently, this includes only the domain's retention period.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::DomainConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDomainOutput`](crate::output::DescribeDomainOutput).
        pub fn build(self) -> crate::output::DescribeDomainOutput {
            crate::output::DescribeDomainOutput {
                domain_info: self.domain_info,
                configuration: self.configuration,
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Detailed information about an activity type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeActivityTypeOutput {
    /// <p>General information about the activity type.</p>
    /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running. </p> </li>
    /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub type_info: std::option::Option<crate::model::ActivityTypeInfo>,
    /// <p>The configuration settings registered with the activity type.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::ActivityTypeConfiguration>,
    _request_id: Option<String>,
}
impl DescribeActivityTypeOutput {
    /// <p>General information about the activity type.</p>
    /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
    /// <ul>
    /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running. </p> </li>
    /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
    /// </ul>
    pub fn type_info(&self) -> std::option::Option<&crate::model::ActivityTypeInfo> {
        self.type_info.as_ref()
    }
    /// <p>The configuration settings registered with the activity type.</p>
    pub fn configuration(&self) -> std::option::Option<&crate::model::ActivityTypeConfiguration> {
        self.configuration.as_ref()
    }
}
impl aws_http::request_id::RequestId for DescribeActivityTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput).
    pub fn builder() -> crate::output::describe_activity_type_output::Builder {
        crate::output::describe_activity_type_output::Builder::default()
    }
}

/// See [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput).
pub mod describe_activity_type_output {

    /// A builder for [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_info: std::option::Option<crate::model::ActivityTypeInfo>,
        pub(crate) configuration: std::option::Option<crate::model::ActivityTypeConfiguration>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>General information about the activity type.</p>
        /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running. </p> </li>
        /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
        /// </ul>
        pub fn type_info(mut self, input: crate::model::ActivityTypeInfo) -> Self {
            self.type_info = Some(input);
            self
        }
        /// <p>General information about the activity type.</p>
        /// <p>The status of activity type (returned in the ActivityTypeInfo structure) can be one of the following.</p>
        /// <ul>
        /// <li> <p> <code>REGISTERED</code>  The type is registered and available. Workers supporting this type should be running. </p> </li>
        /// <li> <p> <code>DEPRECATED</code>  The type was deprecated using <code>DeprecateActivityType</code>, but is still in use. You should keep workers supporting this type running. You cannot create new tasks of this type. </p> </li>
        /// </ul>
        pub fn set_type_info(
            mut self,
            input: std::option::Option<crate::model::ActivityTypeInfo>,
        ) -> Self {
            self.type_info = input;
            self
        }
        /// <p>The configuration settings registered with the activity type.</p>
        pub fn configuration(mut self, input: crate::model::ActivityTypeConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration settings registered with the activity type.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ActivityTypeConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DescribeActivityTypeOutput`](crate::output::DescribeActivityTypeOutput).
        pub fn build(self) -> crate::output::DescribeActivityTypeOutput {
            crate::output::DescribeActivityTypeOutput {
                type_info: self.type_info,
                configuration: self.configuration,
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeprecateWorkflowTypeOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for DeprecateWorkflowTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DeprecateWorkflowTypeOutput {
    /// Creates a new builder-style object to manufacture [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput).
    pub fn builder() -> crate::output::deprecate_workflow_type_output::Builder {
        crate::output::deprecate_workflow_type_output::Builder::default()
    }
}

/// See [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput).
pub mod deprecate_workflow_type_output {

    /// A builder for [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeprecateWorkflowTypeOutput`](crate::output::DeprecateWorkflowTypeOutput).
        pub fn build(self) -> crate::output::DeprecateWorkflowTypeOutput {
            crate::output::DeprecateWorkflowTypeOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeprecateDomainOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for DeprecateDomainOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DeprecateDomainOutput {
    /// Creates a new builder-style object to manufacture [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput).
    pub fn builder() -> crate::output::deprecate_domain_output::Builder {
        crate::output::deprecate_domain_output::Builder::default()
    }
}

/// See [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput).
pub mod deprecate_domain_output {

    /// A builder for [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeprecateDomainOutput`](crate::output::DeprecateDomainOutput).
        pub fn build(self) -> crate::output::DeprecateDomainOutput {
            crate::output::DeprecateDomainOutput {
                _request_id: self._request_id,
            }
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeprecateActivityTypeOutput {
    _request_id: Option<String>,
}
impl aws_http::request_id::RequestId for DeprecateActivityTypeOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DeprecateActivityTypeOutput {
    /// Creates a new builder-style object to manufacture [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput).
    pub fn builder() -> crate::output::deprecate_activity_type_output::Builder {
        crate::output::deprecate_activity_type_output::Builder::default()
    }
}

/// See [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput).
pub mod deprecate_activity_type_output {

    /// A builder for [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        _request_id: Option<String>,
    }
    impl Builder {
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`DeprecateActivityTypeOutput`](crate::output::DeprecateActivityTypeOutput).
        pub fn build(self) -> crate::output::DeprecateActivityTypeOutput {
            crate::output::DeprecateActivityTypeOutput {
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains the count of tasks in a task list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CountPendingDecisionTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    #[doc(hidden)]
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    #[doc(hidden)]
    pub truncated: bool,
    _request_id: Option<String>,
}
impl CountPendingDecisionTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl aws_http::request_id::RequestId for CountPendingDecisionTasksOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl CountPendingDecisionTasksOutput {
    /// Creates a new builder-style object to manufacture [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput).
    pub fn builder() -> crate::output::count_pending_decision_tasks_output::Builder {
        crate::output::count_pending_decision_tasks_output::Builder::default()
    }
}

/// See [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput).
pub mod count_pending_decision_tasks_output {

    /// A builder for [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The number of tasks in the task list.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of tasks in the task list.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CountPendingDecisionTasksOutput`](crate::output::CountPendingDecisionTasksOutput).
        pub fn build(self) -> crate::output::CountPendingDecisionTasksOutput {
            crate::output::CountPendingDecisionTasksOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains the count of tasks in a task list.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CountPendingActivityTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    #[doc(hidden)]
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    #[doc(hidden)]
    pub truncated: bool,
    _request_id: Option<String>,
}
impl CountPendingActivityTasksOutput {
    /// <p>The number of tasks in the task list.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl aws_http::request_id::RequestId for CountPendingActivityTasksOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl CountPendingActivityTasksOutput {
    /// Creates a new builder-style object to manufacture [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput).
    pub fn builder() -> crate::output::count_pending_activity_tasks_output::Builder {
        crate::output::count_pending_activity_tasks_output::Builder::default()
    }
}

/// See [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput).
pub mod count_pending_activity_tasks_output {

    /// A builder for [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The number of tasks in the task list.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of tasks in the task list.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CountPendingActivityTasksOutput`](crate::output::CountPendingActivityTasksOutput).
        pub fn build(self) -> crate::output::CountPendingActivityTasksOutput {
            crate::output::CountPendingActivityTasksOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains the count of workflow executions returned from <code>CountOpenWorkflowExecutions</code> or <code>CountClosedWorkflowExecutions</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CountOpenWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    #[doc(hidden)]
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    #[doc(hidden)]
    pub truncated: bool,
    _request_id: Option<String>,
}
impl CountOpenWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl aws_http::request_id::RequestId for CountOpenWorkflowExecutionsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl CountOpenWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput).
    pub fn builder() -> crate::output::count_open_workflow_executions_output::Builder {
        crate::output::count_open_workflow_executions_output::Builder::default()
    }
}

/// See [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput).
pub mod count_open_workflow_executions_output {

    /// A builder for [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The number of workflow executions.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of workflow executions.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CountOpenWorkflowExecutionsOutput`](crate::output::CountOpenWorkflowExecutionsOutput).
        pub fn build(self) -> crate::output::CountOpenWorkflowExecutionsOutput {
            crate::output::CountOpenWorkflowExecutionsOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}

/// <p>Contains the count of workflow executions returned from <code>CountOpenWorkflowExecutions</code> or <code>CountClosedWorkflowExecutions</code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CountClosedWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    #[doc(hidden)]
    pub count: i32,
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    #[doc(hidden)]
    pub truncated: bool,
    _request_id: Option<String>,
}
impl CountClosedWorkflowExecutionsOutput {
    /// <p>The number of workflow executions.</p>
    pub fn count(&self) -> i32 {
        self.count
    }
    /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
    pub fn truncated(&self) -> bool {
        self.truncated
    }
}
impl aws_http::request_id::RequestId for CountClosedWorkflowExecutionsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl CountClosedWorkflowExecutionsOutput {
    /// Creates a new builder-style object to manufacture [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput).
    pub fn builder() -> crate::output::count_closed_workflow_executions_output::Builder {
        crate::output::count_closed_workflow_executions_output::Builder::default()
    }
}

/// See [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput).
pub mod count_closed_workflow_executions_output {

    /// A builder for [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) count: std::option::Option<i32>,
        pub(crate) truncated: std::option::Option<bool>,
        _request_id: Option<String>,
    }
    impl Builder {
        /// <p>The number of workflow executions.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of workflow executions.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input;
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn truncated(mut self, input: bool) -> Self {
            self.truncated = Some(input);
            self
        }
        /// <p>If set to true, indicates that the actual count was more than the maximum supported by this API and the count returned is the truncated value.</p>
        pub fn set_truncated(mut self, input: std::option::Option<bool>) -> Self {
            self.truncated = input;
            self
        }
        pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
            self._request_id = Some(request_id.into());
            self
        }

        pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
            self._request_id = request_id;
            self
        }
        /// Consumes the builder and constructs a [`CountClosedWorkflowExecutionsOutput`](crate::output::CountClosedWorkflowExecutionsOutput).
        pub fn build(self) -> crate::output::CountClosedWorkflowExecutionsOutput {
            crate::output::CountClosedWorkflowExecutionsOutput {
                count: self.count.unwrap_or_default(),
                truncated: self.truncated.unwrap_or_default(),
                _request_id: self._request_id,
            }
        }
    }
}
