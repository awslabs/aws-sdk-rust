// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `SimpleWorkflowService`.
///
/// This client allows ergonomic access to a `SimpleWorkflowService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn count_closed_workflow_executions(
        &self,
    ) -> fluent_builders::CountClosedWorkflowExecutions<C, M, R> {
        fluent_builders::CountClosedWorkflowExecutions::new(self.handle.clone())
    }
    pub fn count_open_workflow_executions(
        &self,
    ) -> fluent_builders::CountOpenWorkflowExecutions<C, M, R> {
        fluent_builders::CountOpenWorkflowExecutions::new(self.handle.clone())
    }
    pub fn count_pending_activity_tasks(
        &self,
    ) -> fluent_builders::CountPendingActivityTasks<C, M, R> {
        fluent_builders::CountPendingActivityTasks::new(self.handle.clone())
    }
    pub fn count_pending_decision_tasks(
        &self,
    ) -> fluent_builders::CountPendingDecisionTasks<C, M, R> {
        fluent_builders::CountPendingDecisionTasks::new(self.handle.clone())
    }
    pub fn deprecate_activity_type(&self) -> fluent_builders::DeprecateActivityType<C, M, R> {
        fluent_builders::DeprecateActivityType::new(self.handle.clone())
    }
    pub fn deprecate_domain(&self) -> fluent_builders::DeprecateDomain<C, M, R> {
        fluent_builders::DeprecateDomain::new(self.handle.clone())
    }
    pub fn deprecate_workflow_type(&self) -> fluent_builders::DeprecateWorkflowType<C, M, R> {
        fluent_builders::DeprecateWorkflowType::new(self.handle.clone())
    }
    pub fn describe_activity_type(&self) -> fluent_builders::DescribeActivityType<C, M, R> {
        fluent_builders::DescribeActivityType::new(self.handle.clone())
    }
    pub fn describe_domain(&self) -> fluent_builders::DescribeDomain<C, M, R> {
        fluent_builders::DescribeDomain::new(self.handle.clone())
    }
    pub fn describe_workflow_execution(
        &self,
    ) -> fluent_builders::DescribeWorkflowExecution<C, M, R> {
        fluent_builders::DescribeWorkflowExecution::new(self.handle.clone())
    }
    pub fn describe_workflow_type(&self) -> fluent_builders::DescribeWorkflowType<C, M, R> {
        fluent_builders::DescribeWorkflowType::new(self.handle.clone())
    }
    pub fn get_workflow_execution_history(
        &self,
    ) -> fluent_builders::GetWorkflowExecutionHistory<C, M, R> {
        fluent_builders::GetWorkflowExecutionHistory::new(self.handle.clone())
    }
    pub fn list_activity_types(&self) -> fluent_builders::ListActivityTypes<C, M, R> {
        fluent_builders::ListActivityTypes::new(self.handle.clone())
    }
    pub fn list_closed_workflow_executions(
        &self,
    ) -> fluent_builders::ListClosedWorkflowExecutions<C, M, R> {
        fluent_builders::ListClosedWorkflowExecutions::new(self.handle.clone())
    }
    pub fn list_domains(&self) -> fluent_builders::ListDomains<C, M, R> {
        fluent_builders::ListDomains::new(self.handle.clone())
    }
    pub fn list_open_workflow_executions(
        &self,
    ) -> fluent_builders::ListOpenWorkflowExecutions<C, M, R> {
        fluent_builders::ListOpenWorkflowExecutions::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_workflow_types(&self) -> fluent_builders::ListWorkflowTypes<C, M, R> {
        fluent_builders::ListWorkflowTypes::new(self.handle.clone())
    }
    pub fn poll_for_activity_task(&self) -> fluent_builders::PollForActivityTask<C, M, R> {
        fluent_builders::PollForActivityTask::new(self.handle.clone())
    }
    pub fn poll_for_decision_task(&self) -> fluent_builders::PollForDecisionTask<C, M, R> {
        fluent_builders::PollForDecisionTask::new(self.handle.clone())
    }
    pub fn record_activity_task_heartbeat(
        &self,
    ) -> fluent_builders::RecordActivityTaskHeartbeat<C, M, R> {
        fluent_builders::RecordActivityTaskHeartbeat::new(self.handle.clone())
    }
    pub fn register_activity_type(&self) -> fluent_builders::RegisterActivityType<C, M, R> {
        fluent_builders::RegisterActivityType::new(self.handle.clone())
    }
    pub fn register_domain(&self) -> fluent_builders::RegisterDomain<C, M, R> {
        fluent_builders::RegisterDomain::new(self.handle.clone())
    }
    pub fn register_workflow_type(&self) -> fluent_builders::RegisterWorkflowType<C, M, R> {
        fluent_builders::RegisterWorkflowType::new(self.handle.clone())
    }
    pub fn request_cancel_workflow_execution(
        &self,
    ) -> fluent_builders::RequestCancelWorkflowExecution<C, M, R> {
        fluent_builders::RequestCancelWorkflowExecution::new(self.handle.clone())
    }
    pub fn respond_activity_task_canceled(
        &self,
    ) -> fluent_builders::RespondActivityTaskCanceled<C, M, R> {
        fluent_builders::RespondActivityTaskCanceled::new(self.handle.clone())
    }
    pub fn respond_activity_task_completed(
        &self,
    ) -> fluent_builders::RespondActivityTaskCompleted<C, M, R> {
        fluent_builders::RespondActivityTaskCompleted::new(self.handle.clone())
    }
    pub fn respond_activity_task_failed(
        &self,
    ) -> fluent_builders::RespondActivityTaskFailed<C, M, R> {
        fluent_builders::RespondActivityTaskFailed::new(self.handle.clone())
    }
    pub fn respond_decision_task_completed(
        &self,
    ) -> fluent_builders::RespondDecisionTaskCompleted<C, M, R> {
        fluent_builders::RespondDecisionTaskCompleted::new(self.handle.clone())
    }
    pub fn signal_workflow_execution(&self) -> fluent_builders::SignalWorkflowExecution<C, M, R> {
        fluent_builders::SignalWorkflowExecution::new(self.handle.clone())
    }
    pub fn start_workflow_execution(&self) -> fluent_builders::StartWorkflowExecution<C, M, R> {
        fluent_builders::StartWorkflowExecution::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn terminate_workflow_execution(
        &self,
    ) -> fluent_builders::TerminateWorkflowExecution<C, M, R> {
        fluent_builders::TerminateWorkflowExecution::new(self.handle.clone())
    }
    pub fn undeprecate_activity_type(&self) -> fluent_builders::UndeprecateActivityType<C, M, R> {
        fluent_builders::UndeprecateActivityType::new(self.handle.clone())
    }
    pub fn undeprecate_domain(&self) -> fluent_builders::UndeprecateDomain<C, M, R> {
        fluent_builders::UndeprecateDomain::new(self.handle.clone())
    }
    pub fn undeprecate_workflow_type(&self) -> fluent_builders::UndeprecateWorkflowType<C, M, R> {
        fluent_builders::UndeprecateWorkflowType::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CountClosedWorkflowExecutions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::count_closed_workflow_executions_input::Builder,
    }
    impl<C, M, R> CountClosedWorkflowExecutions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountClosedWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::CountClosedWorkflowExecutionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CountClosedWorkflowExecutionsInputOperationOutputAlias,
                crate::output::CountClosedWorkflowExecutionsOutput,
                crate::error::CountClosedWorkflowExecutionsError,
                crate::input::CountClosedWorkflowExecutionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow executions to count.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, only workflow executions that meet the start time criteria of the filter
        /// are counted.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn start_time_filter(mut self, inp: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(inp);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>If specified, only workflow executions that meet the close time criteria of the filter
        /// are counted.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn close_time_filter(mut self, inp: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.close_time_filter(inp);
            self
        }
        pub fn set_close_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_time_filter(input);
            self
        }
        /// <p>If specified, only workflow executions matching the <code>WorkflowId</code> in the
        /// filter are counted.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn execution_filter(mut self, inp: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(inp);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
        /// <p>If specified, indicates the type of the workflow executions to be counted.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn type_filter(mut self, inp: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(inp);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have a tag that matches the filter are
        /// counted.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn tag_filter(mut self, inp: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(inp);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If specified, only workflow executions that match this close status are counted. This
        /// filter has an affect only if <code>executionStatus</code> is specified as
        /// <code>CLOSED</code>.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn close_status_filter(mut self, inp: crate::model::CloseStatusFilter) -> Self {
            self.inner = self.inner.close_status_filter(inp);
            self
        }
        pub fn set_close_status_filter(
            mut self,
            input: std::option::Option<crate::model::CloseStatusFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_status_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CountOpenWorkflowExecutions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::count_open_workflow_executions_input::Builder,
    }
    impl<C, M, R> CountOpenWorkflowExecutions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountOpenWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::CountOpenWorkflowExecutionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CountOpenWorkflowExecutionsInputOperationOutputAlias,
                crate::output::CountOpenWorkflowExecutionsOutput,
                crate::error::CountOpenWorkflowExecutionsError,
                crate::input::CountOpenWorkflowExecutionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow executions to count.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the start time criteria that workflow executions must meet in order to be
        /// counted.</p>
        pub fn start_time_filter(mut self, inp: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(inp);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>Specifies the type of the workflow executions to be counted.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn type_filter(mut self, inp: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(inp);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have a tag that matches the filter are
        /// counted.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn tag_filter(mut self, inp: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(inp);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If specified, only workflow executions matching the <code>WorkflowId</code> in the
        /// filter are counted.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn execution_filter(mut self, inp: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(inp);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CountPendingActivityTasks<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::count_pending_activity_tasks_input::Builder,
    }
    impl<C, M, R> CountPendingActivityTasks<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountPendingActivityTasksOutput,
            smithy_http::result::SdkError<crate::error::CountPendingActivityTasksError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CountPendingActivityTasksInputOperationOutputAlias,
                crate::output::CountPendingActivityTasksOutput,
                crate::error::CountPendingActivityTasksError,
                crate::input::CountPendingActivityTasksInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the task list.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the task list.</p>
        pub fn task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(inp);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CountPendingDecisionTasks<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::count_pending_decision_tasks_input::Builder,
    }
    impl<C, M, R> CountPendingDecisionTasks<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountPendingDecisionTasksOutput,
            smithy_http::result::SdkError<crate::error::CountPendingDecisionTasksError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CountPendingDecisionTasksInputOperationOutputAlias,
                crate::output::CountPendingDecisionTasksOutput,
                crate::error::CountPendingDecisionTasksError,
                crate::input::CountPendingDecisionTasksInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the task list.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the task list.</p>
        pub fn task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(inp);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateActivityType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deprecate_activity_type_input::Builder,
    }
    impl<C, M, R> DeprecateActivityType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::DeprecateActivityTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeprecateActivityTypeInputOperationOutputAlias,
                crate::output::DeprecateActivityTypeOutput,
                crate::error::DeprecateActivityTypeError,
                crate::input::DeprecateActivityTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the activity type is registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The activity type to deprecate.</p>
        pub fn activity_type(mut self, inp: crate::model::ActivityType) -> Self {
            self.inner = self.inner.activity_type(inp);
            self
        }
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.inner = self.inner.set_activity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deprecate_domain_input::Builder,
    }
    impl<C, M, R> DeprecateDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateDomainOutput,
            smithy_http::result::SdkError<crate::error::DeprecateDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeprecateDomainInputOperationOutputAlias,
                crate::output::DeprecateDomainOutput,
                crate::error::DeprecateDomainError,
                crate::input::DeprecateDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain to deprecate.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateWorkflowType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deprecate_workflow_type_input::Builder,
    }
    impl<C, M, R> DeprecateWorkflowType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::DeprecateWorkflowTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeprecateWorkflowTypeInputOperationOutputAlias,
                crate::output::DeprecateWorkflowTypeOutput,
                crate::error::DeprecateWorkflowTypeError,
                crate::input::DeprecateWorkflowTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the workflow type is registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflow type to deprecate.</p>
        pub fn workflow_type(mut self, inp: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(inp);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeActivityType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_activity_type_input::Builder,
    }
    impl<C, M, R> DescribeActivityType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::DescribeActivityTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeActivityTypeInputOperationOutputAlias,
                crate::output::DescribeActivityTypeOutput,
                crate::error::DescribeActivityTypeError,
                crate::input::DescribeActivityTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the activity type is registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The activity type to get information about. Activity types are identified by the
        /// <code>name</code> and <code>version</code> that were supplied when the activity was
        /// registered.</p>
        pub fn activity_type(mut self, inp: crate::model::ActivityType) -> Self {
            self.inner = self.inner.activity_type(inp);
            self
        }
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.inner = self.inner.set_activity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_domain_input::Builder,
    }
    impl<C, M, R> DescribeDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDomainOutput,
            smithy_http::result::SdkError<crate::error::DescribeDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeDomainInputOperationOutputAlias,
                crate::output::DescribeDomainOutput,
                crate::error::DescribeDomainError,
                crate::input::DescribeDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain to describe.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeWorkflowExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_workflow_execution_input::Builder,
    }
    impl<C, M, R> DescribeWorkflowExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::DescribeWorkflowExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeWorkflowExecutionInputOperationOutputAlias,
                crate::output::DescribeWorkflowExecutionOutput,
                crate::error::DescribeWorkflowExecutionError,
                crate::input::DescribeWorkflowExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflow execution to describe.</p>
        pub fn execution(mut self, inp: crate::model::WorkflowExecution) -> Self {
            self.inner = self.inner.execution(inp);
            self
        }
        pub fn set_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.inner = self.inner.set_execution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeWorkflowType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_workflow_type_input::Builder,
    }
    impl<C, M, R> DescribeWorkflowType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::DescribeWorkflowTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeWorkflowTypeInputOperationOutputAlias,
                crate::output::DescribeWorkflowTypeOutput,
                crate::error::DescribeWorkflowTypeError,
                crate::input::DescribeWorkflowTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which this workflow type is registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflow type to describe.</p>
        pub fn workflow_type(mut self, inp: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(inp);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkflowExecutionHistory<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_workflow_execution_history_input::Builder,
    }
    impl<C, M, R> GetWorkflowExecutionHistory<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkflowExecutionHistoryOutput,
            smithy_http::result::SdkError<crate::error::GetWorkflowExecutionHistoryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetWorkflowExecutionHistoryInputOperationOutputAlias,
                crate::output::GetWorkflowExecutionHistoryOutput,
                crate::error::GetWorkflowExecutionHistoryError,
                crate::input::GetWorkflowExecutionHistoryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the workflow execution for which to return the history.</p>
        pub fn execution(mut self, inp: crate::model::WorkflowExecution) -> Self {
            self.inner = self.inner.execution(inp);
            self
        }
        pub fn set_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.inner = self.inner.set_execution(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the events in reverse order. By default the
        /// results are returned in ascending order of the <code>eventTimeStamp</code> of the
        /// events.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListActivityTypes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_activity_types_input::Builder,
    }
    impl<C, M, R> ListActivityTypes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListActivityTypesOutput,
            smithy_http::result::SdkError<crate::error::ListActivityTypesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListActivityTypesInputOperationOutputAlias,
                crate::output::ListActivityTypesOutput,
                crate::error::ListActivityTypesError,
                crate::input::ListActivityTypesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the activity types have been registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, only lists the activity types that have this name.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the registration status of the activity types to list.</p>
        pub fn registration_status(mut self, inp: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(inp);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the
        /// results are returned in ascending alphabetical order by <code>name</code> of the activity
        /// types.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClosedWorkflowExecutions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_closed_workflow_executions_input::Builder,
    }
    impl<C, M, R> ListClosedWorkflowExecutions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClosedWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListClosedWorkflowExecutionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListClosedWorkflowExecutionsInputOperationOutputAlias,
                crate::output::ListClosedWorkflowExecutionsOutput,
                crate::error::ListClosedWorkflowExecutionsError,
                crate::input::ListClosedWorkflowExecutionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the workflow executions to list.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, the workflow executions are included in the returned results based on
        /// whether their start times are within the range specified by this filter. Also, if this
        /// parameter is specified, the returned results are ordered by their start times.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn start_time_filter(mut self, inp: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(inp);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>If specified, the workflow executions are included in the returned results based on
        /// whether their close times are within the range specified by this filter. Also, if this
        /// parameter is specified, the returned results are ordered by their close times.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn close_time_filter(mut self, inp: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.close_time_filter(inp);
            self
        }
        pub fn set_close_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_time_filter(input);
            self
        }
        /// <p>If specified, only workflow executions matching the workflow ID specified in the filter
        /// are returned.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn execution_filter(mut self, inp: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(inp);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
        /// <p>If specified, only workflow executions that match this <i>close
        /// status</i> are listed. For example, if TERMINATED is specified, then only TERMINATED
        /// workflow executions are listed.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn close_status_filter(mut self, inp: crate::model::CloseStatusFilter) -> Self {
            self.inner = self.inner.close_status_filter(inp);
            self
        }
        pub fn set_close_status_filter(
            mut self,
            input: std::option::Option<crate::model::CloseStatusFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_status_filter(input);
            self
        }
        /// <p>If specified, only executions of the type specified in the filter are
        /// returned.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn type_filter(mut self, inp: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(inp);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have the matching tag are listed.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn tag_filter(mut self, inp: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(inp);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default the
        /// results are returned in descending order of the start or the close time of the
        /// executions.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDomains<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_domains_input::Builder,
    }
    impl<C, M, R> ListDomains<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDomainsOutput,
            smithy_http::result::SdkError<crate::error::ListDomainsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListDomainsInputOperationOutputAlias,
                crate::output::ListDomainsOutput,
                crate::error::ListDomainsError,
                crate::input::ListDomainsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>Specifies the registration status of the domains to list.</p>
        pub fn registration_status(mut self, inp: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(inp);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the
        /// results are returned in ascending alphabetical order by <code>name</code> of the
        /// domains.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOpenWorkflowExecutions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_open_workflow_executions_input::Builder,
    }
    impl<C, M, R> ListOpenWorkflowExecutions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOpenWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListOpenWorkflowExecutionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListOpenWorkflowExecutionsInputOperationOutputAlias,
                crate::output::ListOpenWorkflowExecutionsOutput,
                crate::error::ListOpenWorkflowExecutionsError,
                crate::input::ListOpenWorkflowExecutionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the workflow executions to list.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Workflow executions are included in the returned results based on whether their start
        /// times are within the range specified by this filter.</p>
        pub fn start_time_filter(mut self, inp: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(inp);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>If specified, only executions of the type specified in the filter are
        /// returned.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn type_filter(mut self, inp: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(inp);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have the matching tag are listed.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn tag_filter(mut self, inp: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(inp);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default the
        /// results are returned in descending order of the start time of the executions.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
        /// <p>If specified, only workflow executions matching the workflow ID specified in the filter
        /// are returned.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn execution_filter(mut self, inp: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(inp);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon SWF domain.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWorkflowTypes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_workflow_types_input::Builder,
    }
    impl<C, M, R> ListWorkflowTypes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkflowTypesOutput,
            smithy_http::result::SdkError<crate::error::ListWorkflowTypesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListWorkflowTypesInputOperationOutputAlias,
                crate::output::ListWorkflowTypesOutput,
                crate::error::ListWorkflowTypesError,
                crate::input::ListWorkflowTypesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the workflow types have been registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, lists the workflow type with this name.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the registration status of the workflow types to list.</p>
        pub fn registration_status(mut self, inp: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(inp);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default the
        /// results are returned in ascending alphabetical order of the <code>name</code> of the workflow
        /// types.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForActivityTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::poll_for_activity_task_input::Builder,
    }
    impl<C, M, R> PollForActivityTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForActivityTaskOutput,
            smithy_http::result::SdkError<crate::error::PollForActivityTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PollForActivityTaskInputOperationOutputAlias,
                crate::output::PollForActivityTaskOutput,
                crate::error::PollForActivityTaskError,
                crate::input::PollForActivityTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the task lists being polled.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the task list to poll for activity tasks.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(inp);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
        /// <p>Identity of the worker making the request, recorded in the
        /// <code>ActivityTaskStarted</code> event in the workflow history. This enables diagnostic
        /// tracing when problems arise. The form of this identity is user defined.</p>
        pub fn identity(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(inp);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForDecisionTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::poll_for_decision_task_input::Builder,
    }
    impl<C, M, R> PollForDecisionTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForDecisionTaskOutput,
            smithy_http::result::SdkError<crate::error::PollForDecisionTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PollForDecisionTaskInputOperationOutputAlias,
                crate::output::PollForDecisionTaskOutput,
                crate::error::PollForDecisionTaskError,
                crate::input::PollForDecisionTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the task lists to poll.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the task list to poll for decision tasks.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(inp);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
        /// <p>Identity of the decider making the request, which is recorded in the
        /// DecisionTaskStarted event in the workflow history. This enables diagnostic tracing when
        /// problems arise. The form of this identity is user defined.</p>
        pub fn identity(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(inp);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        /// <note>
        /// <p>The <code>nextPageToken</code> returned by this action cannot be used with <a>GetWorkflowExecutionHistory</a> to get the next page. You must call <a>PollForDecisionTask</a> again (with the <code>nextPageToken</code>) to retrieve
        /// the next page of history records. Calling <a>PollForDecisionTask</a> with a
        /// <code>nextPageToken</code> doesn't return a new decision task.</p>
        /// </note>
        pub fn next_page_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(inp);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>  
        /// <p>This
        /// is an upper limit only; the actual number of results returned per call may be fewer than the
        /// specified maximum.</p>
        pub fn maximum_page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.maximum_page_size(inp);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the events in reverse order. By default the
        /// results are returned in ascending order of the <code>eventTimestamp</code> of the
        /// events.</p>
        pub fn reverse_order(mut self, inp: bool) -> Self {
            self.inner = self.inner.reverse_order(inp);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RecordActivityTaskHeartbeat<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::record_activity_task_heartbeat_input::Builder,
    }
    impl<C, M, R> RecordActivityTaskHeartbeat<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RecordActivityTaskHeartbeatOutput,
            smithy_http::result::SdkError<crate::error::RecordActivityTaskHeartbeatError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RecordActivityTaskHeartbeatInputOperationOutputAlias,
                crate::output::RecordActivityTaskHeartbeatOutput,
                crate::error::RecordActivityTaskHeartbeatError,
                crate::input::RecordActivityTaskHeartbeatInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results. </p>
        /// </important>
        pub fn task_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(inp);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>If specified, contains details about the progress of the task.</p>
        pub fn details(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(inp);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterActivityType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_activity_type_input::Builder,
    }
    impl<C, M, R> RegisterActivityType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::RegisterActivityTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterActivityTypeInputOperationOutputAlias,
                crate::output::RegisterActivityTypeOutput,
                crate::error::RegisterActivityTypeError,
                crate::input::RegisterActivityTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which this activity is to be registered.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the activity type within the domain.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The version of the activity type.</p>
        /// <note>
        /// <p>The activity type consists of the name and version, the combination of which must be
        /// unique within the domain.</p>
        /// </note>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>A textual description of the activity type.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>If set, specifies the default maximum duration that a worker can take to process tasks
        /// of this activity type. This default can be overridden when scheduling an activity task using
        /// the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_start_to_close_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_start_to_close_timeout(inp);
            self
        }
        pub fn set_default_task_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the default maximum time before which a worker processing a task of
        /// this type must report progress by calling <a>RecordActivityTaskHeartbeat</a>. If
        /// the timeout is exceeded, the activity task is automatically timed out. This default can be
        /// overridden when scheduling an activity task using the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>. If the activity worker subsequently attempts to record a heartbeat
        /// or returns a result, the activity worker receives an <code>UnknownResource</code> fault. In
        /// this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should
        /// clean up the activity task.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_heartbeat_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_heartbeat_timeout(inp);
            self
        }
        pub fn set_default_task_heartbeat_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_heartbeat_timeout(input);
            self
        }
        /// <p>If set, specifies the default task list to use for scheduling tasks of this activity
        /// type. This default task list is used if a task list isn't provided when a task is scheduled
        /// through the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        pub fn default_task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.default_task_list(inp);
            self
        }
        pub fn set_default_task_list(
            mut self,
            input: std::option::Option<crate::model::TaskList>,
        ) -> Self {
            self.inner = self.inner.set_default_task_list(input);
            self
        }
        /// <p>The default task priority to assign to the activity type. If not assigned, then
        /// <code>0</code> is used. Valid values are integers that range from Java's
        /// <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647).
        /// Higher numbers indicate higher priority.</p>
        /// <p>For more information about setting task priority, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html">Setting Task
        /// Priority</a> in the <i>in the
        /// <i>Amazon SWF Developer Guide</i>.</i>.</p>
        pub fn default_task_priority(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_task_priority(inp);
            self
        }
        pub fn set_default_task_priority(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_priority(input);
            self
        }
        /// <p>If set, specifies the default maximum duration that a task of this activity type can
        /// wait before being assigned to a worker. This default can be overridden when scheduling an
        /// activity task using the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_schedule_to_start_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_schedule_to_start_timeout(inp);
            self
        }
        pub fn set_default_task_schedule_to_start_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_schedule_to_start_timeout(input);
            self
        }
        /// <p>If set, specifies the default maximum duration for a task of this activity type. This
        /// default can be overridden when scheduling an activity task using the
        /// <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_schedule_to_close_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_schedule_to_close_timeout(inp);
            self
        }
        pub fn set_default_task_schedule_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_schedule_to_close_timeout(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_domain_input::Builder,
    }
    impl<C, M, R> RegisterDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterDomainOutput,
            smithy_http::result::SdkError<crate::error::RegisterDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterDomainInputOperationOutputAlias,
                crate::output::RegisterDomainOutput,
                crate::error::RegisterDomainError,
                crate::input::RegisterDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the domain to register. The name must be unique in the region that the domain
        /// is registered in.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A text description of the domain.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The duration (in days) that records and histories of workflow executions on the domain
        /// should be kept by the service. After the retention period, the workflow execution isn't
        /// available in the results of visibility calls.</p>
        /// <p>If you pass the value <code>NONE</code> or <code>0</code> (zero), then the workflow
        /// execution history isn't retained. As soon as the workflow execution completes, the execution
        /// record and its history are deleted.</p>
        /// <p>The maximum workflow execution retention period is 90 days. For more information about
        /// Amazon SWF service limits, see: <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-limits.html">Amazon SWF Service Limits</a> in the
        /// <i>Amazon SWF Developer Guide</i>.</p>
        pub fn workflow_execution_retention_period_in_days(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.workflow_execution_retention_period_in_days(inp);
            self
        }
        pub fn set_workflow_execution_retention_period_in_days(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_workflow_execution_retention_period_in_days(input);
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>Tags to be added when registering a domain.</p>
        /// <p>Tags may only contain unicode letters, digits, whitespace, or these symbols: <code>_ . : / = + - @</code>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::ResourceTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterWorkflowType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_workflow_type_input::Builder,
    }
    impl<C, M, R> RegisterWorkflowType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::RegisterWorkflowTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterWorkflowTypeInputOperationOutputAlias,
                crate::output::RegisterWorkflowTypeOutput,
                crate::error::RegisterWorkflowTypeError,
                crate::input::RegisterWorkflowTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which to register the workflow type.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the workflow type.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The version of the workflow type.</p>
        /// <note>
        /// <p>The workflow type consists of the name and version, the combination of which must be
        /// unique within the domain. To get a list of all currently registered workflow types, use the
        /// <a>ListWorkflowTypes</a> action.</p>
        /// </note>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(inp);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>Textual description of the workflow type.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>If set, specifies the default maximum duration of decision tasks for this workflow
        /// type. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_start_to_close_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_start_to_close_timeout(inp);
            self
        }
        pub fn set_default_task_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the default maximum duration for executions of this workflow type.
        /// You can override this default when starting an execution through the <a>StartWorkflowExecution</a> Action or <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds; an integer greater than or equal to 0. Unlike
        /// some of the other timeout parameters in Amazon SWF, you cannot specify a value of "NONE" for
        /// <code>defaultExecutionStartToCloseTimeout</code>; there is a one-year max limit on the time
        /// that a workflow execution can run. Exceeding this limit always causes the workflow execution
        /// to time out.</p>
        pub fn default_execution_start_to_close_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_execution_start_to_close_timeout(inp);
            self
        }
        pub fn set_default_execution_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_default_execution_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the default task list to use for scheduling decision tasks for
        /// executions of this workflow type. This default is used only if a task list isn't provided when
        /// starting the execution through the <a>StartWorkflowExecution</a> Action or
        /// <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        pub fn default_task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.default_task_list(inp);
            self
        }
        pub fn set_default_task_list(
            mut self,
            input: std::option::Option<crate::model::TaskList>,
        ) -> Self {
            self.inner = self.inner.set_default_task_list(input);
            self
        }
        /// <p>The default task priority to assign to the workflow type. If not assigned, then
        /// <code>0</code> is used. Valid values are integers that range from Java's
        /// <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647).
        /// Higher numbers indicate higher priority.</p>
        /// <p>For more information about setting task priority, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html">Setting Task
        /// Priority</a> in the <i>Amazon SWF Developer Guide</i>.</p>
        pub fn default_task_priority(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_task_priority(inp);
            self
        }
        pub fn set_default_task_priority(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_priority(input);
            self
        }
        /// <p>If set, specifies the default policy to use for the child workflow executions when a
        /// workflow execution of this type is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout. This
        /// default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        /// <p>The supported child policies are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TERMINATE</code>  The child executions are terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REQUEST_CANCEL</code>  A request to cancel is attempted for each child
        /// execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its
        /// history. It is up to the decider to take appropriate actions when it receives an execution
        /// history with this event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ABANDON</code>  No action is taken. The child executions continue to
        /// run.</p>
        /// </li>
        /// </ul>
        pub fn default_child_policy(mut self, inp: crate::model::ChildPolicy) -> Self {
            self.inner = self.inner.default_child_policy(inp);
            self
        }
        pub fn set_default_child_policy(
            mut self,
            input: std::option::Option<crate::model::ChildPolicy>,
        ) -> Self {
            self.inner = self.inner.set_default_child_policy(input);
            self
        }
        /// <p>The default IAM role attached to this workflow type.</p>
        /// <note>
        /// <p>Executions of this workflow type need IAM roles to invoke Lambda functions. If you
        /// don't specify an IAM role when you start this workflow type, the default Lambda role is
        /// attached to the execution. For more information, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html">https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html</a> in the
        /// <i>Amazon SWF Developer Guide</i>.</p>
        /// </note>
        pub fn default_lambda_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_lambda_role(inp);
            self
        }
        pub fn set_default_lambda_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_lambda_role(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestCancelWorkflowExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::request_cancel_workflow_execution_input::Builder,
    }
    impl<C, M, R> RequestCancelWorkflowExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestCancelWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::RequestCancelWorkflowExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RequestCancelWorkflowExecutionInputOperationOutputAlias,
                crate::output::RequestCancelWorkflowExecutionOutput,
                crate::error::RequestCancelWorkflowExecutionError,
                crate::input::RequestCancelWorkflowExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution to cancel.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflowId of the workflow execution to cancel.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The runId of the workflow execution to cancel.</p>
        pub fn run_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(inp);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondActivityTaskCanceled<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::respond_activity_task_canceled_input::Builder,
    }
    impl<C, M, R> RespondActivityTaskCanceled<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondActivityTaskCanceledOutput,
            smithy_http::result::SdkError<crate::error::RespondActivityTaskCanceledError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RespondActivityTaskCanceledInputOperationOutputAlias,
                crate::output::RespondActivityTaskCanceledOutput,
                crate::error::RespondActivityTaskCanceledError,
                crate::input::RespondActivityTaskCanceledInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(inp);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p> Information about the cancellation.</p>
        pub fn details(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(inp);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondActivityTaskCompleted<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::respond_activity_task_completed_input::Builder,
    }
    impl<C, M, R> RespondActivityTaskCompleted<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondActivityTaskCompletedOutput,
            smithy_http::result::SdkError<crate::error::RespondActivityTaskCompletedError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RespondActivityTaskCompletedInputOperationOutputAlias,
                crate::output::RespondActivityTaskCompletedOutput,
                crate::error::RespondActivityTaskCompletedError,
                crate::input::RespondActivityTaskCompletedInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(inp);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>The result of the activity task. It is a free form string that is implementation
        /// specific.</p>
        pub fn result(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.result(inp);
            self
        }
        pub fn set_result(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_result(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondActivityTaskFailed<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::respond_activity_task_failed_input::Builder,
    }
    impl<C, M, R> RespondActivityTaskFailed<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondActivityTaskFailedOutput,
            smithy_http::result::SdkError<crate::error::RespondActivityTaskFailedError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RespondActivityTaskFailedInputOperationOutputAlias,
                crate::output::RespondActivityTaskFailedOutput,
                crate::error::RespondActivityTaskFailedError,
                crate::input::RespondActivityTaskFailedInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(inp);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>Description of the error that may assist in diagnostics.</p>
        pub fn reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(inp);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p> Detailed information about the failure.</p>
        pub fn details(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(inp);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondDecisionTaskCompleted<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::respond_decision_task_completed_input::Builder,
    }
    impl<C, M, R> RespondDecisionTaskCompleted<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondDecisionTaskCompletedOutput,
            smithy_http::result::SdkError<crate::error::RespondDecisionTaskCompletedError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RespondDecisionTaskCompletedInputOperationOutputAlias,
                crate::output::RespondDecisionTaskCompletedOutput,
                crate::error::RespondDecisionTaskCompletedError,
                crate::input::RespondDecisionTaskCompletedInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> from the <a>DecisionTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(inp);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// Appends an item to `decisions`.
        ///
        /// To override the contents of this collection use [`set_decisions`](Self::set_decisions).
        /// <p>The list of decisions (possibly empty) made by the decider while processing this
        /// decision task. See the docs for the <a>Decision</a> structure for
        /// details.</p>
        pub fn decisions(mut self, inp: impl Into<crate::model::Decision>) -> Self {
            self.inner = self.inner.decisions(inp);
            self
        }
        pub fn set_decisions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Decision>>,
        ) -> Self {
            self.inner = self.inner.set_decisions(input);
            self
        }
        /// <p>User defined context to add to workflow execution.</p>
        pub fn execution_context(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.execution_context(inp);
            self
        }
        pub fn set_execution_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_execution_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SignalWorkflowExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::signal_workflow_execution_input::Builder,
    }
    impl<C, M, R> SignalWorkflowExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SignalWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::SignalWorkflowExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SignalWorkflowExecutionInputOperationOutputAlias,
                crate::output::SignalWorkflowExecutionOutput,
                crate::error::SignalWorkflowExecutionError,
                crate::input::SignalWorkflowExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution to signal.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflowId of the workflow execution to signal.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The runId of the workflow execution to signal.</p>
        pub fn run_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(inp);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p>The name of the signal. This name must be meaningful to the target workflow.</p>
        pub fn signal_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.signal_name(inp);
            self
        }
        pub fn set_signal_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_signal_name(input);
            self
        }
        /// <p>Data to attach to the <code>WorkflowExecutionSignaled</code> event in the target
        /// workflow execution's history.</p>
        pub fn input(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input(inp);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartWorkflowExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_workflow_execution_input::Builder,
    }
    impl<C, M, R> StartWorkflowExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartWorkflowExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartWorkflowExecutionInputOperationOutputAlias,
                crate::output::StartWorkflowExecutionOutput,
                crate::error::StartWorkflowExecutionError,
                crate::input::StartWorkflowExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the workflow execution is created.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The user defined identifier associated with the workflow execution. You can use this to
        /// associate a custom identifier with the workflow execution. You may specify the same identifier
        /// if a workflow execution is logically a <i>restart</i> of a previous execution.
        /// You cannot have two open workflow executions with the same <code>workflowId</code> at the same
        /// time within the same domain.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The type of the workflow to start.</p>
        pub fn workflow_type(mut self, inp: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(inp);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
        /// <p>The task list to use for the decision tasks generated for this workflow execution. This
        /// overrides the <code>defaultTaskList</code> specified when registering the workflow
        /// type.</p>
        /// <note>
        /// <p>A task list for this workflow execution must be specified either as a default for the
        /// workflow type or through this parameter. If neither this parameter is set nor a default task
        /// list was specified at registration time then a fault is returned.</p>
        /// </note>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn task_list(mut self, inp: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(inp);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
        /// <p>The task priority to use for this workflow execution. This overrides any default
        /// priority that was assigned when the workflow type was registered. If not set, then the default
        /// task priority for the workflow type is used. Valid values are integers that range from Java's
        /// <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647).
        /// Higher numbers indicate higher priority.</p>
        /// <p>For more information about setting task priority, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html">Setting Task
        /// Priority</a> in the <i>Amazon SWF Developer Guide</i>.</p>
        pub fn task_priority(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_priority(inp);
            self
        }
        pub fn set_task_priority(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_priority(input);
            self
        }
        /// <p>The input for the workflow execution. This is a free form string which should be
        /// meaningful to the workflow you are starting. This <code>input</code> is made available to the
        /// new workflow execution in the <code>WorkflowExecutionStarted</code> history event.</p>
        pub fn input(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input(inp);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
        /// <p>The total duration for this workflow execution. This overrides the
        /// defaultExecutionStartToCloseTimeout specified when registering the workflow type.</p>
        /// <p>The duration is specified in seconds; an integer greater than or equal to
        /// <code>0</code>. Exceeding this limit causes the workflow execution to time out. Unlike some
        /// of the other timeout parameters in Amazon SWF, you cannot specify a value of "NONE" for this
        /// timeout; there is a one-year max limit on the time that a workflow execution can
        /// run.</p>
        /// <note>
        /// <p>An execution start-to-close timeout must be specified either through this parameter
        /// or as a default when the workflow type is registered. If neither this parameter nor a
        /// default execution start-to-close timeout is specified, a fault is returned.</p>
        /// </note>
        pub fn execution_start_to_close_timeout(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.execution_start_to_close_timeout(inp);
            self
        }
        pub fn set_execution_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_execution_start_to_close_timeout(input);
            self
        }
        /// Appends an item to `tagList`.
        ///
        /// To override the contents of this collection use [`set_tag_list`](Self::set_tag_list).
        /// <p>The list of tags to associate with the workflow execution. You can specify a maximum of
        /// 5 tags. You can list workflow executions with a specific tag by calling <a>ListOpenWorkflowExecutions</a> or <a>ListClosedWorkflowExecutions</a> and
        /// specifying a <a>TagFilter</a>.</p>
        pub fn tag_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_list(inp);
            self
        }
        pub fn set_tag_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_list(input);
            self
        }
        /// <p>Specifies the maximum duration of decision tasks for this workflow execution. This
        /// parameter overrides the <code>defaultTaskStartToCloseTimout</code> specified when registering
        /// the workflow type using <a>RegisterWorkflowType</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        /// <note>
        /// <p>A task start-to-close timeout for this workflow execution must be specified either as
        /// a default for the workflow type or through this parameter. If neither this parameter is set
        /// nor a default task start-to-close timeout was specified at registration time then a fault is
        /// returned.</p>
        /// </note>
        pub fn task_start_to_close_timeout(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_start_to_close_timeout(inp);
            self
        }
        pub fn set_task_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the policy to use for the child workflow executions of this workflow
        /// execution if it is terminated, by calling the <a>TerminateWorkflowExecution</a>
        /// action explicitly or due to an expired timeout. This policy overrides the default child policy
        /// specified when registering the workflow type using <a>RegisterWorkflowType</a>.</p>
        /// <p>The supported child policies are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TERMINATE</code>  The child executions are terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REQUEST_CANCEL</code>  A request to cancel is attempted for each child
        /// execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its
        /// history. It is up to the decider to take appropriate actions when it receives an execution
        /// history with this event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ABANDON</code>  No action is taken. The child executions continue to
        /// run.</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>A child policy for this workflow execution must be specified either as a default for
        /// the workflow type or through this parameter. If neither this parameter is set nor a default
        /// child policy was specified at registration time then a fault is returned.</p>
        /// </note>
        pub fn child_policy(mut self, inp: crate::model::ChildPolicy) -> Self {
            self.inner = self.inner.child_policy(inp);
            self
        }
        pub fn set_child_policy(
            mut self,
            input: std::option::Option<crate::model::ChildPolicy>,
        ) -> Self {
            self.inner = self.inner.set_child_policy(input);
            self
        }
        /// <p>The IAM role to attach to this workflow execution.</p>
        /// <note>
        /// <p>Executions of this workflow type need IAM roles to invoke Lambda functions. If you
        /// don't attach an IAM role, any attempt to schedule a Lambda task fails. This results in a
        /// <code>ScheduleLambdaFunctionFailed</code> history event. For more information, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html">https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html</a> in the
        /// <i>Amazon SWF Developer Guide</i>.</p>
        /// </note>
        pub fn lambda_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lambda_role(inp);
            self
        }
        pub fn set_lambda_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lambda_role(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon SWF domain.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The list of tags to add to a domain. </p>
        /// <p>Tags may only contain unicode letters, digits, whitespace, or these symbols: <code>_ . : / = + - @</code>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::ResourceTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TerminateWorkflowExecution<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::terminate_workflow_execution_input::Builder,
    }
    impl<C, M, R> TerminateWorkflowExecution<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TerminateWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::TerminateWorkflowExecutionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TerminateWorkflowExecutionInputOperationOutputAlias,
                crate::output::TerminateWorkflowExecutionOutput,
                crate::error::TerminateWorkflowExecutionError,
                crate::input::TerminateWorkflowExecutionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain of the workflow execution to terminate.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflowId of the workflow execution to terminate.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The runId of the workflow execution to terminate.</p>
        pub fn run_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(inp);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p> A descriptive reason for terminating the workflow execution.</p>
        pub fn reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(inp);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p> Details for terminating the workflow execution.</p>
        pub fn details(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(inp);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
        /// <p>If set, specifies the policy to use for the child workflow executions of the workflow
        /// execution being terminated. This policy overrides the child policy specified for the workflow
        /// execution at registration time or when starting the execution.</p>
        /// <p>The supported child policies are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TERMINATE</code>  The child executions are terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REQUEST_CANCEL</code>  A request to cancel is attempted for each child
        /// execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its
        /// history. It is up to the decider to take appropriate actions when it receives an execution
        /// history with this event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ABANDON</code>  No action is taken. The child executions continue to
        /// run.</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>A child policy for this workflow execution must be specified either as a default for
        /// the workflow type or through this parameter. If neither this parameter is set nor a default
        /// child policy was specified at registration time then a fault is returned.</p>
        /// </note>
        pub fn child_policy(mut self, inp: crate::model::ChildPolicy) -> Self {
            self.inner = self.inner.child_policy(inp);
            self
        }
        pub fn set_child_policy(
            mut self,
            input: std::option::Option<crate::model::ChildPolicy>,
        ) -> Self {
            self.inner = self.inner.set_child_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UndeprecateActivityType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::undeprecate_activity_type_input::Builder,
    }
    impl<C, M, R> UndeprecateActivityType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UndeprecateActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::UndeprecateActivityTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UndeprecateActivityTypeInputOperationOutputAlias,
                crate::output::UndeprecateActivityTypeOutput,
                crate::error::UndeprecateActivityTypeError,
                crate::input::UndeprecateActivityTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain of the deprecated activity type.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The activity type to undeprecate.</p>
        pub fn activity_type(mut self, inp: crate::model::ActivityType) -> Self {
            self.inner = self.inner.activity_type(inp);
            self
        }
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.inner = self.inner.set_activity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UndeprecateDomain<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::undeprecate_domain_input::Builder,
    }
    impl<C, M, R> UndeprecateDomain<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UndeprecateDomainOutput,
            smithy_http::result::SdkError<crate::error::UndeprecateDomainError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UndeprecateDomainInputOperationOutputAlias,
                crate::output::UndeprecateDomainOutput,
                crate::error::UndeprecateDomainError,
                crate::input::UndeprecateDomainInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain of the deprecated workflow type.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UndeprecateWorkflowType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::undeprecate_workflow_type_input::Builder,
    }
    impl<C, M, R> UndeprecateWorkflowType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UndeprecateWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::UndeprecateWorkflowTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UndeprecateWorkflowTypeInputOperationOutputAlias,
                crate::output::UndeprecateWorkflowTypeOutput,
                crate::error::UndeprecateWorkflowTypeError,
                crate::input::UndeprecateWorkflowTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain of the deprecated workflow type.</p>
        pub fn domain(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the domain of the deprecated workflow type.</p>
        pub fn workflow_type(mut self, inp: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(inp);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon SWF domain.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `tagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>The list of tags to remove from the Amazon SWF domain.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
