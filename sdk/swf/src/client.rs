// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn count_closed_workflow_executions(
        &self,
    ) -> fluent_builders::CountClosedWorkflowExecutions<C> {
        fluent_builders::CountClosedWorkflowExecutions::new(self.handle.clone())
    }
    pub fn count_open_workflow_executions(
        &self,
    ) -> fluent_builders::CountOpenWorkflowExecutions<C> {
        fluent_builders::CountOpenWorkflowExecutions::new(self.handle.clone())
    }
    pub fn count_pending_activity_tasks(&self) -> fluent_builders::CountPendingActivityTasks<C> {
        fluent_builders::CountPendingActivityTasks::new(self.handle.clone())
    }
    pub fn count_pending_decision_tasks(&self) -> fluent_builders::CountPendingDecisionTasks<C> {
        fluent_builders::CountPendingDecisionTasks::new(self.handle.clone())
    }
    pub fn deprecate_activity_type(&self) -> fluent_builders::DeprecateActivityType<C> {
        fluent_builders::DeprecateActivityType::new(self.handle.clone())
    }
    pub fn deprecate_domain(&self) -> fluent_builders::DeprecateDomain<C> {
        fluent_builders::DeprecateDomain::new(self.handle.clone())
    }
    pub fn deprecate_workflow_type(&self) -> fluent_builders::DeprecateWorkflowType<C> {
        fluent_builders::DeprecateWorkflowType::new(self.handle.clone())
    }
    pub fn describe_activity_type(&self) -> fluent_builders::DescribeActivityType<C> {
        fluent_builders::DescribeActivityType::new(self.handle.clone())
    }
    pub fn describe_domain(&self) -> fluent_builders::DescribeDomain<C> {
        fluent_builders::DescribeDomain::new(self.handle.clone())
    }
    pub fn describe_workflow_execution(&self) -> fluent_builders::DescribeWorkflowExecution<C> {
        fluent_builders::DescribeWorkflowExecution::new(self.handle.clone())
    }
    pub fn describe_workflow_type(&self) -> fluent_builders::DescribeWorkflowType<C> {
        fluent_builders::DescribeWorkflowType::new(self.handle.clone())
    }
    pub fn get_workflow_execution_history(
        &self,
    ) -> fluent_builders::GetWorkflowExecutionHistory<C> {
        fluent_builders::GetWorkflowExecutionHistory::new(self.handle.clone())
    }
    pub fn list_activity_types(&self) -> fluent_builders::ListActivityTypes<C> {
        fluent_builders::ListActivityTypes::new(self.handle.clone())
    }
    pub fn list_closed_workflow_executions(
        &self,
    ) -> fluent_builders::ListClosedWorkflowExecutions<C> {
        fluent_builders::ListClosedWorkflowExecutions::new(self.handle.clone())
    }
    pub fn list_domains(&self) -> fluent_builders::ListDomains<C> {
        fluent_builders::ListDomains::new(self.handle.clone())
    }
    pub fn list_open_workflow_executions(&self) -> fluent_builders::ListOpenWorkflowExecutions<C> {
        fluent_builders::ListOpenWorkflowExecutions::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_workflow_types(&self) -> fluent_builders::ListWorkflowTypes<C> {
        fluent_builders::ListWorkflowTypes::new(self.handle.clone())
    }
    pub fn poll_for_activity_task(&self) -> fluent_builders::PollForActivityTask<C> {
        fluent_builders::PollForActivityTask::new(self.handle.clone())
    }
    pub fn poll_for_decision_task(&self) -> fluent_builders::PollForDecisionTask<C> {
        fluent_builders::PollForDecisionTask::new(self.handle.clone())
    }
    pub fn record_activity_task_heartbeat(
        &self,
    ) -> fluent_builders::RecordActivityTaskHeartbeat<C> {
        fluent_builders::RecordActivityTaskHeartbeat::new(self.handle.clone())
    }
    pub fn register_activity_type(&self) -> fluent_builders::RegisterActivityType<C> {
        fluent_builders::RegisterActivityType::new(self.handle.clone())
    }
    pub fn register_domain(&self) -> fluent_builders::RegisterDomain<C> {
        fluent_builders::RegisterDomain::new(self.handle.clone())
    }
    pub fn register_workflow_type(&self) -> fluent_builders::RegisterWorkflowType<C> {
        fluent_builders::RegisterWorkflowType::new(self.handle.clone())
    }
    pub fn request_cancel_workflow_execution(
        &self,
    ) -> fluent_builders::RequestCancelWorkflowExecution<C> {
        fluent_builders::RequestCancelWorkflowExecution::new(self.handle.clone())
    }
    pub fn respond_activity_task_canceled(
        &self,
    ) -> fluent_builders::RespondActivityTaskCanceled<C> {
        fluent_builders::RespondActivityTaskCanceled::new(self.handle.clone())
    }
    pub fn respond_activity_task_completed(
        &self,
    ) -> fluent_builders::RespondActivityTaskCompleted<C> {
        fluent_builders::RespondActivityTaskCompleted::new(self.handle.clone())
    }
    pub fn respond_activity_task_failed(&self) -> fluent_builders::RespondActivityTaskFailed<C> {
        fluent_builders::RespondActivityTaskFailed::new(self.handle.clone())
    }
    pub fn respond_decision_task_completed(
        &self,
    ) -> fluent_builders::RespondDecisionTaskCompleted<C> {
        fluent_builders::RespondDecisionTaskCompleted::new(self.handle.clone())
    }
    pub fn signal_workflow_execution(&self) -> fluent_builders::SignalWorkflowExecution<C> {
        fluent_builders::SignalWorkflowExecution::new(self.handle.clone())
    }
    pub fn start_workflow_execution(&self) -> fluent_builders::StartWorkflowExecution<C> {
        fluent_builders::StartWorkflowExecution::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn terminate_workflow_execution(&self) -> fluent_builders::TerminateWorkflowExecution<C> {
        fluent_builders::TerminateWorkflowExecution::new(self.handle.clone())
    }
    pub fn undeprecate_activity_type(&self) -> fluent_builders::UndeprecateActivityType<C> {
        fluent_builders::UndeprecateActivityType::new(self.handle.clone())
    }
    pub fn undeprecate_domain(&self) -> fluent_builders::UndeprecateDomain<C> {
        fluent_builders::UndeprecateDomain::new(self.handle.clone())
    }
    pub fn undeprecate_workflow_type(&self) -> fluent_builders::UndeprecateWorkflowType<C> {
        fluent_builders::UndeprecateWorkflowType::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CountClosedWorkflowExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::count_closed_workflow_executions_input::Builder,
    }
    impl<C> CountClosedWorkflowExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountClosedWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::CountClosedWorkflowExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow executions to count.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, only workflow executions that meet the start time criteria of the filter
        /// are counted.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn start_time_filter(mut self, input: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(input);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>If specified, only workflow executions that meet the close time criteria of the filter
        /// are counted.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn close_time_filter(mut self, input: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.close_time_filter(input);
            self
        }
        pub fn set_close_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_time_filter(input);
            self
        }
        /// <p>If specified, only workflow executions matching the <code>WorkflowId</code> in the
        /// filter are counted.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn execution_filter(mut self, input: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(input);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
        /// <p>If specified, indicates the type of the workflow executions to be counted.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn type_filter(mut self, input: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(input);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have a tag that matches the filter are
        /// counted.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn tag_filter(mut self, input: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(input);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If specified, only workflow executions that match this close status are counted. This
        /// filter has an affect only if <code>executionStatus</code> is specified as
        /// <code>CLOSED</code>.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn close_status_filter(mut self, input: crate::model::CloseStatusFilter) -> Self {
            self.inner = self.inner.close_status_filter(input);
            self
        }
        pub fn set_close_status_filter(
            mut self,
            input: std::option::Option<crate::model::CloseStatusFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_status_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CountOpenWorkflowExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::count_open_workflow_executions_input::Builder,
    }
    impl<C> CountOpenWorkflowExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountOpenWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::CountOpenWorkflowExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow executions to count.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the start time criteria that workflow executions must meet in order to be
        /// counted.</p>
        pub fn start_time_filter(mut self, input: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(input);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>Specifies the type of the workflow executions to be counted.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn type_filter(mut self, input: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(input);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have a tag that matches the filter are
        /// counted.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn tag_filter(mut self, input: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(input);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If specified, only workflow executions matching the <code>WorkflowId</code> in the
        /// filter are counted.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn execution_filter(mut self, input: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(input);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CountPendingActivityTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::count_pending_activity_tasks_input::Builder,
    }
    impl<C> CountPendingActivityTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountPendingActivityTasksOutput,
            smithy_http::result::SdkError<crate::error::CountPendingActivityTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the task list.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the task list.</p>
        pub fn task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(input);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CountPendingDecisionTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::count_pending_decision_tasks_input::Builder,
    }
    impl<C> CountPendingDecisionTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CountPendingDecisionTasksOutput,
            smithy_http::result::SdkError<crate::error::CountPendingDecisionTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the task list.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the task list.</p>
        pub fn task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(input);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateActivityType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deprecate_activity_type_input::Builder,
    }
    impl<C> DeprecateActivityType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::DeprecateActivityTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the activity type is registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The activity type to deprecate.</p>
        pub fn activity_type(mut self, input: crate::model::ActivityType) -> Self {
            self.inner = self.inner.activity_type(input);
            self
        }
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.inner = self.inner.set_activity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deprecate_domain_input::Builder,
    }
    impl<C> DeprecateDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateDomainOutput,
            smithy_http::result::SdkError<crate::error::DeprecateDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain to deprecate.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprecateWorkflowType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deprecate_workflow_type_input::Builder,
    }
    impl<C> DeprecateWorkflowType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprecateWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::DeprecateWorkflowTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the workflow type is registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflow type to deprecate.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(input);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeActivityType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_activity_type_input::Builder,
    }
    impl<C> DescribeActivityType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::DescribeActivityTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the activity type is registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The activity type to get information about. Activity types are identified by the
        /// <code>name</code> and <code>version</code> that were supplied when the activity was
        /// registered.</p>
        pub fn activity_type(mut self, input: crate::model::ActivityType) -> Self {
            self.inner = self.inner.activity_type(input);
            self
        }
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.inner = self.inner.set_activity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_domain_input::Builder,
    }
    impl<C> DescribeDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDomainOutput,
            smithy_http::result::SdkError<crate::error::DescribeDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain to describe.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeWorkflowExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_workflow_execution_input::Builder,
    }
    impl<C> DescribeWorkflowExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::DescribeWorkflowExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflow execution to describe.</p>
        pub fn execution(mut self, input: crate::model::WorkflowExecution) -> Self {
            self.inner = self.inner.execution(input);
            self
        }
        pub fn set_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.inner = self.inner.set_execution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeWorkflowType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_workflow_type_input::Builder,
    }
    impl<C> DescribeWorkflowType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::DescribeWorkflowTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which this workflow type is registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflow type to describe.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(input);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetWorkflowExecutionHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_workflow_execution_history_input::Builder,
    }
    impl<C> GetWorkflowExecutionHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetWorkflowExecutionHistoryOutput,
            smithy_http::result::SdkError<crate::error::GetWorkflowExecutionHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the workflow execution for which to return the history.</p>
        pub fn execution(mut self, input: crate::model::WorkflowExecution) -> Self {
            self.inner = self.inner.execution(input);
            self
        }
        pub fn set_execution(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecution>,
        ) -> Self {
            self.inner = self.inner.set_execution(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the events in reverse order. By default the
        /// results are returned in ascending order of the <code>eventTimeStamp</code> of the
        /// events.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListActivityTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_activity_types_input::Builder,
    }
    impl<C> ListActivityTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListActivityTypesOutput,
            smithy_http::result::SdkError<crate::error::ListActivityTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the activity types have been registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, only lists the activity types that have this name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the registration status of the activity types to list.</p>
        pub fn registration_status(mut self, input: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(input);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the
        /// results are returned in ascending alphabetical order by <code>name</code> of the activity
        /// types.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClosedWorkflowExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_closed_workflow_executions_input::Builder,
    }
    impl<C> ListClosedWorkflowExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClosedWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListClosedWorkflowExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the workflow executions to list.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, the workflow executions are included in the returned results based on
        /// whether their start times are within the range specified by this filter. Also, if this
        /// parameter is specified, the returned results are ordered by their start times.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn start_time_filter(mut self, input: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(input);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>If specified, the workflow executions are included in the returned results based on
        /// whether their close times are within the range specified by this filter. Also, if this
        /// parameter is specified, the returned results are ordered by their close times.</p>
        /// <note>
        /// <p>
        /// <code>startTimeFilter</code> and <code>closeTimeFilter</code> are mutually exclusive. You
        /// must specify one of these in a request but not both.</p>
        /// </note>
        pub fn close_time_filter(mut self, input: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.close_time_filter(input);
            self
        }
        pub fn set_close_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_time_filter(input);
            self
        }
        /// <p>If specified, only workflow executions matching the workflow ID specified in the filter
        /// are returned.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn execution_filter(mut self, input: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(input);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
        /// <p>If specified, only workflow executions that match this <i>close
        /// status</i> are listed. For example, if TERMINATED is specified, then only TERMINATED
        /// workflow executions are listed.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn close_status_filter(mut self, input: crate::model::CloseStatusFilter) -> Self {
            self.inner = self.inner.close_status_filter(input);
            self
        }
        pub fn set_close_status_filter(
            mut self,
            input: std::option::Option<crate::model::CloseStatusFilter>,
        ) -> Self {
            self.inner = self.inner.set_close_status_filter(input);
            self
        }
        /// <p>If specified, only executions of the type specified in the filter are
        /// returned.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn type_filter(mut self, input: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(input);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have the matching tag are listed.</p>
        /// <note>
        /// <p>
        /// <code>closeStatusFilter</code>, <code>executionFilter</code>, <code>typeFilter</code> and
        /// <code>tagFilter</code> are mutually exclusive. You can specify at most one of these in a
        /// request.</p>
        /// </note>
        pub fn tag_filter(mut self, input: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(input);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default the
        /// results are returned in descending order of the start or the close time of the
        /// executions.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_domains_input::Builder,
    }
    impl<C> ListDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDomainsOutput,
            smithy_http::result::SdkError<crate::error::ListDomainsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>Specifies the registration status of the domains to list.</p>
        pub fn registration_status(mut self, input: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(input);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the
        /// results are returned in ascending alphabetical order by <code>name</code> of the
        /// domains.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOpenWorkflowExecutions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_open_workflow_executions_input::Builder,
    }
    impl<C> ListOpenWorkflowExecutions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOpenWorkflowExecutionsOutput,
            smithy_http::result::SdkError<crate::error::ListOpenWorkflowExecutionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the workflow executions to list.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Workflow executions are included in the returned results based on whether their start
        /// times are within the range specified by this filter.</p>
        pub fn start_time_filter(mut self, input: crate::model::ExecutionTimeFilter) -> Self {
            self.inner = self.inner.start_time_filter(input);
            self
        }
        pub fn set_start_time_filter(
            mut self,
            input: std::option::Option<crate::model::ExecutionTimeFilter>,
        ) -> Self {
            self.inner = self.inner.set_start_time_filter(input);
            self
        }
        /// <p>If specified, only executions of the type specified in the filter are
        /// returned.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn type_filter(mut self, input: crate::model::WorkflowTypeFilter) -> Self {
            self.inner = self.inner.type_filter(input);
            self
        }
        pub fn set_type_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowTypeFilter>,
        ) -> Self {
            self.inner = self.inner.set_type_filter(input);
            self
        }
        /// <p>If specified, only executions that have the matching tag are listed.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn tag_filter(mut self, input: crate::model::TagFilter) -> Self {
            self.inner = self.inner.tag_filter(input);
            self
        }
        pub fn set_tag_filter(
            mut self,
            input: std::option::Option<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.set_tag_filter(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default the
        /// results are returned in descending order of the start time of the executions.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
        /// <p>If specified, only workflow executions matching the workflow ID specified in the filter
        /// are returned.</p>
        /// <note>
        /// <p>
        /// <code>executionFilter</code>, <code>typeFilter</code> and <code>tagFilter</code> are
        /// mutually exclusive. You can specify at most one of these in a request.</p>
        /// </note>
        pub fn execution_filter(mut self, input: crate::model::WorkflowExecutionFilter) -> Self {
            self.inner = self.inner.execution_filter(input);
            self
        }
        pub fn set_execution_filter(
            mut self,
            input: std::option::Option<crate::model::WorkflowExecutionFilter>,
        ) -> Self {
            self.inner = self.inner.set_execution_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon SWF domain.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListWorkflowTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_workflow_types_input::Builder,
    }
    impl<C> ListWorkflowTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkflowTypesOutput,
            smithy_http::result::SdkError<crate::error::ListWorkflowTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the workflow types have been registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>If specified, lists the workflow type with this name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Specifies the registration status of the workflow types to list.</p>
        pub fn registration_status(mut self, input: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(input);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the results in reverse order. By default the
        /// results are returned in ascending alphabetical order of the <code>name</code> of the workflow
        /// types.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForActivityTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::poll_for_activity_task_input::Builder,
    }
    impl<C> PollForActivityTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForActivityTaskOutput,
            smithy_http::result::SdkError<crate::error::PollForActivityTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain that contains the task lists being polled.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the task list to poll for activity tasks.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(input);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
        /// <p>Identity of the worker making the request, recorded in the
        /// <code>ActivityTaskStarted</code> event in the workflow history. This enables diagnostic
        /// tracing when problems arise. The form of this identity is user defined.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PollForDecisionTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::poll_for_decision_task_input::Builder,
    }
    impl<C> PollForDecisionTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PollForDecisionTaskOutput,
            smithy_http::result::SdkError<crate::error::PollForDecisionTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the task lists to poll.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>Specifies the task list to poll for decision tasks.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(input);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
        /// <p>Identity of the decider making the request, which is recorded in the
        /// DecisionTaskStarted event in the workflow history. This enables diagnostic tracing when
        /// problems arise. The form of this identity is user defined.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity(input);
            self
        }
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_identity(input);
            self
        }
        /// <p>If <code>NextPageToken</code> is returned there are more results
        /// available.  The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using
        /// the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires
        /// after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has
        /// exceeded its maximum lifetime</code>". </p>
        /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned
        /// in a single call. </p>
        /// <note>
        /// <p>The <code>nextPageToken</code> returned by this action cannot be used with <a>GetWorkflowExecutionHistory</a> to get the next page. You must call <a>PollForDecisionTask</a> again (with the <code>nextPageToken</code>) to retrieve
        /// the next page of history records. Calling <a>PollForDecisionTask</a> with a
        /// <code>nextPageToken</code> doesn't return a new decision task.</p>
        /// </note>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of results that are returned per call.
        /// Use <code>nextPageToken</code> to obtain further pages of results. </p>  
        /// <p>This
        /// is an upper limit only; the actual number of results returned per call may be fewer than the
        /// specified maximum.</p>
        pub fn maximum_page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.maximum_page_size(input);
            self
        }
        pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_maximum_page_size(input);
            self
        }
        /// <p>When set to <code>true</code>, returns the events in reverse order. By default the
        /// results are returned in ascending order of the <code>eventTimestamp</code> of the
        /// events.</p>
        pub fn reverse_order(mut self, input: bool) -> Self {
            self.inner = self.inner.reverse_order(input);
            self
        }
        pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reverse_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RecordActivityTaskHeartbeat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::record_activity_task_heartbeat_input::Builder,
    }
    impl<C> RecordActivityTaskHeartbeat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RecordActivityTaskHeartbeatOutput,
            smithy_http::result::SdkError<crate::error::RecordActivityTaskHeartbeatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results. </p>
        /// </important>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(input);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>If specified, contains details about the progress of the task.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(input);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterActivityType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_activity_type_input::Builder,
    }
    impl<C> RegisterActivityType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::RegisterActivityTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which this activity is to be registered.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the activity type within the domain.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The version of the activity type.</p>
        /// <note>
        /// <p>The activity type consists of the name and version, the combination of which must be
        /// unique within the domain.</p>
        /// </note>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>A textual description of the activity type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>If set, specifies the default maximum duration that a worker can take to process tasks
        /// of this activity type. This default can be overridden when scheduling an activity task using
        /// the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_start_to_close_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_start_to_close_timeout(input);
            self
        }
        pub fn set_default_task_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the default maximum time before which a worker processing a task of
        /// this type must report progress by calling <a>RecordActivityTaskHeartbeat</a>. If
        /// the timeout is exceeded, the activity task is automatically timed out. This default can be
        /// overridden when scheduling an activity task using the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>. If the activity worker subsequently attempts to record a heartbeat
        /// or returns a result, the activity worker receives an <code>UnknownResource</code> fault. In
        /// this case, Amazon SWF no longer considers the activity task to be valid; the activity worker should
        /// clean up the activity task.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_heartbeat_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_heartbeat_timeout(input);
            self
        }
        pub fn set_default_task_heartbeat_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_heartbeat_timeout(input);
            self
        }
        /// <p>If set, specifies the default task list to use for scheduling tasks of this activity
        /// type. This default task list is used if a task list isn't provided when a task is scheduled
        /// through the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        pub fn default_task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.default_task_list(input);
            self
        }
        pub fn set_default_task_list(
            mut self,
            input: std::option::Option<crate::model::TaskList>,
        ) -> Self {
            self.inner = self.inner.set_default_task_list(input);
            self
        }
        /// <p>The default task priority to assign to the activity type. If not assigned, then
        /// <code>0</code> is used. Valid values are integers that range from Java's
        /// <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647).
        /// Higher numbers indicate higher priority.</p>
        /// <p>For more information about setting task priority, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html">Setting Task
        /// Priority</a> in the <i>in the
        /// <i>Amazon SWF Developer Guide</i>.</i>.</p>
        pub fn default_task_priority(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_task_priority(input);
            self
        }
        pub fn set_default_task_priority(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_priority(input);
            self
        }
        /// <p>If set, specifies the default maximum duration that a task of this activity type can
        /// wait before being assigned to a worker. This default can be overridden when scheduling an
        /// activity task using the <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_schedule_to_start_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_schedule_to_start_timeout(input);
            self
        }
        pub fn set_default_task_schedule_to_start_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_schedule_to_start_timeout(input);
            self
        }
        /// <p>If set, specifies the default maximum duration for a task of this activity type. This
        /// default can be overridden when scheduling an activity task using the
        /// <code>ScheduleActivityTask</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_schedule_to_close_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_schedule_to_close_timeout(input);
            self
        }
        pub fn set_default_task_schedule_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_schedule_to_close_timeout(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_domain_input::Builder,
    }
    impl<C> RegisterDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterDomainOutput,
            smithy_http::result::SdkError<crate::error::RegisterDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the domain to register. The name must be unique in the region that the domain
        /// is registered in.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A text description of the domain.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The duration (in days) that records and histories of workflow executions on the domain
        /// should be kept by the service. After the retention period, the workflow execution isn't
        /// available in the results of visibility calls.</p>
        /// <p>If you pass the value <code>NONE</code> or <code>0</code> (zero), then the workflow
        /// execution history isn't retained. As soon as the workflow execution completes, the execution
        /// record and its history are deleted.</p>
        /// <p>The maximum workflow execution retention period is 90 days. For more information about
        /// Amazon SWF service limits, see: <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-limits.html">Amazon SWF Service Limits</a> in the
        /// <i>Amazon SWF Developer Guide</i>.</p>
        pub fn workflow_execution_retention_period_in_days(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .workflow_execution_retention_period_in_days(input);
            self
        }
        pub fn set_workflow_execution_retention_period_in_days(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_workflow_execution_retention_period_in_days(input);
            self
        }
        /// <p>Tags to be added when registering a domain.</p>
        /// <p>Tags may only contain unicode letters, digits, whitespace, or these symbols: <code>_ . : / = + - @</code>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::ResourceTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterWorkflowType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_workflow_type_input::Builder,
    }
    impl<C> RegisterWorkflowType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::RegisterWorkflowTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which to register the workflow type.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the workflow type.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The version of the workflow type.</p>
        /// <note>
        /// <p>The workflow type consists of the name and version, the combination of which must be
        /// unique within the domain. To get a list of all currently registered workflow types, use the
        /// <a>ListWorkflowTypes</a> action.</p>
        /// </note>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>Textual description of the workflow type.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>If set, specifies the default maximum duration of decision tasks for this workflow
        /// type. This default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        pub fn default_task_start_to_close_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_task_start_to_close_timeout(input);
            self
        }
        pub fn set_default_task_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the default maximum duration for executions of this workflow type.
        /// You can override this default when starting an execution through the <a>StartWorkflowExecution</a> Action or <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        /// <p>The duration is specified in seconds; an integer greater than or equal to 0. Unlike
        /// some of the other timeout parameters in Amazon SWF, you cannot specify a value of "NONE" for
        /// <code>defaultExecutionStartToCloseTimeout</code>; there is a one-year max limit on the time
        /// that a workflow execution can run. Exceeding this limit always causes the workflow execution
        /// to time out.</p>
        pub fn default_execution_start_to_close_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.default_execution_start_to_close_timeout(input);
            self
        }
        pub fn set_default_execution_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_default_execution_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the default task list to use for scheduling decision tasks for
        /// executions of this workflow type. This default is used only if a task list isn't provided when
        /// starting the execution through the <a>StartWorkflowExecution</a> Action or
        /// <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        pub fn default_task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.default_task_list(input);
            self
        }
        pub fn set_default_task_list(
            mut self,
            input: std::option::Option<crate::model::TaskList>,
        ) -> Self {
            self.inner = self.inner.set_default_task_list(input);
            self
        }
        /// <p>The default task priority to assign to the workflow type. If not assigned, then
        /// <code>0</code> is used. Valid values are integers that range from Java's
        /// <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647).
        /// Higher numbers indicate higher priority.</p>
        /// <p>For more information about setting task priority, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html">Setting Task
        /// Priority</a> in the <i>Amazon SWF Developer Guide</i>.</p>
        pub fn default_task_priority(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_task_priority(input);
            self
        }
        pub fn set_default_task_priority(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_task_priority(input);
            self
        }
        /// <p>If set, specifies the default policy to use for the child workflow executions when a
        /// workflow execution of this type is terminated, by calling the <a>TerminateWorkflowExecution</a> action explicitly or due to an expired timeout. This
        /// default can be overridden when starting a workflow execution using the <a>StartWorkflowExecution</a> action or the <code>StartChildWorkflowExecution</code>
        /// <a>Decision</a>.</p>
        /// <p>The supported child policies are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TERMINATE</code>  The child executions are terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REQUEST_CANCEL</code>  A request to cancel is attempted for each child
        /// execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its
        /// history. It is up to the decider to take appropriate actions when it receives an execution
        /// history with this event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ABANDON</code>  No action is taken. The child executions continue to
        /// run.</p>
        /// </li>
        /// </ul>
        pub fn default_child_policy(mut self, input: crate::model::ChildPolicy) -> Self {
            self.inner = self.inner.default_child_policy(input);
            self
        }
        pub fn set_default_child_policy(
            mut self,
            input: std::option::Option<crate::model::ChildPolicy>,
        ) -> Self {
            self.inner = self.inner.set_default_child_policy(input);
            self
        }
        /// <p>The default IAM role attached to this workflow type.</p>
        /// <note>
        /// <p>Executions of this workflow type need IAM roles to invoke Lambda functions. If you
        /// don't specify an IAM role when you start this workflow type, the default Lambda role is
        /// attached to the execution. For more information, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html">https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html</a> in the
        /// <i>Amazon SWF Developer Guide</i>.</p>
        /// </note>
        pub fn default_lambda_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_lambda_role(input);
            self
        }
        pub fn set_default_lambda_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_lambda_role(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestCancelWorkflowExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::request_cancel_workflow_execution_input::Builder,
    }
    impl<C> RequestCancelWorkflowExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestCancelWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::RequestCancelWorkflowExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution to cancel.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflowId of the workflow execution to cancel.</p>
        pub fn workflow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(input);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The runId of the workflow execution to cancel.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondActivityTaskCanceled<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::respond_activity_task_canceled_input::Builder,
    }
    impl<C> RespondActivityTaskCanceled<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondActivityTaskCanceledOutput,
            smithy_http::result::SdkError<crate::error::RespondActivityTaskCanceledError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(input);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p> Information about the cancellation.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(input);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondActivityTaskCompleted<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::respond_activity_task_completed_input::Builder,
    }
    impl<C> RespondActivityTaskCompleted<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondActivityTaskCompletedOutput,
            smithy_http::result::SdkError<crate::error::RespondActivityTaskCompletedError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(input);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>The result of the activity task. It is a free form string that is implementation
        /// specific.</p>
        pub fn result(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.result(input);
            self
        }
        pub fn set_result(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_result(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondActivityTaskFailed<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::respond_activity_task_failed_input::Builder,
    }
    impl<C> RespondActivityTaskFailed<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondActivityTaskFailedOutput,
            smithy_http::result::SdkError<crate::error::RespondActivityTaskFailedError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> of the <a>ActivityTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(input);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>Description of the error that may assist in diagnostics.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p> Detailed information about the failure.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(input);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RespondDecisionTaskCompleted<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::respond_decision_task_completed_input::Builder,
    }
    impl<C> RespondDecisionTaskCompleted<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RespondDecisionTaskCompletedOutput,
            smithy_http::result::SdkError<crate::error::RespondDecisionTaskCompletedError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>taskToken</code> from the <a>DecisionTask</a>.</p>
        /// <important>
        /// <p>
        /// <code>taskToken</code> is generated by the service and should be treated as an opaque value.
        /// If the task is passed to another process, its <code>taskToken</code> must also be passed.
        /// This enables it to provide its progress and respond with results.</p>
        /// </important>
        pub fn task_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_token(input);
            self
        }
        pub fn set_task_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_token(input);
            self
        }
        /// <p>The list of decisions (possibly empty) made by the decider while processing this
        /// decision task. See the docs for the <a>Decision</a> structure for
        /// details.</p>
        pub fn decisions(mut self, inp: impl Into<crate::model::Decision>) -> Self {
            self.inner = self.inner.decisions(inp);
            self
        }
        pub fn set_decisions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Decision>>,
        ) -> Self {
            self.inner = self.inner.set_decisions(input);
            self
        }
        /// <p>User defined context to add to workflow execution.</p>
        pub fn execution_context(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.execution_context(input);
            self
        }
        pub fn set_execution_context(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_execution_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SignalWorkflowExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::signal_workflow_execution_input::Builder,
    }
    impl<C> SignalWorkflowExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SignalWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::SignalWorkflowExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain containing the workflow execution to signal.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflowId of the workflow execution to signal.</p>
        pub fn workflow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(input);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The runId of the workflow execution to signal.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p>The name of the signal. This name must be meaningful to the target workflow.</p>
        pub fn signal_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.signal_name(input);
            self
        }
        pub fn set_signal_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_signal_name(input);
            self
        }
        /// <p>Data to attach to the <code>WorkflowExecutionSignaled</code> event in the target
        /// workflow execution's history.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input(input);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartWorkflowExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_workflow_execution_input::Builder,
    }
    impl<C> StartWorkflowExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::StartWorkflowExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain in which the workflow execution is created.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The user defined identifier associated with the workflow execution. You can use this to
        /// associate a custom identifier with the workflow execution. You may specify the same identifier
        /// if a workflow execution is logically a <i>restart</i> of a previous execution.
        /// You cannot have two open workflow executions with the same <code>workflowId</code> at the same
        /// time within the same domain.</p>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn workflow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(input);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The type of the workflow to start.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(input);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
        /// <p>The task list to use for the decision tasks generated for this workflow execution. This
        /// overrides the <code>defaultTaskList</code> specified when registering the workflow
        /// type.</p>
        /// <note>
        /// <p>A task list for this workflow execution must be specified either as a default for the
        /// workflow type or through this parameter. If neither this parameter is set nor a default task
        /// list was specified at registration time then a fault is returned.</p>
        /// </note>
        /// <p>The specified string must not start or end with whitespace. It must not contain a
        /// <code>:</code> (colon), <code>/</code> (slash), <code>|</code> (vertical bar), or any
        /// control characters (<code>\u0000-\u001f</code> | <code>\u007f-\u009f</code>). Also, it must
        /// not <i>be</i> the literal string <code>arn</code>.</p>
        pub fn task_list(mut self, input: crate::model::TaskList) -> Self {
            self.inner = self.inner.task_list(input);
            self
        }
        pub fn set_task_list(mut self, input: std::option::Option<crate::model::TaskList>) -> Self {
            self.inner = self.inner.set_task_list(input);
            self
        }
        /// <p>The task priority to use for this workflow execution. This overrides any default
        /// priority that was assigned when the workflow type was registered. If not set, then the default
        /// task priority for the workflow type is used. Valid values are integers that range from Java's
        /// <code>Integer.MIN_VALUE</code> (-2147483648) to <code>Integer.MAX_VALUE</code> (2147483647).
        /// Higher numbers indicate higher priority.</p>
        /// <p>For more information about setting task priority, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/programming-priority.html">Setting Task
        /// Priority</a> in the <i>Amazon SWF Developer Guide</i>.</p>
        pub fn task_priority(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_priority(input);
            self
        }
        pub fn set_task_priority(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_priority(input);
            self
        }
        /// <p>The input for the workflow execution. This is a free form string which should be
        /// meaningful to the workflow you are starting. This <code>input</code> is made available to the
        /// new workflow execution in the <code>WorkflowExecutionStarted</code> history event.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.input(input);
            self
        }
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_input(input);
            self
        }
        /// <p>The total duration for this workflow execution. This overrides the
        /// defaultExecutionStartToCloseTimeout specified when registering the workflow type.</p>
        /// <p>The duration is specified in seconds; an integer greater than or equal to
        /// <code>0</code>. Exceeding this limit causes the workflow execution to time out. Unlike some
        /// of the other timeout parameters in Amazon SWF, you cannot specify a value of "NONE" for this
        /// timeout; there is a one-year max limit on the time that a workflow execution can
        /// run.</p>
        /// <note>
        /// <p>An execution start-to-close timeout must be specified either through this parameter
        /// or as a default when the workflow type is registered. If neither this parameter nor a
        /// default execution start-to-close timeout is specified, a fault is returned.</p>
        /// </note>
        pub fn execution_start_to_close_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.execution_start_to_close_timeout(input);
            self
        }
        pub fn set_execution_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_execution_start_to_close_timeout(input);
            self
        }
        /// <p>The list of tags to associate with the workflow execution. You can specify a maximum of
        /// 5 tags. You can list workflow executions with a specific tag by calling <a>ListOpenWorkflowExecutions</a> or <a>ListClosedWorkflowExecutions</a> and
        /// specifying a <a>TagFilter</a>.</p>
        pub fn tag_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_list(inp);
            self
        }
        pub fn set_tag_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_list(input);
            self
        }
        /// <p>Specifies the maximum duration of decision tasks for this workflow execution. This
        /// parameter overrides the <code>defaultTaskStartToCloseTimout</code> specified when registering
        /// the workflow type using <a>RegisterWorkflowType</a>.</p>
        /// <p>The duration is specified in seconds, an integer greater than or equal to
        /// <code>0</code>. You can use <code>NONE</code> to specify unlimited duration.</p>
        /// <note>
        /// <p>A task start-to-close timeout for this workflow execution must be specified either as
        /// a default for the workflow type or through this parameter. If neither this parameter is set
        /// nor a default task start-to-close timeout was specified at registration time then a fault is
        /// returned.</p>
        /// </note>
        pub fn task_start_to_close_timeout(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.task_start_to_close_timeout(input);
            self
        }
        pub fn set_task_start_to_close_timeout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_task_start_to_close_timeout(input);
            self
        }
        /// <p>If set, specifies the policy to use for the child workflow executions of this workflow
        /// execution if it is terminated, by calling the <a>TerminateWorkflowExecution</a>
        /// action explicitly or due to an expired timeout. This policy overrides the default child policy
        /// specified when registering the workflow type using <a>RegisterWorkflowType</a>.</p>
        /// <p>The supported child policies are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TERMINATE</code>  The child executions are terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REQUEST_CANCEL</code>  A request to cancel is attempted for each child
        /// execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its
        /// history. It is up to the decider to take appropriate actions when it receives an execution
        /// history with this event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ABANDON</code>  No action is taken. The child executions continue to
        /// run.</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>A child policy for this workflow execution must be specified either as a default for
        /// the workflow type or through this parameter. If neither this parameter is set nor a default
        /// child policy was specified at registration time then a fault is returned.</p>
        /// </note>
        pub fn child_policy(mut self, input: crate::model::ChildPolicy) -> Self {
            self.inner = self.inner.child_policy(input);
            self
        }
        pub fn set_child_policy(
            mut self,
            input: std::option::Option<crate::model::ChildPolicy>,
        ) -> Self {
            self.inner = self.inner.set_child_policy(input);
            self
        }
        /// <p>The IAM role to attach to this workflow execution.</p>
        /// <note>
        /// <p>Executions of this workflow type need IAM roles to invoke Lambda functions. If you
        /// don't attach an IAM role, any attempt to schedule a Lambda task fails. This results in a
        /// <code>ScheduleLambdaFunctionFailed</code> history event. For more information, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html">https://docs.aws.amazon.com/amazonswf/latest/developerguide/lambda-task.html</a> in the
        /// <i>Amazon SWF Developer Guide</i>.</p>
        /// </note>
        pub fn lambda_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lambda_role(input);
            self
        }
        pub fn set_lambda_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_lambda_role(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon SWF domain.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of tags to add to a domain. </p>
        /// <p>Tags may only contain unicode letters, digits, whitespace, or these symbols: <code>_ . : / = + - @</code>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::ResourceTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TerminateWorkflowExecution<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::terminate_workflow_execution_input::Builder,
    }
    impl<C> TerminateWorkflowExecution<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TerminateWorkflowExecutionOutput,
            smithy_http::result::SdkError<crate::error::TerminateWorkflowExecutionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The domain of the workflow execution to terminate.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The workflowId of the workflow execution to terminate.</p>
        pub fn workflow_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(input);
            self
        }
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>The runId of the workflow execution to terminate.</p>
        pub fn run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.run_id(input);
            self
        }
        pub fn set_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_run_id(input);
            self
        }
        /// <p> A descriptive reason for terminating the workflow execution.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason(input);
            self
        }
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_reason(input);
            self
        }
        /// <p> Details for terminating the workflow execution.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.details(input);
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_details(input);
            self
        }
        /// <p>If set, specifies the policy to use for the child workflow executions of the workflow
        /// execution being terminated. This policy overrides the child policy specified for the workflow
        /// execution at registration time or when starting the execution.</p>
        /// <p>The supported child policies are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TERMINATE</code>  The child executions are terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REQUEST_CANCEL</code>  A request to cancel is attempted for each child
        /// execution by recording a <code>WorkflowExecutionCancelRequested</code> event in its
        /// history. It is up to the decider to take appropriate actions when it receives an execution
        /// history with this event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ABANDON</code>  No action is taken. The child executions continue to
        /// run.</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>A child policy for this workflow execution must be specified either as a default for
        /// the workflow type or through this parameter. If neither this parameter is set nor a default
        /// child policy was specified at registration time then a fault is returned.</p>
        /// </note>
        pub fn child_policy(mut self, input: crate::model::ChildPolicy) -> Self {
            self.inner = self.inner.child_policy(input);
            self
        }
        pub fn set_child_policy(
            mut self,
            input: std::option::Option<crate::model::ChildPolicy>,
        ) -> Self {
            self.inner = self.inner.set_child_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UndeprecateActivityType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::undeprecate_activity_type_input::Builder,
    }
    impl<C> UndeprecateActivityType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UndeprecateActivityTypeOutput,
            smithy_http::result::SdkError<crate::error::UndeprecateActivityTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain of the deprecated activity type.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The activity type to undeprecate.</p>
        pub fn activity_type(mut self, input: crate::model::ActivityType) -> Self {
            self.inner = self.inner.activity_type(input);
            self
        }
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<crate::model::ActivityType>,
        ) -> Self {
            self.inner = self.inner.set_activity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UndeprecateDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::undeprecate_domain_input::Builder,
    }
    impl<C> UndeprecateDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UndeprecateDomainOutput,
            smithy_http::result::SdkError<crate::error::UndeprecateDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain of the deprecated workflow type.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UndeprecateWorkflowType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::undeprecate_workflow_type_input::Builder,
    }
    impl<C> UndeprecateWorkflowType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UndeprecateWorkflowTypeOutput,
            smithy_http::result::SdkError<crate::error::UndeprecateWorkflowTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the domain of the deprecated workflow type.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The name of the domain of the deprecated workflow type.</p>
        pub fn workflow_type(mut self, input: crate::model::WorkflowType) -> Self {
            self.inner = self.inner.workflow_type(input);
            self
        }
        pub fn set_workflow_type(
            mut self,
            input: std::option::Option<crate::model::WorkflowType>,
        ) -> Self {
            self.inner = self.inner.set_workflow_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) for the Amazon SWF domain.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of tags to remove from the Amazon SWF domain.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
}
