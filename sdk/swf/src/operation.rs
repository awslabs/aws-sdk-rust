// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Returns the number of closed workflow executions within the given domain that meet the
/// specified filtering criteria.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>tagFilter.tag</code>: String constraint. The key is
/// <code>swf:tagFilter.tag</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.name</code>: String constraint. The key is
/// <code>swf:typeFilter.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.version</code>: String constraint. The key is
/// <code>swf:typeFilter.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CountClosedWorkflowExecutions {
    _private: (),
}
impl CountClosedWorkflowExecutions {
    /// Creates a new builder-style object to manufacture [`CountClosedWorkflowExecutionsInput`](crate::input::CountClosedWorkflowExecutionsInput)
    pub fn builder() -> crate::input::count_closed_workflow_executions_input::Builder {
        crate::input::count_closed_workflow_executions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CountClosedWorkflowExecutions {
    type Output = std::result::Result<
        crate::output::CountClosedWorkflowExecutionsOutput,
        crate::error::CountClosedWorkflowExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_count_closed_workflow_executions_error(response)
        } else {
            crate::operation_deser::parse_count_closed_workflow_executions_response(response)
        }
    }
}

/// <p>Returns the number of open workflow executions within the given domain that meet the
/// specified filtering criteria.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>tagFilter.tag</code>: String constraint. The key is
/// <code>swf:tagFilter.tag</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.name</code>: String constraint. The key is
/// <code>swf:typeFilter.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.version</code>: String constraint. The key is
/// <code>swf:typeFilter.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CountOpenWorkflowExecutions {
    _private: (),
}
impl CountOpenWorkflowExecutions {
    /// Creates a new builder-style object to manufacture [`CountOpenWorkflowExecutionsInput`](crate::input::CountOpenWorkflowExecutionsInput)
    pub fn builder() -> crate::input::count_open_workflow_executions_input::Builder {
        crate::input::count_open_workflow_executions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CountOpenWorkflowExecutions {
    type Output = std::result::Result<
        crate::output::CountOpenWorkflowExecutionsOutput,
        crate::error::CountOpenWorkflowExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_count_open_workflow_executions_error(response)
        } else {
            crate::operation_deser::parse_count_open_workflow_executions_response(response)
        }
    }
}

/// <p>Returns the estimated number of activity tasks in the specified task list. The count
/// returned is an approximation and isn't guaranteed to be exact. If you specify a task list that
/// no activity task was ever scheduled in then <code>0</code> is returned.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the <code>taskList.name</code> parameter by using a
/// <code>Condition</code> element with the <code>swf:taskList.name</code> key to allow the
/// action to access only certain task lists.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CountPendingActivityTasks {
    _private: (),
}
impl CountPendingActivityTasks {
    /// Creates a new builder-style object to manufacture [`CountPendingActivityTasksInput`](crate::input::CountPendingActivityTasksInput)
    pub fn builder() -> crate::input::count_pending_activity_tasks_input::Builder {
        crate::input::count_pending_activity_tasks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CountPendingActivityTasks {
    type Output = std::result::Result<
        crate::output::CountPendingActivityTasksOutput,
        crate::error::CountPendingActivityTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_count_pending_activity_tasks_error(response)
        } else {
            crate::operation_deser::parse_count_pending_activity_tasks_response(response)
        }
    }
}

/// <p>Returns the estimated number of decision tasks in the specified task list. The count
/// returned is an approximation and isn't guaranteed to be exact. If you specify a task list that
/// no decision task was ever scheduled in then <code>0</code> is returned.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the <code>taskList.name</code> parameter by using a
/// <code>Condition</code> element with the <code>swf:taskList.name</code> key to allow the
/// action to access only certain task lists.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CountPendingDecisionTasks {
    _private: (),
}
impl CountPendingDecisionTasks {
    /// Creates a new builder-style object to manufacture [`CountPendingDecisionTasksInput`](crate::input::CountPendingDecisionTasksInput)
    pub fn builder() -> crate::input::count_pending_decision_tasks_input::Builder {
        crate::input::count_pending_decision_tasks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CountPendingDecisionTasks {
    type Output = std::result::Result<
        crate::output::CountPendingDecisionTasksOutput,
        crate::error::CountPendingDecisionTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_count_pending_decision_tasks_error(response)
        } else {
            crate::operation_deser::parse_count_pending_decision_tasks_response(response)
        }
    }
}

/// <p>Deprecates the specified <i>activity type</i>. After an activity type has
/// been deprecated, you cannot create new tasks of that activity type. Tasks of this type that
/// were scheduled before the type was deprecated continue to run.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>activityType.name</code>: String constraint. The key is
/// <code>swf:activityType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>activityType.version</code>: String constraint. The key is
/// <code>swf:activityType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeprecateActivityType {
    _private: (),
}
impl DeprecateActivityType {
    /// Creates a new builder-style object to manufacture [`DeprecateActivityTypeInput`](crate::input::DeprecateActivityTypeInput)
    pub fn builder() -> crate::input::deprecate_activity_type_input::Builder {
        crate::input::deprecate_activity_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeprecateActivityType {
    type Output = std::result::Result<
        crate::output::DeprecateActivityTypeOutput,
        crate::error::DeprecateActivityTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deprecate_activity_type_error(response)
        } else {
            crate::operation_deser::parse_deprecate_activity_type_response(response)
        }
    }
}

/// <p>Deprecates the specified domain. After a domain has been deprecated it cannot be used
/// to create new workflow executions or register new types. However, you can still use visibility
/// actions on this domain. Deprecating a domain also deprecates all activity and workflow types
/// registered in the domain. Executions that were started before the domain was deprecated
/// continues to run.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeprecateDomain {
    _private: (),
}
impl DeprecateDomain {
    /// Creates a new builder-style object to manufacture [`DeprecateDomainInput`](crate::input::DeprecateDomainInput)
    pub fn builder() -> crate::input::deprecate_domain_input::Builder {
        crate::input::deprecate_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeprecateDomain {
    type Output = std::result::Result<
        crate::output::DeprecateDomainOutput,
        crate::error::DeprecateDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deprecate_domain_error(response)
        } else {
            crate::operation_deser::parse_deprecate_domain_response(response)
        }
    }
}

/// <p>Deprecates the specified <i>workflow type</i>. After a workflow type has
/// been deprecated, you cannot create new executions of that type. Executions that were started
/// before the type was deprecated continues to run. A deprecated workflow type may still be used
/// when calling visibility actions.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>workflowType.name</code>: String constraint. The key is
/// <code>swf:workflowType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>workflowType.version</code>: String constraint. The key is
/// <code>swf:workflowType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeprecateWorkflowType {
    _private: (),
}
impl DeprecateWorkflowType {
    /// Creates a new builder-style object to manufacture [`DeprecateWorkflowTypeInput`](crate::input::DeprecateWorkflowTypeInput)
    pub fn builder() -> crate::input::deprecate_workflow_type_input::Builder {
        crate::input::deprecate_workflow_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeprecateWorkflowType {
    type Output = std::result::Result<
        crate::output::DeprecateWorkflowTypeOutput,
        crate::error::DeprecateWorkflowTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deprecate_workflow_type_error(response)
        } else {
            crate::operation_deser::parse_deprecate_workflow_type_response(response)
        }
    }
}

/// <p>Returns information about the specified activity type. This includes configuration
/// settings provided when the type was registered and other general information about the
/// type.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>activityType.name</code>: String constraint. The key is
/// <code>swf:activityType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>activityType.version</code>: String constraint. The key is
/// <code>swf:activityType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeActivityType {
    _private: (),
}
impl DescribeActivityType {
    /// Creates a new builder-style object to manufacture [`DescribeActivityTypeInput`](crate::input::DescribeActivityTypeInput)
    pub fn builder() -> crate::input::describe_activity_type_input::Builder {
        crate::input::describe_activity_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeActivityType {
    type Output = std::result::Result<
        crate::output::DescribeActivityTypeOutput,
        crate::error::DescribeActivityTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_activity_type_error(response)
        } else {
            crate::operation_deser::parse_describe_activity_type_response(response)
        }
    }
}

/// <p>Returns information about the specified domain, including description and
/// status.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomain {
    _private: (),
}
impl DescribeDomain {
    /// Creates a new builder-style object to manufacture [`DescribeDomainInput`](crate::input::DescribeDomainInput)
    pub fn builder() -> crate::input::describe_domain_input::Builder {
        crate::input::describe_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomain {
    type Output =
        std::result::Result<crate::output::DescribeDomainOutput, crate::error::DescribeDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domain_error(response)
        } else {
            crate::operation_deser::parse_describe_domain_response(response)
        }
    }
}

/// <p>Returns information about the specified workflow execution including its type and some
/// statistics.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkflowExecution {
    _private: (),
}
impl DescribeWorkflowExecution {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowExecutionInput`](crate::input::DescribeWorkflowExecutionInput)
    pub fn builder() -> crate::input::describe_workflow_execution_input::Builder {
        crate::input::describe_workflow_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkflowExecution {
    type Output = std::result::Result<
        crate::output::DescribeWorkflowExecutionOutput,
        crate::error::DescribeWorkflowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workflow_execution_error(response)
        } else {
            crate::operation_deser::parse_describe_workflow_execution_response(response)
        }
    }
}

/// <p>Returns information about the specified <i>workflow type</i>. This
/// includes configuration settings specified when the type was registered and other information
/// such as creation date, current status, etc.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>workflowType.name</code>: String constraint. The key is
/// <code>swf:workflowType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>workflowType.version</code>: String constraint. The key is
/// <code>swf:workflowType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkflowType {
    _private: (),
}
impl DescribeWorkflowType {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowTypeInput`](crate::input::DescribeWorkflowTypeInput)
    pub fn builder() -> crate::input::describe_workflow_type_input::Builder {
        crate::input::describe_workflow_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkflowType {
    type Output = std::result::Result<
        crate::output::DescribeWorkflowTypeOutput,
        crate::error::DescribeWorkflowTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workflow_type_error(response)
        } else {
            crate::operation_deser::parse_describe_workflow_type_response(response)
        }
    }
}

/// <p>Returns the history of the specified workflow execution. The results may be split into
/// multiple pages. To retrieve subsequent pages, make the call again using the
/// <code>nextPageToken</code> returned by the initial call.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetWorkflowExecutionHistory {
    _private: (),
}
impl GetWorkflowExecutionHistory {
    /// Creates a new builder-style object to manufacture [`GetWorkflowExecutionHistoryInput`](crate::input::GetWorkflowExecutionHistoryInput)
    pub fn builder() -> crate::input::get_workflow_execution_history_input::Builder {
        crate::input::get_workflow_execution_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetWorkflowExecutionHistory {
    type Output = std::result::Result<
        crate::output::GetWorkflowExecutionHistoryOutput,
        crate::error::GetWorkflowExecutionHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_workflow_execution_history_error(response)
        } else {
            crate::operation_deser::parse_get_workflow_execution_history_response(response)
        }
    }
}

/// <p>Returns information about all activities registered in the specified domain that match
/// the specified name and registration status. The result includes information like creation
/// date, current status of the activity, etc. The results may be split into multiple pages. To
/// retrieve subsequent pages, make the call again using the <code>nextPageToken</code> returned
/// by the initial call.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListActivityTypes {
    _private: (),
}
impl ListActivityTypes {
    /// Creates a new builder-style object to manufacture [`ListActivityTypesInput`](crate::input::ListActivityTypesInput)
    pub fn builder() -> crate::input::list_activity_types_input::Builder {
        crate::input::list_activity_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListActivityTypes {
    type Output = std::result::Result<
        crate::output::ListActivityTypesOutput,
        crate::error::ListActivityTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_activity_types_error(response)
        } else {
            crate::operation_deser::parse_list_activity_types_response(response)
        }
    }
}

/// <p>Returns a list of closed workflow executions in the specified domain that meet the
/// filtering criteria. The results may be split into multiple pages. To retrieve subsequent
/// pages, make the call again using the nextPageToken returned by the initial call.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>tagFilter.tag</code>: String constraint. The key is
/// <code>swf:tagFilter.tag</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.name</code>: String constraint. The key is
/// <code>swf:typeFilter.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.version</code>: String constraint. The key is
/// <code>swf:typeFilter.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListClosedWorkflowExecutions {
    _private: (),
}
impl ListClosedWorkflowExecutions {
    /// Creates a new builder-style object to manufacture [`ListClosedWorkflowExecutionsInput`](crate::input::ListClosedWorkflowExecutionsInput)
    pub fn builder() -> crate::input::list_closed_workflow_executions_input::Builder {
        crate::input::list_closed_workflow_executions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListClosedWorkflowExecutions {
    type Output = std::result::Result<
        crate::output::ListClosedWorkflowExecutionsOutput,
        crate::error::ListClosedWorkflowExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_closed_workflow_executions_error(response)
        } else {
            crate::operation_deser::parse_list_closed_workflow_executions_response(response)
        }
    }
}

/// <p>Returns the list of domains registered in the account. The results may be split into
/// multiple pages. To retrieve subsequent pages, make the call again using the nextPageToken
/// returned by the initial call.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains. The element must be set to
/// <code>arn:aws:swf::AccountID:domain/*</code>, where <i>AccountID</i> is
/// the account ID, with no dashes.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomains {
    _private: (),
}
impl ListDomains {
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput)
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomains {
    type Output =
        std::result::Result<crate::output::ListDomainsOutput, crate::error::ListDomainsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domains_error(response)
        } else {
            crate::operation_deser::parse_list_domains_response(response)
        }
    }
}

/// <p>Returns a list of open workflow executions in the specified domain that meet the
/// filtering criteria. The results may be split into multiple pages. To retrieve subsequent
/// pages, make the call again using the nextPageToken returned by the initial call.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>tagFilter.tag</code>: String constraint. The key is
/// <code>swf:tagFilter.tag</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.name</code>: String constraint. The key is
/// <code>swf:typeFilter.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>typeFilter.version</code>: String constraint. The key is
/// <code>swf:typeFilter.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListOpenWorkflowExecutions {
    _private: (),
}
impl ListOpenWorkflowExecutions {
    /// Creates a new builder-style object to manufacture [`ListOpenWorkflowExecutionsInput`](crate::input::ListOpenWorkflowExecutionsInput)
    pub fn builder() -> crate::input::list_open_workflow_executions_input::Builder {
        crate::input::list_open_workflow_executions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListOpenWorkflowExecutions {
    type Output = std::result::Result<
        crate::output::ListOpenWorkflowExecutionsOutput,
        crate::error::ListOpenWorkflowExecutionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_open_workflow_executions_error(response)
        } else {
            crate::operation_deser::parse_list_open_workflow_executions_response(response)
        }
    }
}

/// <p>List tags for a given domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Returns information about workflow types in the specified domain. The results may be
/// split into multiple pages that can be retrieved by making the call repeatedly.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListWorkflowTypes {
    _private: (),
}
impl ListWorkflowTypes {
    /// Creates a new builder-style object to manufacture [`ListWorkflowTypesInput`](crate::input::ListWorkflowTypesInput)
    pub fn builder() -> crate::input::list_workflow_types_input::Builder {
        crate::input::list_workflow_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListWorkflowTypes {
    type Output = std::result::Result<
        crate::output::ListWorkflowTypesOutput,
        crate::error::ListWorkflowTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_workflow_types_error(response)
        } else {
            crate::operation_deser::parse_list_workflow_types_response(response)
        }
    }
}

/// <p>Used by workers to get an <a>ActivityTask</a> from the specified activity
/// <code>taskList</code>. This initiates a long poll, where the service holds the HTTP
/// connection open and responds as soon as a task becomes available. The maximum time the service
/// holds on to the request before responding is 60 seconds. If no task is available within 60
/// seconds, the poll returns an empty result. An empty result, in this context, means that an
/// ActivityTask is returned, but that the value of taskToken is an empty string. If a task is
/// returned, the worker should use its type to identify and process it correctly.</p>
/// <important>
/// <p>Workers should set their client side socket timeout to at least 70 seconds (10
/// seconds higher than the maximum time service may hold the poll request).</p>
/// </important>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the <code>taskList.name</code> parameter by using a
/// <code>Condition</code> element with the <code>swf:taskList.name</code> key to allow the
/// action to access only certain task lists.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PollForActivityTask {
    _private: (),
}
impl PollForActivityTask {
    /// Creates a new builder-style object to manufacture [`PollForActivityTaskInput`](crate::input::PollForActivityTaskInput)
    pub fn builder() -> crate::input::poll_for_activity_task_input::Builder {
        crate::input::poll_for_activity_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PollForActivityTask {
    type Output = std::result::Result<
        crate::output::PollForActivityTaskOutput,
        crate::error::PollForActivityTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_poll_for_activity_task_error(response)
        } else {
            crate::operation_deser::parse_poll_for_activity_task_response(response)
        }
    }
}

/// <p>Used by deciders to get a <a>DecisionTask</a> from the specified decision
/// <code>taskList</code>. A decision task may be returned for any open workflow execution that
/// is using the specified task list. The task includes a paginated view of the history of the
/// workflow execution. The decider should use the workflow type and the history to determine how
/// to properly handle the task.</p>
/// <p>This action initiates a long poll, where the service holds the HTTP connection open and
/// responds as soon a task becomes available. If no decision task is available in the specified
/// task list before the timeout of 60 seconds expires, an empty result is returned. An empty
/// result, in this context, means that a DecisionTask is returned, but that the value of
/// taskToken is an empty string.</p>
/// <important>
/// <p>Deciders should set their client side socket timeout to at least 70 seconds (10
/// seconds higher than the timeout).</p>
/// </important>
/// <important>
/// <p>Because the number of workflow history events for a single workflow execution might
/// be very large, the result returned might be split up across a number of pages. To retrieve
/// subsequent pages, make additional calls to <code>PollForDecisionTask</code> using the
/// <code>nextPageToken</code> returned by the initial call. Note that you do
/// <i>not</i> call <code>GetWorkflowExecutionHistory</code> with this
/// <code>nextPageToken</code>. Instead, call <code>PollForDecisionTask</code>
/// again.</p>
/// </important>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the <code>taskList.name</code> parameter by using a
/// <code>Condition</code> element with the <code>swf:taskList.name</code> key to allow the
/// action to access only certain task lists.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PollForDecisionTask {
    _private: (),
}
impl PollForDecisionTask {
    /// Creates a new builder-style object to manufacture [`PollForDecisionTaskInput`](crate::input::PollForDecisionTaskInput)
    pub fn builder() -> crate::input::poll_for_decision_task_input::Builder {
        crate::input::poll_for_decision_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PollForDecisionTask {
    type Output = std::result::Result<
        crate::output::PollForDecisionTaskOutput,
        crate::error::PollForDecisionTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_poll_for_decision_task_error(response)
        } else {
            crate::operation_deser::parse_poll_for_decision_task_response(response)
        }
    }
}

/// <p>Used by activity workers to report to the service that the <a>ActivityTask</a> represented by the specified <code>taskToken</code> is still making progress. The worker
/// can also specify details of the progress, for example percent complete, using the
/// <code>details</code> parameter. This action can also be used by the worker as a mechanism to
/// check if cancellation is being requested for the activity task. If a cancellation is being
/// attempted for the specified task, then the boolean <code>cancelRequested</code> flag returned
/// by the service is set to <code>true</code>.</p>
/// <p>This action resets the <code>taskHeartbeatTimeout</code> clock. The
/// <code>taskHeartbeatTimeout</code> is specified in <a>RegisterActivityType</a>.</p>
/// <p>This action doesn't in itself create an event in the workflow execution history.
/// However, if the task times out, the workflow execution history contains a
/// <code>ActivityTaskTimedOut</code> event that contains the information from the last
/// heartbeat generated by the activity worker.</p>
/// <note>
/// <p>The <code>taskStartToCloseTimeout</code> of an activity type is the maximum duration
/// of an activity task, regardless of the number of <a>RecordActivityTaskHeartbeat</a> requests received. The <code>taskStartToCloseTimeout</code> is also specified in <a>RegisterActivityType</a>.</p>
/// </note>
/// <note>
/// <p>This operation is only useful for long-lived activities to report liveliness of the
/// task and to determine if a cancellation is being attempted.</p>
/// </note>
/// <important>
/// <p>If the <code>cancelRequested</code> flag returns <code>true</code>, a cancellation is
/// being attempted. If the worker can cancel the activity, it should respond with <a>RespondActivityTaskCanceled</a>. Otherwise, it should ignore the cancellation
/// request.</p>
/// </important>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RecordActivityTaskHeartbeat {
    _private: (),
}
impl RecordActivityTaskHeartbeat {
    /// Creates a new builder-style object to manufacture [`RecordActivityTaskHeartbeatInput`](crate::input::RecordActivityTaskHeartbeatInput)
    pub fn builder() -> crate::input::record_activity_task_heartbeat_input::Builder {
        crate::input::record_activity_task_heartbeat_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RecordActivityTaskHeartbeat {
    type Output = std::result::Result<
        crate::output::RecordActivityTaskHeartbeatOutput,
        crate::error::RecordActivityTaskHeartbeatError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_record_activity_task_heartbeat_error(response)
        } else {
            crate::operation_deser::parse_record_activity_task_heartbeat_response(response)
        }
    }
}

/// <p>Registers a new <i>activity type</i> along with its configuration
/// settings in the specified domain.</p>
/// <important>
/// <p>A <code>TypeAlreadyExists</code> fault is returned if the type already exists in the
/// domain. You cannot change any configuration settings of the type after its registration, and
/// it must be registered as a new version.</p>
/// </important>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>defaultTaskList.name</code>: String constraint. The key is
/// <code>swf:defaultTaskList.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>name</code>: String constraint. The key is <code>swf:name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>version</code>: String constraint. The key is
/// <code>swf:version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterActivityType {
    _private: (),
}
impl RegisterActivityType {
    /// Creates a new builder-style object to manufacture [`RegisterActivityTypeInput`](crate::input::RegisterActivityTypeInput)
    pub fn builder() -> crate::input::register_activity_type_input::Builder {
        crate::input::register_activity_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterActivityType {
    type Output = std::result::Result<
        crate::output::RegisterActivityTypeOutput,
        crate::error::RegisterActivityTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_activity_type_error(response)
        } else {
            crate::operation_deser::parse_register_activity_type_response(response)
        }
    }
}

/// <p>Registers a new domain.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>You cannot use an IAM policy to control domain access for this action. The name of
/// the domain being registered is available as the resource of this action.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterDomain {
    _private: (),
}
impl RegisterDomain {
    /// Creates a new builder-style object to manufacture [`RegisterDomainInput`](crate::input::RegisterDomainInput)
    pub fn builder() -> crate::input::register_domain_input::Builder {
        crate::input::register_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterDomain {
    type Output =
        std::result::Result<crate::output::RegisterDomainOutput, crate::error::RegisterDomainError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_domain_error(response)
        } else {
            crate::operation_deser::parse_register_domain_response(response)
        }
    }
}

/// <p>Registers a new <i>workflow type</i> and its configuration settings in
/// the specified domain.</p>
/// <p>The retention period for the workflow history is set by the <a>RegisterDomain</a> action.</p>
/// <important>
/// <p>If the type already exists, then a <code>TypeAlreadyExists</code> fault is returned.
/// You cannot change the configuration settings of a workflow type once it is registered and it
/// must be registered as a new version.</p>
/// </important>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>defaultTaskList.name</code>: String constraint. The key is
/// <code>swf:defaultTaskList.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>name</code>: String constraint. The key is <code>swf:name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>version</code>: String constraint. The key is
/// <code>swf:version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterWorkflowType {
    _private: (),
}
impl RegisterWorkflowType {
    /// Creates a new builder-style object to manufacture [`RegisterWorkflowTypeInput`](crate::input::RegisterWorkflowTypeInput)
    pub fn builder() -> crate::input::register_workflow_type_input::Builder {
        crate::input::register_workflow_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterWorkflowType {
    type Output = std::result::Result<
        crate::output::RegisterWorkflowTypeOutput,
        crate::error::RegisterWorkflowTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_workflow_type_error(response)
        } else {
            crate::operation_deser::parse_register_workflow_type_response(response)
        }
    }
}

/// <p>Records a <code>WorkflowExecutionCancelRequested</code> event in the currently running
/// workflow execution identified by the given domain, workflowId, and runId. This logically
/// requests the cancellation of the workflow execution as a whole. It is up to the decider to
/// take appropriate actions when it receives an execution history with this event.</p>
/// <note>
/// <p>If the runId isn't specified, the <code>WorkflowExecutionCancelRequested</code> event
/// is recorded in the history of the current open workflow execution with the specified
/// workflowId in the domain.</p>
/// </note>
/// <note>
/// <p>Because this action allows the workflow to properly clean up and gracefully close, it
/// should be used instead of <a>TerminateWorkflowExecution</a> when
/// possible.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RequestCancelWorkflowExecution {
    _private: (),
}
impl RequestCancelWorkflowExecution {
    /// Creates a new builder-style object to manufacture [`RequestCancelWorkflowExecutionInput`](crate::input::RequestCancelWorkflowExecutionInput)
    pub fn builder() -> crate::input::request_cancel_workflow_execution_input::Builder {
        crate::input::request_cancel_workflow_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RequestCancelWorkflowExecution {
    type Output = std::result::Result<
        crate::output::RequestCancelWorkflowExecutionOutput,
        crate::error::RequestCancelWorkflowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_request_cancel_workflow_execution_error(response)
        } else {
            crate::operation_deser::parse_request_cancel_workflow_execution_response(response)
        }
    }
}

/// <p>Used by workers to tell the service that the <a>ActivityTask</a> identified
/// by the <code>taskToken</code> was successfully canceled. Additional <code>details</code> can
/// be provided using the <code>details</code> argument.</p>
/// <p>These <code>details</code> (if provided) appear in the
/// <code>ActivityTaskCanceled</code> event added to the workflow history.</p>
/// <important>
/// <p>Only use this operation if the <code>canceled</code> flag of a <a>RecordActivityTaskHeartbeat</a> request returns <code>true</code> and if the
/// activity can be safely undone or abandoned.</p>
/// </important>
/// <p>A task is considered open from the time that it is scheduled until it is closed.
/// Therefore a task is reported as open while a worker is processing it. A task is closed after
/// it has been specified in a call to <a>RespondActivityTaskCompleted</a>,
/// RespondActivityTaskCanceled, <a>RespondActivityTaskFailed</a>, or the task has
/// <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html#swf-dev-timeout-types">timed
/// out</a>.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RespondActivityTaskCanceled {
    _private: (),
}
impl RespondActivityTaskCanceled {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskCanceledInput`](crate::input::RespondActivityTaskCanceledInput)
    pub fn builder() -> crate::input::respond_activity_task_canceled_input::Builder {
        crate::input::respond_activity_task_canceled_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RespondActivityTaskCanceled {
    type Output = std::result::Result<
        crate::output::RespondActivityTaskCanceledOutput,
        crate::error::RespondActivityTaskCanceledError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_respond_activity_task_canceled_error(response)
        } else {
            crate::operation_deser::parse_respond_activity_task_canceled_response(response)
        }
    }
}

/// <p>Used by workers to tell the service that the <a>ActivityTask</a> identified
/// by the <code>taskToken</code> completed successfully with a <code>result</code> (if provided).
/// The <code>result</code> appears in the <code>ActivityTaskCompleted</code> event in the
/// workflow history.</p>
/// <important>
/// <p>If the requested task doesn't complete successfully, use <a>RespondActivityTaskFailed</a> instead. If the worker finds that the task is
/// canceled through the <code>canceled</code> flag returned by <a>RecordActivityTaskHeartbeat</a>, it should cancel the task, clean up and then call
/// <a>RespondActivityTaskCanceled</a>.</p>
/// </important>
/// <p>A task is considered open from the time that it is scheduled until it is closed.
/// Therefore a task is reported as open while a worker is processing it. A task is closed after
/// it has been specified in a call to RespondActivityTaskCompleted, <a>RespondActivityTaskCanceled</a>, <a>RespondActivityTaskFailed</a>, or the
/// task has <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html#swf-dev-timeout-types">timed
/// out</a>.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RespondActivityTaskCompleted {
    _private: (),
}
impl RespondActivityTaskCompleted {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskCompletedInput`](crate::input::RespondActivityTaskCompletedInput)
    pub fn builder() -> crate::input::respond_activity_task_completed_input::Builder {
        crate::input::respond_activity_task_completed_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RespondActivityTaskCompleted {
    type Output = std::result::Result<
        crate::output::RespondActivityTaskCompletedOutput,
        crate::error::RespondActivityTaskCompletedError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_respond_activity_task_completed_error(response)
        } else {
            crate::operation_deser::parse_respond_activity_task_completed_response(response)
        }
    }
}

/// <p>Used by workers to tell the service that the <a>ActivityTask</a> identified
/// by the <code>taskToken</code> has failed with <code>reason</code> (if specified). The
/// <code>reason</code> and <code>details</code> appear in the <code>ActivityTaskFailed</code>
/// event added to the workflow history.</p>
/// <p>A task is considered open from the time that it is scheduled until it is closed.
/// Therefore a task is reported as open while a worker is processing it. A task is closed after
/// it has been specified in a call to <a>RespondActivityTaskCompleted</a>, <a>RespondActivityTaskCanceled</a>, RespondActivityTaskFailed, or the task has <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-basic.html#swf-dev-timeout-types">timed
/// out</a>.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RespondActivityTaskFailed {
    _private: (),
}
impl RespondActivityTaskFailed {
    /// Creates a new builder-style object to manufacture [`RespondActivityTaskFailedInput`](crate::input::RespondActivityTaskFailedInput)
    pub fn builder() -> crate::input::respond_activity_task_failed_input::Builder {
        crate::input::respond_activity_task_failed_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RespondActivityTaskFailed {
    type Output = std::result::Result<
        crate::output::RespondActivityTaskFailedOutput,
        crate::error::RespondActivityTaskFailedError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_respond_activity_task_failed_error(response)
        } else {
            crate::operation_deser::parse_respond_activity_task_failed_response(response)
        }
    }
}

/// <p>Used by deciders to tell the service that the <a>DecisionTask</a> identified
/// by the <code>taskToken</code> has successfully completed. The <code>decisions</code> argument
/// specifies the list of decisions made while processing the task.</p>
/// <p>A <code>DecisionTaskCompleted</code> event is added to the workflow history. The
/// <code>executionContext</code> specified is attached to the event in the workflow execution
/// history.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>If an IAM policy grants permission to use <code>RespondDecisionTaskCompleted</code>, it
/// can express permissions for the list of decisions in the <code>decisions</code> parameter.
/// Each of the decisions has one or more parameters, much like a regular API call. To allow for
/// policies to be as readable as possible, you can express permissions on decisions as if they
/// were actual API calls, including applying conditions to some parameters. For more information,
/// see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using
/// IAM to Manage Access to Amazon SWF Workflows</a> in the
/// <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RespondDecisionTaskCompleted {
    _private: (),
}
impl RespondDecisionTaskCompleted {
    /// Creates a new builder-style object to manufacture [`RespondDecisionTaskCompletedInput`](crate::input::RespondDecisionTaskCompletedInput)
    pub fn builder() -> crate::input::respond_decision_task_completed_input::Builder {
        crate::input::respond_decision_task_completed_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RespondDecisionTaskCompleted {
    type Output = std::result::Result<
        crate::output::RespondDecisionTaskCompletedOutput,
        crate::error::RespondDecisionTaskCompletedError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_respond_decision_task_completed_error(response)
        } else {
            crate::operation_deser::parse_respond_decision_task_completed_response(response)
        }
    }
}

/// <p>Records a <code>WorkflowExecutionSignaled</code> event in the workflow execution
/// history and creates a decision task for the workflow execution identified by the given domain,
/// workflowId and runId. The event is recorded with the specified user defined signalName and
/// input (if provided).</p>
/// <note>
/// <p>If a runId isn't specified, then the <code>WorkflowExecutionSignaled</code> event is
/// recorded in the history of the current open workflow with the matching workflowId in the
/// domain.</p>
/// </note>
/// <note>
/// <p>If the specified workflow execution isn't open, this method fails with
/// <code>UnknownResource</code>.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SignalWorkflowExecution {
    _private: (),
}
impl SignalWorkflowExecution {
    /// Creates a new builder-style object to manufacture [`SignalWorkflowExecutionInput`](crate::input::SignalWorkflowExecutionInput)
    pub fn builder() -> crate::input::signal_workflow_execution_input::Builder {
        crate::input::signal_workflow_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SignalWorkflowExecution {
    type Output = std::result::Result<
        crate::output::SignalWorkflowExecutionOutput,
        crate::error::SignalWorkflowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_signal_workflow_execution_error(response)
        } else {
            crate::operation_deser::parse_signal_workflow_execution_response(response)
        }
    }
}

/// <p>Starts an execution of the workflow type in the specified domain using the provided
/// <code>workflowId</code> and input data.</p>
/// <p>This action returns the newly started workflow execution.</p>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>tagList.member.0</code>: The key is <code>swf:tagList.member.0</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>tagList.member.1</code>: The key is <code>swf:tagList.member.1</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>tagList.member.2</code>: The key is <code>swf:tagList.member.2</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>tagList.member.3</code>: The key is <code>swf:tagList.member.3</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>tagList.member.4</code>: The key is <code>swf:tagList.member.4</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>taskList</code>: String constraint. The key is
/// <code>swf:taskList.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>workflowType.name</code>: String constraint. The key is
/// <code>swf:workflowType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>workflowType.version</code>: String constraint. The key is
/// <code>swf:workflowType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartWorkflowExecution {
    _private: (),
}
impl StartWorkflowExecution {
    /// Creates a new builder-style object to manufacture [`StartWorkflowExecutionInput`](crate::input::StartWorkflowExecutionInput)
    pub fn builder() -> crate::input::start_workflow_execution_input::Builder {
        crate::input::start_workflow_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartWorkflowExecution {
    type Output = std::result::Result<
        crate::output::StartWorkflowExecutionOutput,
        crate::error::StartWorkflowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_workflow_execution_error(response)
        } else {
            crate::operation_deser::parse_start_workflow_execution_response(response)
        }
    }
}

/// <p>Add a tag to a Amazon SWF domain.</p>
/// <note>
/// <p>Amazon SWF supports a maximum of 50 tags per resource.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Records a <code>WorkflowExecutionTerminated</code> event and forces closure of the
/// workflow execution identified by the given domain, runId, and workflowId. The child policy,
/// registered with the workflow type or specified when starting this execution, is applied to any
/// open child workflow executions of this workflow execution.</p>
/// <important>
/// <p>If the identified workflow execution was in progress, it is terminated
/// immediately.</p>
/// </important>
/// <note>
/// <p>If a runId isn't specified, then the <code>WorkflowExecutionTerminated</code> event
/// is recorded in the history of the current open workflow with the matching workflowId in the
/// domain.</p>
/// </note>
/// <note>
/// <p>You should consider using <a>RequestCancelWorkflowExecution</a> action
/// instead because it allows the workflow to gracefully close while <a>TerminateWorkflowExecution</a> doesn't.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TerminateWorkflowExecution {
    _private: (),
}
impl TerminateWorkflowExecution {
    /// Creates a new builder-style object to manufacture [`TerminateWorkflowExecutionInput`](crate::input::TerminateWorkflowExecutionInput)
    pub fn builder() -> crate::input::terminate_workflow_execution_input::Builder {
        crate::input::terminate_workflow_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TerminateWorkflowExecution {
    type Output = std::result::Result<
        crate::output::TerminateWorkflowExecutionOutput,
        crate::error::TerminateWorkflowExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_terminate_workflow_execution_error(response)
        } else {
            crate::operation_deser::parse_terminate_workflow_execution_response(response)
        }
    }
}

/// <p>Undeprecates a previously deprecated <i>activity type</i>. After an activity type has
/// been undeprecated, you can create new tasks of that activity type.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>activityType.name</code>: String constraint. The key is
/// <code>swf:activityType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>activityType.version</code>: String constraint. The key is
/// <code>swf:activityType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UndeprecateActivityType {
    _private: (),
}
impl UndeprecateActivityType {
    /// Creates a new builder-style object to manufacture [`UndeprecateActivityTypeInput`](crate::input::UndeprecateActivityTypeInput)
    pub fn builder() -> crate::input::undeprecate_activity_type_input::Builder {
        crate::input::undeprecate_activity_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UndeprecateActivityType {
    type Output = std::result::Result<
        crate::output::UndeprecateActivityTypeOutput,
        crate::error::UndeprecateActivityTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_undeprecate_activity_type_error(response)
        } else {
            crate::operation_deser::parse_undeprecate_activity_type_response(response)
        }
    }
}

/// <p>Undeprecates a previously deprecated domain. After a domain has been undeprecated it can be used
/// to create new workflow executions or register new types.</p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>You cannot use an IAM policy to constrain this action's parameters.</p>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UndeprecateDomain {
    _private: (),
}
impl UndeprecateDomain {
    /// Creates a new builder-style object to manufacture [`UndeprecateDomainInput`](crate::input::UndeprecateDomainInput)
    pub fn builder() -> crate::input::undeprecate_domain_input::Builder {
        crate::input::undeprecate_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UndeprecateDomain {
    type Output = std::result::Result<
        crate::output::UndeprecateDomainOutput,
        crate::error::UndeprecateDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_undeprecate_domain_error(response)
        } else {
            crate::operation_deser::parse_undeprecate_domain_response(response)
        }
    }
}

/// <p>Undeprecates a previously deprecated <i>workflow type</i>. After a workflow type has
/// been undeprecated, you can create new executions of that type. </p>
/// <note>
/// <p>This operation is eventually consistent. The results are best effort and may not
/// exactly reflect recent updates and changes.</p>
/// </note>
/// <p>
/// <b>Access Control</b>
/// </p>
/// <p>You can use IAM policies to control this action's access to Amazon SWF resources as
/// follows:</p>
/// <ul>
/// <li>
/// <p>Use a <code>Resource</code> element with the domain name to limit the action to
/// only specified domains.</p>
/// </li>
/// <li>
/// <p>Use an <code>Action</code> element to allow or deny permission to call this
/// action.</p>
/// </li>
/// <li>
/// <p>Constrain the following parameters by using a <code>Condition</code> element with
/// the appropriate keys.</p>
/// <ul>
/// <li>
/// <p>
/// <code>workflowType.name</code>: String constraint. The key is
/// <code>swf:workflowType.name</code>.</p>
/// </li>
/// <li>
/// <p>
/// <code>workflowType.version</code>: String constraint. The key is
/// <code>swf:workflowType.version</code>.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// <p>If the caller doesn't have sufficient permissions to invoke the action, or the
/// parameter values fall outside the specified constraints, the action fails. The associated
/// event attribute's <code>cause</code> parameter is set to <code>OPERATION_NOT_PERMITTED</code>.
/// For details and example IAM policies, see <a href="https://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-iam.html">Using IAM to Manage Access to Amazon SWF
/// Workflows</a> in the <i>Amazon SWF Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UndeprecateWorkflowType {
    _private: (),
}
impl UndeprecateWorkflowType {
    /// Creates a new builder-style object to manufacture [`UndeprecateWorkflowTypeInput`](crate::input::UndeprecateWorkflowTypeInput)
    pub fn builder() -> crate::input::undeprecate_workflow_type_input::Builder {
        crate::input::undeprecate_workflow_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UndeprecateWorkflowType {
    type Output = std::result::Result<
        crate::output::UndeprecateWorkflowTypeOutput,
        crate::error::UndeprecateWorkflowTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_undeprecate_workflow_type_error(response)
        } else {
            crate::operation_deser::parse_undeprecate_workflow_type_response(response)
        }
    }
}

/// <p>Remove a tag from a Amazon SWF domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}
