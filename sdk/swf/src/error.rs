// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnknownResourceFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnknownResourceFault {
    /// Creates a new builder-style object to manufacture [`UnknownResourceFault`](crate::error::UnknownResourceFault).
    pub fn builder() -> crate::error::unknown_resource_fault::Builder {
        crate::error::unknown_resource_fault::Builder::default()
    }
}
/// See [`UnknownResourceFault`](crate::error::UnknownResourceFault).
pub mod unknown_resource_fault {
    
    /// A builder for [`UnknownResourceFault`](crate::error::UnknownResourceFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`UnknownResourceFault`](crate::error::UnknownResourceFault).
        pub fn build(self) -> crate::error::UnknownResourceFault {
            crate::error::UnknownResourceFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl UnknownResourceFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for UnknownResourceFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnknownResourceFault")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnknownResourceFault {}
impl aws_http::request_id::RequestId for crate::error::UnknownResourceFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnknownResourceFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OperationNotPermittedFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OperationNotPermittedFault {
    /// Creates a new builder-style object to manufacture [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault).
    pub fn builder() -> crate::error::operation_not_permitted_fault::Builder {
        crate::error::operation_not_permitted_fault::Builder::default()
    }
}
/// See [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault).
pub mod operation_not_permitted_fault {
    
    /// A builder for [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault).
        pub fn build(self) -> crate::error::OperationNotPermittedFault {
            crate::error::OperationNotPermittedFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl OperationNotPermittedFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for OperationNotPermittedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationNotPermittedFault")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OperationNotPermittedFault {}
impl aws_http::request_id::RequestId for crate::error::OperationNotPermittedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OperationNotPermittedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LimitExceededFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl LimitExceededFault {
    /// Creates a new builder-style object to manufacture [`LimitExceededFault`](crate::error::LimitExceededFault).
    pub fn builder() -> crate::error::limit_exceeded_fault::Builder {
        crate::error::limit_exceeded_fault::Builder::default()
    }
}
/// See [`LimitExceededFault`](crate::error::LimitExceededFault).
pub mod limit_exceeded_fault {
    
    /// A builder for [`LimitExceededFault`](crate::error::LimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`LimitExceededFault`](crate::error::LimitExceededFault).
        pub fn build(self) -> crate::error::LimitExceededFault {
            crate::error::LimitExceededFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl LimitExceededFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for LimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededFault")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::LimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for LimitExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UndeprecateWorkflowTypeErrorKind = UndeprecateWorkflowTypeError;
/// Error type for the `UndeprecateWorkflowTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UndeprecateWorkflowTypeError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned if the type already exists in the specified domain. You may get this fault if you are registering a type that is either already registered or deprecated, or if you undeprecate a type that is currently registered.</p>
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UndeprecateWorkflowTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UndeprecateWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UndeprecateWorkflowTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UndeprecateWorkflowTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UndeprecateWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UndeprecateWorkflowTypeError {
    /// Creates the `UndeprecateWorkflowTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UndeprecateWorkflowTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeAlreadyExistsFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UndeprecateWorkflowTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `UndeprecateWorkflowTypeError::TypeAlreadyExistsFault`.
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(self, Self::TypeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `UndeprecateWorkflowTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for UndeprecateWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Returned if the type already exists in the specified domain. You may get this fault if you are registering a type that is either already registered or deprecated, or if you undeprecate a type that is currently registered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TypeAlreadyExistsFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TypeAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault).
    pub fn builder() -> crate::error::type_already_exists_fault::Builder {
        crate::error::type_already_exists_fault::Builder::default()
    }
}
/// See [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault).
pub mod type_already_exists_fault {
    
    /// A builder for [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault).
        pub fn build(self) -> crate::error::TypeAlreadyExistsFault {
            crate::error::TypeAlreadyExistsFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl TypeAlreadyExistsFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TypeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TypeAlreadyExistsFault")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TypeAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::TypeAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TypeAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UndeprecateDomainErrorKind = UndeprecateDomainError;
/// Error type for the `UndeprecateDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UndeprecateDomainError {
    /// <p>Returned if the domain already exists. You may get this fault if you are registering a domain that is either already registered or deprecated, or if you undeprecate a domain that is currently registered.</p>
    DomainAlreadyExistsFault(crate::error::DomainAlreadyExistsFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UndeprecateDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UndeprecateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DomainAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UndeprecateDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DomainAlreadyExistsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UndeprecateDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UndeprecateDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UndeprecateDomainError {
    /// Creates the `UndeprecateDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UndeprecateDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DomainAlreadyExistsFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UndeprecateDomainError::DomainAlreadyExistsFault`.
    pub fn is_domain_already_exists_fault(&self) -> bool {
        matches!(self, Self::DomainAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `UndeprecateDomainError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `UndeprecateDomainError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for UndeprecateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DomainAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Returned if the domain already exists. You may get this fault if you are registering a domain that is either already registered or deprecated, or if you undeprecate a domain that is currently registered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainAlreadyExistsFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DomainAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault).
    pub fn builder() -> crate::error::domain_already_exists_fault::Builder {
        crate::error::domain_already_exists_fault::Builder::default()
    }
}
/// See [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault).
pub mod domain_already_exists_fault {
    
    /// A builder for [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault).
        pub fn build(self) -> crate::error::DomainAlreadyExistsFault {
            crate::error::DomainAlreadyExistsFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl DomainAlreadyExistsFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for DomainAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainAlreadyExistsFault")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DomainAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DomainAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DomainAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UndeprecateActivityTypeErrorKind = UndeprecateActivityTypeError;
/// Error type for the `UndeprecateActivityTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UndeprecateActivityTypeError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned if the type already exists in the specified domain. You may get this fault if you are registering a type that is either already registered or deprecated, or if you undeprecate a type that is currently registered.</p>
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UndeprecateActivityTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UndeprecateActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UndeprecateActivityTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UndeprecateActivityTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UndeprecateActivityTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UndeprecateActivityTypeError {
    /// Creates the `UndeprecateActivityTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UndeprecateActivityTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeAlreadyExistsFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UndeprecateActivityTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `UndeprecateActivityTypeError::TypeAlreadyExistsFault`.
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(self, Self::TypeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `UndeprecateActivityTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for UndeprecateActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type TerminateWorkflowExecutionErrorKind = TerminateWorkflowExecutionError;
/// Error type for the `TerminateWorkflowExecutionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TerminateWorkflowExecutionError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TerminateWorkflowExecutionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for TerminateWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TerminateWorkflowExecutionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TerminateWorkflowExecutionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for TerminateWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TerminateWorkflowExecutionError {
    /// Creates the `TerminateWorkflowExecutionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `TerminateWorkflowExecutionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TerminateWorkflowExecutionError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `TerminateWorkflowExecutionError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for TerminateWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>You've exceeded the number of tags allowed for a domain.</p>
    TooManyTagsFault(crate::error::TooManyTagsFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyTagsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyTagsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TooManyTagsFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TooManyTagsFault`.
    pub fn is_too_many_tags_fault(&self) -> bool {
        matches!(self, Self::TooManyTagsFault(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TooManyTagsFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>You've exceeded the number of tags allowed for a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyTagsFault  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyTagsFault {
    /// Creates a new builder-style object to manufacture [`TooManyTagsFault`](crate::error::TooManyTagsFault).
    pub fn builder() -> crate::error::too_many_tags_fault::Builder {
        crate::error::too_many_tags_fault::Builder::default()
    }
}
/// See [`TooManyTagsFault`](crate::error::TooManyTagsFault).
pub mod too_many_tags_fault {
    
    /// A builder for [`TooManyTagsFault`](crate::error::TooManyTagsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`TooManyTagsFault`](crate::error::TooManyTagsFault).
        pub fn build(self) -> crate::error::TooManyTagsFault {
            crate::error::TooManyTagsFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl TooManyTagsFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TooManyTagsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsFault")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsFault {}
impl aws_http::request_id::RequestId for crate::error::TooManyTagsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyTagsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type StartWorkflowExecutionErrorKind = StartWorkflowExecutionError;
/// Error type for the `StartWorkflowExecutionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartWorkflowExecutionError {
    /// <p>The <code>StartWorkflowExecution</code> API action was called without the required parameters set.</p> 
    /// <p>Some workflow execution parameters, such as the decision <code>taskList</code>, must be set to start the execution. However, these parameters might have been set as defaults when the workflow type was registered. In this case, you can omit these parameters from the <code>StartWorkflowExecution</code> call and Amazon SWF uses the values defined in the workflow type.</p> <note> 
    /// <p>If these parameters aren't set and no default parameters were defined in the workflow type, this error is displayed.</p> 
    /// </note>
    DefaultUndefinedFault(crate::error::DefaultUndefinedFault),
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the specified activity or workflow type was already deprecated.</p>
    TypeDeprecatedFault(crate::error::TypeDeprecatedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// <p>Returned by <code>StartWorkflowExecution</code> when an open execution with the same workflowId is already running in the specified domain.</p>
    WorkflowExecutionAlreadyStartedFault(crate::error::WorkflowExecutionAlreadyStartedFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for StartWorkflowExecutionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for StartWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DefaultUndefinedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::WorkflowExecutionAlreadyStartedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StartWorkflowExecutionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DefaultUndefinedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::WorkflowExecutionAlreadyStartedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::StartWorkflowExecutionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for StartWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartWorkflowExecutionError {
    /// Creates the `StartWorkflowExecutionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `StartWorkflowExecutionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DefaultUndefinedFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeDeprecatedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::WorkflowExecutionAlreadyStartedFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `StartWorkflowExecutionError::DefaultUndefinedFault`.
    pub fn is_default_undefined_fault(&self) -> bool {
        matches!(self, Self::DefaultUndefinedFault(_))
    }
    /// Returns `true` if the error kind is `StartWorkflowExecutionError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `StartWorkflowExecutionError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `StartWorkflowExecutionError::TypeDeprecatedFault`.
    pub fn is_type_deprecated_fault(&self) -> bool {
        matches!(self, Self::TypeDeprecatedFault(_))
    }
    /// Returns `true` if the error kind is `StartWorkflowExecutionError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
    /// Returns `true` if the error kind is `StartWorkflowExecutionError::WorkflowExecutionAlreadyStartedFault`.
    pub fn is_workflow_execution_already_started_fault(&self) -> bool {
        matches!(self, Self::WorkflowExecutionAlreadyStartedFault(_))
    }
}
impl std::error::Error for StartWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DefaultUndefinedFault(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::WorkflowExecutionAlreadyStartedFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Returned by <code>StartWorkflowExecution</code> when an open execution with the same workflowId is already running in the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkflowExecutionAlreadyStartedFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl WorkflowExecutionAlreadyStartedFault {
    /// Creates a new builder-style object to manufacture [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault).
    pub fn builder() -> crate::error::workflow_execution_already_started_fault::Builder {
        crate::error::workflow_execution_already_started_fault::Builder::default()
    }
}
/// See [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault).
pub mod workflow_execution_already_started_fault {
    
    /// A builder for [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault).
        pub fn build(self) -> crate::error::WorkflowExecutionAlreadyStartedFault {
            crate::error::WorkflowExecutionAlreadyStartedFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl WorkflowExecutionAlreadyStartedFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for WorkflowExecutionAlreadyStartedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WorkflowExecutionAlreadyStartedFault")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for WorkflowExecutionAlreadyStartedFault {}
impl aws_http::request_id::RequestId for crate::error::WorkflowExecutionAlreadyStartedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for WorkflowExecutionAlreadyStartedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>Returned when the specified activity or workflow type was already deprecated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TypeDeprecatedFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TypeDeprecatedFault {
    /// Creates a new builder-style object to manufacture [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault).
    pub fn builder() -> crate::error::type_deprecated_fault::Builder {
        crate::error::type_deprecated_fault::Builder::default()
    }
}
/// See [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault).
pub mod type_deprecated_fault {
    
    /// A builder for [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault).
        pub fn build(self) -> crate::error::TypeDeprecatedFault {
            crate::error::TypeDeprecatedFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl TypeDeprecatedFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for TypeDeprecatedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TypeDeprecatedFault")?;
        if let Some(inner_8) = &self.message {
             {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TypeDeprecatedFault {}
impl aws_http::request_id::RequestId for crate::error::TypeDeprecatedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TypeDeprecatedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>The <code>StartWorkflowExecution</code> API action was called without the required parameters set.</p> 
/// <p>Some workflow execution parameters, such as the decision <code>taskList</code>, must be set to start the execution. However, these parameters might have been set as defaults when the workflow type was registered. In this case, you can omit these parameters from the <code>StartWorkflowExecution</code> call and Amazon SWF uses the values defined in the workflow type.</p> <note> 
/// <p>If these parameters aren't set and no default parameters were defined in the workflow type, this error is displayed.</p> 
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultUndefinedFault  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DefaultUndefinedFault {
    /// Creates a new builder-style object to manufacture [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault).
    pub fn builder() -> crate::error::default_undefined_fault::Builder {
        crate::error::default_undefined_fault::Builder::default()
    }
}
/// See [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault).
pub mod default_undefined_fault {
    
    /// A builder for [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault).
        pub fn build(self) -> crate::error::DefaultUndefinedFault {
            crate::error::DefaultUndefinedFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl DefaultUndefinedFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for DefaultUndefinedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultUndefinedFault")?;
        if let Some(inner_9) = &self.message {
             {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DefaultUndefinedFault {}
impl aws_http::request_id::RequestId for crate::error::DefaultUndefinedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DefaultUndefinedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type SignalWorkflowExecutionErrorKind = SignalWorkflowExecutionError;
/// Error type for the `SignalWorkflowExecutionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignalWorkflowExecutionError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for SignalWorkflowExecutionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for SignalWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SignalWorkflowExecutionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::SignalWorkflowExecutionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for SignalWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignalWorkflowExecutionError {
    /// Creates the `SignalWorkflowExecutionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `SignalWorkflowExecutionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `SignalWorkflowExecutionError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `SignalWorkflowExecutionError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for SignalWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RespondDecisionTaskCompletedErrorKind = RespondDecisionTaskCompletedError;
/// Error type for the `RespondDecisionTaskCompletedError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondDecisionTaskCompletedError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RespondDecisionTaskCompletedError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RespondDecisionTaskCompletedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RespondDecisionTaskCompletedError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RespondDecisionTaskCompletedError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RespondDecisionTaskCompletedError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondDecisionTaskCompletedError {
    /// Creates the `RespondDecisionTaskCompletedError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RespondDecisionTaskCompletedError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RespondDecisionTaskCompletedError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RespondDecisionTaskCompletedError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RespondDecisionTaskCompletedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RespondActivityTaskFailedErrorKind = RespondActivityTaskFailedError;
/// Error type for the `RespondActivityTaskFailedError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondActivityTaskFailedError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RespondActivityTaskFailedError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RespondActivityTaskFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RespondActivityTaskFailedError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RespondActivityTaskFailedError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RespondActivityTaskFailedError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondActivityTaskFailedError {
    /// Creates the `RespondActivityTaskFailedError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RespondActivityTaskFailedError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RespondActivityTaskFailedError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RespondActivityTaskFailedError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RespondActivityTaskFailedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RespondActivityTaskCompletedErrorKind = RespondActivityTaskCompletedError;
/// Error type for the `RespondActivityTaskCompletedError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondActivityTaskCompletedError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RespondActivityTaskCompletedError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RespondActivityTaskCompletedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RespondActivityTaskCompletedError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RespondActivityTaskCompletedError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RespondActivityTaskCompletedError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondActivityTaskCompletedError {
    /// Creates the `RespondActivityTaskCompletedError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RespondActivityTaskCompletedError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RespondActivityTaskCompletedError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RespondActivityTaskCompletedError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RespondActivityTaskCompletedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RespondActivityTaskCanceledErrorKind = RespondActivityTaskCanceledError;
/// Error type for the `RespondActivityTaskCanceledError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondActivityTaskCanceledError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RespondActivityTaskCanceledError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RespondActivityTaskCanceledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RespondActivityTaskCanceledError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RespondActivityTaskCanceledError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RespondActivityTaskCanceledError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondActivityTaskCanceledError {
    /// Creates the `RespondActivityTaskCanceledError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RespondActivityTaskCanceledError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RespondActivityTaskCanceledError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RespondActivityTaskCanceledError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RespondActivityTaskCanceledError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RequestCancelWorkflowExecutionErrorKind = RequestCancelWorkflowExecutionError;
/// Error type for the `RequestCancelWorkflowExecutionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RequestCancelWorkflowExecutionError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RequestCancelWorkflowExecutionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RequestCancelWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RequestCancelWorkflowExecutionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RequestCancelWorkflowExecutionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RequestCancelWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RequestCancelWorkflowExecutionError {
    /// Creates the `RequestCancelWorkflowExecutionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RequestCancelWorkflowExecutionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RequestCancelWorkflowExecutionError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RequestCancelWorkflowExecutionError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RequestCancelWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RegisterWorkflowTypeErrorKind = RegisterWorkflowTypeError;
/// Error type for the `RegisterWorkflowTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterWorkflowTypeError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned if the type already exists in the specified domain. You may get this fault if you are registering a type that is either already registered or deprecated, or if you undeprecate a type that is currently registered.</p>
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterWorkflowTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RegisterWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterWorkflowTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterWorkflowTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RegisterWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterWorkflowTypeError {
    /// Creates the `RegisterWorkflowTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RegisterWorkflowTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeAlreadyExistsFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterWorkflowTypeError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `RegisterWorkflowTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RegisterWorkflowTypeError::TypeAlreadyExistsFault`.
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(self, Self::TypeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RegisterWorkflowTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RegisterWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RegisterDomainErrorKind = RegisterDomainError;
/// Error type for the `RegisterDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterDomainError {
    /// <p>Returned if the domain already exists. You may get this fault if you are registering a domain that is either already registered or deprecated, or if you undeprecate a domain that is currently registered.</p>
    DomainAlreadyExistsFault(crate::error::DomainAlreadyExistsFault),
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>You've exceeded the number of tags allowed for a domain.</p>
    TooManyTagsFault(crate::error::TooManyTagsFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RegisterDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DomainAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyTagsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DomainAlreadyExistsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyTagsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RegisterDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterDomainError {
    /// Creates the `RegisterDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RegisterDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DomainAlreadyExistsFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TooManyTagsFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterDomainError::DomainAlreadyExistsFault`.
    pub fn is_domain_already_exists_fault(&self) -> bool {
        matches!(self, Self::DomainAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RegisterDomainError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `RegisterDomainError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RegisterDomainError::TooManyTagsFault`.
    pub fn is_too_many_tags_fault(&self) -> bool {
        matches!(self, Self::TooManyTagsFault(_))
    }
}
impl std::error::Error for RegisterDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DomainAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TooManyTagsFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RegisterActivityTypeErrorKind = RegisterActivityTypeError;
/// Error type for the `RegisterActivityTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterActivityTypeError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned if the type already exists in the specified domain. You may get this fault if you are registering a type that is either already registered or deprecated, or if you undeprecate a type that is currently registered.</p>
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterActivityTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RegisterActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterActivityTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterActivityTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RegisterActivityTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterActivityTypeError {
    /// Creates the `RegisterActivityTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RegisterActivityTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeAlreadyExistsFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterActivityTypeError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `RegisterActivityTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RegisterActivityTypeError::TypeAlreadyExistsFault`.
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(self, Self::TypeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RegisterActivityTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RegisterActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RecordActivityTaskHeartbeatErrorKind = RecordActivityTaskHeartbeatError;
/// Error type for the `RecordActivityTaskHeartbeatError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RecordActivityTaskHeartbeatError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RecordActivityTaskHeartbeatError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RecordActivityTaskHeartbeatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RecordActivityTaskHeartbeatError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RecordActivityTaskHeartbeatError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RecordActivityTaskHeartbeatError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RecordActivityTaskHeartbeatError {
    /// Creates the `RecordActivityTaskHeartbeatError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RecordActivityTaskHeartbeatError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RecordActivityTaskHeartbeatError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `RecordActivityTaskHeartbeatError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for RecordActivityTaskHeartbeatError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type PollForDecisionTaskErrorKind = PollForDecisionTaskError;
/// Error type for the `PollForDecisionTaskError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PollForDecisionTaskError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PollForDecisionTaskError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for PollForDecisionTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PollForDecisionTaskError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PollForDecisionTaskError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for PollForDecisionTaskError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PollForDecisionTaskError {
    /// Creates the `PollForDecisionTaskError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `PollForDecisionTaskError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PollForDecisionTaskError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `PollForDecisionTaskError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `PollForDecisionTaskError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for PollForDecisionTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type PollForActivityTaskErrorKind = PollForActivityTaskError;
/// Error type for the `PollForActivityTaskError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PollForActivityTaskError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PollForActivityTaskError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for PollForActivityTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PollForActivityTaskError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PollForActivityTaskError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for PollForActivityTaskError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PollForActivityTaskError {
    /// Creates the `PollForActivityTaskError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `PollForActivityTaskError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PollForActivityTaskError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `PollForActivityTaskError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `PollForActivityTaskError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for PollForActivityTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListWorkflowTypesErrorKind = ListWorkflowTypesError;
/// Error type for the `ListWorkflowTypesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorkflowTypesError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListWorkflowTypesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListWorkflowTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListWorkflowTypesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListWorkflowTypesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListWorkflowTypesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorkflowTypesError {
    /// Creates the `ListWorkflowTypesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListWorkflowTypesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListWorkflowTypesError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `ListWorkflowTypesError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for ListWorkflowTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::LimitExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::LimitExceededFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::LimitExceededFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::LimitExceededFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListOpenWorkflowExecutionsErrorKind = ListOpenWorkflowExecutionsError;
/// Error type for the `ListOpenWorkflowExecutionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpenWorkflowExecutionsError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListOpenWorkflowExecutionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListOpenWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListOpenWorkflowExecutionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListOpenWorkflowExecutionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListOpenWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpenWorkflowExecutionsError {
    /// Creates the `ListOpenWorkflowExecutionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListOpenWorkflowExecutionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListOpenWorkflowExecutionsError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `ListOpenWorkflowExecutionsError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for ListOpenWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListDomainsErrorKind = ListDomainsError;
/// Error type for the `ListDomainsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainsError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDomainsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDomainsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDomainsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListDomainsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainsError {
    /// Creates the `ListDomainsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListDomainsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDomainsError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
}
impl std::error::Error for ListDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListClosedWorkflowExecutionsErrorKind = ListClosedWorkflowExecutionsError;
/// Error type for the `ListClosedWorkflowExecutionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClosedWorkflowExecutionsError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListClosedWorkflowExecutionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListClosedWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListClosedWorkflowExecutionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListClosedWorkflowExecutionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListClosedWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClosedWorkflowExecutionsError {
    /// Creates the `ListClosedWorkflowExecutionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListClosedWorkflowExecutionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListClosedWorkflowExecutionsError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `ListClosedWorkflowExecutionsError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for ListClosedWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListActivityTypesErrorKind = ListActivityTypesError;
/// Error type for the `ListActivityTypesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListActivityTypesError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListActivityTypesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListActivityTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListActivityTypesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListActivityTypesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListActivityTypesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListActivityTypesError {
    /// Creates the `ListActivityTypesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListActivityTypesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListActivityTypesError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `ListActivityTypesError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for ListActivityTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetWorkflowExecutionHistoryErrorKind = GetWorkflowExecutionHistoryError;
/// Error type for the `GetWorkflowExecutionHistoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorkflowExecutionHistoryError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetWorkflowExecutionHistoryError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetWorkflowExecutionHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetWorkflowExecutionHistoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetWorkflowExecutionHistoryError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetWorkflowExecutionHistoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorkflowExecutionHistoryError {
    /// Creates the `GetWorkflowExecutionHistoryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetWorkflowExecutionHistoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetWorkflowExecutionHistoryError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `GetWorkflowExecutionHistoryError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for GetWorkflowExecutionHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeWorkflowTypeErrorKind = DescribeWorkflowTypeError;
/// Error type for the `DescribeWorkflowTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkflowTypeError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeWorkflowTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeWorkflowTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeWorkflowTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkflowTypeError {
    /// Creates the `DescribeWorkflowTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeWorkflowTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeWorkflowTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DescribeWorkflowTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DescribeWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeWorkflowExecutionErrorKind = DescribeWorkflowExecutionError;
/// Error type for the `DescribeWorkflowExecutionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkflowExecutionError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeWorkflowExecutionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeWorkflowExecutionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeWorkflowExecutionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkflowExecutionError {
    /// Creates the `DescribeWorkflowExecutionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeWorkflowExecutionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeWorkflowExecutionError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DescribeWorkflowExecutionError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DescribeWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeDomainErrorKind = DescribeDomainError;
/// Error type for the `DescribeDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainError {
    /// Creates the `DescribeDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDomainError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DescribeDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeActivityTypeErrorKind = DescribeActivityTypeError;
/// Error type for the `DescribeActivityTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeActivityTypeError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeActivityTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeActivityTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeActivityTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeActivityTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeActivityTypeError {
    /// Creates the `DescribeActivityTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeActivityTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeActivityTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DescribeActivityTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DescribeActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeprecateWorkflowTypeErrorKind = DeprecateWorkflowTypeError;
/// Error type for the `DeprecateWorkflowTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateWorkflowTypeError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the specified activity or workflow type was already deprecated.</p>
    TypeDeprecatedFault(crate::error::TypeDeprecatedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeprecateWorkflowTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeprecateWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeprecateWorkflowTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeprecateWorkflowTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeprecateWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateWorkflowTypeError {
    /// Creates the `DeprecateWorkflowTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeprecateWorkflowTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeDeprecatedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeprecateWorkflowTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DeprecateWorkflowTypeError::TypeDeprecatedFault`.
    pub fn is_type_deprecated_fault(&self) -> bool {
        matches!(self, Self::TypeDeprecatedFault(_))
    }
    /// Returns `true` if the error kind is `DeprecateWorkflowTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DeprecateWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeprecateDomainErrorKind = DeprecateDomainError;
/// Error type for the `DeprecateDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateDomainError {
    /// <p>Returned when the specified domain has been deprecated.</p>
    DomainDeprecatedFault(crate::error::DomainDeprecatedFault),
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeprecateDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeprecateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DomainDeprecatedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeprecateDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DomainDeprecatedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeprecateDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeprecateDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateDomainError {
    /// Creates the `DeprecateDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeprecateDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DomainDeprecatedFault(e) => e.meta(),
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeprecateDomainError::DomainDeprecatedFault`.
    pub fn is_domain_deprecated_fault(&self) -> bool {
        matches!(self, Self::DomainDeprecatedFault(_))
    }
    /// Returns `true` if the error kind is `DeprecateDomainError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DeprecateDomainError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DeprecateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DomainDeprecatedFault(_inner) =>
            Some(_inner)
            ,
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>Returned when the specified domain has been deprecated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainDeprecatedFault  {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DomainDeprecatedFault {
    /// Creates a new builder-style object to manufacture [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault).
    pub fn builder() -> crate::error::domain_deprecated_fault::Builder {
        crate::error::domain_deprecated_fault::Builder::default()
    }
}
/// See [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault).
pub mod domain_deprecated_fault {
    
    /// A builder for [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault).
        pub fn build(self) -> crate::error::DomainDeprecatedFault {
            crate::error::DomainDeprecatedFault {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl DomainDeprecatedFault {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for DomainDeprecatedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainDeprecatedFault")?;
        if let Some(inner_10) = &self.message {
             {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DomainDeprecatedFault {}
impl aws_http::request_id::RequestId for crate::error::DomainDeprecatedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DomainDeprecatedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeprecateActivityTypeErrorKind = DeprecateActivityTypeError;
/// Error type for the `DeprecateActivityTypeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateActivityTypeError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the specified activity or workflow type was already deprecated.</p>
    TypeDeprecatedFault(crate::error::TypeDeprecatedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeprecateActivityTypeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeprecateActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeprecateActivityTypeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeprecateActivityTypeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeprecateActivityTypeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateActivityTypeError {
    /// Creates the `DeprecateActivityTypeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeprecateActivityTypeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::TypeDeprecatedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeprecateActivityTypeError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `DeprecateActivityTypeError::TypeDeprecatedFault`.
    pub fn is_type_deprecated_fault(&self) -> bool {
        matches!(self, Self::TypeDeprecatedFault(_))
    }
    /// Returns `true` if the error kind is `DeprecateActivityTypeError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for DeprecateActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::TypeDeprecatedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CountPendingDecisionTasksErrorKind = CountPendingDecisionTasksError;
/// Error type for the `CountPendingDecisionTasksError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountPendingDecisionTasksError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CountPendingDecisionTasksError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CountPendingDecisionTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CountPendingDecisionTasksError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CountPendingDecisionTasksError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CountPendingDecisionTasksError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountPendingDecisionTasksError {
    /// Creates the `CountPendingDecisionTasksError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CountPendingDecisionTasksError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CountPendingDecisionTasksError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `CountPendingDecisionTasksError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for CountPendingDecisionTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CountPendingActivityTasksErrorKind = CountPendingActivityTasksError;
/// Error type for the `CountPendingActivityTasksError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountPendingActivityTasksError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CountPendingActivityTasksError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CountPendingActivityTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CountPendingActivityTasksError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CountPendingActivityTasksError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CountPendingActivityTasksError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountPendingActivityTasksError {
    /// Creates the `CountPendingActivityTasksError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CountPendingActivityTasksError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CountPendingActivityTasksError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `CountPendingActivityTasksError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for CountPendingActivityTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CountOpenWorkflowExecutionsErrorKind = CountOpenWorkflowExecutionsError;
/// Error type for the `CountOpenWorkflowExecutionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountOpenWorkflowExecutionsError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CountOpenWorkflowExecutionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CountOpenWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CountOpenWorkflowExecutionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CountOpenWorkflowExecutionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CountOpenWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountOpenWorkflowExecutionsError {
    /// Creates the `CountOpenWorkflowExecutionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CountOpenWorkflowExecutionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CountOpenWorkflowExecutionsError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `CountOpenWorkflowExecutionsError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for CountOpenWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CountClosedWorkflowExecutionsErrorKind = CountClosedWorkflowExecutionsError;
/// Error type for the `CountClosedWorkflowExecutionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountClosedWorkflowExecutionsError {
    /// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CountClosedWorkflowExecutionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CountClosedWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnknownResourceFault(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CountClosedWorkflowExecutionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CountClosedWorkflowExecutionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CountClosedWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountClosedWorkflowExecutionsError {
    /// Creates the `CountClosedWorkflowExecutionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CountClosedWorkflowExecutionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::OperationNotPermittedFault(e) => e.meta(),
            Self::UnknownResourceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CountClosedWorkflowExecutionsError::OperationNotPermittedFault`.
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(self, Self::OperationNotPermittedFault(_))
    }
    /// Returns `true` if the error kind is `CountClosedWorkflowExecutionsError::UnknownResourceFault`.
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(self, Self::UnknownResourceFault(_))
    }
}
impl std::error::Error for CountClosedWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::OperationNotPermittedFault(_inner) =>
            Some(_inner)
            ,
            Self::UnknownResourceFault(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

