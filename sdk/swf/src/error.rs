// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CountClosedWorkflowExecutionsError {
    pub kind: CountClosedWorkflowExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountClosedWorkflowExecutionsErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CountClosedWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CountClosedWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            CountClosedWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            CountClosedWorkflowExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CountClosedWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        CountClosedWorkflowExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountClosedWorkflowExecutionsError {
    pub fn new(kind: CountClosedWorkflowExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CountClosedWorkflowExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CountClosedWorkflowExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountClosedWorkflowExecutionsErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountClosedWorkflowExecutionsErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for CountClosedWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CountClosedWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            CountClosedWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            CountClosedWorkflowExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CountOpenWorkflowExecutionsError {
    pub kind: CountOpenWorkflowExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountOpenWorkflowExecutionsErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CountOpenWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CountOpenWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            CountOpenWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            CountOpenWorkflowExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CountOpenWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        CountOpenWorkflowExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountOpenWorkflowExecutionsError {
    pub fn new(kind: CountOpenWorkflowExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CountOpenWorkflowExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CountOpenWorkflowExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountOpenWorkflowExecutionsErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountOpenWorkflowExecutionsErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for CountOpenWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CountOpenWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            CountOpenWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            CountOpenWorkflowExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CountPendingActivityTasksError {
    pub kind: CountPendingActivityTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountPendingActivityTasksErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CountPendingActivityTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CountPendingActivityTasksErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            CountPendingActivityTasksErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            CountPendingActivityTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CountPendingActivityTasksError {
    fn code(&self) -> Option<&str> {
        CountPendingActivityTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountPendingActivityTasksError {
    pub fn new(kind: CountPendingActivityTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CountPendingActivityTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CountPendingActivityTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountPendingActivityTasksErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountPendingActivityTasksErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for CountPendingActivityTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CountPendingActivityTasksErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            CountPendingActivityTasksErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            CountPendingActivityTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CountPendingDecisionTasksError {
    pub kind: CountPendingDecisionTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CountPendingDecisionTasksErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CountPendingDecisionTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CountPendingDecisionTasksErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            CountPendingDecisionTasksErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            CountPendingDecisionTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CountPendingDecisionTasksError {
    fn code(&self) -> Option<&str> {
        CountPendingDecisionTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CountPendingDecisionTasksError {
    pub fn new(kind: CountPendingDecisionTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CountPendingDecisionTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CountPendingDecisionTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountPendingDecisionTasksErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            CountPendingDecisionTasksErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for CountPendingDecisionTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CountPendingDecisionTasksErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            CountPendingDecisionTasksErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            CountPendingDecisionTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeprecateActivityTypeError {
    pub kind: DeprecateActivityTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateActivityTypeErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeDeprecatedFault(crate::error::TypeDeprecatedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeprecateActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeprecateActivityTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DeprecateActivityTypeErrorKind::TypeDeprecatedFault(_inner) => _inner.fmt(f),
            DeprecateActivityTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DeprecateActivityTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeprecateActivityTypeError {
    fn code(&self) -> Option<&str> {
        DeprecateActivityTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateActivityTypeError {
    pub fn new(kind: DeprecateActivityTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeprecateActivityTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeprecateActivityTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateActivityTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_deprecated_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateActivityTypeErrorKind::TypeDeprecatedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateActivityTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for DeprecateActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeprecateActivityTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DeprecateActivityTypeErrorKind::TypeDeprecatedFault(_inner) => Some(_inner),
            DeprecateActivityTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DeprecateActivityTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeprecateDomainError {
    pub kind: DeprecateDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateDomainErrorKind {
    DomainDeprecatedFault(crate::error::DomainDeprecatedFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeprecateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeprecateDomainErrorKind::DomainDeprecatedFault(_inner) => _inner.fmt(f),
            DeprecateDomainErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DeprecateDomainErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DeprecateDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeprecateDomainError {
    fn code(&self) -> Option<&str> {
        DeprecateDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateDomainError {
    pub fn new(kind: DeprecateDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeprecateDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeprecateDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_domain_deprecated_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateDomainErrorKind::DomainDeprecatedFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateDomainErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateDomainErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for DeprecateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeprecateDomainErrorKind::DomainDeprecatedFault(_inner) => Some(_inner),
            DeprecateDomainErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DeprecateDomainErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DeprecateDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeprecateWorkflowTypeError {
    pub kind: DeprecateWorkflowTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeprecateWorkflowTypeErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeDeprecatedFault(crate::error::TypeDeprecatedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeprecateWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeprecateWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DeprecateWorkflowTypeErrorKind::TypeDeprecatedFault(_inner) => _inner.fmt(f),
            DeprecateWorkflowTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DeprecateWorkflowTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeprecateWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        DeprecateWorkflowTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeprecateWorkflowTypeError {
    pub fn new(kind: DeprecateWorkflowTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeprecateWorkflowTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeprecateWorkflowTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateWorkflowTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_deprecated_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateWorkflowTypeErrorKind::TypeDeprecatedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeprecateWorkflowTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for DeprecateWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeprecateWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DeprecateWorkflowTypeErrorKind::TypeDeprecatedFault(_inner) => Some(_inner),
            DeprecateWorkflowTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DeprecateWorkflowTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeActivityTypeError {
    pub kind: DescribeActivityTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeActivityTypeErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeActivityTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DescribeActivityTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DescribeActivityTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeActivityTypeError {
    fn code(&self) -> Option<&str> {
        DescribeActivityTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeActivityTypeError {
    pub fn new(kind: DescribeActivityTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeActivityTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeActivityTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActivityTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeActivityTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for DescribeActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeActivityTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DescribeActivityTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DescribeActivityTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDomainError {
    pub kind: DescribeDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDomainErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DescribeDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDomainError {
    fn code(&self) -> Option<&str> {
        DescribeDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainError {
    pub fn new(kind: DescribeDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDomainErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(&self.kind, DescribeDomainErrorKind::UnknownResourceFault(_))
    }
}
impl std::error::Error for DescribeDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDomainErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DescribeDomainErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DescribeDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkflowExecutionError {
    pub kind: DescribeWorkflowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkflowExecutionErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DescribeWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DescribeWorkflowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        DescribeWorkflowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkflowExecutionError {
    pub fn new(kind: DescribeWorkflowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkflowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkflowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkflowExecutionErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkflowExecutionErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for DescribeWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DescribeWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DescribeWorkflowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeWorkflowTypeError {
    pub kind: DescribeWorkflowTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeWorkflowTypeErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            DescribeWorkflowTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            DescribeWorkflowTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        DescribeWorkflowTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeWorkflowTypeError {
    pub fn new(kind: DescribeWorkflowTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeWorkflowTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeWorkflowTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkflowTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeWorkflowTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for DescribeWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            DescribeWorkflowTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            DescribeWorkflowTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWorkflowExecutionHistoryError {
    pub kind: GetWorkflowExecutionHistoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWorkflowExecutionHistoryErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWorkflowExecutionHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWorkflowExecutionHistoryErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            GetWorkflowExecutionHistoryErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            GetWorkflowExecutionHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWorkflowExecutionHistoryError {
    fn code(&self) -> Option<&str> {
        GetWorkflowExecutionHistoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWorkflowExecutionHistoryError {
    pub fn new(kind: GetWorkflowExecutionHistoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWorkflowExecutionHistoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWorkflowExecutionHistoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowExecutionHistoryErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            GetWorkflowExecutionHistoryErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for GetWorkflowExecutionHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWorkflowExecutionHistoryErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            GetWorkflowExecutionHistoryErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            GetWorkflowExecutionHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListActivityTypesError {
    pub kind: ListActivityTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListActivityTypesErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListActivityTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListActivityTypesErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            ListActivityTypesErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            ListActivityTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListActivityTypesError {
    fn code(&self) -> Option<&str> {
        ListActivityTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListActivityTypesError {
    pub fn new(kind: ListActivityTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListActivityTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListActivityTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListActivityTypesErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListActivityTypesErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for ListActivityTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListActivityTypesErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            ListActivityTypesErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            ListActivityTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClosedWorkflowExecutionsError {
    pub kind: ListClosedWorkflowExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClosedWorkflowExecutionsErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClosedWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClosedWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            ListClosedWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            ListClosedWorkflowExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListClosedWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        ListClosedWorkflowExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClosedWorkflowExecutionsError {
    pub fn new(kind: ListClosedWorkflowExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClosedWorkflowExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClosedWorkflowExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListClosedWorkflowExecutionsErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListClosedWorkflowExecutionsErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for ListClosedWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClosedWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            ListClosedWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            ListClosedWorkflowExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainsError {
    pub kind: ListDomainsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainsErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainsErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            ListDomainsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDomainsError {
    fn code(&self) -> Option<&str> {
        ListDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainsError {
    pub fn new(kind: ListDomainsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainsErrorKind::OperationNotPermittedFault(_)
        )
    }
}
impl std::error::Error for ListDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainsErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            ListDomainsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOpenWorkflowExecutionsError {
    pub kind: ListOpenWorkflowExecutionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOpenWorkflowExecutionsErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOpenWorkflowExecutionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOpenWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            ListOpenWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            ListOpenWorkflowExecutionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOpenWorkflowExecutionsError {
    fn code(&self) -> Option<&str> {
        ListOpenWorkflowExecutionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOpenWorkflowExecutionsError {
    pub fn new(kind: ListOpenWorkflowExecutionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOpenWorkflowExecutionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOpenWorkflowExecutionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenWorkflowExecutionsErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListOpenWorkflowExecutionsErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for ListOpenWorkflowExecutionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOpenWorkflowExecutionsErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            ListOpenWorkflowExecutionsErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            ListOpenWorkflowExecutionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::LimitExceededFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::LimitExceededFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWorkflowTypesError {
    pub kind: ListWorkflowTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWorkflowTypesErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWorkflowTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWorkflowTypesErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            ListWorkflowTypesErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            ListWorkflowTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWorkflowTypesError {
    fn code(&self) -> Option<&str> {
        ListWorkflowTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWorkflowTypesError {
    pub fn new(kind: ListWorkflowTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWorkflowTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWorkflowTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkflowTypesErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListWorkflowTypesErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for ListWorkflowTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWorkflowTypesErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            ListWorkflowTypesErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            ListWorkflowTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PollForActivityTaskError {
    pub kind: PollForActivityTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PollForActivityTaskErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PollForActivityTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PollForActivityTaskErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            PollForActivityTaskErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            PollForActivityTaskErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            PollForActivityTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PollForActivityTaskError {
    fn code(&self) -> Option<&str> {
        PollForActivityTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PollForActivityTaskError {
    pub fn new(kind: PollForActivityTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PollForActivityTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PollForActivityTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            PollForActivityTaskErrorKind::LimitExceededFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            PollForActivityTaskErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            PollForActivityTaskErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for PollForActivityTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PollForActivityTaskErrorKind::LimitExceededFault(_inner) => Some(_inner),
            PollForActivityTaskErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            PollForActivityTaskErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            PollForActivityTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PollForDecisionTaskError {
    pub kind: PollForDecisionTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PollForDecisionTaskErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PollForDecisionTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PollForDecisionTaskErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            PollForDecisionTaskErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            PollForDecisionTaskErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            PollForDecisionTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PollForDecisionTaskError {
    fn code(&self) -> Option<&str> {
        PollForDecisionTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PollForDecisionTaskError {
    pub fn new(kind: PollForDecisionTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PollForDecisionTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PollForDecisionTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            PollForDecisionTaskErrorKind::LimitExceededFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            PollForDecisionTaskErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            PollForDecisionTaskErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for PollForDecisionTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PollForDecisionTaskErrorKind::LimitExceededFault(_inner) => Some(_inner),
            PollForDecisionTaskErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            PollForDecisionTaskErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            PollForDecisionTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RecordActivityTaskHeartbeatError {
    pub kind: RecordActivityTaskHeartbeatErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RecordActivityTaskHeartbeatErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RecordActivityTaskHeartbeatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RecordActivityTaskHeartbeatErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            RecordActivityTaskHeartbeatErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RecordActivityTaskHeartbeatErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RecordActivityTaskHeartbeatError {
    fn code(&self) -> Option<&str> {
        RecordActivityTaskHeartbeatError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RecordActivityTaskHeartbeatError {
    pub fn new(kind: RecordActivityTaskHeartbeatErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RecordActivityTaskHeartbeatErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RecordActivityTaskHeartbeatErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RecordActivityTaskHeartbeatErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RecordActivityTaskHeartbeatErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RecordActivityTaskHeartbeatError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RecordActivityTaskHeartbeatErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            RecordActivityTaskHeartbeatErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RecordActivityTaskHeartbeatErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterActivityTypeError {
    pub kind: RegisterActivityTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterActivityTypeErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterActivityTypeErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            RegisterActivityTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            RegisterActivityTypeErrorKind::TypeAlreadyExistsFault(_inner) => _inner.fmt(f),
            RegisterActivityTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RegisterActivityTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterActivityTypeError {
    fn code(&self) -> Option<&str> {
        RegisterActivityTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterActivityTypeError {
    pub fn new(kind: RegisterActivityTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterActivityTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterActivityTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterActivityTypeErrorKind::LimitExceededFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterActivityTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterActivityTypeErrorKind::TypeAlreadyExistsFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterActivityTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RegisterActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterActivityTypeErrorKind::LimitExceededFault(_inner) => Some(_inner),
            RegisterActivityTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            RegisterActivityTypeErrorKind::TypeAlreadyExistsFault(_inner) => Some(_inner),
            RegisterActivityTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RegisterActivityTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterDomainError {
    pub kind: RegisterDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterDomainErrorKind {
    DomainAlreadyExistsFault(crate::error::DomainAlreadyExistsFault),
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TooManyTagsFault(crate::error::TooManyTagsFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterDomainErrorKind::DomainAlreadyExistsFault(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::TooManyTagsFault(_inner) => _inner.fmt(f),
            RegisterDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterDomainError {
    fn code(&self) -> Option<&str> {
        RegisterDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterDomainError {
    pub fn new(kind: RegisterDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_domain_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDomainErrorKind::DomainAlreadyExistsFault(_)
        )
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::LimitExceededFault(_))
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterDomainErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_too_many_tags_fault(&self) -> bool {
        matches!(&self.kind, RegisterDomainErrorKind::TooManyTagsFault(_))
    }
}
impl std::error::Error for RegisterDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterDomainErrorKind::DomainAlreadyExistsFault(_inner) => Some(_inner),
            RegisterDomainErrorKind::LimitExceededFault(_inner) => Some(_inner),
            RegisterDomainErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            RegisterDomainErrorKind::TooManyTagsFault(_inner) => Some(_inner),
            RegisterDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterWorkflowTypeError {
    pub kind: RegisterWorkflowTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterWorkflowTypeErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterWorkflowTypeErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            RegisterWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            RegisterWorkflowTypeErrorKind::TypeAlreadyExistsFault(_inner) => _inner.fmt(f),
            RegisterWorkflowTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RegisterWorkflowTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        RegisterWorkflowTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterWorkflowTypeError {
    pub fn new(kind: RegisterWorkflowTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterWorkflowTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterWorkflowTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkflowTypeErrorKind::LimitExceededFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkflowTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkflowTypeErrorKind::TypeAlreadyExistsFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RegisterWorkflowTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RegisterWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterWorkflowTypeErrorKind::LimitExceededFault(_inner) => Some(_inner),
            RegisterWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            RegisterWorkflowTypeErrorKind::TypeAlreadyExistsFault(_inner) => Some(_inner),
            RegisterWorkflowTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RegisterWorkflowTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RequestCancelWorkflowExecutionError {
    pub kind: RequestCancelWorkflowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RequestCancelWorkflowExecutionErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RequestCancelWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RequestCancelWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            RequestCancelWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RequestCancelWorkflowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RequestCancelWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        RequestCancelWorkflowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RequestCancelWorkflowExecutionError {
    pub fn new(kind: RequestCancelWorkflowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RequestCancelWorkflowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RequestCancelWorkflowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RequestCancelWorkflowExecutionErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RequestCancelWorkflowExecutionErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RequestCancelWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RequestCancelWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            RequestCancelWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RequestCancelWorkflowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RespondActivityTaskCanceledError {
    pub kind: RespondActivityTaskCanceledErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondActivityTaskCanceledErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RespondActivityTaskCanceledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RespondActivityTaskCanceledErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            RespondActivityTaskCanceledErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RespondActivityTaskCanceledErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RespondActivityTaskCanceledError {
    fn code(&self) -> Option<&str> {
        RespondActivityTaskCanceledError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondActivityTaskCanceledError {
    pub fn new(kind: RespondActivityTaskCanceledErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RespondActivityTaskCanceledErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RespondActivityTaskCanceledErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondActivityTaskCanceledErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondActivityTaskCanceledErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RespondActivityTaskCanceledError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RespondActivityTaskCanceledErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            RespondActivityTaskCanceledErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RespondActivityTaskCanceledErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RespondActivityTaskCompletedError {
    pub kind: RespondActivityTaskCompletedErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondActivityTaskCompletedErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RespondActivityTaskCompletedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RespondActivityTaskCompletedErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            RespondActivityTaskCompletedErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RespondActivityTaskCompletedErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RespondActivityTaskCompletedError {
    fn code(&self) -> Option<&str> {
        RespondActivityTaskCompletedError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondActivityTaskCompletedError {
    pub fn new(kind: RespondActivityTaskCompletedErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RespondActivityTaskCompletedErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RespondActivityTaskCompletedErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondActivityTaskCompletedErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondActivityTaskCompletedErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RespondActivityTaskCompletedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RespondActivityTaskCompletedErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            RespondActivityTaskCompletedErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RespondActivityTaskCompletedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RespondActivityTaskFailedError {
    pub kind: RespondActivityTaskFailedErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondActivityTaskFailedErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RespondActivityTaskFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RespondActivityTaskFailedErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            RespondActivityTaskFailedErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RespondActivityTaskFailedErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RespondActivityTaskFailedError {
    fn code(&self) -> Option<&str> {
        RespondActivityTaskFailedError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondActivityTaskFailedError {
    pub fn new(kind: RespondActivityTaskFailedErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RespondActivityTaskFailedErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RespondActivityTaskFailedErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondActivityTaskFailedErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondActivityTaskFailedErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RespondActivityTaskFailedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RespondActivityTaskFailedErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            RespondActivityTaskFailedErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RespondActivityTaskFailedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RespondDecisionTaskCompletedError {
    pub kind: RespondDecisionTaskCompletedErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondDecisionTaskCompletedErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RespondDecisionTaskCompletedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RespondDecisionTaskCompletedErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            RespondDecisionTaskCompletedErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            RespondDecisionTaskCompletedErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RespondDecisionTaskCompletedError {
    fn code(&self) -> Option<&str> {
        RespondDecisionTaskCompletedError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondDecisionTaskCompletedError {
    pub fn new(kind: RespondDecisionTaskCompletedErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RespondDecisionTaskCompletedErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RespondDecisionTaskCompletedErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondDecisionTaskCompletedErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            RespondDecisionTaskCompletedErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for RespondDecisionTaskCompletedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RespondDecisionTaskCompletedErrorKind::OperationNotPermittedFault(_inner) => {
                Some(_inner)
            }
            RespondDecisionTaskCompletedErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            RespondDecisionTaskCompletedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignalWorkflowExecutionError {
    pub kind: SignalWorkflowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignalWorkflowExecutionErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignalWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SignalWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            SignalWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            SignalWorkflowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SignalWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        SignalWorkflowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignalWorkflowExecutionError {
    pub fn new(kind: SignalWorkflowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SignalWorkflowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SignalWorkflowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            SignalWorkflowExecutionErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            SignalWorkflowExecutionErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for SignalWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SignalWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            SignalWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            SignalWorkflowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartWorkflowExecutionError {
    pub kind: StartWorkflowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartWorkflowExecutionErrorKind {
    DefaultUndefinedFault(crate::error::DefaultUndefinedFault),
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeDeprecatedFault(crate::error::TypeDeprecatedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    WorkflowExecutionAlreadyStartedFault(crate::error::WorkflowExecutionAlreadyStartedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartWorkflowExecutionErrorKind::DefaultUndefinedFault(_inner) => _inner.fmt(f),
            StartWorkflowExecutionErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            StartWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            StartWorkflowExecutionErrorKind::TypeDeprecatedFault(_inner) => _inner.fmt(f),
            StartWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            StartWorkflowExecutionErrorKind::WorkflowExecutionAlreadyStartedFault(_inner) => {
                _inner.fmt(f)
            }
            StartWorkflowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        StartWorkflowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartWorkflowExecutionError {
    pub fn new(kind: StartWorkflowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartWorkflowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartWorkflowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_default_undefined_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowExecutionErrorKind::DefaultUndefinedFault(_)
        )
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowExecutionErrorKind::LimitExceededFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowExecutionErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_deprecated_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowExecutionErrorKind::TypeDeprecatedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowExecutionErrorKind::UnknownResourceFault(_)
        )
    }
    pub fn is_workflow_execution_already_started_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartWorkflowExecutionErrorKind::WorkflowExecutionAlreadyStartedFault(_)
        )
    }
}
impl std::error::Error for StartWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartWorkflowExecutionErrorKind::DefaultUndefinedFault(_inner) => Some(_inner),
            StartWorkflowExecutionErrorKind::LimitExceededFault(_inner) => Some(_inner),
            StartWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            StartWorkflowExecutionErrorKind::TypeDeprecatedFault(_inner) => Some(_inner),
            StartWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            StartWorkflowExecutionErrorKind::WorkflowExecutionAlreadyStartedFault(_inner) => {
                Some(_inner)
            }
            StartWorkflowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TooManyTagsFault(crate::error::TooManyTagsFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            TagResourceErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsFault(_inner) => _inner.fmt(f),
            TagResourceErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededFault(_))
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_too_many_tags_fault(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsFault(_))
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::UnknownResourceFault(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::LimitExceededFault(_inner) => Some(_inner),
            TagResourceErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsFault(_inner) => Some(_inner),
            TagResourceErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TerminateWorkflowExecutionError {
    pub kind: TerminateWorkflowExecutionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TerminateWorkflowExecutionErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TerminateWorkflowExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TerminateWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => {
                _inner.fmt(f)
            }
            TerminateWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            TerminateWorkflowExecutionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TerminateWorkflowExecutionError {
    fn code(&self) -> Option<&str> {
        TerminateWorkflowExecutionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TerminateWorkflowExecutionError {
    pub fn new(kind: TerminateWorkflowExecutionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TerminateWorkflowExecutionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TerminateWorkflowExecutionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            TerminateWorkflowExecutionErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            TerminateWorkflowExecutionErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for TerminateWorkflowExecutionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TerminateWorkflowExecutionErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            TerminateWorkflowExecutionErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            TerminateWorkflowExecutionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UndeprecateActivityTypeError {
    pub kind: UndeprecateActivityTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UndeprecateActivityTypeErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UndeprecateActivityTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UndeprecateActivityTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            UndeprecateActivityTypeErrorKind::TypeAlreadyExistsFault(_inner) => _inner.fmt(f),
            UndeprecateActivityTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            UndeprecateActivityTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UndeprecateActivityTypeError {
    fn code(&self) -> Option<&str> {
        UndeprecateActivityTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UndeprecateActivityTypeError {
    pub fn new(kind: UndeprecateActivityTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UndeprecateActivityTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UndeprecateActivityTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateActivityTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateActivityTypeErrorKind::TypeAlreadyExistsFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateActivityTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for UndeprecateActivityTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UndeprecateActivityTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            UndeprecateActivityTypeErrorKind::TypeAlreadyExistsFault(_inner) => Some(_inner),
            UndeprecateActivityTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            UndeprecateActivityTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UndeprecateDomainError {
    pub kind: UndeprecateDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UndeprecateDomainErrorKind {
    DomainAlreadyExistsFault(crate::error::DomainAlreadyExistsFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UndeprecateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UndeprecateDomainErrorKind::DomainAlreadyExistsFault(_inner) => _inner.fmt(f),
            UndeprecateDomainErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            UndeprecateDomainErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            UndeprecateDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UndeprecateDomainError {
    fn code(&self) -> Option<&str> {
        UndeprecateDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UndeprecateDomainError {
    pub fn new(kind: UndeprecateDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UndeprecateDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UndeprecateDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_domain_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateDomainErrorKind::DomainAlreadyExistsFault(_)
        )
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateDomainErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateDomainErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for UndeprecateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UndeprecateDomainErrorKind::DomainAlreadyExistsFault(_inner) => Some(_inner),
            UndeprecateDomainErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            UndeprecateDomainErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            UndeprecateDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UndeprecateWorkflowTypeError {
    pub kind: UndeprecateWorkflowTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UndeprecateWorkflowTypeErrorKind {
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    TypeAlreadyExistsFault(crate::error::TypeAlreadyExistsFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UndeprecateWorkflowTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UndeprecateWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            UndeprecateWorkflowTypeErrorKind::TypeAlreadyExistsFault(_inner) => _inner.fmt(f),
            UndeprecateWorkflowTypeErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            UndeprecateWorkflowTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UndeprecateWorkflowTypeError {
    fn code(&self) -> Option<&str> {
        UndeprecateWorkflowTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UndeprecateWorkflowTypeError {
    pub fn new(kind: UndeprecateWorkflowTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UndeprecateWorkflowTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UndeprecateWorkflowTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateWorkflowTypeErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_type_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateWorkflowTypeErrorKind::TypeAlreadyExistsFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(
            &self.kind,
            UndeprecateWorkflowTypeErrorKind::UnknownResourceFault(_)
        )
    }
}
impl std::error::Error for UndeprecateWorkflowTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UndeprecateWorkflowTypeErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            UndeprecateWorkflowTypeErrorKind::TypeAlreadyExistsFault(_inner) => Some(_inner),
            UndeprecateWorkflowTypeErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            UndeprecateWorkflowTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    LimitExceededFault(crate::error::LimitExceededFault),
    OperationNotPermittedFault(crate::error::OperationNotPermittedFault),
    UnknownResourceFault(crate::error::UnknownResourceFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::LimitExceededFault(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::OperationNotPermittedFault(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::UnknownResourceFault(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::LimitExceededFault(_))
    }
    pub fn is_operation_not_permitted_fault(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::OperationNotPermittedFault(_)
        )
    }
    pub fn is_unknown_resource_fault(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::UnknownResourceFault(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::LimitExceededFault(_inner) => Some(_inner),
            UntagResourceErrorKind::OperationNotPermittedFault(_inner) => Some(_inner),
            UntagResourceErrorKind::UnknownResourceFault(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Returned when the named resource cannot be found with in the scope of this operation (region or domain). This could happen if the named resource was never created or is no longer available for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnknownResourceFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnknownResourceFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnknownResourceFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnknownResourceFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnknownResourceFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnknownResourceFault")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnknownResourceFault {}
/// See [`UnknownResourceFault`](crate::error::UnknownResourceFault)
pub mod unknown_resource_fault {
    /// A builder for [`UnknownResourceFault`](crate::error::UnknownResourceFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnknownResourceFault`](crate::error::UnknownResourceFault)
        pub fn build(self) -> crate::error::UnknownResourceFault {
            crate::error::UnknownResourceFault {
                message: self.message,
            }
        }
    }
}
impl UnknownResourceFault {
    /// Creates a new builder-style object to manufacture [`UnknownResourceFault`](crate::error::UnknownResourceFault)
    pub fn builder() -> crate::error::unknown_resource_fault::Builder {
        crate::error::unknown_resource_fault::Builder::default()
    }
}

/// <p>Returned when the caller doesn't have sufficient permissions to invoke the action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationNotPermittedFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationNotPermittedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationNotPermittedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationNotPermittedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationNotPermittedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationNotPermittedFault")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationNotPermittedFault {}
/// See [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault)
pub mod operation_not_permitted_fault {
    /// A builder for [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault)
        pub fn build(self) -> crate::error::OperationNotPermittedFault {
            crate::error::OperationNotPermittedFault {
                message: self.message,
            }
        }
    }
}
impl OperationNotPermittedFault {
    /// Creates a new builder-style object to manufacture [`OperationNotPermittedFault`](crate::error::OperationNotPermittedFault)
    pub fn builder() -> crate::error::operation_not_permitted_fault::Builder {
        crate::error::operation_not_permitted_fault::Builder::default()
    }
}

/// <p>Returned by any operation if a system imposed limitation has been reached. To address this fault you should either clean up unused resources or increase the limit by contacting AWS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededFault")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededFault {}
/// See [`LimitExceededFault`](crate::error::LimitExceededFault)
pub mod limit_exceeded_fault {
    /// A builder for [`LimitExceededFault`](crate::error::LimitExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededFault`](crate::error::LimitExceededFault)
        pub fn build(self) -> crate::error::LimitExceededFault {
            crate::error::LimitExceededFault {
                message: self.message,
            }
        }
    }
}
impl LimitExceededFault {
    /// Creates a new builder-style object to manufacture [`LimitExceededFault`](crate::error::LimitExceededFault)
    pub fn builder() -> crate::error::limit_exceeded_fault::Builder {
        crate::error::limit_exceeded_fault::Builder::default()
    }
}

/// <p>Returned if the type already exists in the specified domain. You may get this fault if you are registering a type that is either already registered or deprecated, or if you undeprecate a type that is currently registered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TypeAlreadyExistsFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TypeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TypeAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TypeAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TypeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TypeAlreadyExistsFault")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for TypeAlreadyExistsFault {}
/// See [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault)
pub mod type_already_exists_fault {
    /// A builder for [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault)
        pub fn build(self) -> crate::error::TypeAlreadyExistsFault {
            crate::error::TypeAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl TypeAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`TypeAlreadyExistsFault`](crate::error::TypeAlreadyExistsFault)
    pub fn builder() -> crate::error::type_already_exists_fault::Builder {
        crate::error::type_already_exists_fault::Builder::default()
    }
}

/// <p>Returned if the domain already exists. You may get this fault if you are registering a domain that is either already registered or deprecated, or if you undeprecate a domain that is currently registered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainAlreadyExistsFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DomainAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainAlreadyExistsFault")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for DomainAlreadyExistsFault {}
/// See [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault)
pub mod domain_already_exists_fault {
    /// A builder for [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault)
        pub fn build(self) -> crate::error::DomainAlreadyExistsFault {
            crate::error::DomainAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl DomainAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DomainAlreadyExistsFault`](crate::error::DomainAlreadyExistsFault)
    pub fn builder() -> crate::error::domain_already_exists_fault::Builder {
        crate::error::domain_already_exists_fault::Builder::default()
    }
}

/// <p>You've exceeded the number of tags allowed for a domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsFault")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsFault {}
/// See [`TooManyTagsFault`](crate::error::TooManyTagsFault)
pub mod too_many_tags_fault {
    /// A builder for [`TooManyTagsFault`](crate::error::TooManyTagsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsFault`](crate::error::TooManyTagsFault)
        pub fn build(self) -> crate::error::TooManyTagsFault {
            crate::error::TooManyTagsFault {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsFault {
    /// Creates a new builder-style object to manufacture [`TooManyTagsFault`](crate::error::TooManyTagsFault)
    pub fn builder() -> crate::error::too_many_tags_fault::Builder {
        crate::error::too_many_tags_fault::Builder::default()
    }
}

/// <p>Returned by <a>StartWorkflowExecution</a> when an open execution with the same workflowId is already running in
/// the specified domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkflowExecutionAlreadyStartedFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WorkflowExecutionAlreadyStartedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkflowExecutionAlreadyStartedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl WorkflowExecutionAlreadyStartedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for WorkflowExecutionAlreadyStartedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WorkflowExecutionAlreadyStartedFault")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for WorkflowExecutionAlreadyStartedFault {}
/// See [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault)
pub mod workflow_execution_already_started_fault {
    /// A builder for [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault)
        pub fn build(self) -> crate::error::WorkflowExecutionAlreadyStartedFault {
            crate::error::WorkflowExecutionAlreadyStartedFault {
                message: self.message,
            }
        }
    }
}
impl WorkflowExecutionAlreadyStartedFault {
    /// Creates a new builder-style object to manufacture [`WorkflowExecutionAlreadyStartedFault`](crate::error::WorkflowExecutionAlreadyStartedFault)
    pub fn builder() -> crate::error::workflow_execution_already_started_fault::Builder {
        crate::error::workflow_execution_already_started_fault::Builder::default()
    }
}

/// <p>Returned when the specified activity or workflow type was already deprecated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TypeDeprecatedFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TypeDeprecatedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TypeDeprecatedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TypeDeprecatedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TypeDeprecatedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TypeDeprecatedFault")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for TypeDeprecatedFault {}
/// See [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault)
pub mod type_deprecated_fault {
    /// A builder for [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault)
        pub fn build(self) -> crate::error::TypeDeprecatedFault {
            crate::error::TypeDeprecatedFault {
                message: self.message,
            }
        }
    }
}
impl TypeDeprecatedFault {
    /// Creates a new builder-style object to manufacture [`TypeDeprecatedFault`](crate::error::TypeDeprecatedFault)
    pub fn builder() -> crate::error::type_deprecated_fault::Builder {
        crate::error::type_deprecated_fault::Builder::default()
    }
}

/// <p>The <code>StartWorkflowExecution</code> API action was called without the required
/// parameters set.</p>
/// <p>Some workflow execution parameters, such as the decision <code>taskList</code>, must be
/// set to start the execution. However, these parameters might have been set as defaults when the
/// workflow type was registered. In this case, you can omit these parameters from the
/// <code>StartWorkflowExecution</code> call and Amazon SWF uses the values defined in the workflow
/// type.</p>
/// <note>
/// <p>If these parameters aren't set and no default parameters were defined in the workflow
/// type, this error is displayed.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultUndefinedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultUndefinedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultUndefinedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DefaultUndefinedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultUndefinedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultUndefinedFault")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for DefaultUndefinedFault {}
/// See [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault)
pub mod default_undefined_fault {
    /// A builder for [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault)
        pub fn build(self) -> crate::error::DefaultUndefinedFault {
            crate::error::DefaultUndefinedFault {
                message: self.message,
            }
        }
    }
}
impl DefaultUndefinedFault {
    /// Creates a new builder-style object to manufacture [`DefaultUndefinedFault`](crate::error::DefaultUndefinedFault)
    pub fn builder() -> crate::error::default_undefined_fault::Builder {
        crate::error::default_undefined_fault::Builder::default()
    }
}

/// <p>Returned when the specified domain has been deprecated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DomainDeprecatedFault {
    /// <p>A description that may help with diagnosing the cause of the fault.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DomainDeprecatedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DomainDeprecatedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DomainDeprecatedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainDeprecatedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainDeprecatedFault")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for DomainDeprecatedFault {}
/// See [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault)
pub mod domain_deprecated_fault {
    /// A builder for [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A description that may help with diagnosing the cause of the fault.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault)
        pub fn build(self) -> crate::error::DomainDeprecatedFault {
            crate::error::DomainDeprecatedFault {
                message: self.message,
            }
        }
    }
}
impl DomainDeprecatedFault {
    /// Creates a new builder-style object to manufacture [`DomainDeprecatedFault`](crate::error::DomainDeprecatedFault)
    pub fn builder() -> crate::error::domain_deprecated_fault::Builder {
        crate::error::domain_deprecated_fault::Builder::default()
    }
}
