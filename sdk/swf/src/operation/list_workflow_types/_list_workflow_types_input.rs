// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListWorkflowTypesInput {
    /// <p>The name of the domain in which the workflow types have been registered.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p>If specified, lists the workflow type with this name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the registration status of the workflow types to list.</p>
    #[doc(hidden)]
    pub registration_status: std::option::Option<crate::types::RegistrationStatus>,
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    #[doc(hidden)]
    pub maximum_page_size: i32,
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in ascending alphabetical order of the <code>name</code> of the workflow types.</p>
    #[doc(hidden)]
    pub reverse_order: bool,
}
impl ListWorkflowTypesInput {
    /// <p>The name of the domain in which the workflow types have been registered.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>If specified, lists the workflow type with this name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the registration status of the workflow types to list.</p>
    pub fn registration_status(&self) -> std::option::Option<&crate::types::RegistrationStatus> {
        self.registration_status.as_ref()
    }
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    pub fn maximum_page_size(&self) -> i32 {
        self.maximum_page_size
    }
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in ascending alphabetical order of the <code>name</code> of the workflow types.</p>
    pub fn reverse_order(&self) -> bool {
        self.reverse_order
    }
}
impl ListWorkflowTypesInput {
    /// Creates a new builder-style object to manufacture [`ListWorkflowTypesInput`](crate::operation::list_workflow_types::ListWorkflowTypesInput).
    pub fn builder(
    ) -> crate::operation::list_workflow_types::builders::ListWorkflowTypesInputBuilder {
        crate::operation::list_workflow_types::builders::ListWorkflowTypesInputBuilder::default()
    }
}

/// A builder for [`ListWorkflowTypesInput`](crate::operation::list_workflow_types::ListWorkflowTypesInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ListWorkflowTypesInputBuilder {
    pub(crate) domain: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) registration_status: std::option::Option<crate::types::RegistrationStatus>,
    pub(crate) next_page_token: std::option::Option<std::string::String>,
    pub(crate) maximum_page_size: std::option::Option<i32>,
    pub(crate) reverse_order: std::option::Option<bool>,
}
impl ListWorkflowTypesInputBuilder {
    /// <p>The name of the domain in which the workflow types have been registered.</p>
    pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
        self.domain = Some(input.into());
        self
    }
    /// <p>The name of the domain in which the workflow types have been registered.</p>
    pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.domain = input;
        self
    }
    /// <p>If specified, lists the workflow type with this name.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>If specified, lists the workflow type with this name.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>Specifies the registration status of the workflow types to list.</p>
    pub fn registration_status(mut self, input: crate::types::RegistrationStatus) -> Self {
        self.registration_status = Some(input);
        self
    }
    /// <p>Specifies the registration status of the workflow types to list.</p>
    pub fn set_registration_status(
        mut self,
        input: std::option::Option<crate::types::RegistrationStatus>,
    ) -> Self {
        self.registration_status = input;
        self
    }
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.next_page_token = Some(input.into());
        self
    }
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p>
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    pub fn set_next_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.next_page_token = input;
        self
    }
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    pub fn maximum_page_size(mut self, input: i32) -> Self {
        self.maximum_page_size = Some(input);
        self
    }
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
        self.maximum_page_size = input;
        self
    }
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in ascending alphabetical order of the <code>name</code> of the workflow types.</p>
    pub fn reverse_order(mut self, input: bool) -> Self {
        self.reverse_order = Some(input);
        self
    }
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default the results are returned in ascending alphabetical order of the <code>name</code> of the workflow types.</p>
    pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
        self.reverse_order = input;
        self
    }
    /// Consumes the builder and constructs a [`ListWorkflowTypesInput`](crate::operation::list_workflow_types::ListWorkflowTypesInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::list_workflow_types::ListWorkflowTypesInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::list_workflow_types::ListWorkflowTypesInput {
                domain: self.domain,
                name: self.name,
                registration_status: self.registration_status,
                next_page_token: self.next_page_token,
                maximum_page_size: self.maximum_page_size.unwrap_or_default(),
                reverse_order: self.reverse_order.unwrap_or_default(),
            },
        )
    }
}
