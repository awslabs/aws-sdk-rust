// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Input data for a TaskCompleted response to a decision task.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RespondDecisionTaskCompletedInput {
    /// <p>The <code>taskToken</code> from the <code>DecisionTask</code>.</p><important>
    /// <p><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</p>
    /// </important>
    pub task_token: ::std::option::Option<::std::string::String>,
    /// <p>The list of decisions (possibly empty) made by the decider while processing this decision task. See the docs for the <code>Decision</code> structure for details.</p>
    pub decisions: ::std::option::Option<::std::vec::Vec<crate::types::Decision>>,
    /// <p>User defined context to add to workflow execution.</p>
    pub execution_context: ::std::option::Option<::std::string::String>,
    /// <p>The task list to use for the future decision tasks of this workflow execution. This list overrides the original task list you specified while starting the workflow execution.</p>
    pub task_list: ::std::option::Option<crate::types::TaskList>,
    /// <p>Specifies a timeout (in seconds) for the task list override. When this parameter is missing, the task list override is permanent. This parameter makes it possible to temporarily override the task list. If a decision task scheduled on the override task list is not started within the timeout, the decision task will time out. Amazon SWF will revert the override and schedule a new decision task to the original task list.</p>
    /// <p>If a decision task scheduled on the override task list is started within the timeout, but not completed within the start-to-close timeout, Amazon SWF will also revert the override and schedule a new decision task to the original task list.</p>
    pub task_list_schedule_to_start_timeout: ::std::option::Option<::std::string::String>,
}
impl RespondDecisionTaskCompletedInput {
    /// <p>The <code>taskToken</code> from the <code>DecisionTask</code>.</p><important>
    /// <p><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</p>
    /// </important>
    pub fn task_token(&self) -> ::std::option::Option<&str> {
        self.task_token.as_deref()
    }
    /// <p>The list of decisions (possibly empty) made by the decider while processing this decision task. See the docs for the <code>Decision</code> structure for details.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.decisions.is_none()`.
    pub fn decisions(&self) -> &[crate::types::Decision] {
        self.decisions.as_deref().unwrap_or_default()
    }
    /// <p>User defined context to add to workflow execution.</p>
    pub fn execution_context(&self) -> ::std::option::Option<&str> {
        self.execution_context.as_deref()
    }
    /// <p>The task list to use for the future decision tasks of this workflow execution. This list overrides the original task list you specified while starting the workflow execution.</p>
    pub fn task_list(&self) -> ::std::option::Option<&crate::types::TaskList> {
        self.task_list.as_ref()
    }
    /// <p>Specifies a timeout (in seconds) for the task list override. When this parameter is missing, the task list override is permanent. This parameter makes it possible to temporarily override the task list. If a decision task scheduled on the override task list is not started within the timeout, the decision task will time out. Amazon SWF will revert the override and schedule a new decision task to the original task list.</p>
    /// <p>If a decision task scheduled on the override task list is started within the timeout, but not completed within the start-to-close timeout, Amazon SWF will also revert the override and schedule a new decision task to the original task list.</p>
    pub fn task_list_schedule_to_start_timeout(&self) -> ::std::option::Option<&str> {
        self.task_list_schedule_to_start_timeout.as_deref()
    }
}
impl RespondDecisionTaskCompletedInput {
    /// Creates a new builder-style object to manufacture [`RespondDecisionTaskCompletedInput`](crate::operation::respond_decision_task_completed::RespondDecisionTaskCompletedInput).
    pub fn builder() -> crate::operation::respond_decision_task_completed::builders::RespondDecisionTaskCompletedInputBuilder {
        crate::operation::respond_decision_task_completed::builders::RespondDecisionTaskCompletedInputBuilder::default()
    }
}

/// A builder for [`RespondDecisionTaskCompletedInput`](crate::operation::respond_decision_task_completed::RespondDecisionTaskCompletedInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct RespondDecisionTaskCompletedInputBuilder {
    pub(crate) task_token: ::std::option::Option<::std::string::String>,
    pub(crate) decisions: ::std::option::Option<::std::vec::Vec<crate::types::Decision>>,
    pub(crate) execution_context: ::std::option::Option<::std::string::String>,
    pub(crate) task_list: ::std::option::Option<crate::types::TaskList>,
    pub(crate) task_list_schedule_to_start_timeout: ::std::option::Option<::std::string::String>,
}
impl RespondDecisionTaskCompletedInputBuilder {
    /// <p>The <code>taskToken</code> from the <code>DecisionTask</code>.</p><important>
    /// <p><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</p>
    /// </important>
    /// This field is required.
    pub fn task_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.task_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>taskToken</code> from the <code>DecisionTask</code>.</p><important>
    /// <p><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</p>
    /// </important>
    pub fn set_task_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.task_token = input;
        self
    }
    /// <p>The <code>taskToken</code> from the <code>DecisionTask</code>.</p><important>
    /// <p><code>taskToken</code> is generated by the service and should be treated as an opaque value. If the task is passed to another process, its <code>taskToken</code> must also be passed. This enables it to provide its progress and respond with results.</p>
    /// </important>
    pub fn get_task_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.task_token
    }
    /// Appends an item to `decisions`.
    ///
    /// To override the contents of this collection use [`set_decisions`](Self::set_decisions).
    ///
    /// <p>The list of decisions (possibly empty) made by the decider while processing this decision task. See the docs for the <code>Decision</code> structure for details.</p>
    pub fn decisions(mut self, input: crate::types::Decision) -> Self {
        let mut v = self.decisions.unwrap_or_default();
        v.push(input);
        self.decisions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of decisions (possibly empty) made by the decider while processing this decision task. See the docs for the <code>Decision</code> structure for details.</p>
    pub fn set_decisions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Decision>>) -> Self {
        self.decisions = input;
        self
    }
    /// <p>The list of decisions (possibly empty) made by the decider while processing this decision task. See the docs for the <code>Decision</code> structure for details.</p>
    pub fn get_decisions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Decision>> {
        &self.decisions
    }
    /// <p>User defined context to add to workflow execution.</p>
    pub fn execution_context(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.execution_context = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User defined context to add to workflow execution.</p>
    pub fn set_execution_context(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.execution_context = input;
        self
    }
    /// <p>User defined context to add to workflow execution.</p>
    pub fn get_execution_context(&self) -> &::std::option::Option<::std::string::String> {
        &self.execution_context
    }
    /// <p>The task list to use for the future decision tasks of this workflow execution. This list overrides the original task list you specified while starting the workflow execution.</p>
    pub fn task_list(mut self, input: crate::types::TaskList) -> Self {
        self.task_list = ::std::option::Option::Some(input);
        self
    }
    /// <p>The task list to use for the future decision tasks of this workflow execution. This list overrides the original task list you specified while starting the workflow execution.</p>
    pub fn set_task_list(mut self, input: ::std::option::Option<crate::types::TaskList>) -> Self {
        self.task_list = input;
        self
    }
    /// <p>The task list to use for the future decision tasks of this workflow execution. This list overrides the original task list you specified while starting the workflow execution.</p>
    pub fn get_task_list(&self) -> &::std::option::Option<crate::types::TaskList> {
        &self.task_list
    }
    /// <p>Specifies a timeout (in seconds) for the task list override. When this parameter is missing, the task list override is permanent. This parameter makes it possible to temporarily override the task list. If a decision task scheduled on the override task list is not started within the timeout, the decision task will time out. Amazon SWF will revert the override and schedule a new decision task to the original task list.</p>
    /// <p>If a decision task scheduled on the override task list is started within the timeout, but not completed within the start-to-close timeout, Amazon SWF will also revert the override and schedule a new decision task to the original task list.</p>
    pub fn task_list_schedule_to_start_timeout(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.task_list_schedule_to_start_timeout = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies a timeout (in seconds) for the task list override. When this parameter is missing, the task list override is permanent. This parameter makes it possible to temporarily override the task list. If a decision task scheduled on the override task list is not started within the timeout, the decision task will time out. Amazon SWF will revert the override and schedule a new decision task to the original task list.</p>
    /// <p>If a decision task scheduled on the override task list is started within the timeout, but not completed within the start-to-close timeout, Amazon SWF will also revert the override and schedule a new decision task to the original task list.</p>
    pub fn set_task_list_schedule_to_start_timeout(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.task_list_schedule_to_start_timeout = input;
        self
    }
    /// <p>Specifies a timeout (in seconds) for the task list override. When this parameter is missing, the task list override is permanent. This parameter makes it possible to temporarily override the task list. If a decision task scheduled on the override task list is not started within the timeout, the decision task will time out. Amazon SWF will revert the override and schedule a new decision task to the original task list.</p>
    /// <p>If a decision task scheduled on the override task list is started within the timeout, but not completed within the start-to-close timeout, Amazon SWF will also revert the override and schedule a new decision task to the original task list.</p>
    pub fn get_task_list_schedule_to_start_timeout(&self) -> &::std::option::Option<::std::string::String> {
        &self.task_list_schedule_to_start_timeout
    }
    /// Consumes the builder and constructs a [`RespondDecisionTaskCompletedInput`](crate::operation::respond_decision_task_completed::RespondDecisionTaskCompletedInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::respond_decision_task_completed::RespondDecisionTaskCompletedInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::respond_decision_task_completed::RespondDecisionTaskCompletedInput {
            task_token: self.task_token,
            decisions: self.decisions,
            execution_context: self.execution_context,
            task_list: self.task_list,
            task_list_schedule_to_start_timeout: self.task_list_schedule_to_start_timeout,
        })
    }
}
