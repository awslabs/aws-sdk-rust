// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListActivityTypesInput  {
    /// <p>The name of the domain in which the activity types have been registered.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p>If specified, only lists the activity types that have this name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the registration status of the activity types to list.</p>
    #[doc(hidden)]
    pub registration_status: std::option::Option<crate::types::RegistrationStatus>,
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p> 
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    #[doc(hidden)]
    pub maximum_page_size: i32,
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the results are returned in ascending alphabetical order by <code>name</code> of the activity types.</p>
    #[doc(hidden)]
    pub reverse_order: bool,
}
impl ListActivityTypesInput {
    /// <p>The name of the domain in which the activity types have been registered.</p>
    pub fn domain(&self) -> std::option::Option<& str> {
        self.domain.as_deref()
    }
    /// <p>If specified, only lists the activity types that have this name.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Specifies the registration status of the activity types to list.</p>
    pub fn registration_status(&self) -> std::option::Option<& crate::types::RegistrationStatus> {
        self.registration_status.as_ref()
    }
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p> 
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    pub fn next_page_token(&self) -> std::option::Option<& str> {
        self.next_page_token.as_deref()
    }
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    pub fn maximum_page_size(&self) -> i32 {
        self.maximum_page_size
    }
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the results are returned in ascending alphabetical order by <code>name</code> of the activity types.</p>
    pub fn reverse_order(&self) -> bool {
        self.reverse_order
    }
}
impl ListActivityTypesInput {
    /// Creates a new builder-style object to manufacture [`ListActivityTypesInput`](crate::operation::list_activity_types::ListActivityTypesInput).
    pub fn builder() -> crate::operation::list_activity_types::builders::ListActivityTypesInputBuilder {
        crate::operation::list_activity_types::builders::ListActivityTypesInputBuilder::default()
    }
}

/// A builder for [`ListActivityTypesInput`](crate::operation::list_activity_types::ListActivityTypesInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ListActivityTypesInputBuilder {
    pub(crate) domain: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) registration_status: std::option::Option<crate::types::RegistrationStatus>,
    pub(crate) next_page_token: std::option::Option<std::string::String>,
    pub(crate) maximum_page_size: std::option::Option<i32>,
    pub(crate) reverse_order: std::option::Option<bool>,
}
impl ListActivityTypesInputBuilder {
    /// <p>The name of the domain in which the activity types have been registered.</p>
    pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
        self.domain = Some(input.into());
        self
    }
    /// <p>The name of the domain in which the activity types have been registered.</p>
    pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.domain = input; self
    }
    /// <p>If specified, only lists the activity types that have this name.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>If specified, only lists the activity types that have this name.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input; self
    }
    /// <p>Specifies the registration status of the activity types to list.</p>
    pub fn registration_status(mut self, input: crate::types::RegistrationStatus) -> Self {
        self.registration_status = Some(input);
        self
    }
    /// <p>Specifies the registration status of the activity types to list.</p>
    pub fn set_registration_status(mut self, input: std::option::Option<crate::types::RegistrationStatus>) -> Self {
        self.registration_status = input; self
    }
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p> 
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.next_page_token = Some(input.into());
        self
    }
    /// <p>If <code>NextPageToken</code> is returned there are more results available. The value of <code>NextPageToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 60 seconds. Using an expired pagination token will return a <code>400</code> error: "<code>Specified token has exceeded its maximum lifetime</code>". </p> 
    /// <p>The configured <code>maximumPageSize</code> determines how many results can be returned in a single call. </p>
    pub fn set_next_page_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.next_page_token = input; self
    }
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    pub fn maximum_page_size(mut self, input: i32) -> Self {
        self.maximum_page_size = Some(input);
        self
    }
    /// <p>The maximum number of results that are returned per call. Use <code>nextPageToken</code> to obtain further pages of results. </p>
    pub fn set_maximum_page_size(mut self, input: std::option::Option<i32>) -> Self {
        self.maximum_page_size = input; self
    }
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the results are returned in ascending alphabetical order by <code>name</code> of the activity types.</p>
    pub fn reverse_order(mut self, input: bool) -> Self {
        self.reverse_order = Some(input);
        self
    }
    /// <p>When set to <code>true</code>, returns the results in reverse order. By default, the results are returned in ascending alphabetical order by <code>name</code> of the activity types.</p>
    pub fn set_reverse_order(mut self, input: std::option::Option<bool>) -> Self {
        self.reverse_order = input; self
    }
    /// Consumes the builder and constructs a [`ListActivityTypesInput`](crate::operation::list_activity_types::ListActivityTypesInput).
    pub fn build(self) -> Result<crate::operation::list_activity_types::ListActivityTypesInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::list_activity_types::ListActivityTypesInput {
                domain: self.domain
                ,
                name: self.name
                ,
                registration_status: self.registration_status
                ,
                next_page_token: self.next_page_token
                ,
                maximum_page_size: self.maximum_page_size
                    .unwrap_or_default()
                ,
                reverse_order: self.reverse_order
                    .unwrap_or_default()
                ,
            }
        )
    }
}

