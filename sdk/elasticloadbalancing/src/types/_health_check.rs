// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a health check.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HealthCheck {
    /// <p>The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.</p>
    /// <p>TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy.</p>
    /// <p>SSL is also specified as SSL: port pair, for example, SSL:5000.</p>
    /// <p>For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy.</p>
    /// <p>The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.</p>
    pub target: ::std::string::String,
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub interval: i32,
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    /// <p>This value must be less than the <code>Interval</code> value.</p>
    pub timeout: i32,
    /// <p>The number of consecutive health check failures required before moving the instance to the <code>Unhealthy</code> state.</p>
    pub unhealthy_threshold: i32,
    /// <p>The number of consecutive health checks successes required before moving the instance to the <code>Healthy</code> state.</p>
    pub healthy_threshold: i32,
}
impl HealthCheck {
    /// <p>The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.</p>
    /// <p>TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy.</p>
    /// <p>SSL is also specified as SSL: port pair, for example, SSL:5000.</p>
    /// <p>For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy.</p>
    /// <p>The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.</p>
    pub fn target(&self) -> &str {
        use std::ops::Deref;
        self.target.deref()
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn interval(&self) -> i32 {
        self.interval
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    /// <p>This value must be less than the <code>Interval</code> value.</p>
    pub fn timeout(&self) -> i32 {
        self.timeout
    }
    /// <p>The number of consecutive health check failures required before moving the instance to the <code>Unhealthy</code> state.</p>
    pub fn unhealthy_threshold(&self) -> i32 {
        self.unhealthy_threshold
    }
    /// <p>The number of consecutive health checks successes required before moving the instance to the <code>Healthy</code> state.</p>
    pub fn healthy_threshold(&self) -> i32 {
        self.healthy_threshold
    }
}
impl HealthCheck {
    /// Creates a new builder-style object to manufacture [`HealthCheck`](crate::types::HealthCheck).
    pub fn builder() -> crate::types::builders::HealthCheckBuilder {
        crate::types::builders::HealthCheckBuilder::default()
    }
}

/// A builder for [`HealthCheck`](crate::types::HealthCheck).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct HealthCheckBuilder {
    pub(crate) target: ::std::option::Option<::std::string::String>,
    pub(crate) interval: ::std::option::Option<i32>,
    pub(crate) timeout: ::std::option::Option<i32>,
    pub(crate) unhealthy_threshold: ::std::option::Option<i32>,
    pub(crate) healthy_threshold: ::std::option::Option<i32>,
}
impl HealthCheckBuilder {
    /// <p>The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.</p>
    /// <p>TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy.</p>
    /// <p>SSL is also specified as SSL: port pair, for example, SSL:5000.</p>
    /// <p>For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy.</p>
    /// <p>The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.</p>
    /// This field is required.
    pub fn target(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.target = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.</p>
    /// <p>TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy.</p>
    /// <p>SSL is also specified as SSL: port pair, for example, SSL:5000.</p>
    /// <p>For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy.</p>
    /// <p>The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.</p>
    pub fn set_target(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.target = input;
        self
    }
    /// <p>The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535.</p>
    /// <p>TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy.</p>
    /// <p>SSL is also specified as SSL: port pair, for example, SSL:5000.</p>
    /// <p>For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy.</p>
    /// <p>The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.</p>
    pub fn get_target(&self) -> &::std::option::Option<::std::string::String> {
        &self.target
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    /// This field is required.
    pub fn interval(mut self, input: i32) -> Self {
        self.interval = ::std::option::Option::Some(input);
        self
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn set_interval(mut self, input: ::std::option::Option<i32>) -> Self {
        self.interval = input;
        self
    }
    /// <p>The approximate interval, in seconds, between health checks of an individual instance.</p>
    pub fn get_interval(&self) -> &::std::option::Option<i32> {
        &self.interval
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    /// <p>This value must be less than the <code>Interval</code> value.</p>
    /// This field is required.
    pub fn timeout(mut self, input: i32) -> Self {
        self.timeout = ::std::option::Option::Some(input);
        self
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    /// <p>This value must be less than the <code>Interval</code> value.</p>
    pub fn set_timeout(mut self, input: ::std::option::Option<i32>) -> Self {
        self.timeout = input;
        self
    }
    /// <p>The amount of time, in seconds, during which no response means a failed health check.</p>
    /// <p>This value must be less than the <code>Interval</code> value.</p>
    pub fn get_timeout(&self) -> &::std::option::Option<i32> {
        &self.timeout
    }
    /// <p>The number of consecutive health check failures required before moving the instance to the <code>Unhealthy</code> state.</p>
    /// This field is required.
    pub fn unhealthy_threshold(mut self, input: i32) -> Self {
        self.unhealthy_threshold = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of consecutive health check failures required before moving the instance to the <code>Unhealthy</code> state.</p>
    pub fn set_unhealthy_threshold(mut self, input: ::std::option::Option<i32>) -> Self {
        self.unhealthy_threshold = input;
        self
    }
    /// <p>The number of consecutive health check failures required before moving the instance to the <code>Unhealthy</code> state.</p>
    pub fn get_unhealthy_threshold(&self) -> &::std::option::Option<i32> {
        &self.unhealthy_threshold
    }
    /// <p>The number of consecutive health checks successes required before moving the instance to the <code>Healthy</code> state.</p>
    /// This field is required.
    pub fn healthy_threshold(mut self, input: i32) -> Self {
        self.healthy_threshold = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of consecutive health checks successes required before moving the instance to the <code>Healthy</code> state.</p>
    pub fn set_healthy_threshold(mut self, input: ::std::option::Option<i32>) -> Self {
        self.healthy_threshold = input;
        self
    }
    /// <p>The number of consecutive health checks successes required before moving the instance to the <code>Healthy</code> state.</p>
    pub fn get_healthy_threshold(&self) -> &::std::option::Option<i32> {
        &self.healthy_threshold
    }
    /// Consumes the builder and constructs a [`HealthCheck`](crate::types::HealthCheck).
    /// This method will fail if any of the following fields are not set:
    /// - [`target`](crate::types::builders::HealthCheckBuilder::target)
    /// - [`interval`](crate::types::builders::HealthCheckBuilder::interval)
    /// - [`timeout`](crate::types::builders::HealthCheckBuilder::timeout)
    /// - [`unhealthy_threshold`](crate::types::builders::HealthCheckBuilder::unhealthy_threshold)
    /// - [`healthy_threshold`](crate::types::builders::HealthCheckBuilder::healthy_threshold)
    pub fn build(self) -> ::std::result::Result<crate::types::HealthCheck, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::HealthCheck {
            target: self.target.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "target",
                    "target was not specified but it is required when building HealthCheck",
                )
            })?,
            interval: self.interval.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "interval",
                    "interval was not specified but it is required when building HealthCheck",
                )
            })?,
            timeout: self.timeout.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "timeout",
                    "timeout was not specified but it is required when building HealthCheck",
                )
            })?,
            unhealthy_threshold: self.unhealthy_threshold.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "unhealthy_threshold",
                    "unhealthy_threshold was not specified but it is required when building HealthCheck",
                )
            })?,
            healthy_threshold: self.healthy_threshold.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "healthy_threshold",
                    "healthy_threshold was not specified but it is required when building HealthCheck",
                )
            })?,
        })
    }
}
