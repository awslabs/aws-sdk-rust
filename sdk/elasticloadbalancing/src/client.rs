// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `ElasticLoadBalancing_v7`.
///
/// This client allows ergonomic access to a `ElasticLoadBalancing_v7`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn add_tags(&self) -> fluent_builders::AddTags<C, M, R> {
        fluent_builders::AddTags::new(self.handle.clone())
    }
    pub fn apply_security_groups_to_load_balancer(
        &self,
    ) -> fluent_builders::ApplySecurityGroupsToLoadBalancer<C, M, R> {
        fluent_builders::ApplySecurityGroupsToLoadBalancer::new(self.handle.clone())
    }
    pub fn attach_load_balancer_to_subnets(
        &self,
    ) -> fluent_builders::AttachLoadBalancerToSubnets<C, M, R> {
        fluent_builders::AttachLoadBalancerToSubnets::new(self.handle.clone())
    }
    pub fn configure_health_check(&self) -> fluent_builders::ConfigureHealthCheck<C, M, R> {
        fluent_builders::ConfigureHealthCheck::new(self.handle.clone())
    }
    pub fn create_app_cookie_stickiness_policy(
        &self,
    ) -> fluent_builders::CreateAppCookieStickinessPolicy<C, M, R> {
        fluent_builders::CreateAppCookieStickinessPolicy::new(self.handle.clone())
    }
    pub fn create_lb_cookie_stickiness_policy(
        &self,
    ) -> fluent_builders::CreateLBCookieStickinessPolicy<C, M, R> {
        fluent_builders::CreateLBCookieStickinessPolicy::new(self.handle.clone())
    }
    pub fn create_load_balancer(&self) -> fluent_builders::CreateLoadBalancer<C, M, R> {
        fluent_builders::CreateLoadBalancer::new(self.handle.clone())
    }
    pub fn create_load_balancer_listeners(
        &self,
    ) -> fluent_builders::CreateLoadBalancerListeners<C, M, R> {
        fluent_builders::CreateLoadBalancerListeners::new(self.handle.clone())
    }
    pub fn create_load_balancer_policy(
        &self,
    ) -> fluent_builders::CreateLoadBalancerPolicy<C, M, R> {
        fluent_builders::CreateLoadBalancerPolicy::new(self.handle.clone())
    }
    pub fn delete_load_balancer(&self) -> fluent_builders::DeleteLoadBalancer<C, M, R> {
        fluent_builders::DeleteLoadBalancer::new(self.handle.clone())
    }
    pub fn delete_load_balancer_listeners(
        &self,
    ) -> fluent_builders::DeleteLoadBalancerListeners<C, M, R> {
        fluent_builders::DeleteLoadBalancerListeners::new(self.handle.clone())
    }
    pub fn delete_load_balancer_policy(
        &self,
    ) -> fluent_builders::DeleteLoadBalancerPolicy<C, M, R> {
        fluent_builders::DeleteLoadBalancerPolicy::new(self.handle.clone())
    }
    pub fn deregister_instances_from_load_balancer(
        &self,
    ) -> fluent_builders::DeregisterInstancesFromLoadBalancer<C, M, R> {
        fluent_builders::DeregisterInstancesFromLoadBalancer::new(self.handle.clone())
    }
    pub fn describe_account_limits(&self) -> fluent_builders::DescribeAccountLimits<C, M, R> {
        fluent_builders::DescribeAccountLimits::new(self.handle.clone())
    }
    pub fn describe_instance_health(&self) -> fluent_builders::DescribeInstanceHealth<C, M, R> {
        fluent_builders::DescribeInstanceHealth::new(self.handle.clone())
    }
    pub fn describe_load_balancer_attributes(
        &self,
    ) -> fluent_builders::DescribeLoadBalancerAttributes<C, M, R> {
        fluent_builders::DescribeLoadBalancerAttributes::new(self.handle.clone())
    }
    pub fn describe_load_balancer_policies(
        &self,
    ) -> fluent_builders::DescribeLoadBalancerPolicies<C, M, R> {
        fluent_builders::DescribeLoadBalancerPolicies::new(self.handle.clone())
    }
    pub fn describe_load_balancer_policy_types(
        &self,
    ) -> fluent_builders::DescribeLoadBalancerPolicyTypes<C, M, R> {
        fluent_builders::DescribeLoadBalancerPolicyTypes::new(self.handle.clone())
    }
    pub fn describe_load_balancers(&self) -> fluent_builders::DescribeLoadBalancers<C, M, R> {
        fluent_builders::DescribeLoadBalancers::new(self.handle.clone())
    }
    pub fn describe_tags(&self) -> fluent_builders::DescribeTags<C, M, R> {
        fluent_builders::DescribeTags::new(self.handle.clone())
    }
    pub fn detach_load_balancer_from_subnets(
        &self,
    ) -> fluent_builders::DetachLoadBalancerFromSubnets<C, M, R> {
        fluent_builders::DetachLoadBalancerFromSubnets::new(self.handle.clone())
    }
    pub fn disable_availability_zones_for_load_balancer(
        &self,
    ) -> fluent_builders::DisableAvailabilityZonesForLoadBalancer<C, M, R> {
        fluent_builders::DisableAvailabilityZonesForLoadBalancer::new(self.handle.clone())
    }
    pub fn enable_availability_zones_for_load_balancer(
        &self,
    ) -> fluent_builders::EnableAvailabilityZonesForLoadBalancer<C, M, R> {
        fluent_builders::EnableAvailabilityZonesForLoadBalancer::new(self.handle.clone())
    }
    pub fn modify_load_balancer_attributes(
        &self,
    ) -> fluent_builders::ModifyLoadBalancerAttributes<C, M, R> {
        fluent_builders::ModifyLoadBalancerAttributes::new(self.handle.clone())
    }
    pub fn register_instances_with_load_balancer(
        &self,
    ) -> fluent_builders::RegisterInstancesWithLoadBalancer<C, M, R> {
        fluent_builders::RegisterInstancesWithLoadBalancer::new(self.handle.clone())
    }
    pub fn remove_tags(&self) -> fluent_builders::RemoveTags<C, M, R> {
        fluent_builders::RemoveTags::new(self.handle.clone())
    }
    pub fn set_load_balancer_listener_ssl_certificate(
        &self,
    ) -> fluent_builders::SetLoadBalancerListenerSSLCertificate<C, M, R> {
        fluent_builders::SetLoadBalancerListenerSSLCertificate::new(self.handle.clone())
    }
    pub fn set_load_balancer_policies_for_backend_server(
        &self,
    ) -> fluent_builders::SetLoadBalancerPoliciesForBackendServer<C, M, R> {
        fluent_builders::SetLoadBalancerPoliciesForBackendServer::new(self.handle.clone())
    }
    pub fn set_load_balancer_policies_of_listener(
        &self,
    ) -> fluent_builders::SetLoadBalancerPoliciesOfListener<C, M, R> {
        fluent_builders::SetLoadBalancerPoliciesOfListener::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_tags_input::Builder,
    }
    impl<C, M, R> AddTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsOutput,
            smithy_http::result::SdkError<crate::error::AddTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddTagsInputOperationOutputAlias,
                crate::output::AddTagsOutput,
                crate::error::AddTagsError,
                crate::input::AddTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `LoadBalancerNames`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_names`](Self::set_load_balancer_names).
        /// <p>The name of the load balancer. You can specify one load balancer only.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ApplySecurityGroupsToLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::apply_security_groups_to_load_balancer_input::Builder,
    }
    impl<C, M, R> ApplySecurityGroupsToLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ApplySecurityGroupsToLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::ApplySecurityGroupsToLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ApplySecurityGroupsToLoadBalancerInputOperationOutputAlias,
                crate::output::ApplySecurityGroupsToLoadBalancerOutput,
                crate::error::ApplySecurityGroupsToLoadBalancerError,
                crate::input::ApplySecurityGroupsToLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `SecurityGroups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        /// <p>The IDs of the security groups to associate with the load balancer. Note that you cannot specify the name of the security group.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachLoadBalancerToSubnets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::attach_load_balancer_to_subnets_input::Builder,
    }
    impl<C, M, R> AttachLoadBalancerToSubnets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachLoadBalancerToSubnetsOutput,
            smithy_http::result::SdkError<crate::error::AttachLoadBalancerToSubnetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AttachLoadBalancerToSubnetsInputOperationOutputAlias,
                crate::output::AttachLoadBalancerToSubnetsOutput,
                crate::error::AttachLoadBalancerToSubnetsError,
                crate::input::AttachLoadBalancerToSubnetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        /// <p>The IDs of the subnets to add. You can add only one subnet per Availability Zone.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ConfigureHealthCheck<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::configure_health_check_input::Builder,
    }
    impl<C, M, R> ConfigureHealthCheck<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ConfigureHealthCheckOutput,
            smithy_http::result::SdkError<crate::error::ConfigureHealthCheckError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ConfigureHealthCheckInputOperationOutputAlias,
                crate::output::ConfigureHealthCheckOutput,
                crate::error::ConfigureHealthCheckError,
                crate::input::ConfigureHealthCheckInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The configuration information.</p>
        pub fn health_check(mut self, inp: crate::model::HealthCheck) -> Self {
            self.inner = self.inner.health_check(inp);
            self
        }
        pub fn set_health_check(
            mut self,
            input: std::option::Option<crate::model::HealthCheck>,
        ) -> Self {
            self.inner = self.inner.set_health_check(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAppCookieStickinessPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_app_cookie_stickiness_policy_input::Builder,
    }
    impl<C, M, R> CreateAppCookieStickinessPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAppCookieStickinessPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateAppCookieStickinessPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateAppCookieStickinessPolicyInputOperationOutputAlias,
                crate::output::CreateAppCookieStickinessPolicyOutput,
                crate::error::CreateAppCookieStickinessPolicyError,
                crate::input::CreateAppCookieStickinessPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The name of the application cookie used for stickiness.</p>
        pub fn cookie_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cookie_name(inp);
            self
        }
        pub fn set_cookie_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cookie_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLBCookieStickinessPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_lb_cookie_stickiness_policy_input::Builder,
    }
    impl<C, M, R> CreateLBCookieStickinessPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLbCookieStickinessPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateLBCookieStickinessPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLbCookieStickinessPolicyInputOperationOutputAlias,
                crate::output::CreateLbCookieStickinessPolicyOutput,
                crate::error::CreateLBCookieStickinessPolicyError,
                crate::input::CreateLbCookieStickinessPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The time period, in seconds, after which the cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.</p>
        pub fn cookie_expiration_period(mut self, inp: i64) -> Self {
            self.inner = self.inner.cookie_expiration_period(inp);
            self
        }
        pub fn set_cookie_expiration_period(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_cookie_expiration_period(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_load_balancer_input::Builder,
    }
    impl<C, M, R> CreateLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLoadBalancerInputOperationOutputAlias,
                crate::output::CreateLoadBalancerOutput,
                crate::error::CreateLoadBalancerError,
                crate::input::CreateLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        /// <p>This name must be unique within your set of load balancers for the region, must have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and cannot begin or end with a hyphen.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Listeners`.
        ///
        /// To override the contents of this collection use [`set_listeners`](Self::set_listeners).
        /// <p>The listeners.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html">Listeners for Your Classic Load Balancer</a>
        /// in the <i>Classic Load Balancers Guide</i>.</p>
        pub fn listeners(mut self, inp: impl Into<crate::model::Listener>) -> Self {
            self.inner = self.inner.listeners(inp);
            self
        }
        pub fn set_listeners(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Listener>>,
        ) -> Self {
            self.inner = self.inner.set_listeners(input);
            self
        }
        /// Appends an item to `AvailabilityZones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        /// <p>One or more Availability Zones from the same region as the load balancer.</p>
        /// <p>You must specify at least one Availability Zone.</p>
        /// <p>You can add more Availability Zones after you create the load balancer using
        /// <a>EnableAvailabilityZonesForLoadBalancer</a>.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// Appends an item to `Subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        /// <p>The IDs of the subnets in your VPC to attach to the load balancer.
        /// Specify one subnet per Availability Zone specified in <code>AvailabilityZones</code>.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// Appends an item to `SecurityGroups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        /// <p>The IDs of the security groups to assign to the load balancer.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
        /// <p>The type of a load balancer. Valid only for load balancers in a VPC.</p>          
        /// <p>By default, Elastic Load Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP addresses.
        /// For more information about Internet-facing and Internal load balancers, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#load-balancer-scheme">Load Balancer Scheme</a>
        /// in the <i>Elastic Load Balancing User Guide</i>.</p>
        /// <p>Specify <code>internal</code> to create a load balancer with a DNS name that resolves to private IP addresses.</p>
        pub fn scheme(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheme(inp);
            self
        }
        pub fn set_scheme(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_scheme(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A list of tags to assign to the load balancer.</p>
        /// <p>For more information about tagging your load balancer, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/add-remove-tags.html">Tag Your Classic Load Balancer</a>
        /// in the <i>Classic Load Balancers Guide</i>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancerListeners<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_load_balancer_listeners_input::Builder,
    }
    impl<C, M, R> CreateLoadBalancerListeners<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerListenersOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerListenersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLoadBalancerListenersInputOperationOutputAlias,
                crate::output::CreateLoadBalancerListenersOutput,
                crate::error::CreateLoadBalancerListenersError,
                crate::input::CreateLoadBalancerListenersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Listeners`.
        ///
        /// To override the contents of this collection use [`set_listeners`](Self::set_listeners).
        /// <p>The listeners.</p>
        pub fn listeners(mut self, inp: impl Into<crate::model::Listener>) -> Self {
            self.inner = self.inner.listeners(inp);
            self
        }
        pub fn set_listeners(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Listener>>,
        ) -> Self {
            self.inner = self.inner.set_listeners(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancerPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_load_balancer_policy_input::Builder,
    }
    impl<C, M, R> CreateLoadBalancerPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerPolicyOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLoadBalancerPolicyInputOperationOutputAlias,
                crate::output::CreateLoadBalancerPolicyOutput,
                crate::error::CreateLoadBalancerPolicyError,
                crate::input::CreateLoadBalancerPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The name of the load balancer policy to be created. This name must be unique within the set of policies for this load balancer.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The name of the base policy type.
        /// To get the list of policy types, use <a>DescribeLoadBalancerPolicyTypes</a>.</p>
        pub fn policy_type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_type_name(inp);
            self
        }
        pub fn set_policy_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_type_name(input);
            self
        }
        /// Appends an item to `PolicyAttributes`.
        ///
        /// To override the contents of this collection use [`set_policy_attributes`](Self::set_policy_attributes).
        /// <p>The policy attributes.</p>
        pub fn policy_attributes(mut self, inp: impl Into<crate::model::PolicyAttribute>) -> Self {
            self.inner = self.inner.policy_attributes(inp);
            self
        }
        pub fn set_policy_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PolicyAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_policy_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_load_balancer_input::Builder,
    }
    impl<C, M, R> DeleteLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLoadBalancerInputOperationOutputAlias,
                crate::output::DeleteLoadBalancerOutput,
                crate::error::DeleteLoadBalancerError,
                crate::input::DeleteLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancerListeners<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_load_balancer_listeners_input::Builder,
    }
    impl<C, M, R> DeleteLoadBalancerListeners<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerListenersOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerListenersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLoadBalancerListenersInputOperationOutputAlias,
                crate::output::DeleteLoadBalancerListenersOutput,
                crate::error::DeleteLoadBalancerListenersError,
                crate::input::DeleteLoadBalancerListenersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `LoadBalancerPorts`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_ports`](Self::set_load_balancer_ports).
        /// <p>The client port numbers of the listeners.</p>
        pub fn load_balancer_ports(mut self, inp: impl Into<i32>) -> Self {
            self.inner = self.inner.load_balancer_ports(inp);
            self
        }
        pub fn set_load_balancer_ports(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_ports(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancerPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_load_balancer_policy_input::Builder,
    }
    impl<C, M, R> DeleteLoadBalancerPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLoadBalancerPolicyInputOperationOutputAlias,
                crate::output::DeleteLoadBalancerPolicyOutput,
                crate::error::DeleteLoadBalancerPolicyError,
                crate::input::DeleteLoadBalancerPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterInstancesFromLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deregister_instances_from_load_balancer_input::Builder,
    }
    impl<C, M, R> DeregisterInstancesFromLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterInstancesFromLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::DeregisterInstancesFromLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeregisterInstancesFromLoadBalancerInputOperationOutputAlias,
                crate::output::DeregisterInstancesFromLoadBalancerOutput,
                crate::error::DeregisterInstancesFromLoadBalancerError,
                crate::input::DeregisterInstancesFromLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Instances`.
        ///
        /// To override the contents of this collection use [`set_instances`](Self::set_instances).
        /// <p>The IDs of the instances.</p>
        pub fn instances(mut self, inp: impl Into<crate::model::Instance>) -> Self {
            self.inner = self.inner.instances(inp);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        ) -> Self {
            self.inner = self.inner.set_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountLimits<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_account_limits_input::Builder,
    }
    impl<C, M, R> DescribeAccountLimits<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountLimitsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAccountLimitsInputOperationOutputAlias,
                crate::output::DescribeAccountLimitsOutput,
                crate::error::DescribeAccountLimitsError,
                crate::input::DescribeAccountLimitsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceHealth<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_instance_health_input::Builder,
    }
    impl<C, M, R> DescribeInstanceHealth<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceHealthOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceHealthError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeInstanceHealthInputOperationOutputAlias,
                crate::output::DescribeInstanceHealthOutput,
                crate::error::DescribeInstanceHealthError,
                crate::input::DescribeInstanceHealthInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Instances`.
        ///
        /// To override the contents of this collection use [`set_instances`](Self::set_instances).
        /// <p>The IDs of the instances.</p>
        pub fn instances(mut self, inp: impl Into<crate::model::Instance>) -> Self {
            self.inner = self.inner.instances(inp);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        ) -> Self {
            self.inner = self.inner.set_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancerAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_load_balancer_attributes_input::Builder,
    }
    impl<C, M, R> DescribeLoadBalancerAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancerAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancerAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLoadBalancerAttributesInputOperationOutputAlias,
                crate::output::DescribeLoadBalancerAttributesOutput,
                crate::error::DescribeLoadBalancerAttributesError,
                crate::input::DescribeLoadBalancerAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancerPolicies<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_load_balancer_policies_input::Builder,
    }
    impl<C, M, R> DescribeLoadBalancerPolicies<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancerPoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancerPoliciesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLoadBalancerPoliciesInputOperationOutputAlias,
                crate::output::DescribeLoadBalancerPoliciesOutput,
                crate::error::DescribeLoadBalancerPoliciesError,
                crate::input::DescribeLoadBalancerPoliciesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `PolicyNames`.
        ///
        /// To override the contents of this collection use [`set_policy_names`](Self::set_policy_names).
        /// <p>The names of the policies.</p>
        pub fn policy_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names(inp);
            self
        }
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancerPolicyTypes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_load_balancer_policy_types_input::Builder,
    }
    impl<C, M, R> DescribeLoadBalancerPolicyTypes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancerPolicyTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancerPolicyTypesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLoadBalancerPolicyTypesInputOperationOutputAlias,
                crate::output::DescribeLoadBalancerPolicyTypesOutput,
                crate::error::DescribeLoadBalancerPolicyTypesError,
                crate::input::DescribeLoadBalancerPolicyTypesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `PolicyTypeNames`.
        ///
        /// To override the contents of this collection use [`set_policy_type_names`](Self::set_policy_type_names).
        /// <p>The names of the policy types. If no names are specified, describes all policy types defined by Elastic Load Balancing.</p>
        pub fn policy_type_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_type_names(inp);
            self
        }
        pub fn set_policy_type_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_type_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_load_balancers_input::Builder,
    }
    impl<C, M, R> DescribeLoadBalancers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLoadBalancersInputOperationOutputAlias,
                crate::output::DescribeLoadBalancersOutput,
                crate::error::DescribeLoadBalancersError,
                crate::input::DescribeLoadBalancersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `LoadBalancerNames`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_names`](Self::set_load_balancer_names).
        /// <p>The names of the load balancers.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call (a number from 1 to 400). The default is 400.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_tags_input::Builder,
    }
    impl<C, M, R> DescribeTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTagsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTagsInputOperationOutputAlias,
                crate::output::DescribeTagsOutput,
                crate::error::DescribeTagsError,
                crate::input::DescribeTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `LoadBalancerNames`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_names`](Self::set_load_balancer_names).
        /// <p>The names of the load balancers.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachLoadBalancerFromSubnets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::detach_load_balancer_from_subnets_input::Builder,
    }
    impl<C, M, R> DetachLoadBalancerFromSubnets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachLoadBalancerFromSubnetsOutput,
            smithy_http::result::SdkError<crate::error::DetachLoadBalancerFromSubnetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DetachLoadBalancerFromSubnetsInputOperationOutputAlias,
                crate::output::DetachLoadBalancerFromSubnetsOutput,
                crate::error::DetachLoadBalancerFromSubnetsError,
                crate::input::DetachLoadBalancerFromSubnetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        /// <p>The IDs of the subnets.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableAvailabilityZonesForLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disable_availability_zones_for_load_balancer_input::Builder,
    }
    impl<C, M, R> DisableAvailabilityZonesForLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableAvailabilityZonesForLoadBalancerOutput,
            smithy_http::result::SdkError<
                crate::error::DisableAvailabilityZonesForLoadBalancerError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisableAvailabilityZonesForLoadBalancerInputOperationOutputAlias,
                crate::output::DisableAvailabilityZonesForLoadBalancerOutput,
                crate::error::DisableAvailabilityZonesForLoadBalancerError,
                crate::input::DisableAvailabilityZonesForLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `AvailabilityZones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        /// <p>The Availability Zones.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableAvailabilityZonesForLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::enable_availability_zones_for_load_balancer_input::Builder,
    }
    impl<C, M, R> EnableAvailabilityZonesForLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableAvailabilityZonesForLoadBalancerOutput,
            smithy_http::result::SdkError<
                crate::error::EnableAvailabilityZonesForLoadBalancerError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::EnableAvailabilityZonesForLoadBalancerInputOperationOutputAlias,
                crate::output::EnableAvailabilityZonesForLoadBalancerOutput,
                crate::error::EnableAvailabilityZonesForLoadBalancerError,
                crate::input::EnableAvailabilityZonesForLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `AvailabilityZones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        /// <p>The Availability Zones. These must be in the same region as the load balancer.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyLoadBalancerAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::modify_load_balancer_attributes_input::Builder,
    }
    impl<C, M, R> ModifyLoadBalancerAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyLoadBalancerAttributesOutput,
            smithy_http::result::SdkError<crate::error::ModifyLoadBalancerAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ModifyLoadBalancerAttributesInputOperationOutputAlias,
                crate::output::ModifyLoadBalancerAttributesOutput,
                crate::error::ModifyLoadBalancerAttributesError,
                crate::input::ModifyLoadBalancerAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The attributes for the load balancer.</p>
        pub fn load_balancer_attributes(
            mut self,
            inp: crate::model::LoadBalancerAttributes,
        ) -> Self {
            self.inner = self.inner.load_balancer_attributes(inp);
            self
        }
        pub fn set_load_balancer_attributes(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerAttributes>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterInstancesWithLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_instances_with_load_balancer_input::Builder,
    }
    impl<C, M, R> RegisterInstancesWithLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterInstancesWithLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::RegisterInstancesWithLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterInstancesWithLoadBalancerInputOperationOutputAlias,
                crate::output::RegisterInstancesWithLoadBalancerOutput,
                crate::error::RegisterInstancesWithLoadBalancerError,
                crate::input::RegisterInstancesWithLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// Appends an item to `Instances`.
        ///
        /// To override the contents of this collection use [`set_instances`](Self::set_instances).
        /// <p>The IDs of the instances.</p>
        pub fn instances(mut self, inp: impl Into<crate::model::Instance>) -> Self {
            self.inner = self.inner.instances(inp);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        ) -> Self {
            self.inner = self.inner.set_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_tags_input::Builder,
    }
    impl<C, M, R> RemoveTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveTagsInputOperationOutputAlias,
                crate::output::RemoveTagsOutput,
                crate::error::RemoveTagsError,
                crate::input::RemoveTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `LoadBalancerNames`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_names`](Self::set_load_balancer_names).
        /// <p>The name of the load balancer. You can specify a maximum of one load balancer name.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The list of tag keys to remove.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::TagKeyOnly>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagKeyOnly>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetLoadBalancerListenerSSLCertificate<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_load_balancer_listener_ssl_certificate_input::Builder,
    }
    impl<C, M, R> SetLoadBalancerListenerSSLCertificate<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetLoadBalancerListenerSslCertificateOutput,
            smithy_http::result::SdkError<crate::error::SetLoadBalancerListenerSSLCertificateError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetLoadBalancerListenerSslCertificateInputOperationOutputAlias,
                crate::output::SetLoadBalancerListenerSslCertificateOutput,
                crate::error::SetLoadBalancerListenerSSLCertificateError,
                crate::input::SetLoadBalancerListenerSslCertificateInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The port that uses the specified SSL certificate.</p>
        pub fn load_balancer_port(mut self, inp: i32) -> Self {
            self.inner = self.inner.load_balancer_port(inp);
            self
        }
        pub fn set_load_balancer_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_load_balancer_port(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the SSL certificate.</p>
        pub fn ssl_certificate_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssl_certificate_id(inp);
            self
        }
        pub fn set_ssl_certificate_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssl_certificate_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetLoadBalancerPoliciesForBackendServer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_load_balancer_policies_for_backend_server_input::Builder,
    }
    impl<C, M, R> SetLoadBalancerPoliciesForBackendServer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetLoadBalancerPoliciesForBackendServerOutput,
            smithy_http::result::SdkError<
                crate::error::SetLoadBalancerPoliciesForBackendServerError,
            >,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetLoadBalancerPoliciesForBackendServerInputOperationOutputAlias,
                crate::output::SetLoadBalancerPoliciesForBackendServerOutput,
                crate::error::SetLoadBalancerPoliciesForBackendServerError,
                crate::input::SetLoadBalancerPoliciesForBackendServerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The port number associated with the EC2 instance.</p>
        pub fn instance_port(mut self, inp: i32) -> Self {
            self.inner = self.inner.instance_port(inp);
            self
        }
        pub fn set_instance_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_port(input);
            self
        }
        /// Appends an item to `PolicyNames`.
        ///
        /// To override the contents of this collection use [`set_policy_names`](Self::set_policy_names).
        /// <p>The names of the policies. If the list is empty, then all current polices are removed from the EC2 instance.</p>
        pub fn policy_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names(inp);
            self
        }
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetLoadBalancerPoliciesOfListener<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_load_balancer_policies_of_listener_input::Builder,
    }
    impl<C, M, R> SetLoadBalancerPoliciesOfListener<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetLoadBalancerPoliciesOfListenerOutput,
            smithy_http::result::SdkError<crate::error::SetLoadBalancerPoliciesOfListenerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetLoadBalancerPoliciesOfListenerInputOperationOutputAlias,
                crate::output::SetLoadBalancerPoliciesOfListenerOutput,
                crate::error::SetLoadBalancerPoliciesOfListenerError,
                crate::input::SetLoadBalancerPoliciesOfListenerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_name(inp);
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_name(input);
            self
        }
        /// <p>The external port of the load balancer.</p>
        pub fn load_balancer_port(mut self, inp: i32) -> Self {
            self.inner = self.inner.load_balancer_port(inp);
            self
        }
        pub fn set_load_balancer_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_load_balancer_port(input);
            self
        }
        /// Appends an item to `PolicyNames`.
        ///
        /// To override the contents of this collection use [`set_policy_names`](Self::set_policy_names).
        /// <p>The names of the policies. This list must include all policies to be enabled. If you omit a policy that is currently enabled, it is disabled. If the list is empty, all current policies are disabled.</p>
        pub fn policy_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names(inp);
            self
        }
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
