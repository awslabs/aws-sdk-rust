// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl CreateLoadBalancerInput {
    /// Consumes the builder and constructs an Operation<[`CreateLoadBalancer`](crate::operation::create_load_balancer::CreateLoadBalancer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::create_load_balancer::CreateLoadBalancer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::create_load_balancer::CreateLoadBalancerInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_load_balancer::CreateLoadBalancerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-www-form-urlencoded",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_load_balancer_input::ser_create_load_balancer_input_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::create_load_balancer::CreateLoadBalancer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLoadBalancer",
            "elasticloadbalancing",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `CreateLoadBalancer`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateLoadBalancer;
impl CreateLoadBalancer {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateLoadBalancer {
    type Output = std::result::Result<
        crate::operation::create_load_balancer::CreateLoadBalancerOutput,
        crate::operation::create_load_balancer::CreateLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_create_load_balancer::de_create_load_balancer_http_error(
                response,
            )
        } else {
            crate::protocol_serde::shape_create_load_balancer::de_create_load_balancer_http_response(
                response,
            )
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateLoadBalancerErrorKind = CreateLoadBalancerError;
/// Error type for the `CreateLoadBalancerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLoadBalancerError {
    /// <p>The specified ARN does not refer to a valid SSL certificate in AWS Identity and Access Management (IAM) or AWS Certificate Manager (ACM). Note that if you recently uploaded the certificate to IAM, this error might indicate that the certificate is not fully available yet.</p>
    CertificateNotFoundException(crate::types::error::CertificateNotFoundException),
    /// <p>The specified load balancer name already exists for this account.</p>
    DuplicateAccessPointNameException(crate::types::error::DuplicateAccessPointNameException),
    /// <p>A tag key was specified more than once.</p>
    DuplicateTagKeysException(crate::types::error::DuplicateTagKeysException),
    /// <p>The requested configuration change is not valid.</p>
    InvalidConfigurationRequestException(crate::types::error::InvalidConfigurationRequestException),
    /// <p>The specified value for the schema is not valid. You can only specify a scheme for load balancers in a VPC.</p>
    InvalidSchemeException(crate::types::error::InvalidSchemeException),
    /// <p>One or more of the specified security groups do not exist.</p>
    InvalidSecurityGroupException(crate::types::error::InvalidSecurityGroupException),
    /// <p>The specified VPC has no associated Internet gateway.</p>
    InvalidSubnetException(crate::types::error::InvalidSubnetException),
    /// <p>This operation is not allowed.</p>
    OperationNotPermittedException(crate::types::error::OperationNotPermittedException),
    /// <p>One or more of the specified subnets do not exist.</p>
    SubnetNotFoundException(crate::types::error::SubnetNotFoundException),
    /// <p>The quota for the number of load balancers has been reached.</p>
    TooManyAccessPointsException(crate::types::error::TooManyAccessPointsException),
    /// <p>The quota for the number of tags that can be assigned to a load balancer has been reached.</p>
    TooManyTagsException(crate::types::error::TooManyTagsException),
    /// <p>The specified protocol or signature version is not supported.</p>
    UnsupportedProtocolException(crate::types::error::UnsupportedProtocolException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateLoadBalancerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateLoadBalancerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CertificateNotFoundException(_inner) => _inner.fmt(f),
            Self::DuplicateAccessPointNameException(_inner) => _inner.fmt(f),
            Self::DuplicateTagKeysException(_inner) => _inner.fmt(f),
            Self::InvalidConfigurationRequestException(_inner) => _inner.fmt(f),
            Self::InvalidSchemeException(_inner) => _inner.fmt(f),
            Self::InvalidSecurityGroupException(_inner) => _inner.fmt(f),
            Self::InvalidSubnetException(_inner) => _inner.fmt(f),
            Self::OperationNotPermittedException(_inner) => _inner.fmt(f),
            Self::SubnetNotFoundException(_inner) => _inner.fmt(f),
            Self::TooManyAccessPointsException(_inner) => _inner.fmt(f),
            Self::TooManyTagsException(_inner) => _inner.fmt(f),
            Self::UnsupportedProtocolException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateLoadBalancerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CertificateNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DuplicateAccessPointNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DuplicateTagKeysException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConfigurationRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSchemeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSecurityGroupException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnetException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OperationNotPermittedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyAccessPointsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTagsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedProtocolException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::create_load_balancer::CreateLoadBalancerError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateLoadBalancerError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLoadBalancerError {
    /// Creates the `CreateLoadBalancerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateLoadBalancerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CertificateNotFoundException(e) => e.meta(),
            Self::DuplicateAccessPointNameException(e) => e.meta(),
            Self::DuplicateTagKeysException(e) => e.meta(),
            Self::InvalidConfigurationRequestException(e) => e.meta(),
            Self::InvalidSchemeException(e) => e.meta(),
            Self::InvalidSecurityGroupException(e) => e.meta(),
            Self::InvalidSubnetException(e) => e.meta(),
            Self::OperationNotPermittedException(e) => e.meta(),
            Self::SubnetNotFoundException(e) => e.meta(),
            Self::TooManyAccessPointsException(e) => e.meta(),
            Self::TooManyTagsException(e) => e.meta(),
            Self::UnsupportedProtocolException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::CertificateNotFoundException`.
    pub fn is_certificate_not_found_exception(&self) -> bool {
        matches!(self, Self::CertificateNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::DuplicateAccessPointNameException`.
    pub fn is_duplicate_access_point_name_exception(&self) -> bool {
        matches!(self, Self::DuplicateAccessPointNameException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::DuplicateTagKeysException`.
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(self, Self::DuplicateTagKeysException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::InvalidConfigurationRequestException`.
    pub fn is_invalid_configuration_request_exception(&self) -> bool {
        matches!(self, Self::InvalidConfigurationRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::InvalidSchemeException`.
    pub fn is_invalid_scheme_exception(&self) -> bool {
        matches!(self, Self::InvalidSchemeException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::InvalidSecurityGroupException`.
    pub fn is_invalid_security_group_exception(&self) -> bool {
        matches!(self, Self::InvalidSecurityGroupException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::InvalidSubnetException`.
    pub fn is_invalid_subnet_exception(&self) -> bool {
        matches!(self, Self::InvalidSubnetException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::OperationNotPermittedException`.
    pub fn is_operation_not_permitted_exception(&self) -> bool {
        matches!(self, Self::OperationNotPermittedException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::SubnetNotFoundException`.
    pub fn is_subnet_not_found_exception(&self) -> bool {
        matches!(self, Self::SubnetNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::TooManyAccessPointsException`.
    pub fn is_too_many_access_points_exception(&self) -> bool {
        matches!(self, Self::TooManyAccessPointsException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(self, Self::TooManyTagsException(_))
    }
    /// Returns `true` if the error kind is `CreateLoadBalancerError::UnsupportedProtocolException`.
    pub fn is_unsupported_protocol_exception(&self) -> bool {
        matches!(self, Self::UnsupportedProtocolException(_))
    }
}
impl std::error::Error for CreateLoadBalancerError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CertificateNotFoundException(_inner) => Some(_inner),
            Self::DuplicateAccessPointNameException(_inner) => Some(_inner),
            Self::DuplicateTagKeysException(_inner) => Some(_inner),
            Self::InvalidConfigurationRequestException(_inner) => Some(_inner),
            Self::InvalidSchemeException(_inner) => Some(_inner),
            Self::InvalidSecurityGroupException(_inner) => Some(_inner),
            Self::InvalidSubnetException(_inner) => Some(_inner),
            Self::OperationNotPermittedException(_inner) => Some(_inner),
            Self::SubnetNotFoundException(_inner) => Some(_inner),
            Self::TooManyAccessPointsException(_inner) => Some(_inner),
            Self::TooManyTagsException(_inner) => Some(_inner),
            Self::UnsupportedProtocolException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::create_load_balancer::_create_load_balancer_output::CreateLoadBalancerOutput;

pub use crate::operation::create_load_balancer::_create_load_balancer_input::CreateLoadBalancerInput;

mod _create_load_balancer_input;

mod _create_load_balancer_output;

/// Builders
pub mod builders;
