// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::delete_load_balancer::_delete_load_balancer_output::DeleteLoadBalancerOutputBuilder;

pub use crate::operation::delete_load_balancer::_delete_load_balancer_input::DeleteLoadBalancerInputBuilder;

impl DeleteLoadBalancerInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::delete_load_balancer::DeleteLoadBalancerOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_load_balancer::DeleteLoadBalancerError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.delete_load_balancer();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `DeleteLoadBalancer`.
///
/// <p>Deletes the specified load balancer.</p>
/// <p>If you are attempting to recreate a load balancer, you must reconfigure all settings. The DNS name associated with a deleted load balancer are no longer usable. The name and associated DNS record of the deleted load balancer no longer exist and traffic sent to any of its IP addresses is no longer delivered to your instances.</p>
/// <p>If the load balancer does not exist or has already been deleted, the call to <code>DeleteLoadBalancer</code> still succeeds.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct DeleteLoadBalancerFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::delete_load_balancer::builders::DeleteLoadBalancerInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::delete_load_balancer::DeleteLoadBalancerOutput,
        crate::operation::delete_load_balancer::DeleteLoadBalancerError,
    > for DeleteLoadBalancerFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::delete_load_balancer::DeleteLoadBalancerOutput,
            crate::operation::delete_load_balancer::DeleteLoadBalancerError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl DeleteLoadBalancerFluentBuilder {
    /// Creates a new `DeleteLoadBalancer`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the DeleteLoadBalancer as a reference.
    pub fn as_input(&self) -> &crate::operation::delete_load_balancer::builders::DeleteLoadBalancerInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::delete_load_balancer::DeleteLoadBalancerOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_load_balancer::DeleteLoadBalancerError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::delete_load_balancer::DeleteLoadBalancer::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::delete_load_balancer::DeleteLoadBalancer::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::delete_load_balancer::DeleteLoadBalancerOutput,
        crate::operation::delete_load_balancer::DeleteLoadBalancerError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.load_balancer_name(input.into());
        self
    }
    /// <p>The name of the load balancer.</p>
    pub fn set_load_balancer_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_load_balancer_name(input);
        self
    }
    /// <p>The name of the load balancer.</p>
    pub fn get_load_balancer_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_load_balancer_name()
    }
}
