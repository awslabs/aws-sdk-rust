// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The request was rejected because it attempted to create a resource that already exists.</p>
    AlreadyExistsException(crate::error::AlreadyExistsException),
    /// <p>The request was rejected because the specified CloudHSM cluster is already associated with an CloudHSM key store in the account, or it shares a backup history with an CloudHSM key store in the account. Each CloudHSM key store in the account must be associated with a different CloudHSM cluster.</p>
    /// <p>CloudHSM clusters that share a backup history have the same cluster certificate. To view the cluster certificate of an CloudHSM cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
    CloudHsmClusterInUseException(crate::error::CloudHsmClusterInUseException),
    /// <p>The request was rejected because the associated CloudHSM cluster did not meet the configuration requirements for an CloudHSM key store.</p>
    /// <ul>
    /// <li> <p>The CloudHSM cluster must be configured with private subnets in at least two different Availability Zones in the Region.</p> </li>
    /// <li> <p>The <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">security group for the cluster</a> (cloudhsm-cluster-<i>
    /// <cluster-id></cluster-id></i>-sg) must include inbound rules and outbound rules that allow TCP traffic on ports 2223-2225. The <b>Source</b> in the inbound rules and the <b>Destination</b> in the outbound rules must match the security group ID. These rules are set by default when you create the CloudHSM cluster. Do not delete or change them. To get information about a particular security group, use the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html">DescribeSecurityGroups</a> operation.</p> </li>
    /// <li> <p>The CloudHSM cluster must contain at least as many HSMs as the operation requires. To add HSMs, use the CloudHSM <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_CreateHsm.html">CreateHsm</a> operation.</p> <p>For the <code>CreateCustomKeyStore</code>, <code>UpdateCustomKeyStore</code>, and <code>CreateKey</code> operations, the CloudHSM cluster must have at least two active HSMs, each in a different Availability Zone. For the <code>ConnectCustomKeyStore</code> operation, the CloudHSM must contain at least one active HSM.</p> </li>
    /// </ul>
    /// <p>For information about the requirements for an CloudHSM cluster that is associated with an CloudHSM key store, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">Assemble the Prerequisites</a> in the <i>Key Management Service Developer Guide</i>. For information about creating a private subnet for an CloudHSM cluster, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/create-subnets.html">Create a Private Subnet</a> in the <i>CloudHSM User Guide</i>. For information about cluster security groups, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">Configure a Default Security Group</a> in the <i> <i>CloudHSM User Guide</i> </i>. </p>
    CloudHsmClusterInvalidConfigurationException(
        crate::error::CloudHsmClusterInvalidConfigurationException,
    ),
    /// <p>The request was rejected because the CloudHSM cluster associated with the CloudHSM key store is not active. Initialize and activate the cluster and try the command again. For detailed instructions, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/getting-started.html">Getting Started</a> in the <i>CloudHSM User Guide</i>.</p>
    CloudHsmClusterNotActiveException(crate::error::CloudHsmClusterNotActiveException),
    /// <p>The request was rejected because KMS cannot find the CloudHSM cluster with the specified cluster ID. Retry the request with a different cluster ID.</p>
    CloudHsmClusterNotFoundException(crate::error::CloudHsmClusterNotFoundException),
    /// <p>The request was rejected because the specified CloudHSM cluster has a different cluster certificate than the original cluster. You cannot use the operation to specify an unrelated cluster for an CloudHSM key store.</p>
    /// <p>Specify an CloudHSM cluster that shares a backup history with the original cluster. This includes clusters that were created from a backup of the current cluster, and clusters that were created from the same backup that produced the current cluster.</p>
    /// <p>CloudHSM clusters that share a backup history have the same cluster certificate. To view the cluster certificate of an CloudHSM cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
    CloudHsmClusterNotRelatedException(crate::error::CloudHsmClusterNotRelatedException),
    /// <p>The request was rejected because the custom key store contains KMS keys. After verifying that you do not need to use the KMS keys, use the <code>ScheduleKeyDeletion</code> operation to delete the KMS keys. After they are deleted, you can delete the custom key store.</p>
    CustomKeyStoreHasCmKsException(crate::error::CustomKeyStoreHasCmKsException),
    /// <p>The request was rejected because of the <code>ConnectionState</code> of the custom key store. To get the <code>ConnectionState</code> of a custom key store, use the <code>DescribeCustomKeyStores</code> operation.</p>
    /// <p>This exception is thrown under the following conditions:</p>
    /// <ul>
    /// <li> <p>You requested the <code>ConnectCustomKeyStore</code> operation on a custom key store with a <code>ConnectionState</code> of <code>DISCONNECTING</code> or <code>FAILED</code>. This operation is valid for all other <code>ConnectionState</code> values. To reconnect a custom key store in a <code>FAILED</code> state, disconnect it (<code>DisconnectCustomKeyStore</code>), then connect it (<code>ConnectCustomKeyStore</code>).</p> </li>
    /// <li> <p>You requested the <code>CreateKey</code> operation in a custom key store that is not connected. This operations is valid only when the custom key store <code>ConnectionState</code> is <code>CONNECTED</code>.</p> </li>
    /// <li> <p>You requested the <code>DisconnectCustomKeyStore</code> operation on a custom key store with a <code>ConnectionState</code> of <code>DISCONNECTING</code> or <code>DISCONNECTED</code>. This operation is valid for all other <code>ConnectionState</code> values.</p> </li>
    /// <li> <p>You requested the <code>UpdateCustomKeyStore</code> or <code>DeleteCustomKeyStore</code> operation on a custom key store that is not disconnected. This operation is valid only when the custom key store <code>ConnectionState</code> is <code>DISCONNECTED</code>.</p> </li>
    /// <li> <p>You requested the <code>GenerateRandom</code> operation in an CloudHSM key store that is not connected. This operation is valid only when the CloudHSM key store <code>ConnectionState</code> is <code>CONNECTED</code>. </p> </li>
    /// </ul>
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    /// <p>The request was rejected because the specified custom key store name is already assigned to another custom key store in the account. Try again with a custom key store name that is unique in the account.</p>
    CustomKeyStoreNameInUseException(crate::error::CustomKeyStoreNameInUseException),
    /// <p>The request was rejected because KMS cannot find a custom key store with the specified key store name or ID.</p>
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    /// <p>The system timed out while trying to fulfill the request. You can retry the request.</p>
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    /// <p>The request was rejected because the specified KMS key is not enabled.</p>
    DisabledException(crate::error::DisabledException),
    /// <p>The request was rejected because the specified import token is expired. Use <code>GetParametersForImport</code> to get a new import token and public key, use the new public key to encrypt the key material, and then try the request again.</p>
    ExpiredImportTokenException(crate::error::ExpiredImportTokenException),
    /// <p>The request was rejected because the specified KMS key cannot decrypt the data. The <code>KeyId</code> in a <code>Decrypt</code> request and the <code>SourceKeyId</code> in a <code>ReEncrypt</code> request must identify the same KMS key that was used to encrypt the ciphertext.</p>
    IncorrectKeyException(crate::error::IncorrectKeyException),
    /// <p>The request was rejected because the key material in the request is, expired, invalid, or is not the same key material that was previously imported into this KMS key.</p>
    IncorrectKeyMaterialException(crate::error::IncorrectKeyMaterialException),
    /// <p>The request was rejected because the trust anchor certificate in the request to create an CloudHSM key store is not the trust anchor certificate for the specified CloudHSM cluster.</p>
    /// <p>When you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize the CloudHSM cluster</a>, you create the trust anchor certificate and save it in the <code>customerCA.crt</code> file.</p>
    IncorrectTrustAnchorException(crate::error::IncorrectTrustAnchorException),
    /// <p>The request was rejected because the specified alias name is not valid.</p>
    InvalidAliasNameException(crate::error::InvalidAliasNameException),
    /// <p>The request was rejected because a specified ARN, or an ARN in a key policy, is not valid.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>From the <code>Decrypt</code> or <code>ReEncrypt</code> operation, the request was rejected because the specified ciphertext, or additional authenticated data incorporated into the ciphertext, such as the encryption context, is corrupted, missing, or otherwise invalid.</p>
    /// <p>From the <code>ImportKeyMaterial</code> operation, the request was rejected because KMS could not decrypt the encrypted (wrapped) key material. </p>
    InvalidCiphertextException(crate::error::InvalidCiphertextException),
    /// <p>The request was rejected because the specified <code>GrantId</code> is not valid.</p>
    InvalidGrantIdException(crate::error::InvalidGrantIdException),
    /// <p>The request was rejected because the specified grant token is not valid.</p>
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    /// <p>The request was rejected because the provided import token is invalid or is associated with a different KMS key.</p>
    InvalidImportTokenException(crate::error::InvalidImportTokenException),
    /// <p>The request was rejected for one of the following reasons: </p>
    /// <ul>
    /// <li> <p>The <code>KeyUsage</code> value of the KMS key is incompatible with the API operation.</p> </li>
    /// <li> <p>The encryption algorithm or signing algorithm specified for the operation is incompatible with the type of key material in the KMS key <code>(KeySpec</code>).</p> </li>
    /// </ul>
    /// <p>For encrypting, decrypting, re-encrypting, and generating data keys, the <code>KeyUsage</code> must be <code>ENCRYPT_DECRYPT</code>. For signing and verifying messages, the <code>KeyUsage</code> must be <code>SIGN_VERIFY</code>. For generating and verifying message authentication codes (MACs), the <code>KeyUsage</code> must be <code>GENERATE_VERIFY_MAC</code>. To find the <code>KeyUsage</code> of a KMS key, use the <code>DescribeKey</code> operation.</p>
    /// <p>To find the encryption or signing algorithms supported for a particular KMS key, use the <code>DescribeKey</code> operation.</p>
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    /// <p>The request was rejected because the marker that specifies where pagination should next begin is not valid.</p>
    InvalidMarkerException(crate::error::InvalidMarkerException),
    /// <p>The request was rejected because an internal exception occurred. The request can be retried.</p>
    KmsInternalException(crate::error::KmsInternalException),
    /// <p>The request was rejected because the HMAC verification failed. HMAC verification fails when the HMAC computed by using the specified message, HMAC KMS key, and MAC algorithm does not match the HMAC specified in the request.</p>
    KmsInvalidMacException(crate::error::KmsInvalidMacException),
    /// <p>The request was rejected because the signature verification failed. Signature verification fails when it cannot confirm that signature was produced by signing the specified message with the specified KMS key and signing algorithm.</p>
    KmsInvalidSignatureException(crate::error::KmsInvalidSignatureException),
    /// <p>The request was rejected because the state of the specified resource is not valid for this request.</p>
    /// <p>This exceptions means one of the following:</p>
    /// <ul>
    /// <li> <p>The key state of the KMS key is not compatible with the operation. </p> <p>To find the key state, use the <code>DescribeKey</code> operation. For more information about which key states are compatible with each KMS operation, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key states of KMS keys</a> in the <i> <i>Key Management Service Developer Guide</i> </i>.</p> </li>
    /// <li> <p>For cryptographic operations on KMS keys in custom key stores, this exception represents a general failure with many possible causes. To identify the cause, see the error message that accompanies the exception.</p> </li>
    /// </ul>
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    /// <p>The request was rejected because the specified KMS key was not available. You can retry the request.</p>
    KeyUnavailableException(crate::error::KeyUnavailableException),
    /// <p>The request was rejected because a quota was exceeded. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html">Quotas</a> in the <i>Key Management Service Developer Guide</i>.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The request was rejected because the specified policy is not syntactically or semantically correct.</p>
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    /// <p>The request was rejected because the specified entity or resource could not be found.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>The request was rejected because one or more tags are not valid.</p>
    TagException(crate::error::TagException),
    /// <p>The request was rejected because a specified parameter is not supported or a specified resource is not valid for this operation.</p>
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// <p>The request was rejected because the (<code>XksKeyId</code>) is already associated with a KMS key in this external key store. Each KMS key in an external key store must be associated with a different external key.</p>
    XksKeyAlreadyInUseException(crate::error::XksKeyAlreadyInUseException),
    /// <p>The request was rejected because the external key specified by the <code>XksKeyId</code> parameter did not meet the configuration requirements for an external key store.</p>
    /// <p>The external key must be an AES-256 symmetric key that is enabled and performs encryption and decryption.</p>
    XksKeyInvalidConfigurationException(crate::error::XksKeyInvalidConfigurationException),
    /// <p>The request was rejected because the external key store proxy could not find the external key. This exception is thrown when the value of the <code>XksKeyId</code> parameter doesn't identify a key in the external key manager associated with the external key proxy.</p>
    /// <p>Verify that the <code>XksKeyId</code> represents an existing key in the external key manager. Use the key identifier that the external key store proxy uses to identify the key. For details, see the documentation provided with your external key store proxy or key manager.</p>
    XksKeyNotFoundException(crate::error::XksKeyNotFoundException),
    /// <p>The request was rejected because the proxy credentials failed to authenticate to the specified external key store proxy. The specified external key store proxy rejected a status request from KMS due to invalid credentials. This can indicate an error in the credentials or in the identification of the external key store proxy.</p>
    XksProxyIncorrectAuthenticationCredentialException(
        crate::error::XksProxyIncorrectAuthenticationCredentialException,
    ),
    /// <p>The request was rejected because the Amazon VPC endpoint service configuration does not fulfill the requirements for an external key store proxy. For details, see the exception message.</p>
    XksProxyInvalidConfigurationException(crate::error::XksProxyInvalidConfigurationException),
    /// <p></p>
    /// <p>KMS cannot interpret the response it received from the external key store proxy. The problem might be a poorly constructed response, but it could also be a transient network issue. If you see this error repeatedly, report it to the proxy vendor.</p>
    XksProxyInvalidResponseException(crate::error::XksProxyInvalidResponseException),
    /// <p>The request was rejected because the concatenation of the <code>XksProxyUriEndpoint</code> is already associated with an external key store in the Amazon Web Services account and Region. Each external key store in an account and Region must use a unique external key store proxy address.</p>
    XksProxyUriEndpointInUseException(crate::error::XksProxyUriEndpointInUseException),
    /// <p>The request was rejected because the concatenation of the <code>XksProxyUriEndpoint</code> and <code>XksProxyUriPath</code> is already associated with an external key store in the Amazon Web Services account and Region. Each external key store in an account and Region must use a unique external key store proxy API address.</p>
    XksProxyUriInUseException(crate::error::XksProxyUriInUseException),
    /// <p>KMS was unable to reach the specified <code>XksProxyUriPath</code>. The path must be reachable before you create the external key store or update its settings.</p>
    /// <p>This exception is also thrown when the external key store proxy response to a <code>GetHealthStatus</code> request indicates that all external key manager instances are unavailable.</p>
    XksProxyUriUnreachableException(crate::error::XksProxyUriUnreachableException),
    /// <p>The request was rejected because the specified Amazon VPC endpoint service is already associated with an external key store in the Amazon Web Services account and Region. Each external key store in an Amazon Web Services account and Region must use a different Amazon VPC endpoint service.</p>
    XksProxyVpcEndpointServiceInUseException(
        crate::error::XksProxyVpcEndpointServiceInUseException,
    ),
    /// <p>The request was rejected because the Amazon VPC endpoint service configuration does not fulfill the requirements for an external key store proxy. For details, see the exception message and <a href="kms/latest/developerguide/vpc-connectivity.html#xks-vpc-requirements">review the requirements</a> for Amazon VPC endpoint service connectivity for an external key store.</p>
    XksProxyVpcEndpointServiceInvalidConfigurationException(
        crate::error::XksProxyVpcEndpointServiceInvalidConfigurationException,
    ),
    /// <p>The request was rejected because KMS could not find the specified VPC endpoint service. Use <code>DescribeCustomKeyStores</code> to verify the VPC endpoint service name for the external key store. Also, confirm that the <code>Allow principals</code> list for the VPC endpoint service includes the KMS service principal for the Region, such as <code>cks.kms.us-east-1.amazonaws.com</code>.</p>
    XksProxyVpcEndpointServiceNotFoundException(
        crate::error::XksProxyVpcEndpointServiceNotFoundException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AlreadyExistsException(inner) => inner.fmt(f),
            Error::CloudHsmClusterInUseException(inner) => inner.fmt(f),
            Error::CloudHsmClusterInvalidConfigurationException(inner) => inner.fmt(f),
            Error::CloudHsmClusterNotActiveException(inner) => inner.fmt(f),
            Error::CloudHsmClusterNotFoundException(inner) => inner.fmt(f),
            Error::CloudHsmClusterNotRelatedException(inner) => inner.fmt(f),
            Error::CustomKeyStoreHasCmKsException(inner) => inner.fmt(f),
            Error::CustomKeyStoreInvalidStateException(inner) => inner.fmt(f),
            Error::CustomKeyStoreNameInUseException(inner) => inner.fmt(f),
            Error::CustomKeyStoreNotFoundException(inner) => inner.fmt(f),
            Error::DependencyTimeoutException(inner) => inner.fmt(f),
            Error::DisabledException(inner) => inner.fmt(f),
            Error::ExpiredImportTokenException(inner) => inner.fmt(f),
            Error::IncorrectKeyException(inner) => inner.fmt(f),
            Error::IncorrectKeyMaterialException(inner) => inner.fmt(f),
            Error::IncorrectTrustAnchorException(inner) => inner.fmt(f),
            Error::InvalidAliasNameException(inner) => inner.fmt(f),
            Error::InvalidArnException(inner) => inner.fmt(f),
            Error::InvalidCiphertextException(inner) => inner.fmt(f),
            Error::InvalidGrantIdException(inner) => inner.fmt(f),
            Error::InvalidGrantTokenException(inner) => inner.fmt(f),
            Error::InvalidImportTokenException(inner) => inner.fmt(f),
            Error::InvalidKeyUsageException(inner) => inner.fmt(f),
            Error::InvalidMarkerException(inner) => inner.fmt(f),
            Error::KmsInternalException(inner) => inner.fmt(f),
            Error::KmsInvalidMacException(inner) => inner.fmt(f),
            Error::KmsInvalidSignatureException(inner) => inner.fmt(f),
            Error::KmsInvalidStateException(inner) => inner.fmt(f),
            Error::KeyUnavailableException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::MalformedPolicyDocumentException(inner) => inner.fmt(f),
            Error::NotFoundException(inner) => inner.fmt(f),
            Error::TagException(inner) => inner.fmt(f),
            Error::UnsupportedOperationException(inner) => inner.fmt(f),
            Error::XksKeyAlreadyInUseException(inner) => inner.fmt(f),
            Error::XksKeyInvalidConfigurationException(inner) => inner.fmt(f),
            Error::XksKeyNotFoundException(inner) => inner.fmt(f),
            Error::XksProxyIncorrectAuthenticationCredentialException(inner) => inner.fmt(f),
            Error::XksProxyInvalidConfigurationException(inner) => inner.fmt(f),
            Error::XksProxyInvalidResponseException(inner) => inner.fmt(f),
            Error::XksProxyUriEndpointInUseException(inner) => inner.fmt(f),
            Error::XksProxyUriInUseException(inner) => inner.fmt(f),
            Error::XksProxyUriUnreachableException(inner) => inner.fmt(f),
            Error::XksProxyVpcEndpointServiceInUseException(inner) => inner.fmt(f),
            Error::XksProxyVpcEndpointServiceInvalidConfigurationException(inner) => inner.fmt(f),
            Error::XksProxyVpcEndpointServiceNotFoundException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CancelKeyDeletionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CancelKeyDeletionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CancelKeyDeletionError> for Error {
    fn from(err: crate::error::CancelKeyDeletionError) -> Self {
        match err {
            crate::error::CancelKeyDeletionError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::CancelKeyDeletionError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::CancelKeyDeletionError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::CancelKeyDeletionError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::CancelKeyDeletionError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::CancelKeyDeletionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ConnectCustomKeyStoreError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ConnectCustomKeyStoreError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ConnectCustomKeyStoreError> for Error {
    fn from(err: crate::error::ConnectCustomKeyStoreError) -> Self {
        match err {
            crate::error::ConnectCustomKeyStoreError::CloudHsmClusterInvalidConfigurationException(inner) => Error::CloudHsmClusterInvalidConfigurationException(inner),
            crate::error::ConnectCustomKeyStoreError::CloudHsmClusterNotActiveException(inner) => Error::CloudHsmClusterNotActiveException(inner),
            crate::error::ConnectCustomKeyStoreError::CustomKeyStoreInvalidStateException(inner) => Error::CustomKeyStoreInvalidStateException(inner),
            crate::error::ConnectCustomKeyStoreError::CustomKeyStoreNotFoundException(inner) => Error::CustomKeyStoreNotFoundException(inner),
            crate::error::ConnectCustomKeyStoreError::KmsInternalException(inner) => Error::KmsInternalException(inner),
            crate::error::ConnectCustomKeyStoreError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAliasError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateAliasError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateAliasError> for Error {
    fn from(err: crate::error::CreateAliasError) -> Self {
        match err {
            crate::error::CreateAliasError::AlreadyExistsException(inner) => {
                Error::AlreadyExistsException(inner)
            }
            crate::error::CreateAliasError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::CreateAliasError::InvalidAliasNameException(inner) => {
                Error::InvalidAliasNameException(inner)
            }
            crate::error::CreateAliasError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::CreateAliasError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::CreateAliasError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateAliasError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::CreateAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCustomKeyStoreError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateCustomKeyStoreError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCustomKeyStoreError> for Error {
    fn from(err: crate::error::CreateCustomKeyStoreError) -> Self {
        match err {
            crate::error::CreateCustomKeyStoreError::CloudHsmClusterInUseException(inner) => Error::CloudHsmClusterInUseException(inner),
            crate::error::CreateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationException(inner) => Error::CloudHsmClusterInvalidConfigurationException(inner),
            crate::error::CreateCustomKeyStoreError::CloudHsmClusterNotActiveException(inner) => Error::CloudHsmClusterNotActiveException(inner),
            crate::error::CreateCustomKeyStoreError::CloudHsmClusterNotFoundException(inner) => Error::CloudHsmClusterNotFoundException(inner),
            crate::error::CreateCustomKeyStoreError::CustomKeyStoreNameInUseException(inner) => Error::CustomKeyStoreNameInUseException(inner),
            crate::error::CreateCustomKeyStoreError::IncorrectTrustAnchorException(inner) => Error::IncorrectTrustAnchorException(inner),
            crate::error::CreateCustomKeyStoreError::KmsInternalException(inner) => Error::KmsInternalException(inner),
            crate::error::CreateCustomKeyStoreError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyIncorrectAuthenticationCredentialException(inner) => Error::XksProxyIncorrectAuthenticationCredentialException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyInvalidConfigurationException(inner) => Error::XksProxyInvalidConfigurationException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyInvalidResponseException(inner) => Error::XksProxyInvalidResponseException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyUriEndpointInUseException(inner) => Error::XksProxyUriEndpointInUseException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyUriInUseException(inner) => Error::XksProxyUriInUseException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyUriUnreachableException(inner) => Error::XksProxyUriUnreachableException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyVpcEndpointServiceInUseException(inner) => Error::XksProxyVpcEndpointServiceInUseException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyVpcEndpointServiceInvalidConfigurationException(inner) => Error::XksProxyVpcEndpointServiceInvalidConfigurationException(inner),
            crate::error::CreateCustomKeyStoreError::XksProxyVpcEndpointServiceNotFoundException(inner) => Error::XksProxyVpcEndpointServiceNotFoundException(inner),
            crate::error::CreateCustomKeyStoreError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateGrantError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateGrantError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateGrantError> for Error {
    fn from(err: crate::error::CreateGrantError) -> Self {
        match err {
            crate::error::CreateGrantError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::CreateGrantError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::CreateGrantError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::CreateGrantError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::CreateGrantError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::CreateGrantError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::CreateGrantError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateGrantError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::CreateGrantError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateKeyError> for Error {
    fn from(err: crate::error::CreateKeyError) -> Self {
        match err {
            crate::error::CreateKeyError::CloudHsmClusterInvalidConfigurationException(inner) => {
                Error::CloudHsmClusterInvalidConfigurationException(inner)
            }
            crate::error::CreateKeyError::CustomKeyStoreInvalidStateException(inner) => {
                Error::CustomKeyStoreInvalidStateException(inner)
            }
            crate::error::CreateKeyError::CustomKeyStoreNotFoundException(inner) => {
                Error::CustomKeyStoreNotFoundException(inner)
            }
            crate::error::CreateKeyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::CreateKeyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::CreateKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::CreateKeyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateKeyError::MalformedPolicyDocumentException(inner) => {
                Error::MalformedPolicyDocumentException(inner)
            }
            crate::error::CreateKeyError::TagException(inner) => Error::TagException(inner),
            crate::error::CreateKeyError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::CreateKeyError::XksKeyAlreadyInUseException(inner) => {
                Error::XksKeyAlreadyInUseException(inner)
            }
            crate::error::CreateKeyError::XksKeyInvalidConfigurationException(inner) => {
                Error::XksKeyInvalidConfigurationException(inner)
            }
            crate::error::CreateKeyError::XksKeyNotFoundException(inner) => {
                Error::XksKeyNotFoundException(inner)
            }
            crate::error::CreateKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DecryptError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DecryptError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DecryptError> for Error {
    fn from(err: crate::error::DecryptError) -> Self {
        match err {
            crate::error::DecryptError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::DecryptError::DisabledException(inner) => Error::DisabledException(inner),
            crate::error::DecryptError::IncorrectKeyException(inner) => {
                Error::IncorrectKeyException(inner)
            }
            crate::error::DecryptError::InvalidCiphertextException(inner) => {
                Error::InvalidCiphertextException(inner)
            }
            crate::error::DecryptError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::DecryptError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::DecryptError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::DecryptError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DecryptError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::DecryptError::NotFoundException(inner) => Error::NotFoundException(inner),
            crate::error::DecryptError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAliasError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteAliasError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteAliasError> for Error {
    fn from(err: crate::error::DeleteAliasError) -> Self {
        match err {
            crate::error::DeleteAliasError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::DeleteAliasError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DeleteAliasError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::DeleteAliasError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DeleteAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCustomKeyStoreError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCustomKeyStoreError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCustomKeyStoreError> for Error {
    fn from(err: crate::error::DeleteCustomKeyStoreError) -> Self {
        match err {
            crate::error::DeleteCustomKeyStoreError::CustomKeyStoreHasCmKsException(inner) => {
                Error::CustomKeyStoreHasCmKsException(inner)
            }
            crate::error::DeleteCustomKeyStoreError::CustomKeyStoreInvalidStateException(inner) => {
                Error::CustomKeyStoreInvalidStateException(inner)
            }
            crate::error::DeleteCustomKeyStoreError::CustomKeyStoreNotFoundException(inner) => {
                Error::CustomKeyStoreNotFoundException(inner)
            }
            crate::error::DeleteCustomKeyStoreError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DeleteCustomKeyStoreError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteImportedKeyMaterialError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteImportedKeyMaterialError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteImportedKeyMaterialError> for Error {
    fn from(err: crate::error::DeleteImportedKeyMaterialError) -> Self {
        match err {
            crate::error::DeleteImportedKeyMaterialError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::DeleteImportedKeyMaterialError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::DeleteImportedKeyMaterialError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DeleteImportedKeyMaterialError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::DeleteImportedKeyMaterialError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DeleteImportedKeyMaterialError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::DeleteImportedKeyMaterialError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeCustomKeyStoresError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeCustomKeyStoresError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeCustomKeyStoresError> for Error {
    fn from(err: crate::error::DescribeCustomKeyStoresError) -> Self {
        match err {
            crate::error::DescribeCustomKeyStoresError::CustomKeyStoreNotFoundException(inner) => {
                Error::CustomKeyStoreNotFoundException(inner)
            }
            crate::error::DescribeCustomKeyStoresError::InvalidMarkerException(inner) => {
                Error::InvalidMarkerException(inner)
            }
            crate::error::DescribeCustomKeyStoresError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DescribeCustomKeyStoresError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeKeyError> for Error {
    fn from(err: crate::error::DescribeKeyError) -> Self {
        match err {
            crate::error::DescribeKeyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::DescribeKeyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::DescribeKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DescribeKeyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DescribeKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisableKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableKeyError> for Error {
    fn from(err: crate::error::DisableKeyError) -> Self {
        match err {
            crate::error::DisableKeyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::DisableKeyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::DisableKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DisableKeyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::DisableKeyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DisableKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableKeyRotationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisableKeyRotationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableKeyRotationError> for Error {
    fn from(err: crate::error::DisableKeyRotationError) -> Self {
        match err {
            crate::error::DisableKeyRotationError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::DisableKeyRotationError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::DisableKeyRotationError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::DisableKeyRotationError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DisableKeyRotationError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::DisableKeyRotationError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::DisableKeyRotationError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::DisableKeyRotationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisconnectCustomKeyStoreError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisconnectCustomKeyStoreError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisconnectCustomKeyStoreError> for Error {
    fn from(err: crate::error::DisconnectCustomKeyStoreError) -> Self {
        match err {
            crate::error::DisconnectCustomKeyStoreError::CustomKeyStoreInvalidStateException(
                inner,
            ) => Error::CustomKeyStoreInvalidStateException(inner),
            crate::error::DisconnectCustomKeyStoreError::CustomKeyStoreNotFoundException(inner) => {
                Error::CustomKeyStoreNotFoundException(inner)
            }
            crate::error::DisconnectCustomKeyStoreError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::DisconnectCustomKeyStoreError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EnableKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableKeyError> for Error {
    fn from(err: crate::error::EnableKeyError) -> Self {
        match err {
            crate::error::EnableKeyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::EnableKeyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::EnableKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::EnableKeyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::EnableKeyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::EnableKeyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::EnableKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableKeyRotationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::EnableKeyRotationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableKeyRotationError> for Error {
    fn from(err: crate::error::EnableKeyRotationError) -> Self {
        match err {
            crate::error::EnableKeyRotationError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::EnableKeyRotationError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::EnableKeyRotationError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::EnableKeyRotationError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::EnableKeyRotationError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::EnableKeyRotationError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::EnableKeyRotationError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::EnableKeyRotationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EncryptError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EncryptError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EncryptError> for Error {
    fn from(err: crate::error::EncryptError) -> Self {
        match err {
            crate::error::EncryptError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::EncryptError::DisabledException(inner) => Error::DisabledException(inner),
            crate::error::EncryptError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::EncryptError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::EncryptError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::EncryptError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::EncryptError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::EncryptError::NotFoundException(inner) => Error::NotFoundException(inner),
            crate::error::EncryptError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GenerateDataKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GenerateDataKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GenerateDataKeyError> for Error {
    fn from(err: crate::error::GenerateDataKeyError) -> Self {
        match err {
            crate::error::GenerateDataKeyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GenerateDataKeyError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::GenerateDataKeyError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::GenerateDataKeyError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::GenerateDataKeyError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::GenerateDataKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GenerateDataKeyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GenerateDataKeyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GenerateDataKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GenerateDataKeyPairError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GenerateDataKeyPairError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GenerateDataKeyPairError> for Error {
    fn from(err: crate::error::GenerateDataKeyPairError) -> Self {
        match err {
            crate::error::GenerateDataKeyPairError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GenerateDataKeyPairError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::GenerateDataKeyPairError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::GenerateDataKeyPairError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::GenerateDataKeyPairError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::GenerateDataKeyPairError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GenerateDataKeyPairError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GenerateDataKeyPairError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GenerateDataKeyPairError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::GenerateDataKeyPairError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GenerateDataKeyPairWithoutPlaintextError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GenerateDataKeyPairWithoutPlaintextError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GenerateDataKeyPairWithoutPlaintextError> for Error {
    fn from(err: crate::error::GenerateDataKeyPairWithoutPlaintextError) -> Self {
        match err {
            crate::error::GenerateDataKeyPairWithoutPlaintextError::DependencyTimeoutException(inner) => Error::DependencyTimeoutException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::DisabledException(inner) => Error::DisabledException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::InvalidGrantTokenException(inner) => Error::InvalidGrantTokenException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::InvalidKeyUsageException(inner) => Error::InvalidKeyUsageException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::KeyUnavailableException(inner) => Error::KeyUnavailableException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::KmsInternalException(inner) => Error::KmsInternalException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::KmsInvalidStateException(inner) => Error::KmsInvalidStateException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::NotFoundException(inner) => Error::NotFoundException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::UnsupportedOperationException(inner) => Error::UnsupportedOperationException(inner),
            crate::error::GenerateDataKeyPairWithoutPlaintextError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GenerateDataKeyWithoutPlaintextError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GenerateDataKeyWithoutPlaintextError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GenerateDataKeyWithoutPlaintextError> for Error {
    fn from(err: crate::error::GenerateDataKeyWithoutPlaintextError) -> Self {
        match err {
            crate::error::GenerateDataKeyWithoutPlaintextError::DependencyTimeoutException(
                inner,
            ) => Error::DependencyTimeoutException(inner),
            crate::error::GenerateDataKeyWithoutPlaintextError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenException(
                inner,
            ) => Error::InvalidGrantTokenException(inner),
            crate::error::GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::GenerateDataKeyWithoutPlaintextError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::GenerateDataKeyWithoutPlaintextError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GenerateDataKeyWithoutPlaintextError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GenerateDataKeyWithoutPlaintextError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GenerateDataKeyWithoutPlaintextError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GenerateMacError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GenerateMacError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GenerateMacError> for Error {
    fn from(err: crate::error::GenerateMacError) -> Self {
        match err {
            crate::error::GenerateMacError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::GenerateMacError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::GenerateMacError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::GenerateMacError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::GenerateMacError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GenerateMacError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GenerateMacError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GenerateMacError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GenerateRandomError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GenerateRandomError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GenerateRandomError> for Error {
    fn from(err: crate::error::GenerateRandomError) -> Self {
        match err {
            crate::error::GenerateRandomError::CustomKeyStoreInvalidStateException(inner) => {
                Error::CustomKeyStoreInvalidStateException(inner)
            }
            crate::error::GenerateRandomError::CustomKeyStoreNotFoundException(inner) => {
                Error::CustomKeyStoreNotFoundException(inner)
            }
            crate::error::GenerateRandomError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GenerateRandomError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GenerateRandomError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::GenerateRandomError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetKeyPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetKeyPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetKeyPolicyError> for Error {
    fn from(err: crate::error::GetKeyPolicyError) -> Self {
        match err {
            crate::error::GetKeyPolicyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GetKeyPolicyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::GetKeyPolicyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GetKeyPolicyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GetKeyPolicyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetKeyPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetKeyRotationStatusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetKeyRotationStatusError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetKeyRotationStatusError> for Error {
    fn from(err: crate::error::GetKeyRotationStatusError) -> Self {
        match err {
            crate::error::GetKeyRotationStatusError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GetKeyRotationStatusError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::GetKeyRotationStatusError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GetKeyRotationStatusError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GetKeyRotationStatusError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetKeyRotationStatusError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::GetKeyRotationStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetParametersForImportError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetParametersForImportError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetParametersForImportError> for Error {
    fn from(err: crate::error::GetParametersForImportError) -> Self {
        match err {
            crate::error::GetParametersForImportError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GetParametersForImportError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::GetParametersForImportError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GetParametersForImportError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GetParametersForImportError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetParametersForImportError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::GetParametersForImportError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetPublicKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetPublicKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetPublicKeyError> for Error {
    fn from(err: crate::error::GetPublicKeyError) -> Self {
        match err {
            crate::error::GetPublicKeyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::GetPublicKeyError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::GetPublicKeyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::GetPublicKeyError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::GetPublicKeyError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::GetPublicKeyError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::GetPublicKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::GetPublicKeyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::GetPublicKeyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::GetPublicKeyError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::GetPublicKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ImportKeyMaterialError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ImportKeyMaterialError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ImportKeyMaterialError> for Error {
    fn from(err: crate::error::ImportKeyMaterialError) -> Self {
        match err {
            crate::error::ImportKeyMaterialError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ImportKeyMaterialError::ExpiredImportTokenException(inner) => {
                Error::ExpiredImportTokenException(inner)
            }
            crate::error::ImportKeyMaterialError::IncorrectKeyMaterialException(inner) => {
                Error::IncorrectKeyMaterialException(inner)
            }
            crate::error::ImportKeyMaterialError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ImportKeyMaterialError::InvalidCiphertextException(inner) => {
                Error::InvalidCiphertextException(inner)
            }
            crate::error::ImportKeyMaterialError::InvalidImportTokenException(inner) => {
                Error::InvalidImportTokenException(inner)
            }
            crate::error::ImportKeyMaterialError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ImportKeyMaterialError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::ImportKeyMaterialError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ImportKeyMaterialError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::ImportKeyMaterialError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListAliasesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListAliasesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListAliasesError> for Error {
    fn from(err: crate::error::ListAliasesError) -> Self {
        match err {
            crate::error::ListAliasesError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ListAliasesError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ListAliasesError::InvalidMarkerException(inner) => {
                Error::InvalidMarkerException(inner)
            }
            crate::error::ListAliasesError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ListAliasesError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ListAliasesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListGrantsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListGrantsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListGrantsError> for Error {
    fn from(err: crate::error::ListGrantsError) -> Self {
        match err {
            crate::error::ListGrantsError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ListGrantsError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ListGrantsError::InvalidGrantIdException(inner) => {
                Error::InvalidGrantIdException(inner)
            }
            crate::error::ListGrantsError::InvalidMarkerException(inner) => {
                Error::InvalidMarkerException(inner)
            }
            crate::error::ListGrantsError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ListGrantsError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::ListGrantsError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ListGrantsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListKeyPoliciesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListKeyPoliciesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListKeyPoliciesError> for Error {
    fn from(err: crate::error::ListKeyPoliciesError) -> Self {
        match err {
            crate::error::ListKeyPoliciesError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ListKeyPoliciesError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ListKeyPoliciesError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ListKeyPoliciesError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::ListKeyPoliciesError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ListKeyPoliciesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListKeysError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListKeysError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListKeysError> for Error {
    fn from(err: crate::error::ListKeysError) -> Self {
        match err {
            crate::error::ListKeysError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ListKeysError::InvalidMarkerException(inner) => {
                Error::InvalidMarkerException(inner)
            }
            crate::error::ListKeysError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ListKeysError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListResourceTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListResourceTagsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListResourceTagsError> for Error {
    fn from(err: crate::error::ListResourceTagsError) -> Self {
        match err {
            crate::error::ListResourceTagsError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ListResourceTagsError::InvalidMarkerException(inner) => {
                Error::InvalidMarkerException(inner)
            }
            crate::error::ListResourceTagsError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ListResourceTagsError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ListResourceTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListRetirableGrantsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListRetirableGrantsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListRetirableGrantsError> for Error {
    fn from(err: crate::error::ListRetirableGrantsError) -> Self {
        match err {
            crate::error::ListRetirableGrantsError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ListRetirableGrantsError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ListRetirableGrantsError::InvalidMarkerException(inner) => {
                Error::InvalidMarkerException(inner)
            }
            crate::error::ListRetirableGrantsError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ListRetirableGrantsError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ListRetirableGrantsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutKeyPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutKeyPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutKeyPolicyError> for Error {
    fn from(err: crate::error::PutKeyPolicyError) -> Self {
        match err {
            crate::error::PutKeyPolicyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::PutKeyPolicyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::PutKeyPolicyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::PutKeyPolicyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::PutKeyPolicyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::PutKeyPolicyError::MalformedPolicyDocumentException(inner) => {
                Error::MalformedPolicyDocumentException(inner)
            }
            crate::error::PutKeyPolicyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::PutKeyPolicyError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::PutKeyPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ReEncryptError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ReEncryptError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ReEncryptError> for Error {
    fn from(err: crate::error::ReEncryptError) -> Self {
        match err {
            crate::error::ReEncryptError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ReEncryptError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::ReEncryptError::IncorrectKeyException(inner) => {
                Error::IncorrectKeyException(inner)
            }
            crate::error::ReEncryptError::InvalidCiphertextException(inner) => {
                Error::InvalidCiphertextException(inner)
            }
            crate::error::ReEncryptError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::ReEncryptError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::ReEncryptError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::ReEncryptError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ReEncryptError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::ReEncryptError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ReEncryptError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ReplicateKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ReplicateKeyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ReplicateKeyError> for Error {
    fn from(err: crate::error::ReplicateKeyError) -> Self {
        match err {
            crate::error::ReplicateKeyError::AlreadyExistsException(inner) => {
                Error::AlreadyExistsException(inner)
            }
            crate::error::ReplicateKeyError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::ReplicateKeyError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ReplicateKeyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ReplicateKeyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::ReplicateKeyError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ReplicateKeyError::MalformedPolicyDocumentException(inner) => {
                Error::MalformedPolicyDocumentException(inner)
            }
            crate::error::ReplicateKeyError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ReplicateKeyError::TagException(inner) => Error::TagException(inner),
            crate::error::ReplicateKeyError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::ReplicateKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RetireGrantError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RetireGrantError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RetireGrantError> for Error {
    fn from(err: crate::error::RetireGrantError) -> Self {
        match err {
            crate::error::RetireGrantError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::RetireGrantError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::RetireGrantError::InvalidGrantIdException(inner) => {
                Error::InvalidGrantIdException(inner)
            }
            crate::error::RetireGrantError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::RetireGrantError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::RetireGrantError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::RetireGrantError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::RetireGrantError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RevokeGrantError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RevokeGrantError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RevokeGrantError> for Error {
    fn from(err: crate::error::RevokeGrantError) -> Self {
        match err {
            crate::error::RevokeGrantError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::RevokeGrantError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::RevokeGrantError::InvalidGrantIdException(inner) => {
                Error::InvalidGrantIdException(inner)
            }
            crate::error::RevokeGrantError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::RevokeGrantError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::RevokeGrantError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::RevokeGrantError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ScheduleKeyDeletionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ScheduleKeyDeletionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ScheduleKeyDeletionError> for Error {
    fn from(err: crate::error::ScheduleKeyDeletionError) -> Self {
        match err {
            crate::error::ScheduleKeyDeletionError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::ScheduleKeyDeletionError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ScheduleKeyDeletionError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::ScheduleKeyDeletionError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::ScheduleKeyDeletionError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::ScheduleKeyDeletionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SignError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SignError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::SignError> for Error {
    fn from(err: crate::error::SignError) -> Self {
        match err {
            crate::error::SignError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::SignError::DisabledException(inner) => Error::DisabledException(inner),
            crate::error::SignError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::SignError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::SignError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::SignError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::SignError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::SignError::NotFoundException(inner) => Error::NotFoundException(inner),
            crate::error::SignError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::TagResourceError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::TagResourceError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::TagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::TagResourceError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::TagResourceError::TagException(inner) => Error::TagException(inner),
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::UntagResourceError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::UntagResourceError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::UntagResourceError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UntagResourceError::TagException(inner) => Error::TagException(inner),
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateAliasError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateAliasError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateAliasError> for Error {
    fn from(err: crate::error::UpdateAliasError) -> Self {
        match err {
            crate::error::UpdateAliasError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::UpdateAliasError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::UpdateAliasError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::UpdateAliasError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateAliasError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdateAliasError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCustomKeyStoreError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateCustomKeyStoreError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateCustomKeyStoreError> for Error {
    fn from(err: crate::error::UpdateCustomKeyStoreError) -> Self {
        match err {
            crate::error::UpdateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationException(inner) => Error::CloudHsmClusterInvalidConfigurationException(inner),
            crate::error::UpdateCustomKeyStoreError::CloudHsmClusterNotActiveException(inner) => Error::CloudHsmClusterNotActiveException(inner),
            crate::error::UpdateCustomKeyStoreError::CloudHsmClusterNotFoundException(inner) => Error::CloudHsmClusterNotFoundException(inner),
            crate::error::UpdateCustomKeyStoreError::CloudHsmClusterNotRelatedException(inner) => Error::CloudHsmClusterNotRelatedException(inner),
            crate::error::UpdateCustomKeyStoreError::CustomKeyStoreInvalidStateException(inner) => Error::CustomKeyStoreInvalidStateException(inner),
            crate::error::UpdateCustomKeyStoreError::CustomKeyStoreNameInUseException(inner) => Error::CustomKeyStoreNameInUseException(inner),
            crate::error::UpdateCustomKeyStoreError::CustomKeyStoreNotFoundException(inner) => Error::CustomKeyStoreNotFoundException(inner),
            crate::error::UpdateCustomKeyStoreError::KmsInternalException(inner) => Error::KmsInternalException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyIncorrectAuthenticationCredentialException(inner) => Error::XksProxyIncorrectAuthenticationCredentialException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyInvalidConfigurationException(inner) => Error::XksProxyInvalidConfigurationException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyInvalidResponseException(inner) => Error::XksProxyInvalidResponseException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyUriEndpointInUseException(inner) => Error::XksProxyUriEndpointInUseException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyUriInUseException(inner) => Error::XksProxyUriInUseException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyUriUnreachableException(inner) => Error::XksProxyUriUnreachableException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyVpcEndpointServiceInUseException(inner) => Error::XksProxyVpcEndpointServiceInUseException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyVpcEndpointServiceInvalidConfigurationException(inner) => Error::XksProxyVpcEndpointServiceInvalidConfigurationException(inner),
            crate::error::UpdateCustomKeyStoreError::XksProxyVpcEndpointServiceNotFoundException(inner) => Error::XksProxyVpcEndpointServiceNotFoundException(inner),
            crate::error::UpdateCustomKeyStoreError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateKeyDescriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateKeyDescriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateKeyDescriptionError> for Error {
    fn from(err: crate::error::UpdateKeyDescriptionError) -> Self {
        match err {
            crate::error::UpdateKeyDescriptionError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::UpdateKeyDescriptionError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::UpdateKeyDescriptionError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::UpdateKeyDescriptionError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::UpdateKeyDescriptionError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdateKeyDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePrimaryRegionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdatePrimaryRegionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdatePrimaryRegionError> for Error {
    fn from(err: crate::error::UpdatePrimaryRegionError) -> Self {
        match err {
            crate::error::UpdatePrimaryRegionError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::UpdatePrimaryRegionError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::UpdatePrimaryRegionError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::UpdatePrimaryRegionError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::UpdatePrimaryRegionError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::UpdatePrimaryRegionError::UnsupportedOperationException(inner) => {
                Error::UnsupportedOperationException(inner)
            }
            crate::error::UpdatePrimaryRegionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::VerifyError> for Error {
    fn from(err: crate::error::VerifyError) -> Self {
        match err {
            crate::error::VerifyError::DependencyTimeoutException(inner) => {
                Error::DependencyTimeoutException(inner)
            }
            crate::error::VerifyError::DisabledException(inner) => Error::DisabledException(inner),
            crate::error::VerifyError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::VerifyError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::VerifyError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::VerifyError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::VerifyError::KmsInvalidSignatureException(inner) => {
                Error::KmsInvalidSignatureException(inner)
            }
            crate::error::VerifyError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::VerifyError::NotFoundException(inner) => Error::NotFoundException(inner),
            crate::error::VerifyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::VerifyMacError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::VerifyMacError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::VerifyMacError> for Error {
    fn from(err: crate::error::VerifyMacError) -> Self {
        match err {
            crate::error::VerifyMacError::DisabledException(inner) => {
                Error::DisabledException(inner)
            }
            crate::error::VerifyMacError::InvalidGrantTokenException(inner) => {
                Error::InvalidGrantTokenException(inner)
            }
            crate::error::VerifyMacError::InvalidKeyUsageException(inner) => {
                Error::InvalidKeyUsageException(inner)
            }
            crate::error::VerifyMacError::KeyUnavailableException(inner) => {
                Error::KeyUnavailableException(inner)
            }
            crate::error::VerifyMacError::KmsInternalException(inner) => {
                Error::KmsInternalException(inner)
            }
            crate::error::VerifyMacError::KmsInvalidMacException(inner) => {
                Error::KmsInvalidMacException(inner)
            }
            crate::error::VerifyMacError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::error::VerifyMacError::NotFoundException(inner) => {
                Error::NotFoundException(inner)
            }
            crate::error::VerifyMacError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AlreadyExistsException(e) => e.request_id(),
            Self::CloudHsmClusterInUseException(e) => e.request_id(),
            Self::CloudHsmClusterInvalidConfigurationException(e) => e.request_id(),
            Self::CloudHsmClusterNotActiveException(e) => e.request_id(),
            Self::CloudHsmClusterNotFoundException(e) => e.request_id(),
            Self::CloudHsmClusterNotRelatedException(e) => e.request_id(),
            Self::CustomKeyStoreHasCmKsException(e) => e.request_id(),
            Self::CustomKeyStoreInvalidStateException(e) => e.request_id(),
            Self::CustomKeyStoreNameInUseException(e) => e.request_id(),
            Self::CustomKeyStoreNotFoundException(e) => e.request_id(),
            Self::DependencyTimeoutException(e) => e.request_id(),
            Self::DisabledException(e) => e.request_id(),
            Self::ExpiredImportTokenException(e) => e.request_id(),
            Self::IncorrectKeyException(e) => e.request_id(),
            Self::IncorrectKeyMaterialException(e) => e.request_id(),
            Self::IncorrectTrustAnchorException(e) => e.request_id(),
            Self::InvalidAliasNameException(e) => e.request_id(),
            Self::InvalidArnException(e) => e.request_id(),
            Self::InvalidCiphertextException(e) => e.request_id(),
            Self::InvalidGrantIdException(e) => e.request_id(),
            Self::InvalidGrantTokenException(e) => e.request_id(),
            Self::InvalidImportTokenException(e) => e.request_id(),
            Self::InvalidKeyUsageException(e) => e.request_id(),
            Self::InvalidMarkerException(e) => e.request_id(),
            Self::KmsInternalException(e) => e.request_id(),
            Self::KmsInvalidMacException(e) => e.request_id(),
            Self::KmsInvalidSignatureException(e) => e.request_id(),
            Self::KmsInvalidStateException(e) => e.request_id(),
            Self::KeyUnavailableException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::MalformedPolicyDocumentException(e) => e.request_id(),
            Self::NotFoundException(e) => e.request_id(),
            Self::TagException(e) => e.request_id(),
            Self::UnsupportedOperationException(e) => e.request_id(),
            Self::XksKeyAlreadyInUseException(e) => e.request_id(),
            Self::XksKeyInvalidConfigurationException(e) => e.request_id(),
            Self::XksKeyNotFoundException(e) => e.request_id(),
            Self::XksProxyIncorrectAuthenticationCredentialException(e) => e.request_id(),
            Self::XksProxyInvalidConfigurationException(e) => e.request_id(),
            Self::XksProxyInvalidResponseException(e) => e.request_id(),
            Self::XksProxyUriEndpointInUseException(e) => e.request_id(),
            Self::XksProxyUriInUseException(e) => e.request_id(),
            Self::XksProxyUriUnreachableException(e) => e.request_id(),
            Self::XksProxyVpcEndpointServiceInUseException(e) => e.request_id(),
            Self::XksProxyVpcEndpointServiceInvalidConfigurationException(e) => e.request_id(),
            Self::XksProxyVpcEndpointServiceNotFoundException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
