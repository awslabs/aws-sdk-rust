// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelKeyDeletionError {
    pub kind: CancelKeyDeletionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelKeyDeletionErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelKeyDeletionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelKeyDeletionErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelKeyDeletionError {
    fn code(&self) -> Option<&str> {
        CancelKeyDeletionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelKeyDeletionError {
    pub fn new(kind: CancelKeyDeletionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelKeyDeletionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelKeyDeletionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelKeyDeletionErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelKeyDeletionErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelKeyDeletionErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelKeyDeletionErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CancelKeyDeletionErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CancelKeyDeletionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelKeyDeletionErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::InvalidArnException(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::KmsInternalException(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::NotFoundException(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConnectCustomKeyStoreError {
    pub kind: ConnectCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConnectCustomKeyStoreErrorKind {
    CloudHsmClusterInvalidConfigurationException(
        crate::error::CloudHsmClusterInvalidConfigurationException,
    ),
    CloudHsmClusterNotActiveException(crate::error::CloudHsmClusterNotActiveException),
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConnectCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(
                _inner,
            ) => _inner.fmt(f),
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_inner) => {
                _inner.fmt(f)
            }
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ConnectCustomKeyStoreErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConnectCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        ConnectCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConnectCustomKeyStoreError {
    pub fn new(kind: ConnectCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConnectCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConnectCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cloud_hsm_cluster_invalid_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_)
        )
    }
    pub fn is_custom_key_store_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_)
        )
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConnectCustomKeyStoreErrorKind::KmsInternalException(_)
        )
    }
}
impl std::error::Error for ConnectCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(
                _inner,
            ) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_inner) => {
                Some(_inner)
            }
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                Some(_inner)
            }
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::KmsInternalException(_inner) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAliasError {
    pub kind: CreateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAliasErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidAliasNameException(crate::error::InvalidAliasNameException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAliasErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::InvalidAliasNameException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAliasError {
    fn code(&self) -> Option<&str> {
        CreateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAliasError {
    pub fn new(kind: CreateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateAliasErrorKind::AlreadyExistsException(_))
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_alias_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::InvalidAliasNameException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateAliasErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAliasErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateAliasErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAliasErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CreateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAliasErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateAliasErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            CreateAliasErrorKind::InvalidAliasNameException(_inner) => Some(_inner),
            CreateAliasErrorKind::KmsInternalException(_inner) => Some(_inner),
            CreateAliasErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            CreateAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAliasErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomKeyStoreError {
    pub kind: CreateCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomKeyStoreErrorKind {
    CloudHsmClusterInUseException(crate::error::CloudHsmClusterInUseException),
    CloudHsmClusterInvalidConfigurationException(
        crate::error::CloudHsmClusterInvalidConfigurationException,
    ),
    CloudHsmClusterNotActiveException(crate::error::CloudHsmClusterNotActiveException),
    CloudHsmClusterNotFoundException(crate::error::CloudHsmClusterNotFoundException),
    CustomKeyStoreNameInUseException(crate::error::CustomKeyStoreNameInUseException),
    IncorrectTrustAnchorException(crate::error::IncorrectTrustAnchorException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInUseException(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomKeyStoreErrorKind::IncorrectTrustAnchorException(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        CreateCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomKeyStoreError {
    pub fn new(kind: CreateCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cloud_hsm_cluster_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInUseException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_invalid_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundException(_)
        )
    }
    pub fn is_custom_key_store_name_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseException(_)
        )
    }
    pub fn is_incorrect_trust_anchor_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::IncorrectTrustAnchorException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomKeyStoreErrorKind::KmsInternalException(_)
        )
    }
}
impl std::error::Error for CreateCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInUseException(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_inner) => {
                Some(_inner)
            }
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_inner) => {
                Some(_inner)
            }
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundException(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseException(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::IncorrectTrustAnchorException(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::KmsInternalException(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGrantError {
    pub kind: CreateGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGrantErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGrantErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::DisabledException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGrantError {
    fn code(&self) -> Option<&str> {
        CreateGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGrantError {
    pub fn new(kind: CreateGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::DisabledException(_))
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::InvalidArnException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CreateGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGrantErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            CreateGrantErrorKind::DisabledException(_inner) => Some(_inner),
            CreateGrantErrorKind::InvalidArnException(_inner) => Some(_inner),
            CreateGrantErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            CreateGrantErrorKind::KmsInternalException(_inner) => Some(_inner),
            CreateGrantErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            CreateGrantErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateGrantErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateKeyError {
    pub kind: CreateKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateKeyErrorKind {
    CloudHsmClusterInvalidConfigurationException(
        crate::error::CloudHsmClusterInvalidConfigurationException,
    ),
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    TagException(crate::error::TagException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateKeyErrorKind::CloudHsmClusterInvalidConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            CreateKeyErrorKind::CustomKeyStoreInvalidStateException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::CustomKeyStoreNotFoundException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::TagException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateKeyError {
    fn code(&self) -> Option<&str> {
        CreateKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateKeyError {
    pub fn new(kind: CreateKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cloud_hsm_cluster_invalid_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyErrorKind::CloudHsmClusterInvalidConfigurationException(_)
        )
    }
    pub fn is_custom_key_store_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyErrorKind::CustomKeyStoreInvalidStateException(_)
        )
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyErrorKind::KmsInternalException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_tag_exception(&self) -> bool {
        matches!(&self.kind, CreateKeyErrorKind::TagException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateKeyErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for CreateKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateKeyErrorKind::CloudHsmClusterInvalidConfigurationException(_inner) => {
                Some(_inner)
            }
            CreateKeyErrorKind::CustomKeyStoreInvalidStateException(_inner) => Some(_inner),
            CreateKeyErrorKind::CustomKeyStoreNotFoundException(_inner) => Some(_inner),
            CreateKeyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            CreateKeyErrorKind::InvalidArnException(_inner) => Some(_inner),
            CreateKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            CreateKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateKeyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            CreateKeyErrorKind::TagException(_inner) => Some(_inner),
            CreateKeyErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            CreateKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DecryptError {
    pub kind: DecryptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DecryptErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    IncorrectKeyException(crate::error::IncorrectKeyException),
    InvalidCiphertextException(crate::error::InvalidCiphertextException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DecryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DecryptErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            DecryptErrorKind::DisabledException(_inner) => _inner.fmt(f),
            DecryptErrorKind::IncorrectKeyException(_inner) => _inner.fmt(f),
            DecryptErrorKind::InvalidCiphertextException(_inner) => _inner.fmt(f),
            DecryptErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            DecryptErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            DecryptErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            DecryptErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DecryptErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            DecryptErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DecryptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DecryptError {
    fn code(&self) -> Option<&str> {
        DecryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DecryptError {
    pub fn new(kind: DecryptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DecryptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DecryptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::DependencyTimeoutException(_))
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::DisabledException(_))
    }
    pub fn is_incorrect_key_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::IncorrectKeyException(_))
    }
    pub fn is_invalid_ciphertext_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::InvalidCiphertextException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::InvalidGrantTokenException(_))
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::InvalidKeyUsageException(_))
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::KeyUnavailableException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DecryptErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DecryptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DecryptErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            DecryptErrorKind::DisabledException(_inner) => Some(_inner),
            DecryptErrorKind::IncorrectKeyException(_inner) => Some(_inner),
            DecryptErrorKind::InvalidCiphertextException(_inner) => Some(_inner),
            DecryptErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            DecryptErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            DecryptErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            DecryptErrorKind::KmsInternalException(_inner) => Some(_inner),
            DecryptErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            DecryptErrorKind::NotFoundException(_inner) => Some(_inner),
            DecryptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAliasError {
    pub kind: DeleteAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAliasErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAliasErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAliasError {
    pub fn new(kind: DeleteAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAliasErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteAliasErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAliasErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAliasErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAliasErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            DeleteAliasErrorKind::KmsInternalException(_inner) => Some(_inner),
            DeleteAliasErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            DeleteAliasErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomKeyStoreError {
    pub kind: DeleteCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomKeyStoreErrorKind {
    CustomKeyStoreHasCmKsException(crate::error::CustomKeyStoreHasCmKsException),
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreHasCmKsException(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        DeleteCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomKeyStoreError {
    pub fn new(kind: DeleteCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_key_store_has_cm_ks_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreHasCmKsException(_)
        )
    }
    pub fn is_custom_key_store_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_)
        )
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomKeyStoreErrorKind::KmsInternalException(_)
        )
    }
}
impl std::error::Error for DeleteCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreHasCmKsException(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                Some(_inner)
            }
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::KmsInternalException(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteImportedKeyMaterialError {
    pub kind: DeleteImportedKeyMaterialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteImportedKeyMaterialErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteImportedKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteImportedKeyMaterialErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::UnsupportedOperationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteImportedKeyMaterialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteImportedKeyMaterialError {
    fn code(&self) -> Option<&str> {
        DeleteImportedKeyMaterialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteImportedKeyMaterialError {
    pub fn new(kind: DeleteImportedKeyMaterialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteImportedKeyMaterialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteImportedKeyMaterialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportedKeyMaterialErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportedKeyMaterialErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportedKeyMaterialErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportedKeyMaterialErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportedKeyMaterialErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteImportedKeyMaterialErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for DeleteImportedKeyMaterialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteImportedKeyMaterialErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::InvalidArnException(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::KmsInternalException(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::UnsupportedOperationException(_inner) => {
                Some(_inner)
            }
            DeleteImportedKeyMaterialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomKeyStoresError {
    pub kind: DescribeCustomKeyStoresErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomKeyStoresErrorKind {
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    InvalidMarkerException(crate::error::InvalidMarkerException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomKeyStoresError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomKeyStoresErrorKind::CustomKeyStoreNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCustomKeyStoresErrorKind::InvalidMarkerException(_inner) => _inner.fmt(f),
            DescribeCustomKeyStoresErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DescribeCustomKeyStoresErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCustomKeyStoresError {
    fn code(&self) -> Option<&str> {
        DescribeCustomKeyStoresError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomKeyStoresError {
    pub fn new(kind: DescribeCustomKeyStoresErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomKeyStoresErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomKeyStoresErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomKeyStoresErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_invalid_marker_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomKeyStoresErrorKind::InvalidMarkerException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCustomKeyStoresErrorKind::KmsInternalException(_)
        )
    }
}
impl std::error::Error for DescribeCustomKeyStoresError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomKeyStoresErrorKind::CustomKeyStoreNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeCustomKeyStoresErrorKind::InvalidMarkerException(_inner) => Some(_inner),
            DescribeCustomKeyStoresErrorKind::KmsInternalException(_inner) => Some(_inner),
            DescribeCustomKeyStoresErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeKeyError {
    pub kind: DescribeKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeKeyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeKeyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeKeyError {
    fn code(&self) -> Option<&str> {
        DescribeKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeKeyError {
    pub fn new(kind: DescribeKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeKeyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, DescribeKeyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeKeyErrorKind::KmsInternalException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeKeyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DescribeKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeKeyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            DescribeKeyErrorKind::InvalidArnException(_inner) => Some(_inner),
            DescribeKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            DescribeKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableKeyError {
    pub kind: DisableKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableKeyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableKeyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableKeyError {
    fn code(&self) -> Option<&str> {
        DisableKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableKeyError {
    pub fn new(kind: DisableKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, DisableKeyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, DisableKeyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, DisableKeyErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DisableKeyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DisableKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableKeyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            DisableKeyErrorKind::InvalidArnException(_inner) => Some(_inner),
            DisableKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            DisableKeyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            DisableKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            DisableKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableKeyRotationError {
    pub kind: DisableKeyRotationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableKeyRotationErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableKeyRotationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableKeyRotationErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::DisabledException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableKeyRotationError {
    fn code(&self) -> Option<&str> {
        DisableKeyRotationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableKeyRotationError {
    pub fn new(kind: DisableKeyRotationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableKeyRotationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableKeyRotationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::DisabledException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableKeyRotationErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for DisableKeyRotationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableKeyRotationErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::DisabledException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::InvalidArnException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::KmsInternalException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::NotFoundException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisconnectCustomKeyStoreError {
    pub kind: DisconnectCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisconnectCustomKeyStoreErrorKind {
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisconnectCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisconnectCustomKeyStoreErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            DisconnectCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisconnectCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        DisconnectCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisconnectCustomKeyStoreError {
    pub fn new(kind: DisconnectCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisconnectCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisconnectCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_key_store_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_)
        )
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisconnectCustomKeyStoreErrorKind::KmsInternalException(_)
        )
    }
}
impl std::error::Error for DisconnectCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                Some(_inner)
            }
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => {
                Some(_inner)
            }
            DisconnectCustomKeyStoreErrorKind::KmsInternalException(_inner) => Some(_inner),
            DisconnectCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableKeyError {
    pub kind: EnableKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableKeyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableKeyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableKeyError {
    fn code(&self) -> Option<&str> {
        EnableKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableKeyError {
    pub fn new(kind: EnableKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableKeyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for EnableKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableKeyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            EnableKeyErrorKind::InvalidArnException(_inner) => Some(_inner),
            EnableKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            EnableKeyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            EnableKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            EnableKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            EnableKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableKeyRotationError {
    pub kind: EnableKeyRotationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableKeyRotationErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableKeyRotationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableKeyRotationErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::DisabledException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableKeyRotationError {
    fn code(&self) -> Option<&str> {
        EnableKeyRotationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableKeyRotationError {
    pub fn new(kind: EnableKeyRotationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableKeyRotationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableKeyRotationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableKeyRotationErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyRotationErrorKind::DisabledException(_))
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableKeyRotationErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableKeyRotationErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableKeyRotationErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, EnableKeyRotationErrorKind::NotFoundException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableKeyRotationErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for EnableKeyRotationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableKeyRotationErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::DisabledException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::InvalidArnException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::KmsInternalException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::NotFoundException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EncryptError {
    pub kind: EncryptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EncryptErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EncryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EncryptErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            EncryptErrorKind::DisabledException(_inner) => _inner.fmt(f),
            EncryptErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            EncryptErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            EncryptErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            EncryptErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            EncryptErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            EncryptErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            EncryptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EncryptError {
    fn code(&self) -> Option<&str> {
        EncryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EncryptError {
    pub fn new(kind: EncryptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EncryptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EncryptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::DependencyTimeoutException(_))
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::DisabledException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::InvalidGrantTokenException(_))
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::InvalidKeyUsageException(_))
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::KeyUnavailableException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, EncryptErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for EncryptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EncryptErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            EncryptErrorKind::DisabledException(_inner) => Some(_inner),
            EncryptErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            EncryptErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            EncryptErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            EncryptErrorKind::KmsInternalException(_inner) => Some(_inner),
            EncryptErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            EncryptErrorKind::NotFoundException(_inner) => Some(_inner),
            EncryptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyError {
    pub kind: GenerateDataKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::DisabledException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyError {
    pub fn new(kind: GenerateDataKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, GenerateDataKeyErrorKind::DisabledException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyErrorKind::InvalidKeyUsageException(_)
        )
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyErrorKind::KeyUnavailableException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GenerateDataKeyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GenerateDataKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::DisabledException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyPairError {
    pub kind: GenerateDataKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyPairErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyPairErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::DisabledException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyPairError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyPairError {
    pub fn new(kind: GenerateDataKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::DisabledException(_)
        )
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::InvalidKeyUsageException(_)
        )
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::KeyUnavailableException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GenerateDataKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyPairErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::DisabledException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::KmsInternalException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::NotFoundException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyPairWithoutPlaintextError {
    pub kind: GenerateDataKeyPairWithoutPlaintextErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyPairWithoutPlaintextErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyPairWithoutPlaintextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyPairWithoutPlaintextErrorKind::DependencyTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::DisabledException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidGrantTokenException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidKeyUsageException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KmsInternalException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KmsInvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::UnsupportedOperationException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyPairWithoutPlaintextError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyPairWithoutPlaintextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyPairWithoutPlaintextError {
    pub fn new(
        kind: GenerateDataKeyPairWithoutPlaintextErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::DisabledException(_)
        )
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidKeyUsageException(_)
        )
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::KeyUnavailableException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyPairWithoutPlaintextErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GenerateDataKeyPairWithoutPlaintextError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyPairWithoutPlaintextErrorKind::DependencyTimeoutException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::DisabledException(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidGrantTokenException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidKeyUsageException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KmsInternalException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KmsInvalidStateException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::NotFoundException(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextErrorKind::UnsupportedOperationException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyWithoutPlaintextError {
    pub kind: GenerateDataKeyWithoutPlaintextErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyWithoutPlaintextErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyWithoutPlaintextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyWithoutPlaintextErrorKind::DependencyTimeoutException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::DisabledException(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidGrantTokenException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidKeyUsageException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::KeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::KmsInvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyWithoutPlaintextError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyWithoutPlaintextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyWithoutPlaintextError {
    pub fn new(kind: GenerateDataKeyWithoutPlaintextErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::DisabledException(_)
        )
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidKeyUsageException(_)
        )
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::KeyUnavailableException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateDataKeyWithoutPlaintextErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GenerateDataKeyWithoutPlaintextError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyWithoutPlaintextErrorKind::DependencyTimeoutException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::DisabledException(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidGrantTokenException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidKeyUsageException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::KeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::KmsInternalException(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::KmsInvalidStateException(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::NotFoundException(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateRandomError {
    pub kind: GenerateRandomErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateRandomErrorKind {
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateRandomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateRandomErrorKind::CustomKeyStoreInvalidStateException(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::CustomKeyStoreNotFoundException(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateRandomError {
    fn code(&self) -> Option<&str> {
        GenerateRandomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateRandomError {
    pub fn new(kind: GenerateRandomErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateRandomErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateRandomErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_custom_key_store_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateRandomErrorKind::CustomKeyStoreInvalidStateException(_)
        )
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateRandomErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateRandomErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, GenerateRandomErrorKind::KmsInternalException(_))
    }
}
impl std::error::Error for GenerateRandomError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateRandomErrorKind::CustomKeyStoreInvalidStateException(_inner) => Some(_inner),
            GenerateRandomErrorKind::CustomKeyStoreNotFoundException(_inner) => Some(_inner),
            GenerateRandomErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GenerateRandomErrorKind::KmsInternalException(_inner) => Some(_inner),
            GenerateRandomErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetKeyPolicyError {
    pub kind: GetKeyPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyPolicyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetKeyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetKeyPolicyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetKeyPolicyError {
    fn code(&self) -> Option<&str> {
        GetKeyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyPolicyError {
    pub fn new(kind: GetKeyPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetKeyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetKeyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPolicyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPolicyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPolicyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyPolicyErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetKeyPolicyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetKeyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetKeyPolicyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::KmsInternalException(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetKeyRotationStatusError {
    pub kind: GetKeyRotationStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyRotationStatusErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetKeyRotationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetKeyRotationStatusErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetKeyRotationStatusError {
    fn code(&self) -> Option<&str> {
        GetKeyRotationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyRotationStatusError {
    pub fn new(kind: GetKeyRotationStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetKeyRotationStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetKeyRotationStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyRotationStatusErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyRotationStatusErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyRotationStatusErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyRotationStatusErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyRotationStatusErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetKeyRotationStatusErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetKeyRotationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetKeyRotationStatusErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::KmsInternalException(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::NotFoundException(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetParametersForImportError {
    pub kind: GetParametersForImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetParametersForImportErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetParametersForImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetParametersForImportErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetParametersForImportError {
    fn code(&self) -> Option<&str> {
        GetParametersForImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetParametersForImportError {
    pub fn new(kind: GetParametersForImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetParametersForImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetParametersForImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersForImportErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersForImportErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersForImportErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersForImportErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersForImportErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetParametersForImportErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetParametersForImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetParametersForImportErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GetParametersForImportErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetParametersForImportErrorKind::KmsInternalException(_inner) => Some(_inner),
            GetParametersForImportErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            GetParametersForImportErrorKind::NotFoundException(_inner) => Some(_inner),
            GetParametersForImportErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetParametersForImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPublicKeyError {
    pub kind: GetPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPublicKeyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPublicKeyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::DisabledException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPublicKeyError {
    fn code(&self) -> Option<&str> {
        GetPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPublicKeyError {
    pub fn new(kind: GetPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPublicKeyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, GetPublicKeyErrorKind::DisabledException(_))
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, GetPublicKeyErrorKind::InvalidArnException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPublicKeyErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPublicKeyErrorKind::InvalidKeyUsageException(_)
        )
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPublicKeyErrorKind::KeyUnavailableException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, GetPublicKeyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPublicKeyErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPublicKeyErrorKind::NotFoundException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPublicKeyErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for GetPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPublicKeyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::DisabledException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            GetPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportKeyMaterialError {
    pub kind: ImportKeyMaterialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportKeyMaterialErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    ExpiredImportTokenException(crate::error::ExpiredImportTokenException),
    IncorrectKeyMaterialException(crate::error::IncorrectKeyMaterialException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidCiphertextException(crate::error::InvalidCiphertextException),
    InvalidImportTokenException(crate::error::InvalidImportTokenException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportKeyMaterialErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::ExpiredImportTokenException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::IncorrectKeyMaterialException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::InvalidCiphertextException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::InvalidImportTokenException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportKeyMaterialError {
    fn code(&self) -> Option<&str> {
        ImportKeyMaterialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportKeyMaterialError {
    pub fn new(kind: ImportKeyMaterialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportKeyMaterialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportKeyMaterialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_expired_import_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::ExpiredImportTokenException(_)
        )
    }
    pub fn is_incorrect_key_material_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::IncorrectKeyMaterialException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_invalid_ciphertext_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::InvalidCiphertextException(_)
        )
    }
    pub fn is_invalid_import_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::InvalidImportTokenException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ImportKeyMaterialErrorKind::NotFoundException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportKeyMaterialErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for ImportKeyMaterialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportKeyMaterialErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::ExpiredImportTokenException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::IncorrectKeyMaterialException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::InvalidArnException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::InvalidCiphertextException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::InvalidImportTokenException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::KmsInternalException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::NotFoundException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAliasesError {
    pub kind: ListAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAliasesErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidMarkerException(crate::error::InvalidMarkerException),
    KmsInternalException(crate::error::KmsInternalException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAliasesErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::InvalidMarkerException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAliasesError {
    fn code(&self) -> Option<&str> {
        ListAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAliasesError {
    pub fn new(kind: ListAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAliasesErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, ListAliasesErrorKind::InvalidArnException(_))
    }
    pub fn is_invalid_marker_exception(&self) -> bool {
        matches!(&self.kind, ListAliasesErrorKind::InvalidMarkerException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, ListAliasesErrorKind::KmsInternalException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAliasesErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAliasesErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ListAliasesErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListAliasesErrorKind::InvalidMarkerException(_inner) => Some(_inner),
            ListAliasesErrorKind::KmsInternalException(_inner) => Some(_inner),
            ListAliasesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGrantsError {
    pub kind: ListGrantsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGrantsErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidGrantIdException(crate::error::InvalidGrantIdException),
    InvalidMarkerException(crate::error::InvalidMarkerException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGrantsErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::InvalidGrantIdException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::InvalidMarkerException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGrantsError {
    fn code(&self) -> Option<&str> {
        ListGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGrantsError {
    pub fn new(kind: ListGrantsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGrantsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGrantsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGrantsErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, ListGrantsErrorKind::InvalidArnException(_))
    }
    pub fn is_invalid_grant_id_exception(&self) -> bool {
        matches!(&self.kind, ListGrantsErrorKind::InvalidGrantIdException(_))
    }
    pub fn is_invalid_marker_exception(&self) -> bool {
        matches!(&self.kind, ListGrantsErrorKind::InvalidMarkerException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, ListGrantsErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, ListGrantsErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListGrantsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGrantsErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ListGrantsErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListGrantsErrorKind::InvalidGrantIdException(_inner) => Some(_inner),
            ListGrantsErrorKind::InvalidMarkerException(_inner) => Some(_inner),
            ListGrantsErrorKind::KmsInternalException(_inner) => Some(_inner),
            ListGrantsErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            ListGrantsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListGrantsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListKeyPoliciesError {
    pub kind: ListKeyPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKeyPoliciesErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListKeyPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListKeyPoliciesErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListKeyPoliciesError {
    fn code(&self) -> Option<&str> {
        ListKeyPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKeyPoliciesError {
    pub fn new(kind: ListKeyPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListKeyPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListKeyPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKeyPoliciesErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, ListKeyPoliciesErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKeyPoliciesErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKeyPoliciesErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListKeyPoliciesErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListKeyPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListKeyPoliciesErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::KmsInternalException(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListKeysError {
    pub kind: ListKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKeysErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidMarkerException(crate::error::InvalidMarkerException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListKeysErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ListKeysErrorKind::InvalidMarkerException(_inner) => _inner.fmt(f),
            ListKeysErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ListKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListKeysError {
    fn code(&self) -> Option<&str> {
        ListKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKeysError {
    pub fn new(kind: ListKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(&self.kind, ListKeysErrorKind::DependencyTimeoutException(_))
    }
    pub fn is_invalid_marker_exception(&self) -> bool {
        matches!(&self.kind, ListKeysErrorKind::InvalidMarkerException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, ListKeysErrorKind::KmsInternalException(_))
    }
}
impl std::error::Error for ListKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListKeysErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ListKeysErrorKind::InvalidMarkerException(_inner) => Some(_inner),
            ListKeysErrorKind::KmsInternalException(_inner) => Some(_inner),
            ListKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourceTagsError {
    pub kind: ListResourceTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourceTagsErrorKind {
    InvalidArnException(crate::error::InvalidArnException),
    InvalidMarkerException(crate::error::InvalidMarkerException),
    KmsInternalException(crate::error::KmsInternalException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourceTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourceTagsErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::InvalidMarkerException(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourceTagsError {
    fn code(&self) -> Option<&str> {
        ListResourceTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourceTagsError {
    pub fn new(kind: ListResourceTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourceTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourceTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceTagsErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_invalid_marker_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceTagsErrorKind::InvalidMarkerException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceTagsErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListResourceTagsErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListResourceTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourceTagsErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListResourceTagsErrorKind::InvalidMarkerException(_inner) => Some(_inner),
            ListResourceTagsErrorKind::KmsInternalException(_inner) => Some(_inner),
            ListResourceTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListResourceTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRetirableGrantsError {
    pub kind: ListRetirableGrantsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRetirableGrantsErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidMarkerException(crate::error::InvalidMarkerException),
    KmsInternalException(crate::error::KmsInternalException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRetirableGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRetirableGrantsErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::InvalidMarkerException(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRetirableGrantsError {
    fn code(&self) -> Option<&str> {
        ListRetirableGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRetirableGrantsError {
    pub fn new(kind: ListRetirableGrantsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRetirableGrantsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRetirableGrantsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRetirableGrantsErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRetirableGrantsErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_invalid_marker_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRetirableGrantsErrorKind::InvalidMarkerException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRetirableGrantsErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRetirableGrantsErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListRetirableGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRetirableGrantsErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::InvalidMarkerException(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::KmsInternalException(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutKeyPolicyError {
    pub kind: PutKeyPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutKeyPolicyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutKeyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutKeyPolicyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutKeyPolicyError {
    fn code(&self) -> Option<&str> {
        PutKeyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutKeyPolicyError {
    pub fn new(kind: PutKeyPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutKeyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutKeyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutKeyPolicyErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, PutKeyPolicyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, PutKeyPolicyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutKeyPolicyErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutKeyPolicyErrorKind::LimitExceededException(_))
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutKeyPolicyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutKeyPolicyErrorKind::NotFoundException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutKeyPolicyErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for PutKeyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutKeyPolicyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::InvalidArnException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::KmsInternalException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::NotFoundException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReEncryptError {
    pub kind: ReEncryptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReEncryptErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    IncorrectKeyException(crate::error::IncorrectKeyException),
    InvalidCiphertextException(crate::error::InvalidCiphertextException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReEncryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReEncryptErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::DisabledException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::IncorrectKeyException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::InvalidCiphertextException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReEncryptError {
    fn code(&self) -> Option<&str> {
        ReEncryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReEncryptError {
    pub fn new(kind: ReEncryptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReEncryptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReEncryptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReEncryptErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::DisabledException(_))
    }
    pub fn is_incorrect_key_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::IncorrectKeyException(_))
    }
    pub fn is_invalid_ciphertext_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReEncryptErrorKind::InvalidCiphertextException(_)
        )
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReEncryptErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::InvalidKeyUsageException(_))
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::KeyUnavailableException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ReEncryptErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ReEncryptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReEncryptErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ReEncryptErrorKind::DisabledException(_inner) => Some(_inner),
            ReEncryptErrorKind::IncorrectKeyException(_inner) => Some(_inner),
            ReEncryptErrorKind::InvalidCiphertextException(_inner) => Some(_inner),
            ReEncryptErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            ReEncryptErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            ReEncryptErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            ReEncryptErrorKind::KmsInternalException(_inner) => Some(_inner),
            ReEncryptErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            ReEncryptErrorKind::NotFoundException(_inner) => Some(_inner),
            ReEncryptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReplicateKeyError {
    pub kind: ReplicateKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReplicateKeyErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    DisabledException(crate::error::DisabledException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedPolicyDocumentException(crate::error::MalformedPolicyDocumentException),
    NotFoundException(crate::error::NotFoundException),
    TagException(crate::error::TagException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReplicateKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReplicateKeyErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::DisabledException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::MalformedPolicyDocumentException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::TagException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            ReplicateKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReplicateKeyError {
    fn code(&self) -> Option<&str> {
        ReplicateKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReplicateKeyError {
    pub fn new(kind: ReplicateKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReplicateKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReplicateKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::AlreadyExistsException(_))
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::DisabledException(_))
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateKeyErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateKeyErrorKind::MalformedPolicyDocumentException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::NotFoundException(_))
    }
    pub fn is_tag_exception(&self) -> bool {
        matches!(&self.kind, ReplicateKeyErrorKind::TagException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateKeyErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for ReplicateKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReplicateKeyErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::DisabledException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::InvalidArnException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::KmsInternalException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::MalformedPolicyDocumentException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::TagException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            ReplicateKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RetireGrantError {
    pub kind: RetireGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RetireGrantErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidGrantIdException(crate::error::InvalidGrantIdException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RetireGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RetireGrantErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::InvalidGrantIdException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RetireGrantError {
    fn code(&self) -> Option<&str> {
        RetireGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RetireGrantError {
    pub fn new(kind: RetireGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RetireGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RetireGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            RetireGrantErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, RetireGrantErrorKind::InvalidArnException(_))
    }
    pub fn is_invalid_grant_id_exception(&self) -> bool {
        matches!(&self.kind, RetireGrantErrorKind::InvalidGrantIdException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            RetireGrantErrorKind::InvalidGrantTokenException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, RetireGrantErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RetireGrantErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RetireGrantErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for RetireGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RetireGrantErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            RetireGrantErrorKind::InvalidArnException(_inner) => Some(_inner),
            RetireGrantErrorKind::InvalidGrantIdException(_inner) => Some(_inner),
            RetireGrantErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            RetireGrantErrorKind::KmsInternalException(_inner) => Some(_inner),
            RetireGrantErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            RetireGrantErrorKind::NotFoundException(_inner) => Some(_inner),
            RetireGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeGrantError {
    pub kind: RevokeGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeGrantErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    InvalidGrantIdException(crate::error::InvalidGrantIdException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeGrantErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::InvalidGrantIdException(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeGrantError {
    fn code(&self) -> Option<&str> {
        RevokeGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeGrantError {
    pub fn new(kind: RevokeGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeGrantErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, RevokeGrantErrorKind::InvalidArnException(_))
    }
    pub fn is_invalid_grant_id_exception(&self) -> bool {
        matches!(&self.kind, RevokeGrantErrorKind::InvalidGrantIdException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, RevokeGrantErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeGrantErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RevokeGrantErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for RevokeGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeGrantErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            RevokeGrantErrorKind::InvalidArnException(_inner) => Some(_inner),
            RevokeGrantErrorKind::InvalidGrantIdException(_inner) => Some(_inner),
            RevokeGrantErrorKind::KmsInternalException(_inner) => Some(_inner),
            RevokeGrantErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            RevokeGrantErrorKind::NotFoundException(_inner) => Some(_inner),
            RevokeGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ScheduleKeyDeletionError {
    pub kind: ScheduleKeyDeletionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ScheduleKeyDeletionErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ScheduleKeyDeletionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ScheduleKeyDeletionErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ScheduleKeyDeletionError {
    fn code(&self) -> Option<&str> {
        ScheduleKeyDeletionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ScheduleKeyDeletionError {
    pub fn new(kind: ScheduleKeyDeletionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ScheduleKeyDeletionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ScheduleKeyDeletionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            ScheduleKeyDeletionErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ScheduleKeyDeletionErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ScheduleKeyDeletionErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ScheduleKeyDeletionErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ScheduleKeyDeletionErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ScheduleKeyDeletionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ScheduleKeyDeletionErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::InvalidArnException(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::KmsInternalException(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::NotFoundException(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignError {
    pub kind: SignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SignErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            SignErrorKind::DisabledException(_inner) => _inner.fmt(f),
            SignErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            SignErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            SignErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            SignErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            SignErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            SignErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SignError {
    fn code(&self) -> Option<&str> {
        SignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignError {
    pub fn new(kind: SignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::DependencyTimeoutException(_))
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::DisabledException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::InvalidGrantTokenException(_))
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::InvalidKeyUsageException(_))
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::KeyUnavailableException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, SignErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for SignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SignErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            SignErrorKind::DisabledException(_inner) => Some(_inner),
            SignErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            SignErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            SignErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            SignErrorKind::KmsInternalException(_inner) => Some(_inner),
            SignErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            SignErrorKind::NotFoundException(_inner) => Some(_inner),
            SignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TagException(crate::error::TagException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_tag_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TagException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidArnException(_inner) => Some(_inner),
            TagResourceErrorKind::KmsInternalException(_inner) => Some(_inner),
            TagResourceErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::TagException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    TagException(crate::error::TagException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidArnException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_tag_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TagException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidArnException(_inner) => Some(_inner),
            UntagResourceErrorKind::KmsInternalException(_inner) => Some(_inner),
            UntagResourceErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::TagException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAliasError {
    pub kind: UpdateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAliasErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAliasErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAliasError {
    fn code(&self) -> Option<&str> {
        UpdateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAliasError {
    pub fn new(kind: UpdateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, UpdateAliasErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAliasErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateAliasErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateAliasErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UpdateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAliasErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            UpdateAliasErrorKind::KmsInternalException(_inner) => Some(_inner),
            UpdateAliasErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            UpdateAliasErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAliasErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCustomKeyStoreError {
    pub kind: UpdateCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCustomKeyStoreErrorKind {
    CloudHsmClusterInvalidConfigurationException(
        crate::error::CloudHsmClusterInvalidConfigurationException,
    ),
    CloudHsmClusterNotActiveException(crate::error::CloudHsmClusterNotActiveException),
    CloudHsmClusterNotFoundException(crate::error::CloudHsmClusterNotFoundException),
    CloudHsmClusterNotRelatedException(crate::error::CloudHsmClusterNotRelatedException),
    CustomKeyStoreInvalidStateException(crate::error::CustomKeyStoreInvalidStateException),
    CustomKeyStoreNameInUseException(crate::error::CustomKeyStoreNameInUseException),
    CustomKeyStoreNotFoundException(crate::error::CustomKeyStoreNotFoundException),
    KmsInternalException(crate::error::KmsInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotRelatedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        UpdateCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCustomKeyStoreError {
    pub fn new(kind: UpdateCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cloud_hsm_cluster_invalid_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_not_active_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundException(_)
        )
    }
    pub fn is_cloud_hsm_cluster_not_related_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotRelatedException(_)
        )
    }
    pub fn is_custom_key_store_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_)
        )
    }
    pub fn is_custom_key_store_name_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseException(_)
        )
    }
    pub fn is_custom_key_store_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomKeyStoreErrorKind::KmsInternalException(_)
        )
    }
}
impl std::error::Error for UpdateCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationException(_inner) => {
                Some(_inner)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveException(_inner) => {
                Some(_inner)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundException(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotRelatedException(_inner) => {
                Some(_inner)
            }
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateException(_inner) => {
                Some(_inner)
            }
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseException(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNotFoundException(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::KmsInternalException(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateKeyDescriptionError {
    pub kind: UpdateKeyDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateKeyDescriptionErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateKeyDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateKeyDescriptionErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateKeyDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateKeyDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateKeyDescriptionError {
    pub fn new(kind: UpdateKeyDescriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateKeyDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateKeyDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateKeyDescriptionErrorKind::DependencyTimeoutException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateKeyDescriptionErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateKeyDescriptionErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateKeyDescriptionErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateKeyDescriptionErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateKeyDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateKeyDescriptionErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::InvalidArnException(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::KmsInternalException(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePrimaryRegionError {
    pub kind: UpdatePrimaryRegionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePrimaryRegionErrorKind {
    DisabledException(crate::error::DisabledException),
    InvalidArnException(crate::error::InvalidArnException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePrimaryRegionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePrimaryRegionErrorKind::DisabledException(_inner) => _inner.fmt(f),
            UpdatePrimaryRegionErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            UpdatePrimaryRegionErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            UpdatePrimaryRegionErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            UpdatePrimaryRegionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdatePrimaryRegionErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            UpdatePrimaryRegionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePrimaryRegionError {
    fn code(&self) -> Option<&str> {
        UpdatePrimaryRegionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePrimaryRegionError {
    pub fn new(kind: UpdatePrimaryRegionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePrimaryRegionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePrimaryRegionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePrimaryRegionErrorKind::DisabledException(_)
        )
    }
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePrimaryRegionErrorKind::InvalidArnException(_)
        )
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePrimaryRegionErrorKind::KmsInternalException(_)
        )
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePrimaryRegionErrorKind::KmsInvalidStateException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePrimaryRegionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePrimaryRegionErrorKind::UnsupportedOperationException(_)
        )
    }
}
impl std::error::Error for UpdatePrimaryRegionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePrimaryRegionErrorKind::DisabledException(_inner) => Some(_inner),
            UpdatePrimaryRegionErrorKind::InvalidArnException(_inner) => Some(_inner),
            UpdatePrimaryRegionErrorKind::KmsInternalException(_inner) => Some(_inner),
            UpdatePrimaryRegionErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            UpdatePrimaryRegionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdatePrimaryRegionErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            UpdatePrimaryRegionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct VerifyError {
    pub kind: VerifyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum VerifyErrorKind {
    DependencyTimeoutException(crate::error::DependencyTimeoutException),
    DisabledException(crate::error::DisabledException),
    InvalidGrantTokenException(crate::error::InvalidGrantTokenException),
    InvalidKeyUsageException(crate::error::InvalidKeyUsageException),
    KeyUnavailableException(crate::error::KeyUnavailableException),
    KmsInternalException(crate::error::KmsInternalException),
    KmsInvalidSignatureException(crate::error::KmsInvalidSignatureException),
    KmsInvalidStateException(crate::error::KmsInvalidStateException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for VerifyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            VerifyErrorKind::DependencyTimeoutException(_inner) => _inner.fmt(f),
            VerifyErrorKind::DisabledException(_inner) => _inner.fmt(f),
            VerifyErrorKind::InvalidGrantTokenException(_inner) => _inner.fmt(f),
            VerifyErrorKind::InvalidKeyUsageException(_inner) => _inner.fmt(f),
            VerifyErrorKind::KeyUnavailableException(_inner) => _inner.fmt(f),
            VerifyErrorKind::KmsInternalException(_inner) => _inner.fmt(f),
            VerifyErrorKind::KmsInvalidSignatureException(_inner) => _inner.fmt(f),
            VerifyErrorKind::KmsInvalidStateException(_inner) => _inner.fmt(f),
            VerifyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            VerifyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for VerifyError {
    fn code(&self) -> Option<&str> {
        VerifyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl VerifyError {
    pub fn new(kind: VerifyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: VerifyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: VerifyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_dependency_timeout_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::DependencyTimeoutException(_))
    }
    pub fn is_disabled_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::DisabledException(_))
    }
    pub fn is_invalid_grant_token_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::InvalidGrantTokenException(_))
    }
    pub fn is_invalid_key_usage_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::InvalidKeyUsageException(_))
    }
    pub fn is_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::KeyUnavailableException(_))
    }
    pub fn is_kms_internal_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::KmsInternalException(_))
    }
    pub fn is_kms_invalid_signature_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::KmsInvalidSignatureException(_))
    }
    pub fn is_kms_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::KmsInvalidStateException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, VerifyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for VerifyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            VerifyErrorKind::DependencyTimeoutException(_inner) => Some(_inner),
            VerifyErrorKind::DisabledException(_inner) => Some(_inner),
            VerifyErrorKind::InvalidGrantTokenException(_inner) => Some(_inner),
            VerifyErrorKind::InvalidKeyUsageException(_inner) => Some(_inner),
            VerifyErrorKind::KeyUnavailableException(_inner) => Some(_inner),
            VerifyErrorKind::KmsInternalException(_inner) => Some(_inner),
            VerifyErrorKind::KmsInvalidSignatureException(_inner) => Some(_inner),
            VerifyErrorKind::KmsInvalidStateException(_inner) => Some(_inner),
            VerifyErrorKind::NotFoundException(_inner) => Some(_inner),
            VerifyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request was rejected because the specified entity or resource could not be
/// found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The request was rejected because the state of the specified resource is not valid for this
/// request.</p>
/// <p>For more information about how key state affects the use of a CMK, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a> in the <i>
/// <i>AWS Key Management Service Developer Guide</i>
/// </i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsInvalidStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsInvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsInvalidStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsInvalidStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsInvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsInvalidStateException [KMSInvalidStateException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsInvalidStateException {}
/// See [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
pub mod kms_invalid_state_exception {
    /// A builder for [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
        pub fn build(self) -> crate::error::KmsInvalidStateException {
            crate::error::KmsInvalidStateException {
                message: self.message,
            }
        }
    }
}
impl KmsInvalidStateException {
    /// Creates a new builder-style object to manufacture [`KmsInvalidStateException`](crate::error::KmsInvalidStateException)
    pub fn builder() -> crate::error::kms_invalid_state_exception::Builder {
        crate::error::kms_invalid_state_exception::Builder::default()
    }
}

/// <p>The request was rejected because the signature verification failed. Signature verification
/// fails when it cannot confirm that signature was produced by signing the specified message with
/// the specified CMK and signing algorithm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsInvalidSignatureException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsInvalidSignatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsInvalidSignatureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsInvalidSignatureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsInvalidSignatureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "KmsInvalidSignatureException [KMSInvalidSignatureException]"
        )?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsInvalidSignatureException {}
/// See [`KmsInvalidSignatureException`](crate::error::KmsInvalidSignatureException)
pub mod kms_invalid_signature_exception {
    /// A builder for [`KmsInvalidSignatureException`](crate::error::KmsInvalidSignatureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsInvalidSignatureException`](crate::error::KmsInvalidSignatureException)
        pub fn build(self) -> crate::error::KmsInvalidSignatureException {
            crate::error::KmsInvalidSignatureException {
                message: self.message,
            }
        }
    }
}
impl KmsInvalidSignatureException {
    /// Creates a new builder-style object to manufacture [`KmsInvalidSignatureException`](crate::error::KmsInvalidSignatureException)
    pub fn builder() -> crate::error::kms_invalid_signature_exception::Builder {
        crate::error::kms_invalid_signature_exception::Builder::default()
    }
}

/// <p>The request was rejected because an internal exception occurred. The request can be
/// retried.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KmsInternalException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KmsInternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KmsInternalException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KmsInternalException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsInternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsInternalException [KMSInternalException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for KmsInternalException {}
/// See [`KmsInternalException`](crate::error::KmsInternalException)
pub mod kms_internal_exception {
    /// A builder for [`KmsInternalException`](crate::error::KmsInternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsInternalException`](crate::error::KmsInternalException)
        pub fn build(self) -> crate::error::KmsInternalException {
            crate::error::KmsInternalException {
                message: self.message,
            }
        }
    }
}
impl KmsInternalException {
    /// Creates a new builder-style object to manufacture [`KmsInternalException`](crate::error::KmsInternalException)
    pub fn builder() -> crate::error::kms_internal_exception::Builder {
        crate::error::kms_internal_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK was not available. You can retry the
/// request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KeyUnavailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeyUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KeyUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyUnavailableException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for KeyUnavailableException {}
/// See [`KeyUnavailableException`](crate::error::KeyUnavailableException)
pub mod key_unavailable_exception {
    /// A builder for [`KeyUnavailableException`](crate::error::KeyUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`KeyUnavailableException`](crate::error::KeyUnavailableException)
        pub fn build(self) -> crate::error::KeyUnavailableException {
            crate::error::KeyUnavailableException {
                message: self.message,
            }
        }
    }
}
impl KeyUnavailableException {
    /// Creates a new builder-style object to manufacture [`KeyUnavailableException`](crate::error::KeyUnavailableException)
    pub fn builder() -> crate::error::key_unavailable_exception::Builder {
        crate::error::key_unavailable_exception::Builder::default()
    }
}

/// <p>The request was rejected for one of the following reasons: </p>
/// <ul>
/// <li>
/// <p>The <code>KeyUsage</code> value of the CMK is incompatible with the API
/// operation.</p>
/// </li>
/// <li>
/// <p>The encryption algorithm or signing algorithm specified for the operation is
/// incompatible with the type of key material in the CMK
/// <code>(CustomerMasterKeySpec</code>).</p>
/// </li>
/// </ul>
/// <p>For encrypting, decrypting, re-encrypting, and generating data keys, the
/// <code>KeyUsage</code> must be <code>ENCRYPT_DECRYPT</code>. For signing and verifying, the
/// <code>KeyUsage</code> must be <code>SIGN_VERIFY</code>. To find the <code>KeyUsage</code> of
/// a CMK, use the <a>DescribeKey</a> operation.</p>
/// <p>To find the encryption or signing algorithms supported for a particular CMK, use the <a>DescribeKey</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidKeyUsageException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidKeyUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidKeyUsageException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidKeyUsageException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKeyUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKeyUsageException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKeyUsageException {}
/// See [`InvalidKeyUsageException`](crate::error::InvalidKeyUsageException)
pub mod invalid_key_usage_exception {
    /// A builder for [`InvalidKeyUsageException`](crate::error::InvalidKeyUsageException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKeyUsageException`](crate::error::InvalidKeyUsageException)
        pub fn build(self) -> crate::error::InvalidKeyUsageException {
            crate::error::InvalidKeyUsageException {
                message: self.message,
            }
        }
    }
}
impl InvalidKeyUsageException {
    /// Creates a new builder-style object to manufacture [`InvalidKeyUsageException`](crate::error::InvalidKeyUsageException)
    pub fn builder() -> crate::error::invalid_key_usage_exception::Builder {
        crate::error::invalid_key_usage_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified grant token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGrantTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGrantTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGrantTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGrantTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGrantTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGrantTokenException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGrantTokenException {}
/// See [`InvalidGrantTokenException`](crate::error::InvalidGrantTokenException)
pub mod invalid_grant_token_exception {
    /// A builder for [`InvalidGrantTokenException`](crate::error::InvalidGrantTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGrantTokenException`](crate::error::InvalidGrantTokenException)
        pub fn build(self) -> crate::error::InvalidGrantTokenException {
            crate::error::InvalidGrantTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidGrantTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidGrantTokenException`](crate::error::InvalidGrantTokenException)
    pub fn builder() -> crate::error::invalid_grant_token_exception::Builder {
        crate::error::invalid_grant_token_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK is not enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisabledException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DisabledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DisabledException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for DisabledException {}
/// See [`DisabledException`](crate::error::DisabledException)
pub mod disabled_exception {
    /// A builder for [`DisabledException`](crate::error::DisabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DisabledException`](crate::error::DisabledException)
        pub fn build(self) -> crate::error::DisabledException {
            crate::error::DisabledException {
                message: self.message,
            }
        }
    }
}
impl DisabledException {
    /// Creates a new builder-style object to manufacture [`DisabledException`](crate::error::DisabledException)
    pub fn builder() -> crate::error::disabled_exception::Builder {
        crate::error::disabled_exception::Builder::default()
    }
}

/// <p>The system timed out while trying to fulfill the request. The request can be
/// retried.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DependencyTimeoutException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DependencyTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DependencyTimeoutException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DependencyTimeoutException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DependencyTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependencyTimeoutException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for DependencyTimeoutException {}
/// See [`DependencyTimeoutException`](crate::error::DependencyTimeoutException)
pub mod dependency_timeout_exception {
    /// A builder for [`DependencyTimeoutException`](crate::error::DependencyTimeoutException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DependencyTimeoutException`](crate::error::DependencyTimeoutException)
        pub fn build(self) -> crate::error::DependencyTimeoutException {
            crate::error::DependencyTimeoutException {
                message: self.message,
            }
        }
    }
}
impl DependencyTimeoutException {
    /// Creates a new builder-style object to manufacture [`DependencyTimeoutException`](crate::error::DependencyTimeoutException)
    pub fn builder() -> crate::error::dependency_timeout_exception::Builder {
        crate::error::dependency_timeout_exception::Builder::default()
    }
}

/// <p>The request was rejected because a specified parameter is not supported or a specified
/// resource is not valid for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedOperationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperationException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperationException {}
/// See [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
pub mod unsupported_operation_exception {
    /// A builder for [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
        pub fn build(self) -> crate::error::UnsupportedOperationException {
            crate::error::UnsupportedOperationException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperationException {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
    pub fn builder() -> crate::error::unsupported_operation_exception::Builder {
        crate::error::unsupported_operation_exception::Builder::default()
    }
}

/// <p>The request was rejected because a specified ARN, or an ARN in a key policy, is not
/// valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidArnException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArnException {}
/// See [`InvalidArnException`](crate::error::InvalidArnException)
pub mod invalid_arn_exception {
    /// A builder for [`InvalidArnException`](crate::error::InvalidArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnException`](crate::error::InvalidArnException)
        pub fn build(self) -> crate::error::InvalidArnException {
            crate::error::InvalidArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidArnException {
    /// Creates a new builder-style object to manufacture [`InvalidArnException`](crate::error::InvalidArnException)
    pub fn builder() -> crate::error::invalid_arn_exception::Builder {
        crate::error::invalid_arn_exception::Builder::default()
    }
}

/// <p>The request was rejected because AWS KMS cannot find a custom key store with the specified
/// key store name or ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreNotFoundException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreNotFoundException {}
/// See [`CustomKeyStoreNotFoundException`](crate::error::CustomKeyStoreNotFoundException)
pub mod custom_key_store_not_found_exception {
    /// A builder for [`CustomKeyStoreNotFoundException`](crate::error::CustomKeyStoreNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreNotFoundException`](crate::error::CustomKeyStoreNotFoundException)
        pub fn build(self) -> crate::error::CustomKeyStoreNotFoundException {
            crate::error::CustomKeyStoreNotFoundException {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreNotFoundException {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreNotFoundException`](crate::error::CustomKeyStoreNotFoundException)
    pub fn builder() -> crate::error::custom_key_store_not_found_exception::Builder {
        crate::error::custom_key_store_not_found_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified custom key store name is already assigned
/// to another custom key store in the account. Try again with a custom key store name that is
/// unique in the account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreNameInUseException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreNameInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreNameInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreNameInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreNameInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreNameInUseException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreNameInUseException {}
/// See [`CustomKeyStoreNameInUseException`](crate::error::CustomKeyStoreNameInUseException)
pub mod custom_key_store_name_in_use_exception {
    /// A builder for [`CustomKeyStoreNameInUseException`](crate::error::CustomKeyStoreNameInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreNameInUseException`](crate::error::CustomKeyStoreNameInUseException)
        pub fn build(self) -> crate::error::CustomKeyStoreNameInUseException {
            crate::error::CustomKeyStoreNameInUseException {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreNameInUseException {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreNameInUseException`](crate::error::CustomKeyStoreNameInUseException)
    pub fn builder() -> crate::error::custom_key_store_name_in_use_exception::Builder {
        crate::error::custom_key_store_name_in_use_exception::Builder::default()
    }
}

/// <p>The request was rejected because of the <code>ConnectionState</code> of the custom key
/// store. To get the <code>ConnectionState</code> of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
/// <p>This exception is thrown under the following conditions:</p>
/// <ul>
/// <li>
/// <p>You requested the <a>CreateKey</a> or <a>GenerateRandom</a>
/// operation in a custom key store that is not connected. These operations are valid only
/// when the custom key store <code>ConnectionState</code> is <code>CONNECTED</code>.</p>
/// </li>
/// <li>
/// <p>You requested the <a>UpdateCustomKeyStore</a> or <a>DeleteCustomKeyStore</a> operation on a custom key store that is not
/// disconnected. This operation is valid only when the custom key store
/// <code>ConnectionState</code> is <code>DISCONNECTED</code>.</p>
/// </li>
/// <li>
/// <p>You requested the <a>ConnectCustomKeyStore</a> operation on a custom key
/// store with a <code>ConnectionState</code> of <code>DISCONNECTING</code> or
/// <code>FAILED</code>. This operation is valid for all other <code>ConnectionState</code>
/// values.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreInvalidStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreInvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreInvalidStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreInvalidStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreInvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreInvalidStateException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreInvalidStateException {}
/// See [`CustomKeyStoreInvalidStateException`](crate::error::CustomKeyStoreInvalidStateException)
pub mod custom_key_store_invalid_state_exception {
    /// A builder for [`CustomKeyStoreInvalidStateException`](crate::error::CustomKeyStoreInvalidStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreInvalidStateException`](crate::error::CustomKeyStoreInvalidStateException)
        pub fn build(self) -> crate::error::CustomKeyStoreInvalidStateException {
            crate::error::CustomKeyStoreInvalidStateException {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreInvalidStateException {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreInvalidStateException`](crate::error::CustomKeyStoreInvalidStateException)
    pub fn builder() -> crate::error::custom_key_store_invalid_state_exception::Builder {
        crate::error::custom_key_store_invalid_state_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster has a different cluster
/// certificate than the original cluster. You cannot use the operation to specify an unrelated
/// cluster.</p>
/// <p>Specify a cluster that shares a backup history with the original cluster. This includes
/// clusters that were created from a backup of the current cluster, and clusters that were
/// created from the same backup that produced the current cluster.</p>
/// <p>Clusters that share a backup history have the same cluster certificate. To view the
/// cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterNotRelatedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterNotRelatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotRelatedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotRelatedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterNotRelatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterNotRelatedException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterNotRelatedException {}
/// See [`CloudHsmClusterNotRelatedException`](crate::error::CloudHsmClusterNotRelatedException)
pub mod cloud_hsm_cluster_not_related_exception {
    /// A builder for [`CloudHsmClusterNotRelatedException`](crate::error::CloudHsmClusterNotRelatedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotRelatedException`](crate::error::CloudHsmClusterNotRelatedException)
        pub fn build(self) -> crate::error::CloudHsmClusterNotRelatedException {
            crate::error::CloudHsmClusterNotRelatedException {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotRelatedException {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotRelatedException`](crate::error::CloudHsmClusterNotRelatedException)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_related_exception::Builder {
        crate::error::cloud_hsm_cluster_not_related_exception::Builder::default()
    }
}

/// <p>The request was rejected because AWS KMS cannot find the AWS CloudHSM cluster with the specified
/// cluster ID. Retry the request with a different cluster ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterNotFoundException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterNotFoundException {}
/// See [`CloudHsmClusterNotFoundException`](crate::error::CloudHsmClusterNotFoundException)
pub mod cloud_hsm_cluster_not_found_exception {
    /// A builder for [`CloudHsmClusterNotFoundException`](crate::error::CloudHsmClusterNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotFoundException`](crate::error::CloudHsmClusterNotFoundException)
        pub fn build(self) -> crate::error::CloudHsmClusterNotFoundException {
            crate::error::CloudHsmClusterNotFoundException {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotFoundException {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotFoundException`](crate::error::CloudHsmClusterNotFoundException)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_found_exception::Builder {
        crate::error::cloud_hsm_cluster_not_found_exception::Builder::default()
    }
}

/// <p>The request was rejected because the AWS CloudHSM cluster that is associated with the custom key
/// store is not active. Initialize and activate the cluster and try the command again. For
/// detailed instructions, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/getting-started.html">Getting Started</a> in the <i>AWS CloudHSM User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterNotActiveException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterNotActiveException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotActiveException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotActiveException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterNotActiveException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterNotActiveException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterNotActiveException {}
/// See [`CloudHsmClusterNotActiveException`](crate::error::CloudHsmClusterNotActiveException)
pub mod cloud_hsm_cluster_not_active_exception {
    /// A builder for [`CloudHsmClusterNotActiveException`](crate::error::CloudHsmClusterNotActiveException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotActiveException`](crate::error::CloudHsmClusterNotActiveException)
        pub fn build(self) -> crate::error::CloudHsmClusterNotActiveException {
            crate::error::CloudHsmClusterNotActiveException {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotActiveException {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotActiveException`](crate::error::CloudHsmClusterNotActiveException)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_active_exception::Builder {
        crate::error::cloud_hsm_cluster_not_active_exception::Builder::default()
    }
}

/// <p>The request was rejected because the associated AWS CloudHSM cluster did not meet the
/// configuration requirements for a custom key store.</p>
/// <ul>
/// <li>
/// <p>The cluster must be configured with private subnets in at least two different
/// Availability Zones in the Region.</p>
/// </li>
/// <li>
/// <p>The <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">security group for
/// the cluster</a> (cloudhsm-cluster-<i><cluster-id></i>-sg) must
/// include inbound rules and outbound rules that allow TCP traffic on ports 2223-2225. The
/// <b>Source</b> in the inbound rules and the <b>Destination</b> in the outbound rules must match the security group
/// ID. These rules are set by default when you create the cluster. Do not delete or change
/// them. To get information about a particular security group, use the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html">DescribeSecurityGroups</a> operation.</p>
/// </li>
/// <li>
/// <p>The cluster must contain at least as many HSMs as the operation requires. To add HSMs,
/// use the AWS CloudHSM <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_CreateHsm.html">CreateHsm</a> operation.</p>
/// <p>For the <a>CreateCustomKeyStore</a>, <a>UpdateCustomKeyStore</a>, and <a>CreateKey</a> operations, the AWS CloudHSM cluster must have at least two
/// active HSMs, each in a different Availability Zone. For the <a>ConnectCustomKeyStore</a> operation, the AWS CloudHSM must contain at least one active
/// HSM.</p>
/// </li>
/// </ul>
/// <p>For information about the requirements for an AWS CloudHSM cluster that is associated with a
/// custom key store, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">Assemble the Prerequisites</a>
/// in the <i>AWS Key Management Service Developer Guide</i>. For information about creating a private subnet for an AWS CloudHSM cluster,
/// see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/create-subnets.html">Create a Private
/// Subnet</a> in the <i>AWS CloudHSM User Guide</i>. For information about cluster security groups, see
/// <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">Configure a Default Security
/// Group</a> in the <i>
/// <i>AWS CloudHSM User Guide</i>
/// </i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterInvalidConfigurationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterInvalidConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterInvalidConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterInvalidConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterInvalidConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterInvalidConfigurationException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterInvalidConfigurationException {}
/// See [`CloudHsmClusterInvalidConfigurationException`](crate::error::CloudHsmClusterInvalidConfigurationException)
pub mod cloud_hsm_cluster_invalid_configuration_exception {
    /// A builder for [`CloudHsmClusterInvalidConfigurationException`](crate::error::CloudHsmClusterInvalidConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterInvalidConfigurationException`](crate::error::CloudHsmClusterInvalidConfigurationException)
        pub fn build(self) -> crate::error::CloudHsmClusterInvalidConfigurationException {
            crate::error::CloudHsmClusterInvalidConfigurationException {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterInvalidConfigurationException {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterInvalidConfigurationException`](crate::error::CloudHsmClusterInvalidConfigurationException)
    pub fn builder() -> crate::error::cloud_hsm_cluster_invalid_configuration_exception::Builder {
        crate::error::cloud_hsm_cluster_invalid_configuration_exception::Builder::default()
    }
}

/// <p>The request was rejected because a quota was exceeded. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html">Quotas</a> in the
/// <i>AWS Key Management Service Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request was rejected because one or more tags are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagException {}
/// See [`TagException`](crate::error::TagException)
pub mod tag_exception {
    /// A builder for [`TagException`](crate::error::TagException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagException`](crate::error::TagException)
        pub fn build(self) -> crate::error::TagException {
            crate::error::TagException {
                message: self.message,
            }
        }
    }
}
impl TagException {
    /// Creates a new builder-style object to manufacture [`TagException`](crate::error::TagException)
    pub fn builder() -> crate::error::tag_exception::Builder {
        crate::error::tag_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified <code>GrantId</code> is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGrantIdException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGrantIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGrantIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGrantIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGrantIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGrantIdException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGrantIdException {}
/// See [`InvalidGrantIdException`](crate::error::InvalidGrantIdException)
pub mod invalid_grant_id_exception {
    /// A builder for [`InvalidGrantIdException`](crate::error::InvalidGrantIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGrantIdException`](crate::error::InvalidGrantIdException)
        pub fn build(self) -> crate::error::InvalidGrantIdException {
            crate::error::InvalidGrantIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidGrantIdException {
    /// Creates a new builder-style object to manufacture [`InvalidGrantIdException`](crate::error::InvalidGrantIdException)
    pub fn builder() -> crate::error::invalid_grant_id_exception::Builder {
        crate::error::invalid_grant_id_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified policy is not syntactically or semantically
/// correct.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyDocumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedPolicyDocumentException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentException {}
/// See [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
pub mod malformed_policy_document_exception {
    /// A builder for [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentException {
            crate::error::MalformedPolicyDocumentException {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentException {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentException`](crate::error::MalformedPolicyDocumentException)
    pub fn builder() -> crate::error::malformed_policy_document_exception::Builder {
        crate::error::malformed_policy_document_exception::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
/// exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsException {}
/// See [`AlreadyExistsException`](crate::error::AlreadyExistsException)
pub mod already_exists_exception {
    /// A builder for [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsException`](crate::error::AlreadyExistsException)
        pub fn build(self) -> crate::error::AlreadyExistsException {
            crate::error::AlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    pub fn builder() -> crate::error::already_exists_exception::Builder {
        crate::error::already_exists_exception::Builder::default()
    }
}

/// <p>From the <a>Decrypt</a> or <a>ReEncrypt</a> operation, the request
/// was rejected because the specified ciphertext, or additional authenticated data incorporated
/// into the ciphertext, such as the encryption context, is corrupted, missing, or otherwise
/// invalid.</p>
/// <p>From the <a>ImportKeyMaterial</a> operation, the request was rejected because
/// AWS KMS could not decrypt the encrypted (wrapped) key material. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCiphertextException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCiphertextException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCiphertextException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCiphertextException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCiphertextException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCiphertextException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCiphertextException {}
/// See [`InvalidCiphertextException`](crate::error::InvalidCiphertextException)
pub mod invalid_ciphertext_exception {
    /// A builder for [`InvalidCiphertextException`](crate::error::InvalidCiphertextException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCiphertextException`](crate::error::InvalidCiphertextException)
        pub fn build(self) -> crate::error::InvalidCiphertextException {
            crate::error::InvalidCiphertextException {
                message: self.message,
            }
        }
    }
}
impl InvalidCiphertextException {
    /// Creates a new builder-style object to manufacture [`InvalidCiphertextException`](crate::error::InvalidCiphertextException)
    pub fn builder() -> crate::error::invalid_ciphertext_exception::Builder {
        crate::error::invalid_ciphertext_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK cannot decrypt the data. The
/// <code>KeyId</code> in a <a>Decrypt</a> request and the <code>SourceKeyId</code>
/// in a <a>ReEncrypt</a> request must identify the same CMK that was used to encrypt
/// the ciphertext.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IncorrectKeyException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncorrectKeyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectKeyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectKeyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncorrectKeyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectKeyException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncorrectKeyException {}
/// See [`IncorrectKeyException`](crate::error::IncorrectKeyException)
pub mod incorrect_key_exception {
    /// A builder for [`IncorrectKeyException`](crate::error::IncorrectKeyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IncorrectKeyException`](crate::error::IncorrectKeyException)
        pub fn build(self) -> crate::error::IncorrectKeyException {
            crate::error::IncorrectKeyException {
                message: self.message,
            }
        }
    }
}
impl IncorrectKeyException {
    /// Creates a new builder-style object to manufacture [`IncorrectKeyException`](crate::error::IncorrectKeyException)
    pub fn builder() -> crate::error::incorrect_key_exception::Builder {
        crate::error::incorrect_key_exception::Builder::default()
    }
}

/// <p>The request was rejected because the marker that specifies where pagination should next
/// begin is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMarkerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMarkerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMarkerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMarkerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMarkerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMarkerException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMarkerException {}
/// See [`InvalidMarkerException`](crate::error::InvalidMarkerException)
pub mod invalid_marker_exception {
    /// A builder for [`InvalidMarkerException`](crate::error::InvalidMarkerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMarkerException`](crate::error::InvalidMarkerException)
        pub fn build(self) -> crate::error::InvalidMarkerException {
            crate::error::InvalidMarkerException {
                message: self.message,
            }
        }
    }
}
impl InvalidMarkerException {
    /// Creates a new builder-style object to manufacture [`InvalidMarkerException`](crate::error::InvalidMarkerException)
    pub fn builder() -> crate::error::invalid_marker_exception::Builder {
        crate::error::invalid_marker_exception::Builder::default()
    }
}

/// <p>The request was rejected because the provided import token is invalid or is associated
/// with a different customer master key (CMK).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidImportTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidImportTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidImportTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidImportTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidImportTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImportTokenException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidImportTokenException {}
/// See [`InvalidImportTokenException`](crate::error::InvalidImportTokenException)
pub mod invalid_import_token_exception {
    /// A builder for [`InvalidImportTokenException`](crate::error::InvalidImportTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidImportTokenException`](crate::error::InvalidImportTokenException)
        pub fn build(self) -> crate::error::InvalidImportTokenException {
            crate::error::InvalidImportTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidImportTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidImportTokenException`](crate::error::InvalidImportTokenException)
    pub fn builder() -> crate::error::invalid_import_token_exception::Builder {
        crate::error::invalid_import_token_exception::Builder::default()
    }
}

/// <p>The request was rejected because the key material in the request is, expired, invalid, or
/// is not the same key material that was previously imported into this customer master key
/// (CMK).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IncorrectKeyMaterialException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncorrectKeyMaterialException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectKeyMaterialException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectKeyMaterialException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncorrectKeyMaterialException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectKeyMaterialException")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncorrectKeyMaterialException {}
/// See [`IncorrectKeyMaterialException`](crate::error::IncorrectKeyMaterialException)
pub mod incorrect_key_material_exception {
    /// A builder for [`IncorrectKeyMaterialException`](crate::error::IncorrectKeyMaterialException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IncorrectKeyMaterialException`](crate::error::IncorrectKeyMaterialException)
        pub fn build(self) -> crate::error::IncorrectKeyMaterialException {
            crate::error::IncorrectKeyMaterialException {
                message: self.message,
            }
        }
    }
}
impl IncorrectKeyMaterialException {
    /// Creates a new builder-style object to manufacture [`IncorrectKeyMaterialException`](crate::error::IncorrectKeyMaterialException)
    pub fn builder() -> crate::error::incorrect_key_material_exception::Builder {
        crate::error::incorrect_key_material_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified import token is expired. Use <a>GetParametersForImport</a> to get a new import token and public key, use the new
/// public key to encrypt the key material, and then try the request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExpiredImportTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExpiredImportTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredImportTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredImportTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExpiredImportTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredImportTokenException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExpiredImportTokenException {}
/// See [`ExpiredImportTokenException`](crate::error::ExpiredImportTokenException)
pub mod expired_import_token_exception {
    /// A builder for [`ExpiredImportTokenException`](crate::error::ExpiredImportTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExpiredImportTokenException`](crate::error::ExpiredImportTokenException)
        pub fn build(self) -> crate::error::ExpiredImportTokenException {
            crate::error::ExpiredImportTokenException {
                message: self.message,
            }
        }
    }
}
impl ExpiredImportTokenException {
    /// Creates a new builder-style object to manufacture [`ExpiredImportTokenException`](crate::error::ExpiredImportTokenException)
    pub fn builder() -> crate::error::expired_import_token_exception::Builder {
        crate::error::expired_import_token_exception::Builder::default()
    }
}

/// <p>The request was rejected because the custom key store contains AWS KMS customer master keys
/// (CMKs). After verifying that you do not need to use the CMKs, use the <a>ScheduleKeyDeletion</a> operation to delete the CMKs. After they are deleted, you
/// can delete the custom key store.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreHasCmKsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreHasCmKsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreHasCmKsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreHasCmKsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreHasCmKsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CustomKeyStoreHasCmKsException [CustomKeyStoreHasCMKsException]"
        )?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreHasCmKsException {}
/// See [`CustomKeyStoreHasCmKsException`](crate::error::CustomKeyStoreHasCmKsException)
pub mod custom_key_store_has_cm_ks_exception {
    /// A builder for [`CustomKeyStoreHasCmKsException`](crate::error::CustomKeyStoreHasCmKsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreHasCmKsException`](crate::error::CustomKeyStoreHasCmKsException)
        pub fn build(self) -> crate::error::CustomKeyStoreHasCmKsException {
            crate::error::CustomKeyStoreHasCmKsException {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreHasCmKsException {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreHasCmKsException`](crate::error::CustomKeyStoreHasCmKsException)
    pub fn builder() -> crate::error::custom_key_store_has_cm_ks_exception::Builder {
        crate::error::custom_key_store_has_cm_ks_exception::Builder::default()
    }
}

/// <p>The request was rejected because the trust anchor certificate in the request is not the
/// trust anchor certificate for the specified AWS CloudHSM cluster.</p>
/// <p>When you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize the cluster</a>, you create the trust anchor certificate and save it in the
/// <code>customerCA.crt</code> file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IncorrectTrustAnchorException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncorrectTrustAnchorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectTrustAnchorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectTrustAnchorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncorrectTrustAnchorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectTrustAnchorException")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncorrectTrustAnchorException {}
/// See [`IncorrectTrustAnchorException`](crate::error::IncorrectTrustAnchorException)
pub mod incorrect_trust_anchor_exception {
    /// A builder for [`IncorrectTrustAnchorException`](crate::error::IncorrectTrustAnchorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IncorrectTrustAnchorException`](crate::error::IncorrectTrustAnchorException)
        pub fn build(self) -> crate::error::IncorrectTrustAnchorException {
            crate::error::IncorrectTrustAnchorException {
                message: self.message,
            }
        }
    }
}
impl IncorrectTrustAnchorException {
    /// Creates a new builder-style object to manufacture [`IncorrectTrustAnchorException`](crate::error::IncorrectTrustAnchorException)
    pub fn builder() -> crate::error::incorrect_trust_anchor_exception::Builder {
        crate::error::incorrect_trust_anchor_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster is already associated with a
/// custom key store or it shares a backup history with a cluster that is associated with a custom
/// key store. Each custom key store must be associated with a different AWS CloudHSM cluster.</p>
/// <p>Clusters that share a backup history have the same cluster certificate. To view the
/// cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterInUseException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterInUseException")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterInUseException {}
/// See [`CloudHsmClusterInUseException`](crate::error::CloudHsmClusterInUseException)
pub mod cloud_hsm_cluster_in_use_exception {
    /// A builder for [`CloudHsmClusterInUseException`](crate::error::CloudHsmClusterInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterInUseException`](crate::error::CloudHsmClusterInUseException)
        pub fn build(self) -> crate::error::CloudHsmClusterInUseException {
            crate::error::CloudHsmClusterInUseException {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterInUseException {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterInUseException`](crate::error::CloudHsmClusterInUseException)
    pub fn builder() -> crate::error::cloud_hsm_cluster_in_use_exception::Builder {
        crate::error::cloud_hsm_cluster_in_use_exception::Builder::default()
    }
}

/// <p>The request was rejected because the specified alias name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAliasNameException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAliasNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAliasNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAliasNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAliasNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAliasNameException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAliasNameException {}
/// See [`InvalidAliasNameException`](crate::error::InvalidAliasNameException)
pub mod invalid_alias_name_exception {
    /// A builder for [`InvalidAliasNameException`](crate::error::InvalidAliasNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAliasNameException`](crate::error::InvalidAliasNameException)
        pub fn build(self) -> crate::error::InvalidAliasNameException {
            crate::error::InvalidAliasNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidAliasNameException {
    /// Creates a new builder-style object to manufacture [`InvalidAliasNameException`](crate::error::InvalidAliasNameException)
    pub fn builder() -> crate::error::invalid_alias_name_exception::Builder {
        crate::error::invalid_alias_name_exception::Builder::default()
    }
}
