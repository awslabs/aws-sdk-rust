// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelKeyDeletionError {
    pub kind: CancelKeyDeletionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelKeyDeletionErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelKeyDeletionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelKeyDeletionErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CancelKeyDeletionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelKeyDeletionError {
    fn code(&self) -> Option<&str> {
        CancelKeyDeletionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelKeyDeletionError {
    pub fn new(kind: CancelKeyDeletionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelKeyDeletionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelKeyDeletionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CancelKeyDeletionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelKeyDeletionErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::InvalidArnError(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::KMSInternalError(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::NotFoundError(_inner) => Some(_inner),
            CancelKeyDeletionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConnectCustomKeyStoreError {
    pub kind: ConnectCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConnectCustomKeyStoreErrorKind {
    CloudHsmClusterInvalidConfigurationError(
        crate::error::CloudHsmClusterInvalidConfigurationError,
    ),
    CloudHsmClusterNotActiveError(crate::error::CloudHsmClusterNotActiveError),
    CustomKeyStoreInvalidStateError(crate::error::CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConnectCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterNotActiveError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => {
                _inner.fmt(f)
            }
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConnectCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        ConnectCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConnectCustomKeyStoreError {
    pub fn new(kind: ConnectCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConnectCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConnectCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ConnectCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            ConnectCustomKeyStoreErrorKind::CloudHsmClusterNotActiveError(_inner) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::KMSInternalError(_inner) => Some(_inner),
            ConnectCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAliasError {
    pub kind: CreateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAliasErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidAliasNameError(crate::error::InvalidAliasNameError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAliasErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::InvalidAliasNameError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAliasError {
    fn code(&self) -> Option<&str> {
        CreateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAliasError {
    pub fn new(kind: CreateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAliasErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateAliasErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            CreateAliasErrorKind::InvalidAliasNameError(_inner) => Some(_inner),
            CreateAliasErrorKind::KMSInternalError(_inner) => Some(_inner),
            CreateAliasErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            CreateAliasErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateAliasErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomKeyStoreError {
    pub kind: CreateCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomKeyStoreErrorKind {
    CloudHsmClusterInUseError(crate::error::CloudHsmClusterInUseError),
    CloudHsmClusterInvalidConfigurationError(
        crate::error::CloudHsmClusterInvalidConfigurationError,
    ),
    CloudHsmClusterNotActiveError(crate::error::CloudHsmClusterNotActiveError),
    CloudHsmClusterNotFoundError(crate::error::CloudHsmClusterNotFoundError),
    CustomKeyStoreNameInUseError(crate::error::CustomKeyStoreNameInUseError),
    IncorrectTrustAnchorError(crate::error::IncorrectTrustAnchorError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInUseError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::IncorrectTrustAnchorError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        CreateCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomKeyStoreError {
    pub fn new(kind: CreateCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInUseError(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveError(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundError(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseError(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::IncorrectTrustAnchorError(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::KMSInternalError(_inner) => Some(_inner),
            CreateCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGrantError {
    pub kind: CreateGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGrantErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGrantErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::DisabledError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGrantError {
    fn code(&self) -> Option<&str> {
        CreateGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGrantError {
    pub fn new(kind: CreateGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGrantErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            CreateGrantErrorKind::DisabledError(_inner) => Some(_inner),
            CreateGrantErrorKind::InvalidArnError(_inner) => Some(_inner),
            CreateGrantErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            CreateGrantErrorKind::KMSInternalError(_inner) => Some(_inner),
            CreateGrantErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            CreateGrantErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateGrantErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateKeyError {
    pub kind: CreateKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateKeyErrorKind {
    CloudHsmClusterInvalidConfigurationError(
        crate::error::CloudHsmClusterInvalidConfigurationError,
    ),
    CustomKeyStoreInvalidStateError(crate::error::CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    TagError(crate::error::TagError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateKeyErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::TagError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            CreateKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateKeyError {
    fn code(&self) -> Option<&str> {
        CreateKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateKeyError {
    pub fn new(kind: CreateKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateKeyErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => Some(_inner),
            CreateKeyErrorKind::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            CreateKeyErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            CreateKeyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            CreateKeyErrorKind::InvalidArnError(_inner) => Some(_inner),
            CreateKeyErrorKind::KMSInternalError(_inner) => Some(_inner),
            CreateKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateKeyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreateKeyErrorKind::TagError(_inner) => Some(_inner),
            CreateKeyErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            CreateKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DecryptError {
    pub kind: DecryptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DecryptErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    IncorrectKeyError(crate::error::IncorrectKeyError),
    InvalidCiphertextError(crate::error::InvalidCiphertextError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DecryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DecryptErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DecryptErrorKind::DisabledError(_inner) => _inner.fmt(f),
            DecryptErrorKind::IncorrectKeyError(_inner) => _inner.fmt(f),
            DecryptErrorKind::InvalidCiphertextError(_inner) => _inner.fmt(f),
            DecryptErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            DecryptErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            DecryptErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            DecryptErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DecryptErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DecryptErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DecryptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DecryptError {
    fn code(&self) -> Option<&str> {
        DecryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DecryptError {
    pub fn new(kind: DecryptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DecryptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DecryptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DecryptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DecryptErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            DecryptErrorKind::DisabledError(_inner) => Some(_inner),
            DecryptErrorKind::IncorrectKeyError(_inner) => Some(_inner),
            DecryptErrorKind::InvalidCiphertextError(_inner) => Some(_inner),
            DecryptErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            DecryptErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            DecryptErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            DecryptErrorKind::KMSInternalError(_inner) => Some(_inner),
            DecryptErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            DecryptErrorKind::NotFoundError(_inner) => Some(_inner),
            DecryptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAliasError {
    pub kind: DeleteAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAliasErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAliasErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAliasError {
    pub fn new(kind: DeleteAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAliasErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            DeleteAliasErrorKind::KMSInternalError(_inner) => Some(_inner),
            DeleteAliasErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            DeleteAliasErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomKeyStoreError {
    pub kind: DeleteCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomKeyStoreErrorKind {
    CustomKeyStoreHasCMKsError(crate::error::CustomKeyStoreHasCMKsError),
    CustomKeyStoreInvalidStateError(crate::error::CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreHasCMKsError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        DeleteCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomKeyStoreError {
    pub fn new(kind: DeleteCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreHasCMKsError(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::KMSInternalError(_inner) => Some(_inner),
            DeleteCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteImportedKeyMaterialError {
    pub kind: DeleteImportedKeyMaterialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteImportedKeyMaterialErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteImportedKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteImportedKeyMaterialErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteImportedKeyMaterialError {
    fn code(&self) -> Option<&str> {
        DeleteImportedKeyMaterialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteImportedKeyMaterialError {
    pub fn new(kind: DeleteImportedKeyMaterialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteImportedKeyMaterialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteImportedKeyMaterialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteImportedKeyMaterialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteImportedKeyMaterialErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::InvalidArnError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::KMSInternalError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCustomKeyStoresError {
    pub kind: DescribeCustomKeyStoresErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCustomKeyStoresErrorKind {
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCustomKeyStoresError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCustomKeyStoresErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            DescribeCustomKeyStoresErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DescribeCustomKeyStoresErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCustomKeyStoresError {
    fn code(&self) -> Option<&str> {
        DescribeCustomKeyStoresError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCustomKeyStoresError {
    pub fn new(kind: DescribeCustomKeyStoresErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCustomKeyStoresErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCustomKeyStoresErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeCustomKeyStoresError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCustomKeyStoresErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            DescribeCustomKeyStoresErrorKind::KMSInternalError(_inner) => Some(_inner),
            DescribeCustomKeyStoresErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeKeyError {
    pub kind: DescribeKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeKeyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeKeyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DescribeKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeKeyError {
    fn code(&self) -> Option<&str> {
        DescribeKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeKeyError {
    pub fn new(kind: DescribeKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeKeyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            DescribeKeyErrorKind::InvalidArnError(_inner) => Some(_inner),
            DescribeKeyErrorKind::KMSInternalError(_inner) => Some(_inner),
            DescribeKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            DescribeKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableKeyError {
    pub kind: DisableKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableKeyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableKeyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DisableKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableKeyError {
    fn code(&self) -> Option<&str> {
        DisableKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableKeyError {
    pub fn new(kind: DisableKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DisableKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableKeyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            DisableKeyErrorKind::InvalidArnError(_inner) => Some(_inner),
            DisableKeyErrorKind::KMSInternalError(_inner) => Some(_inner),
            DisableKeyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            DisableKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            DisableKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableKeyRotationError {
    pub kind: DisableKeyRotationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableKeyRotationErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableKeyRotationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableKeyRotationErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::DisabledError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            DisableKeyRotationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableKeyRotationError {
    fn code(&self) -> Option<&str> {
        DisableKeyRotationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableKeyRotationError {
    pub fn new(kind: DisableKeyRotationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableKeyRotationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableKeyRotationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DisableKeyRotationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableKeyRotationErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::DisabledError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::InvalidArnError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::KMSInternalError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::NotFoundError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            DisableKeyRotationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisconnectCustomKeyStoreError {
    pub kind: DisconnectCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisconnectCustomKeyStoreErrorKind {
    CustomKeyStoreInvalidStateError(crate::error::CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisconnectCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => {
                _inner.fmt(f)
            }
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            DisconnectCustomKeyStoreErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            DisconnectCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisconnectCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        DisconnectCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisconnectCustomKeyStoreError {
    pub fn new(kind: DisconnectCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisconnectCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisconnectCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DisconnectCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => {
                Some(_inner)
            }
            DisconnectCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            DisconnectCustomKeyStoreErrorKind::KMSInternalError(_inner) => Some(_inner),
            DisconnectCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableKeyError {
    pub kind: EnableKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableKeyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableKeyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            EnableKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableKeyError {
    fn code(&self) -> Option<&str> {
        EnableKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableKeyError {
    pub fn new(kind: EnableKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for EnableKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableKeyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            EnableKeyErrorKind::InvalidArnError(_inner) => Some(_inner),
            EnableKeyErrorKind::KMSInternalError(_inner) => Some(_inner),
            EnableKeyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            EnableKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            EnableKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            EnableKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableKeyRotationError {
    pub kind: EnableKeyRotationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableKeyRotationErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableKeyRotationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableKeyRotationErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::DisabledError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            EnableKeyRotationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableKeyRotationError {
    fn code(&self) -> Option<&str> {
        EnableKeyRotationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableKeyRotationError {
    pub fn new(kind: EnableKeyRotationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableKeyRotationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableKeyRotationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for EnableKeyRotationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableKeyRotationErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::DisabledError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::InvalidArnError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::KMSInternalError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::NotFoundError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            EnableKeyRotationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EncryptError {
    pub kind: EncryptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EncryptErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EncryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EncryptErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            EncryptErrorKind::DisabledError(_inner) => _inner.fmt(f),
            EncryptErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            EncryptErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            EncryptErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            EncryptErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            EncryptErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            EncryptErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            EncryptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EncryptError {
    fn code(&self) -> Option<&str> {
        EncryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EncryptError {
    pub fn new(kind: EncryptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EncryptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EncryptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for EncryptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EncryptErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            EncryptErrorKind::DisabledError(_inner) => Some(_inner),
            EncryptErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            EncryptErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            EncryptErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            EncryptErrorKind::KMSInternalError(_inner) => Some(_inner),
            EncryptErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            EncryptErrorKind::NotFoundError(_inner) => Some(_inner),
            EncryptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyError {
    pub kind: GenerateDataKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyError {
    pub fn new(kind: GenerateDataKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GenerateDataKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyPairError {
    pub kind: GenerateDataKeyPairErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyPairErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyPairErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyPairError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyPairError {
    pub fn new(kind: GenerateDataKeyPairErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyPairErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyPairErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GenerateDataKeyPairError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyPairErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            GenerateDataKeyPairErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyPairWithoutPlaintextError {
    pub kind: GenerateDataKeyPairWithoutPlaintextErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyPairWithoutPlaintextErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyPairWithoutPlaintextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyPairWithoutPlaintextErrorKind::DependencyTimeoutError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidGrantTokenError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidKeyUsageError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KeyUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextErrorKind::KMSInvalidStateError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextErrorKind::UnsupportedOperationError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyPairWithoutPlaintextError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyPairWithoutPlaintextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyPairWithoutPlaintextError {
    pub fn new(
        kind: GenerateDataKeyPairWithoutPlaintextErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GenerateDataKeyPairWithoutPlaintextError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyPairWithoutPlaintextErrorKind::DependencyTimeoutError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidGrantTokenError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::InvalidKeyUsageError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KeyUnavailableError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextErrorKind::KMSInvalidStateError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextErrorKind::UnsupportedOperationError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateDataKeyWithoutPlaintextError {
    pub kind: GenerateDataKeyWithoutPlaintextErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateDataKeyWithoutPlaintextErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateDataKeyWithoutPlaintextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateDataKeyWithoutPlaintextErrorKind::DependencyTimeoutError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidGrantTokenError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateDataKeyWithoutPlaintextError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyWithoutPlaintextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateDataKeyWithoutPlaintextError {
    pub fn new(kind: GenerateDataKeyWithoutPlaintextErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GenerateDataKeyWithoutPlaintextError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateDataKeyWithoutPlaintextErrorKind::DependencyTimeoutError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidGrantTokenError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyWithoutPlaintextErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateRandomError {
    pub kind: GenerateRandomErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateRandomErrorKind {
    CustomKeyStoreInvalidStateError(crate::error::CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateRandomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateRandomErrorKind::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateRandomErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateRandomError {
    fn code(&self) -> Option<&str> {
        GenerateRandomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateRandomError {
    pub fn new(kind: GenerateRandomErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateRandomErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateRandomErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GenerateRandomError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateRandomErrorKind::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            GenerateRandomErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            GenerateRandomErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateRandomErrorKind::KMSInternalError(_inner) => Some(_inner),
            GenerateRandomErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetKeyPolicyError {
    pub kind: GetKeyPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyPolicyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetKeyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetKeyPolicyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetKeyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetKeyPolicyError {
    fn code(&self) -> Option<&str> {
        GetKeyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyPolicyError {
    pub fn new(kind: GetKeyPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetKeyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetKeyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetKeyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetKeyPolicyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::InvalidArnError(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::KMSInternalError(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::NotFoundError(_inner) => Some(_inner),
            GetKeyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetKeyRotationStatusError {
    pub kind: GetKeyRotationStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetKeyRotationStatusErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetKeyRotationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetKeyRotationStatusErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetKeyRotationStatusError {
    fn code(&self) -> Option<&str> {
        GetKeyRotationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetKeyRotationStatusError {
    pub fn new(kind: GetKeyRotationStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetKeyRotationStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetKeyRotationStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetKeyRotationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetKeyRotationStatusErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::InvalidArnError(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::KMSInternalError(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::NotFoundError(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            GetKeyRotationStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetParametersForImportError {
    pub kind: GetParametersForImportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetParametersForImportErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetParametersForImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetParametersForImportErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GetParametersForImportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetParametersForImportError {
    fn code(&self) -> Option<&str> {
        GetParametersForImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetParametersForImportError {
    pub fn new(kind: GetParametersForImportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetParametersForImportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetParametersForImportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetParametersForImportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetParametersForImportErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GetParametersForImportErrorKind::InvalidArnError(_inner) => Some(_inner),
            GetParametersForImportErrorKind::KMSInternalError(_inner) => Some(_inner),
            GetParametersForImportErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GetParametersForImportErrorKind::NotFoundError(_inner) => Some(_inner),
            GetParametersForImportErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            GetParametersForImportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPublicKeyError {
    pub kind: GetPublicKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPublicKeyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPublicKeyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::DisabledError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GetPublicKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPublicKeyError {
    fn code(&self) -> Option<&str> {
        GetPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPublicKeyError {
    pub fn new(kind: GetPublicKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPublicKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPublicKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetPublicKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPublicKeyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::DisabledError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::InvalidArnError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::KMSInternalError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            GetPublicKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportKeyMaterialError {
    pub kind: ImportKeyMaterialErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportKeyMaterialErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    ExpiredImportTokenError(crate::error::ExpiredImportTokenError),
    IncorrectKeyMaterialError(crate::error::IncorrectKeyMaterialError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidCiphertextError(crate::error::InvalidCiphertextError),
    InvalidImportTokenError(crate::error::InvalidImportTokenError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportKeyMaterialErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::ExpiredImportTokenError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::IncorrectKeyMaterialError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::InvalidCiphertextError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::InvalidImportTokenError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            ImportKeyMaterialErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportKeyMaterialError {
    fn code(&self) -> Option<&str> {
        ImportKeyMaterialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportKeyMaterialError {
    pub fn new(kind: ImportKeyMaterialErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportKeyMaterialErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportKeyMaterialErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ImportKeyMaterialError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportKeyMaterialErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::ExpiredImportTokenError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::IncorrectKeyMaterialError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::InvalidArnError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::InvalidCiphertextError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::InvalidImportTokenError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::KMSInternalError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::NotFoundError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            ImportKeyMaterialErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAliasesError {
    pub kind: ListAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAliasesErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidMarkerError(crate::error::InvalidMarkerError),
    KMSInternalError(crate::error::KMSInternalError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAliasesErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAliasesError {
    fn code(&self) -> Option<&str> {
        ListAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAliasesError {
    pub fn new(kind: ListAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAliasesErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ListAliasesErrorKind::InvalidArnError(_inner) => Some(_inner),
            ListAliasesErrorKind::InvalidMarkerError(_inner) => Some(_inner),
            ListAliasesErrorKind::KMSInternalError(_inner) => Some(_inner),
            ListAliasesErrorKind::NotFoundError(_inner) => Some(_inner),
            ListAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGrantsError {
    pub kind: ListGrantsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGrantsErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidMarkerError(crate::error::InvalidMarkerError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGrantsErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListGrantsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGrantsError {
    fn code(&self) -> Option<&str> {
        ListGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGrantsError {
    pub fn new(kind: ListGrantsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGrantsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGrantsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGrantsErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ListGrantsErrorKind::InvalidArnError(_inner) => Some(_inner),
            ListGrantsErrorKind::InvalidMarkerError(_inner) => Some(_inner),
            ListGrantsErrorKind::KMSInternalError(_inner) => Some(_inner),
            ListGrantsErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            ListGrantsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListGrantsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListKeyPoliciesError {
    pub kind: ListKeyPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKeyPoliciesErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListKeyPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListKeyPoliciesErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListKeyPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListKeyPoliciesError {
    fn code(&self) -> Option<&str> {
        ListKeyPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKeyPoliciesError {
    pub fn new(kind: ListKeyPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListKeyPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListKeyPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListKeyPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListKeyPoliciesErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::InvalidArnError(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::KMSInternalError(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::NotFoundError(_inner) => Some(_inner),
            ListKeyPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListKeysError {
    pub kind: ListKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKeysErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidMarkerError(crate::error::InvalidMarkerError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListKeysErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListKeysErrorKind::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListKeysErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ListKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListKeysError {
    fn code(&self) -> Option<&str> {
        ListKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKeysError {
    pub fn new(kind: ListKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListKeysErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ListKeysErrorKind::InvalidMarkerError(_inner) => Some(_inner),
            ListKeysErrorKind::KMSInternalError(_inner) => Some(_inner),
            ListKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourceTagsError {
    pub kind: ListResourceTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourceTagsErrorKind {
    InvalidArnError(crate::error::InvalidArnError),
    InvalidMarkerError(crate::error::InvalidMarkerError),
    KMSInternalError(crate::error::KMSInternalError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourceTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourceTagsErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListResourceTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourceTagsError {
    fn code(&self) -> Option<&str> {
        ListResourceTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourceTagsError {
    pub fn new(kind: ListResourceTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourceTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourceTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListResourceTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourceTagsErrorKind::InvalidArnError(_inner) => Some(_inner),
            ListResourceTagsErrorKind::InvalidMarkerError(_inner) => Some(_inner),
            ListResourceTagsErrorKind::KMSInternalError(_inner) => Some(_inner),
            ListResourceTagsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListResourceTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRetirableGrantsError {
    pub kind: ListRetirableGrantsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRetirableGrantsErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidMarkerError(crate::error::InvalidMarkerError),
    KMSInternalError(crate::error::KMSInternalError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRetirableGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRetirableGrantsErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListRetirableGrantsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRetirableGrantsError {
    fn code(&self) -> Option<&str> {
        ListRetirableGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRetirableGrantsError {
    pub fn new(kind: ListRetirableGrantsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRetirableGrantsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRetirableGrantsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListRetirableGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRetirableGrantsErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::InvalidArnError(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::InvalidMarkerError(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::KMSInternalError(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListRetirableGrantsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutKeyPolicyError {
    pub kind: PutKeyPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutKeyPolicyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    NotFoundError(crate::error::NotFoundError),
    UnsupportedOperationError(crate::error::UnsupportedOperationError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutKeyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutKeyPolicyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::UnsupportedOperationError(_inner) => _inner.fmt(f),
            PutKeyPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutKeyPolicyError {
    fn code(&self) -> Option<&str> {
        PutKeyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutKeyPolicyError {
    pub fn new(kind: PutKeyPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutKeyPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutKeyPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for PutKeyPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutKeyPolicyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::InvalidArnError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::KMSInternalError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::NotFoundError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::UnsupportedOperationError(_inner) => Some(_inner),
            PutKeyPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReEncryptError {
    pub kind: ReEncryptErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReEncryptErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    IncorrectKeyError(crate::error::IncorrectKeyError),
    InvalidCiphertextError(crate::error::InvalidCiphertextError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReEncryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReEncryptErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::DisabledError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::IncorrectKeyError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::InvalidCiphertextError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ReEncryptErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReEncryptError {
    fn code(&self) -> Option<&str> {
        ReEncryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReEncryptError {
    pub fn new(kind: ReEncryptErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReEncryptErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReEncryptErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ReEncryptError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReEncryptErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ReEncryptErrorKind::DisabledError(_inner) => Some(_inner),
            ReEncryptErrorKind::IncorrectKeyError(_inner) => Some(_inner),
            ReEncryptErrorKind::InvalidCiphertextError(_inner) => Some(_inner),
            ReEncryptErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            ReEncryptErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            ReEncryptErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            ReEncryptErrorKind::KMSInternalError(_inner) => Some(_inner),
            ReEncryptErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            ReEncryptErrorKind::NotFoundError(_inner) => Some(_inner),
            ReEncryptErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RetireGrantError {
    pub kind: RetireGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RetireGrantErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidGrantIdError(crate::error::InvalidGrantIdError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RetireGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RetireGrantErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::InvalidGrantIdError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            RetireGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RetireGrantError {
    fn code(&self) -> Option<&str> {
        RetireGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RetireGrantError {
    pub fn new(kind: RetireGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RetireGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RetireGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RetireGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RetireGrantErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            RetireGrantErrorKind::InvalidArnError(_inner) => Some(_inner),
            RetireGrantErrorKind::InvalidGrantIdError(_inner) => Some(_inner),
            RetireGrantErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            RetireGrantErrorKind::KMSInternalError(_inner) => Some(_inner),
            RetireGrantErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            RetireGrantErrorKind::NotFoundError(_inner) => Some(_inner),
            RetireGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeGrantError {
    pub kind: RevokeGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeGrantErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    InvalidGrantIdError(crate::error::InvalidGrantIdError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeGrantErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::InvalidGrantIdError(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            RevokeGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeGrantError {
    fn code(&self) -> Option<&str> {
        RevokeGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeGrantError {
    pub fn new(kind: RevokeGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RevokeGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeGrantErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            RevokeGrantErrorKind::InvalidArnError(_inner) => Some(_inner),
            RevokeGrantErrorKind::InvalidGrantIdError(_inner) => Some(_inner),
            RevokeGrantErrorKind::KMSInternalError(_inner) => Some(_inner),
            RevokeGrantErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            RevokeGrantErrorKind::NotFoundError(_inner) => Some(_inner),
            RevokeGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ScheduleKeyDeletionError {
    pub kind: ScheduleKeyDeletionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ScheduleKeyDeletionErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ScheduleKeyDeletionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ScheduleKeyDeletionErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ScheduleKeyDeletionError {
    fn code(&self) -> Option<&str> {
        ScheduleKeyDeletionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ScheduleKeyDeletionError {
    pub fn new(kind: ScheduleKeyDeletionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ScheduleKeyDeletionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ScheduleKeyDeletionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ScheduleKeyDeletionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ScheduleKeyDeletionErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::InvalidArnError(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::KMSInternalError(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::NotFoundError(_inner) => Some(_inner),
            ScheduleKeyDeletionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignError {
    pub kind: SignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SignErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            SignErrorKind::DisabledError(_inner) => _inner.fmt(f),
            SignErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            SignErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            SignErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            SignErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            SignErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            SignErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SignError {
    fn code(&self) -> Option<&str> {
        SignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignError {
    pub fn new(kind: SignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SignErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            SignErrorKind::DisabledError(_inner) => Some(_inner),
            SignErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            SignErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            SignErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            SignErrorKind::KMSInternalError(_inner) => Some(_inner),
            SignErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            SignErrorKind::NotFoundError(_inner) => Some(_inner),
            SignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TagError(crate::error::TagError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidArnError(_inner) => Some(_inner),
            TagResourceErrorKind::KMSInternalError(_inner) => Some(_inner),
            TagResourceErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::TagError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    TagError(crate::error::TagError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidArnError(_inner) => Some(_inner),
            UntagResourceErrorKind::KMSInternalError(_inner) => Some(_inner),
            UntagResourceErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::TagError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAliasError {
    pub kind: UpdateAliasErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAliasErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAliasErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateAliasErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAliasError {
    fn code(&self) -> Option<&str> {
        UpdateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAliasError {
    pub fn new(kind: UpdateAliasErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAliasErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateAliasError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAliasErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            UpdateAliasErrorKind::KMSInternalError(_inner) => Some(_inner),
            UpdateAliasErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            UpdateAliasErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateAliasErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateAliasErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCustomKeyStoreError {
    pub kind: UpdateCustomKeyStoreErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCustomKeyStoreErrorKind {
    CloudHsmClusterInvalidConfigurationError(
        crate::error::CloudHsmClusterInvalidConfigurationError,
    ),
    CloudHsmClusterNotActiveError(crate::error::CloudHsmClusterNotActiveError),
    CloudHsmClusterNotFoundError(crate::error::CloudHsmClusterNotFoundError),
    CloudHsmClusterNotRelatedError(crate::error::CloudHsmClusterNotRelatedError),
    CustomKeyStoreInvalidStateError(crate::error::CustomKeyStoreInvalidStateError),
    CustomKeyStoreNameInUseError(crate::error::CustomKeyStoreNameInUseError),
    CustomKeyStoreNotFoundError(crate::error::CustomKeyStoreNotFoundError),
    KMSInternalError(crate::error::KMSInternalError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotRelatedError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        UpdateCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCustomKeyStoreError {
    pub fn new(kind: UpdateCustomKeyStoreErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCustomKeyStoreErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCustomKeyStoreErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotActiveError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotFoundError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CloudHsmClusterNotRelatedError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNameInUseError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::KMSInternalError(_inner) => Some(_inner),
            UpdateCustomKeyStoreErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateKeyDescriptionError {
    pub kind: UpdateKeyDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateKeyDescriptionErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    InvalidArnError(crate::error::InvalidArnError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateKeyDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateKeyDescriptionErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::InvalidArnError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateKeyDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateKeyDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateKeyDescriptionError {
    pub fn new(kind: UpdateKeyDescriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateKeyDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateKeyDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateKeyDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateKeyDescriptionErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::InvalidArnError(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::KMSInternalError(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateKeyDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct VerifyError {
    pub kind: VerifyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum VerifyErrorKind {
    DependencyTimeoutError(crate::error::DependencyTimeoutError),
    DisabledError(crate::error::DisabledError),
    InvalidGrantTokenError(crate::error::InvalidGrantTokenError),
    InvalidKeyUsageError(crate::error::InvalidKeyUsageError),
    KeyUnavailableError(crate::error::KeyUnavailableError),
    KMSInternalError(crate::error::KMSInternalError),
    KMSInvalidSignatureError(crate::error::KMSInvalidSignatureError),
    KMSInvalidStateError(crate::error::KMSInvalidStateError),
    NotFoundError(crate::error::NotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for VerifyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            VerifyErrorKind::DependencyTimeoutError(_inner) => _inner.fmt(f),
            VerifyErrorKind::DisabledError(_inner) => _inner.fmt(f),
            VerifyErrorKind::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            VerifyErrorKind::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            VerifyErrorKind::KeyUnavailableError(_inner) => _inner.fmt(f),
            VerifyErrorKind::KMSInternalError(_inner) => _inner.fmt(f),
            VerifyErrorKind::KMSInvalidSignatureError(_inner) => _inner.fmt(f),
            VerifyErrorKind::KMSInvalidStateError(_inner) => _inner.fmt(f),
            VerifyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            VerifyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for VerifyError {
    fn code(&self) -> Option<&str> {
        VerifyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl VerifyError {
    pub fn new(kind: VerifyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: VerifyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: VerifyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for VerifyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            VerifyErrorKind::DependencyTimeoutError(_inner) => Some(_inner),
            VerifyErrorKind::DisabledError(_inner) => Some(_inner),
            VerifyErrorKind::InvalidGrantTokenError(_inner) => Some(_inner),
            VerifyErrorKind::InvalidKeyUsageError(_inner) => Some(_inner),
            VerifyErrorKind::KeyUnavailableError(_inner) => Some(_inner),
            VerifyErrorKind::KMSInternalError(_inner) => Some(_inner),
            VerifyErrorKind::KMSInvalidSignatureError(_inner) => Some(_inner),
            VerifyErrorKind::KMSInvalidStateError(_inner) => Some(_inner),
            VerifyErrorKind::NotFoundError(_inner) => Some(_inner),
            VerifyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request was rejected because the specified entity or resource could not be
/// found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError [NotFoundException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the state of the specified resource is not valid for this
/// request.</p>
/// <p>For more information about how key state affects the use of a CMK, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a> in the <i>
/// <i>AWS Key Management Service Developer Guide</i>
/// </i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSInvalidStateError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidStateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidStateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidStateError [KMSInvalidStateException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSInvalidStateError {}
/// See [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
pub mod kms_invalid_state_error {
    /// A builder for [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
        pub fn build(self) -> crate::error::KMSInvalidStateError {
            crate::error::KMSInvalidStateError {
                message: self.message,
            }
        }
    }
}
impl KMSInvalidStateError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    pub fn builder() -> crate::error::kms_invalid_state_error::Builder {
        crate::error::kms_invalid_state_error::Builder::default()
    }
}

/// <p>The request was rejected because the signature verification failed. Signature
/// verification fails when it cannot confirm that signature was produced by signing the specified
/// message with the specified CMK and signing algorithm.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSInvalidSignatureError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSInvalidSignatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidSignatureError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidSignatureError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSInvalidSignatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidSignatureError [KMSInvalidSignatureException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSInvalidSignatureError {}
/// See [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
pub mod kms_invalid_signature_error {
    /// A builder for [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
        pub fn build(self) -> crate::error::KMSInvalidSignatureError {
            crate::error::KMSInvalidSignatureError {
                message: self.message,
            }
        }
    }
}
impl KMSInvalidSignatureError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
    pub fn builder() -> crate::error::kms_invalid_signature_error::Builder {
        crate::error::kms_invalid_signature_error::Builder::default()
    }
}

/// <p>The request was rejected because an internal exception occurred. The request can be
/// retried.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KMSInternalError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KMSInternalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInternalError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInternalError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KMSInternalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInternalError [KMSInternalException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for KMSInternalError {}
/// See [`KMSInternalError`](crate::error::KMSInternalError)
pub mod kms_internal_error {
    /// A builder for [`KMSInternalError`](crate::error::KMSInternalError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KMSInternalError`](crate::error::KMSInternalError)
        pub fn build(self) -> crate::error::KMSInternalError {
            crate::error::KMSInternalError {
                message: self.message,
            }
        }
    }
}
impl KMSInternalError {
    /// Creates a new builder-style object to manufacture [`KMSInternalError`](crate::error::KMSInternalError)
    pub fn builder() -> crate::error::kms_internal_error::Builder {
        crate::error::kms_internal_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK was not available. You can retry the
/// request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KeyUnavailableError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KeyUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeyUnavailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KeyUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KeyUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyUnavailableError [KeyUnavailableException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for KeyUnavailableError {}
/// See [`KeyUnavailableError`](crate::error::KeyUnavailableError)
pub mod key_unavailable_error {
    /// A builder for [`KeyUnavailableError`](crate::error::KeyUnavailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`KeyUnavailableError`](crate::error::KeyUnavailableError)
        pub fn build(self) -> crate::error::KeyUnavailableError {
            crate::error::KeyUnavailableError {
                message: self.message,
            }
        }
    }
}
impl KeyUnavailableError {
    /// Creates a new builder-style object to manufacture [`KeyUnavailableError`](crate::error::KeyUnavailableError)
    pub fn builder() -> crate::error::key_unavailable_error::Builder {
        crate::error::key_unavailable_error::Builder::default()
    }
}

/// <p>The request was rejected for one of the following reasons: </p>
/// <ul>
/// <li>
/// <p>The <code>KeyUsage</code> value of the CMK is incompatible with the API
/// operation.</p>
/// </li>
/// <li>
/// <p>The encryption algorithm or signing algorithm specified for the operation is
/// incompatible with the type of key material in the CMK
/// <code>(CustomerMasterKeySpec</code>).</p>
/// </li>
/// </ul>
/// <p>For encrypting, decrypting, re-encrypting, and generating data keys, the
/// <code>KeyUsage</code> must be <code>ENCRYPT_DECRYPT</code>. For signing and verifying, the
/// <code>KeyUsage</code> must be <code>SIGN_VERIFY</code>. To find the <code>KeyUsage</code> of
/// a CMK, use the <a>DescribeKey</a> operation.</p>
/// <p>To find the encryption or signing algorithms supported for a particular CMK, use the <a>DescribeKey</a> operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidKeyUsageError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidKeyUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidKeyUsageError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidKeyUsageError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKeyUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKeyUsageError [InvalidKeyUsageException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKeyUsageError {}
/// See [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
pub mod invalid_key_usage_error {
    /// A builder for [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
        pub fn build(self) -> crate::error::InvalidKeyUsageError {
            crate::error::InvalidKeyUsageError {
                message: self.message,
            }
        }
    }
}
impl InvalidKeyUsageError {
    /// Creates a new builder-style object to manufacture [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
    pub fn builder() -> crate::error::invalid_key_usage_error::Builder {
        crate::error::invalid_key_usage_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified grant token is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGrantTokenError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGrantTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGrantTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGrantTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGrantTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGrantTokenError [InvalidGrantTokenException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGrantTokenError {}
/// See [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
pub mod invalid_grant_token_error {
    /// A builder for [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
        pub fn build(self) -> crate::error::InvalidGrantTokenError {
            crate::error::InvalidGrantTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidGrantTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
    pub fn builder() -> crate::error::invalid_grant_token_error::Builder {
        crate::error::invalid_grant_token_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK is not enabled.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DisabledError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DisabledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DisabledError [DisabledException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for DisabledError {}
/// See [`DisabledError`](crate::error::DisabledError)
pub mod disabled_error {
    /// A builder for [`DisabledError`](crate::error::DisabledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`DisabledError`](crate::error::DisabledError)
        pub fn build(self) -> crate::error::DisabledError {
            crate::error::DisabledError {
                message: self.message,
            }
        }
    }
}
impl DisabledError {
    /// Creates a new builder-style object to manufacture [`DisabledError`](crate::error::DisabledError)
    pub fn builder() -> crate::error::disabled_error::Builder {
        crate::error::disabled_error::Builder::default()
    }
}

/// <p>The system timed out while trying to fulfill the request. The request can be
/// retried.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DependencyTimeoutError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DependencyTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DependencyTimeoutError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DependencyTimeoutError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DependencyTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependencyTimeoutError [DependencyTimeoutException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for DependencyTimeoutError {}
/// See [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
pub mod dependency_timeout_error {
    /// A builder for [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
        pub fn build(self) -> crate::error::DependencyTimeoutError {
            crate::error::DependencyTimeoutError {
                message: self.message,
            }
        }
    }
}
impl DependencyTimeoutError {
    /// Creates a new builder-style object to manufacture [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
    pub fn builder() -> crate::error::dependency_timeout_error::Builder {
        crate::error::dependency_timeout_error::Builder::default()
    }
}

/// <p>The request was rejected because a specified ARN, or an ARN in a key policy, is not
/// valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidArnError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArnError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArnError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnError [InvalidArnException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArnError {}
/// See [`InvalidArnError`](crate::error::InvalidArnError)
pub mod invalid_arn_error {
    /// A builder for [`InvalidArnError`](crate::error::InvalidArnError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnError`](crate::error::InvalidArnError)
        pub fn build(self) -> crate::error::InvalidArnError {
            crate::error::InvalidArnError {
                message: self.message,
            }
        }
    }
}
impl InvalidArnError {
    /// Creates a new builder-style object to manufacture [`InvalidArnError`](crate::error::InvalidArnError)
    pub fn builder() -> crate::error::invalid_arn_error::Builder {
        crate::error::invalid_arn_error::Builder::default()
    }
}

/// <p>The request was rejected because AWS KMS cannot find a custom key store with the specified
/// key store name or ID.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CustomKeyStoreNotFoundError [CustomKeyStoreNotFoundException]"
        )?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreNotFoundError {}
/// See [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
pub mod custom_key_store_not_found_error {
    /// A builder for [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
        pub fn build(self) -> crate::error::CustomKeyStoreNotFoundError {
            crate::error::CustomKeyStoreNotFoundError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreNotFoundError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
    pub fn builder() -> crate::error::custom_key_store_not_found_error::Builder {
        crate::error::custom_key_store_not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified custom key store name is already assigned
/// to another custom key store in the account. Try again with a custom key store name that is
/// unique in the account.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreNameInUseError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreNameInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreNameInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreNameInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreNameInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CustomKeyStoreNameInUseError [CustomKeyStoreNameInUseException]"
        )?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreNameInUseError {}
/// See [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
pub mod custom_key_store_name_in_use_error {
    /// A builder for [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
        pub fn build(self) -> crate::error::CustomKeyStoreNameInUseError {
            crate::error::CustomKeyStoreNameInUseError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreNameInUseError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
    pub fn builder() -> crate::error::custom_key_store_name_in_use_error::Builder {
        crate::error::custom_key_store_name_in_use_error::Builder::default()
    }
}

/// <p>The request was rejected because of the <code>ConnectionState</code> of the custom key
/// store. To get the <code>ConnectionState</code> of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
/// <p>This exception is thrown under the following conditions:</p>
/// <ul>
/// <li>
/// <p>You requested the <a>CreateKey</a> or <a>GenerateRandom</a>
/// operation in a custom key store that is not connected. These operations are valid only
/// when the custom key store <code>ConnectionState</code> is <code>CONNECTED</code>.</p>
/// </li>
/// <li>
/// <p>You requested the <a>UpdateCustomKeyStore</a> or <a>DeleteCustomKeyStore</a> operation on a custom key store that is not
/// disconnected. This operation is valid only when the custom key store
/// <code>ConnectionState</code> is <code>DISCONNECTED</code>.</p>
/// </li>
/// <li>
/// <p>You requested the <a>ConnectCustomKeyStore</a> operation on a custom key
/// store with a <code>ConnectionState</code> of <code>DISCONNECTING</code> or
/// <code>FAILED</code>. This operation is valid for all other <code>ConnectionState</code>
/// values.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreInvalidStateError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreInvalidStateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreInvalidStateError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CustomKeyStoreInvalidStateError [CustomKeyStoreInvalidStateException]"
        )?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreInvalidStateError {}
/// See [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
pub mod custom_key_store_invalid_state_error {
    /// A builder for [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
        pub fn build(self) -> crate::error::CustomKeyStoreInvalidStateError {
            crate::error::CustomKeyStoreInvalidStateError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreInvalidStateError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
    pub fn builder() -> crate::error::custom_key_store_invalid_state_error::Builder {
        crate::error::custom_key_store_invalid_state_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster has a different cluster
/// certificate than the original cluster. You cannot use the operation to specify an unrelated
/// cluster.</p>
/// <p>Specify a cluster that shares a backup history with the original cluster. This includes
/// clusters that were created from a backup of the current cluster, and clusters that were
/// created from the same backup that produced the current cluster.</p>
/// <p>Clusters that share a backup history have the same cluster certificate. To view the
/// cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterNotRelatedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterNotRelatedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotRelatedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotRelatedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterNotRelatedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CloudHsmClusterNotRelatedError [CloudHsmClusterNotRelatedException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterNotRelatedError {}
/// See [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
pub mod cloud_hsm_cluster_not_related_error {
    /// A builder for [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
        pub fn build(self) -> crate::error::CloudHsmClusterNotRelatedError {
            crate::error::CloudHsmClusterNotRelatedError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotRelatedError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_related_error::Builder {
        crate::error::cloud_hsm_cluster_not_related_error::Builder::default()
    }
}

/// <p>The request was rejected because AWS KMS cannot find the AWS CloudHSM cluster with the specified
/// cluster ID. Retry the request with a different cluster ID.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CloudHsmClusterNotFoundError [CloudHsmClusterNotFoundException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterNotFoundError {}
/// See [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
pub mod cloud_hsm_cluster_not_found_error {
    /// A builder for [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
        pub fn build(self) -> crate::error::CloudHsmClusterNotFoundError {
            crate::error::CloudHsmClusterNotFoundError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotFoundError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_found_error::Builder {
        crate::error::cloud_hsm_cluster_not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the AWS CloudHSM cluster that is associated with the custom key
/// store is not active. Initialize and activate the cluster and try the command again. For
/// detailed instructions, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/getting-started.html">Getting Started</a> in the <i>AWS CloudHSM User Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterNotActiveError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterNotActiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotActiveError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotActiveError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterNotActiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CloudHsmClusterNotActiveError [CloudHsmClusterNotActiveException]"
        )?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterNotActiveError {}
/// See [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
pub mod cloud_hsm_cluster_not_active_error {
    /// A builder for [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
        pub fn build(self) -> crate::error::CloudHsmClusterNotActiveError {
            crate::error::CloudHsmClusterNotActiveError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotActiveError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_active_error::Builder {
        crate::error::cloud_hsm_cluster_not_active_error::Builder::default()
    }
}

/// <p>The request was rejected because the associated AWS CloudHSM cluster did not meet the
/// configuration requirements for a custom key store.</p>
/// <ul>
/// <li>
/// <p>The cluster must be configured with private subnets in at least two different
/// Availability Zones in the Region.</p>
/// </li>
/// <li>
/// <p>The <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">security group for
/// the cluster</a> (cloudhsm-cluster-<i><cluster-id></i>-sg) must
/// include inbound rules and outbound rules that allow TCP traffic on ports 2223-2225. The
/// <b>Source</b> in the inbound rules and the <b>Destination</b> in the outbound rules must match the security group
/// ID. These rules are set by default when you create the cluster. Do not delete or change
/// them. To get information about a particular security group, use the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html">DescribeSecurityGroups</a> operation.</p>
/// </li>
/// <li>
/// <p>The cluster must contain at least as many HSMs as the operation requires. To add HSMs,
/// use the AWS CloudHSM <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_CreateHsm.html">CreateHsm</a> operation.</p>
/// <p>For the <a>CreateCustomKeyStore</a>, <a>UpdateCustomKeyStore</a>, and <a>CreateKey</a> operations, the AWS CloudHSM cluster must have at least two
/// active HSMs, each in a different Availability Zone. For the <a>ConnectCustomKeyStore</a> operation, the AWS CloudHSM must contain at least one active
/// HSM.</p>
/// </li>
/// </ul>
/// <p>For information about the requirements for an AWS CloudHSM cluster that is associated with a
/// custom key store, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">Assemble the Prerequisites</a>
/// in the <i>AWS Key Management Service Developer Guide</i>. For information about creating a private subnet for an AWS CloudHSM cluster,
/// see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/create-subnets.html">Create a Private
/// Subnet</a> in the <i>AWS CloudHSM User Guide</i>. For information about cluster security groups, see
/// <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">Configure a Default Security
/// Group</a> in the <i>
/// <i>AWS CloudHSM User Guide</i>
/// </i>. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterInvalidConfigurationError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterInvalidConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterInvalidConfigurationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterInvalidConfigurationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterInvalidConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterInvalidConfigurationError [CloudHsmClusterInvalidConfigurationException]")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterInvalidConfigurationError {}
/// See [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
pub mod cloud_hsm_cluster_invalid_configuration_error {
    /// A builder for [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
        pub fn build(self) -> crate::error::CloudHsmClusterInvalidConfigurationError {
            crate::error::CloudHsmClusterInvalidConfigurationError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterInvalidConfigurationError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_invalid_configuration_error::Builder {
        crate::error::cloud_hsm_cluster_invalid_configuration_error::Builder::default()
    }
}

/// <p>The request was rejected because a quota was exceeded. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html">Quotas</a> in the
/// <i>AWS Key Management Service Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>The request was rejected because one or more tags are not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TagError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagError [TagException]")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagError {}
/// See [`TagError`](crate::error::TagError)
pub mod tag_error {
    /// A builder for [`TagError`](crate::error::TagError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagError`](crate::error::TagError)
        pub fn build(self) -> crate::error::TagError {
            crate::error::TagError {
                message: self.message,
            }
        }
    }
}
impl TagError {
    /// Creates a new builder-style object to manufacture [`TagError`](crate::error::TagError)
    pub fn builder() -> crate::error::tag_error::Builder {
        crate::error::tag_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified <code>GrantId</code> is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGrantIdError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGrantIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGrantIdError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGrantIdError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGrantIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGrantIdError [InvalidGrantIdException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGrantIdError {}
/// See [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
pub mod invalid_grant_id_error {
    /// A builder for [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
        pub fn build(self) -> crate::error::InvalidGrantIdError {
            crate::error::InvalidGrantIdError {
                message: self.message,
            }
        }
    }
}
impl InvalidGrantIdError {
    /// Creates a new builder-style object to manufacture [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
    pub fn builder() -> crate::error::invalid_grant_id_error::Builder {
        crate::error::invalid_grant_id_error::Builder::default()
    }
}

/// <p>From the <a>Decrypt</a> or <a>ReEncrypt</a> operation, the request
/// was rejected because the specified ciphertext, or additional authenticated data incorporated
/// into the ciphertext, such as the encryption context, is corrupted, missing, or otherwise
/// invalid.</p>
/// <p>From the <a>ImportKeyMaterial</a> operation, the request was rejected because
/// AWS KMS could not decrypt the encrypted (wrapped) key material. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCiphertextError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCiphertextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCiphertextError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCiphertextError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCiphertextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCiphertextError [InvalidCiphertextException]")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCiphertextError {}
/// See [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
pub mod invalid_ciphertext_error {
    /// A builder for [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
        pub fn build(self) -> crate::error::InvalidCiphertextError {
            crate::error::InvalidCiphertextError {
                message: self.message,
            }
        }
    }
}
impl InvalidCiphertextError {
    /// Creates a new builder-style object to manufacture [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
    pub fn builder() -> crate::error::invalid_ciphertext_error::Builder {
        crate::error::invalid_ciphertext_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK cannot decrypt the data. The
/// <code>KeyId</code> in a <a>Decrypt</a> request and the <code>SourceKeyId</code>
/// in a <a>ReEncrypt</a> request must identify the same CMK that was used to encrypt
/// the ciphertext.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IncorrectKeyError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncorrectKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectKeyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectKeyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncorrectKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectKeyError [IncorrectKeyException]")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncorrectKeyError {}
/// See [`IncorrectKeyError`](crate::error::IncorrectKeyError)
pub mod incorrect_key_error {
    /// A builder for [`IncorrectKeyError`](crate::error::IncorrectKeyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`IncorrectKeyError`](crate::error::IncorrectKeyError)
        pub fn build(self) -> crate::error::IncorrectKeyError {
            crate::error::IncorrectKeyError {
                message: self.message,
            }
        }
    }
}
impl IncorrectKeyError {
    /// Creates a new builder-style object to manufacture [`IncorrectKeyError`](crate::error::IncorrectKeyError)
    pub fn builder() -> crate::error::incorrect_key_error::Builder {
        crate::error::incorrect_key_error::Builder::default()
    }
}

/// <p>The request was rejected because a specified parameter is not supported or a specified
/// resource is not valid for this operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedOperationError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "UnsupportedOperationError [UnsupportedOperationException]"
        )?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperationError {}
/// See [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
pub mod unsupported_operation_error {
    /// A builder for [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
        pub fn build(self) -> crate::error::UnsupportedOperationError {
            crate::error::UnsupportedOperationError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperationError {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
    pub fn builder() -> crate::error::unsupported_operation_error::Builder {
        crate::error::unsupported_operation_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified policy is not syntactically or semantically
/// correct.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MalformedPolicyDocumentError [MalformedPolicyDocumentException]"
        )?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentError {}
/// See [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
pub mod malformed_policy_document_error {
    /// A builder for [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentError {
            crate::error::MalformedPolicyDocumentError {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentError {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    pub fn builder() -> crate::error::malformed_policy_document_error::Builder {
        crate::error::malformed_policy_document_error::Builder::default()
    }
}

/// <p>The request was rejected because the marker that specifies where pagination should next
/// begin is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMarkerError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMarkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMarkerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMarkerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMarkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMarkerError [InvalidMarkerException]")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMarkerError {}
/// See [`InvalidMarkerError`](crate::error::InvalidMarkerError)
pub mod invalid_marker_error {
    /// A builder for [`InvalidMarkerError`](crate::error::InvalidMarkerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMarkerError`](crate::error::InvalidMarkerError)
        pub fn build(self) -> crate::error::InvalidMarkerError {
            crate::error::InvalidMarkerError {
                message: self.message,
            }
        }
    }
}
impl InvalidMarkerError {
    /// Creates a new builder-style object to manufacture [`InvalidMarkerError`](crate::error::InvalidMarkerError)
    pub fn builder() -> crate::error::invalid_marker_error::Builder {
        crate::error::invalid_marker_error::Builder::default()
    }
}

/// <p>The request was rejected because the provided import token is invalid or is associated
/// with a different customer master key (CMK).</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidImportTokenError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidImportTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidImportTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidImportTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidImportTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImportTokenError [InvalidImportTokenException]")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidImportTokenError {}
/// See [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
pub mod invalid_import_token_error {
    /// A builder for [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
        pub fn build(self) -> crate::error::InvalidImportTokenError {
            crate::error::InvalidImportTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidImportTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
    pub fn builder() -> crate::error::invalid_import_token_error::Builder {
        crate::error::invalid_import_token_error::Builder::default()
    }
}

/// <p>The request was rejected because the key material in the request is, expired, invalid, or
/// is not the same key material that was previously imported into this customer master key
/// (CMK).</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IncorrectKeyMaterialError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncorrectKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectKeyMaterialError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectKeyMaterialError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncorrectKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IncorrectKeyMaterialError [IncorrectKeyMaterialException]"
        )?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncorrectKeyMaterialError {}
/// See [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
pub mod incorrect_key_material_error {
    /// A builder for [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
        pub fn build(self) -> crate::error::IncorrectKeyMaterialError {
            crate::error::IncorrectKeyMaterialError {
                message: self.message,
            }
        }
    }
}
impl IncorrectKeyMaterialError {
    /// Creates a new builder-style object to manufacture [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
    pub fn builder() -> crate::error::incorrect_key_material_error::Builder {
        crate::error::incorrect_key_material_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified import token is expired. Use <a>GetParametersForImport</a> to get a new import token and public key, use the new
/// public key to encrypt the key material, and then try the request again.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExpiredImportTokenError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExpiredImportTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredImportTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredImportTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExpiredImportTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredImportTokenError [ExpiredImportTokenException]")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExpiredImportTokenError {}
/// See [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
pub mod expired_import_token_error {
    /// A builder for [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
        pub fn build(self) -> crate::error::ExpiredImportTokenError {
            crate::error::ExpiredImportTokenError {
                message: self.message,
            }
        }
    }
}
impl ExpiredImportTokenError {
    /// Creates a new builder-style object to manufacture [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
    pub fn builder() -> crate::error::expired_import_token_error::Builder {
        crate::error::expired_import_token_error::Builder::default()
    }
}

/// <p>The request was rejected because the custom key store contains AWS KMS customer master keys
/// (CMKs). After verifying that you do not need to use the CMKs, use the <a>ScheduleKeyDeletion</a> operation to delete the CMKs. After they are deleted, you
/// can delete the custom key store.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomKeyStoreHasCMKsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomKeyStoreHasCMKsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreHasCMKsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreHasCMKsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomKeyStoreHasCMKsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CustomKeyStoreHasCMKsError [CustomKeyStoreHasCMKsException]"
        )?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for CustomKeyStoreHasCMKsError {}
/// See [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
pub mod custom_key_store_has_cm_ks_error {
    /// A builder for [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
        pub fn build(self) -> crate::error::CustomKeyStoreHasCMKsError {
            crate::error::CustomKeyStoreHasCMKsError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreHasCMKsError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
    pub fn builder() -> crate::error::custom_key_store_has_cm_ks_error::Builder {
        crate::error::custom_key_store_has_cm_ks_error::Builder::default()
    }
}

/// <p>The request was rejected because the trust anchor certificate in the request is not the
/// trust anchor certificate for the specified AWS CloudHSM cluster.</p>
/// <p>When you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize the cluster</a>, you create the trust anchor certificate and save it in the
/// <code>customerCA.crt</code> file.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IncorrectTrustAnchorError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncorrectTrustAnchorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectTrustAnchorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectTrustAnchorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncorrectTrustAnchorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IncorrectTrustAnchorError [IncorrectTrustAnchorException]"
        )?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncorrectTrustAnchorError {}
/// See [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
pub mod incorrect_trust_anchor_error {
    /// A builder for [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
        pub fn build(self) -> crate::error::IncorrectTrustAnchorError {
            crate::error::IncorrectTrustAnchorError {
                message: self.message,
            }
        }
    }
}
impl IncorrectTrustAnchorError {
    /// Creates a new builder-style object to manufacture [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
    pub fn builder() -> crate::error::incorrect_trust_anchor_error::Builder {
        crate::error::incorrect_trust_anchor_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster is already associated with a
/// custom key store or it shares a backup history with a cluster that is associated with a custom
/// key store. Each custom key store must be associated with a different AWS CloudHSM cluster.</p>
/// <p>Clusters that share a backup history have the same cluster certificate. To view the
/// cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudHsmClusterInUseError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CloudHsmClusterInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CloudHsmClusterInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "CloudHsmClusterInUseError [CloudHsmClusterInUseException]"
        )?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for CloudHsmClusterInUseError {}
/// See [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
pub mod cloud_hsm_cluster_in_use_error {
    /// A builder for [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
        pub fn build(self) -> crate::error::CloudHsmClusterInUseError {
            crate::error::CloudHsmClusterInUseError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterInUseError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_in_use_error::Builder {
        crate::error::cloud_hsm_cluster_in_use_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified alias name is not valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAliasNameError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAliasNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAliasNameError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAliasNameError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAliasNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAliasNameError [InvalidAliasNameException]")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAliasNameError {}
/// See [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
pub mod invalid_alias_name_error {
    /// A builder for [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
        pub fn build(self) -> crate::error::InvalidAliasNameError {
            crate::error::InvalidAliasNameError {
                message: self.message,
            }
        }
    }
}
impl InvalidAliasNameError {
    /// Creates a new builder-style object to manufacture [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
    pub fn builder() -> crate::error::invalid_alias_name_error::Builder {
        crate::error::invalid_alias_name_error::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
/// exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsError [AlreadyExistsException]")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsError {}
/// See [`AlreadyExistsError`](crate::error::AlreadyExistsError)
pub mod already_exists_error {
    /// A builder for [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsError`](crate::error::AlreadyExistsError)
        pub fn build(self) -> crate::error::AlreadyExistsError {
            crate::error::AlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    pub fn builder() -> crate::error::already_exists_error::Builder {
        crate::error::already_exists_error::Builder::default()
    }
}
