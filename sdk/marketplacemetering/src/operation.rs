// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>BatchMeterUsage is called from a SaaS application listed on the AWS Marketplace to
/// post metering records for a set of customers.</p>
/// <p>For identical requests, the API is idempotent; requests can be retried with the
/// same records or a subset of the input records.</p>
/// <p>Every request to BatchMeterUsage is for one product. If you need to meter usage for
/// multiple products, you must make multiple calls to BatchMeterUsage.</p>
/// <p>BatchMeterUsage can process up to 25 UsageRecords at a time.</p>
/// <p>A UsageRecord can optionally include multiple usage allocations, to provide customers
/// with usagedata split into buckets by tags that you define (or allow the customer to
/// define).</p>
/// <p>BatchMeterUsage requests must be less than 1MB in size.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchMeterUsage {
    _private: (),
}
impl BatchMeterUsage {
    /// Creates a new builder-style object to manufacture [`BatchMeterUsageInput`](crate::input::BatchMeterUsageInput)
    pub fn builder() -> crate::input::batch_meter_usage_input::Builder {
        crate::input::batch_meter_usage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchMeterUsage {
    type Output = std::result::Result<
        crate::output::BatchMeterUsageOutput,
        crate::error::BatchMeterUsageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_meter_usage_error(response)
        } else {
            crate::operation_deser::parse_batch_meter_usage_response(response)
        }
    }
}

/// <p>API to emit metering records. For identical requests, the API is idempotent. It
/// simply returns the metering record ID.</p>
/// <p>MeterUsage is authenticated on the buyer's AWS account using credentials from the
/// EC2 instance, ECS task, or EKS pod.</p>
/// <p>MeterUsage can optionally include multiple usage allocations, to provide customers
/// with usage data split into buckets by tags that you define (or allow the customer to
/// define).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MeterUsage {
    _private: (),
}
impl MeterUsage {
    /// Creates a new builder-style object to manufacture [`MeterUsageInput`](crate::input::MeterUsageInput)
    pub fn builder() -> crate::input::meter_usage_input::Builder {
        crate::input::meter_usage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MeterUsage {
    type Output =
        std::result::Result<crate::output::MeterUsageOutput, crate::error::MeterUsageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_meter_usage_error(response)
        } else {
            crate::operation_deser::parse_meter_usage_response(response)
        }
    }
}

/// <p>Paid container software products sold through AWS Marketplace must integrate with
/// the AWS Marketplace Metering Service and call the RegisterUsage operation for software
/// entitlement and metering. Free and BYOL products for Amazon ECS or Amazon EKS aren't
/// required to call RegisterUsage, but you may choose to do so if you would like to receive
/// usage data in your seller reports. The sections below explain the behavior of
/// RegisterUsage. RegisterUsage performs two primary functions: metering and
/// entitlement.</p>
/// <ul>
/// <li>
/// <p>
/// <i>Entitlement</i>: RegisterUsage allows you to verify that the
/// customer running your paid software is subscribed to your product on AWS
/// Marketplace, enabling you to guard against unauthorized use. Your container
/// image that integrates with RegisterUsage is only required to guard against
/// unauthorized use at container startup, as such a
/// CustomerNotSubscribedException/PlatformNotSupportedException will only be thrown
/// on the initial call to RegisterUsage. Subsequent calls from the same Amazon ECS
/// task instance (e.g. task-id) or Amazon EKS pod will not throw a
/// CustomerNotSubscribedException, even if the customer unsubscribes while the
/// Amazon ECS task or Amazon EKS pod is still running.</p>
/// </li>
/// <li>
/// <p>
/// <i>Metering</i>: RegisterUsage meters software use per ECS task,
/// per hour, or per pod for Amazon EKS with usage prorated to the second. A minimum
/// of 1 minute of usage applies to tasks that are short lived. For example, if a
/// customer has a 10 node Amazon ECS or Amazon EKS cluster and a service configured
/// as a Daemon Set, then Amazon ECS or Amazon EKS will launch a task on all 10
/// cluster nodes and the customer will be charged: (10 * hourly_rate). Metering for
/// software use is automatically handled by the AWS Marketplace Metering Control
/// Plane -- your software is not required to perform any metering specific actions,
/// other than call RegisterUsage once for metering of software use to commence. The
/// AWS Marketplace Metering Control Plane will also continue to bill customers for
/// running ECS tasks and Amazon EKS pods, regardless of the customers subscription
/// state, removing the need for your software to perform entitlement checks at
/// runtime.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterUsage {
    _private: (),
}
impl RegisterUsage {
    /// Creates a new builder-style object to manufacture [`RegisterUsageInput`](crate::input::RegisterUsageInput)
    pub fn builder() -> crate::input::register_usage_input::Builder {
        crate::input::register_usage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterUsage {
    type Output =
        std::result::Result<crate::output::RegisterUsageOutput, crate::error::RegisterUsageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_usage_error(response)
        } else {
            crate::operation_deser::parse_register_usage_response(response)
        }
    }
}

/// <p>ResolveCustomer is called by a SaaS application during the registration process.
/// When a buyer visits your website during the registration process, the buyer submits a
/// registration token through their browser. The registration token is resolved through
/// this API to obtain a CustomerIdentifier and product code.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResolveCustomer {
    _private: (),
}
impl ResolveCustomer {
    /// Creates a new builder-style object to manufacture [`ResolveCustomerInput`](crate::input::ResolveCustomerInput)
    pub fn builder() -> crate::input::resolve_customer_input::Builder {
        crate::input::resolve_customer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResolveCustomer {
    type Output = std::result::Result<
        crate::output::ResolveCustomerOutput,
        crate::error::ResolveCustomerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_resolve_customer_error(response)
        } else {
            crate::operation_deser::parse_resolve_customer_response(response)
        }
    }
}
