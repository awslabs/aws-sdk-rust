// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum Error {
    /// <p>Exception thrown when the customer does not have a valid subscription for the product.</p>
    CustomerNotEntitledException(crate::types::error::CustomerNotEntitledException),
    /// <p>The API is disabled in the Region.</p>
    DisabledApiException(crate::types::error::DisabledApiException),
    /// <p>A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {<code>usageDimension</code>, <code>timestamp</code>} with a different <code>usageQuantity</code>.</p>
    DuplicateRequestException(crate::types::error::DuplicateRequestException),
    /// <p>The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.</p>
    ExpiredTokenException(crate::types::error::ExpiredTokenException),
    /// <p>The <code>ClientToken</code> is being used for multiple requests.</p>
    IdempotencyConflictException(crate::types::error::IdempotencyConflictException),
    /// <p>An internal error has occurred. Retry your request. If the problem persists, post a message with details on the Amazon Web Services forums.</p>
    InternalServiceErrorException(crate::types::error::InternalServiceErrorException),
    /// <p>You have metered usage for a <code>CustomerIdentifier</code> that does not exist.</p>
    InvalidCustomerIdentifierException(crate::types::error::InvalidCustomerIdentifierException),
    /// <p>The endpoint being called is in a Amazon Web Services Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the Amazon Web Services Region of the resource must match.</p>
    InvalidEndpointRegionException(crate::types::error::InvalidEndpointRegionException),
    /// <p>The product code passed does not match the product code used for publishing the product.</p>
    InvalidProductCodeException(crate::types::error::InvalidProductCodeException),
    /// <p>Public Key version is invalid.</p>
    InvalidPublicKeyVersionException(crate::types::error::InvalidPublicKeyVersionException),
    /// <p><code>RegisterUsage</code> must be called in the same Amazon Web Services Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling <code>RegisterUsage</code>.</p>
    InvalidRegionException(crate::types::error::InvalidRegionException),
    /// <p>The tag is invalid, or the number of tags is greater than 5.</p>
    InvalidTagException(crate::types::error::InvalidTagException),
    /// <p>Registration token is invalid.</p>
    InvalidTokenException(crate::types::error::InvalidTokenException),
    /// <p>Sum of allocated usage quantities is not equal to the usage quantity.</p>
    InvalidUsageAllocationsException(crate::types::error::InvalidUsageAllocationsException),
    /// <p>The usage dimension does not match one of the <code>UsageDimensions</code> associated with products.</p>
    InvalidUsageDimensionException(crate::types::error::InvalidUsageDimensionException),
    /// <p>Amazon Web Services Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and Fargate are supported.</p>
    PlatformNotSupportedException(crate::types::error::PlatformNotSupportedException),
    /// <p>The calls to the API are throttled.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// <p>The <code>timestamp</code> value passed in the <code>UsageRecord</code> is out of allowed range.</p>
    /// <p>For <code>BatchMeterUsage</code>, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.</p>
    TimestampOutOfBoundsException(crate::types::error::TimestampOutOfBoundsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-Error) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::CustomerNotEntitledException(inner) => inner.fmt(f),
            Error::DisabledApiException(inner) => inner.fmt(f),
            Error::DuplicateRequestException(inner) => inner.fmt(f),
            Error::ExpiredTokenException(inner) => inner.fmt(f),
            Error::IdempotencyConflictException(inner) => inner.fmt(f),
            Error::InternalServiceErrorException(inner) => inner.fmt(f),
            Error::InvalidCustomerIdentifierException(inner) => inner.fmt(f),
            Error::InvalidEndpointRegionException(inner) => inner.fmt(f),
            Error::InvalidProductCodeException(inner) => inner.fmt(f),
            Error::InvalidPublicKeyVersionException(inner) => inner.fmt(f),
            Error::InvalidRegionException(inner) => inner.fmt(f),
            Error::InvalidTagException(inner) => inner.fmt(f),
            Error::InvalidTokenException(inner) => inner.fmt(f),
            Error::InvalidUsageAllocationsException(inner) => inner.fmt(f),
            Error::InvalidUsageDimensionException(inner) => inner.fmt(f),
            Error::PlatformNotSupportedException(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::TimestampOutOfBoundsException(inner) => inner.fmt(f),
            Error::Unhandled(_) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl From<::aws_smithy_types::error::operation::BuildError> for Error {
    fn from(value: ::aws_smithy_types::error::operation::BuildError) -> Self {
        Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: value.into(),
            meta: ::std::default::Default::default(),
        })
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for Error {
    fn meta(&self) -> &::aws_smithy_types::error::metadata::ErrorMetadata {
        match self {
            Self::CustomerNotEntitledException(inner) => inner.meta(),
            Self::DisabledApiException(inner) => inner.meta(),
            Self::DuplicateRequestException(inner) => inner.meta(),
            Self::ExpiredTokenException(inner) => inner.meta(),
            Self::IdempotencyConflictException(inner) => inner.meta(),
            Self::InternalServiceErrorException(inner) => inner.meta(),
            Self::InvalidCustomerIdentifierException(inner) => inner.meta(),
            Self::InvalidEndpointRegionException(inner) => inner.meta(),
            Self::InvalidProductCodeException(inner) => inner.meta(),
            Self::InvalidPublicKeyVersionException(inner) => inner.meta(),
            Self::InvalidRegionException(inner) => inner.meta(),
            Self::InvalidTagException(inner) => inner.meta(),
            Self::InvalidTokenException(inner) => inner.meta(),
            Self::InvalidUsageAllocationsException(inner) => inner.meta(),
            Self::InvalidUsageDimensionException(inner) => inner.meta(),
            Self::PlatformNotSupportedException(inner) => inner.meta(),
            Self::ThrottlingException(inner) => inner.meta(),
            Self::TimestampOutOfBoundsException(inner) => inner.meta(),
            Self::Unhandled(inner) => &inner.meta,
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::batch_meter_usage::BatchMeterUsageError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::batch_meter_usage::BatchMeterUsageError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::batch_meter_usage::BatchMeterUsageError> for Error {
    fn from(err: crate::operation::batch_meter_usage::BatchMeterUsageError) -> Self {
        match err {
            crate::operation::batch_meter_usage::BatchMeterUsageError::DisabledApiException(inner) => Error::DisabledApiException(inner),
            crate::operation::batch_meter_usage::BatchMeterUsageError::InternalServiceErrorException(inner) => {
                Error::InternalServiceErrorException(inner)
            }
            crate::operation::batch_meter_usage::BatchMeterUsageError::InvalidCustomerIdentifierException(inner) => {
                Error::InvalidCustomerIdentifierException(inner)
            }
            crate::operation::batch_meter_usage::BatchMeterUsageError::InvalidProductCodeException(inner) => {
                Error::InvalidProductCodeException(inner)
            }
            crate::operation::batch_meter_usage::BatchMeterUsageError::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::operation::batch_meter_usage::BatchMeterUsageError::InvalidUsageAllocationsException(inner) => {
                Error::InvalidUsageAllocationsException(inner)
            }
            crate::operation::batch_meter_usage::BatchMeterUsageError::InvalidUsageDimensionException(inner) => {
                Error::InvalidUsageDimensionException(inner)
            }
            crate::operation::batch_meter_usage::BatchMeterUsageError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::batch_meter_usage::BatchMeterUsageError::TimestampOutOfBoundsException(inner) => {
                Error::TimestampOutOfBoundsException(inner)
            }
            crate::operation::batch_meter_usage::BatchMeterUsageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::meter_usage::MeterUsageError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::meter_usage::MeterUsageError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::meter_usage::MeterUsageError> for Error {
    fn from(err: crate::operation::meter_usage::MeterUsageError) -> Self {
        match err {
            crate::operation::meter_usage::MeterUsageError::CustomerNotEntitledException(inner) => Error::CustomerNotEntitledException(inner),
            crate::operation::meter_usage::MeterUsageError::DuplicateRequestException(inner) => Error::DuplicateRequestException(inner),
            crate::operation::meter_usage::MeterUsageError::IdempotencyConflictException(inner) => Error::IdempotencyConflictException(inner),
            crate::operation::meter_usage::MeterUsageError::InternalServiceErrorException(inner) => Error::InternalServiceErrorException(inner),
            crate::operation::meter_usage::MeterUsageError::InvalidEndpointRegionException(inner) => Error::InvalidEndpointRegionException(inner),
            crate::operation::meter_usage::MeterUsageError::InvalidProductCodeException(inner) => Error::InvalidProductCodeException(inner),
            crate::operation::meter_usage::MeterUsageError::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::operation::meter_usage::MeterUsageError::InvalidUsageAllocationsException(inner) => Error::InvalidUsageAllocationsException(inner),
            crate::operation::meter_usage::MeterUsageError::InvalidUsageDimensionException(inner) => Error::InvalidUsageDimensionException(inner),
            crate::operation::meter_usage::MeterUsageError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::meter_usage::MeterUsageError::TimestampOutOfBoundsException(inner) => Error::TimestampOutOfBoundsException(inner),
            crate::operation::meter_usage::MeterUsageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::register_usage::RegisterUsageError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::register_usage::RegisterUsageError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::register_usage::RegisterUsageError> for Error {
    fn from(err: crate::operation::register_usage::RegisterUsageError) -> Self {
        match err {
            crate::operation::register_usage::RegisterUsageError::CustomerNotEntitledException(inner) => Error::CustomerNotEntitledException(inner),
            crate::operation::register_usage::RegisterUsageError::DisabledApiException(inner) => Error::DisabledApiException(inner),
            crate::operation::register_usage::RegisterUsageError::InternalServiceErrorException(inner) => Error::InternalServiceErrorException(inner),
            crate::operation::register_usage::RegisterUsageError::InvalidProductCodeException(inner) => Error::InvalidProductCodeException(inner),
            crate::operation::register_usage::RegisterUsageError::InvalidPublicKeyVersionException(inner) => {
                Error::InvalidPublicKeyVersionException(inner)
            }
            crate::operation::register_usage::RegisterUsageError::InvalidRegionException(inner) => Error::InvalidRegionException(inner),
            crate::operation::register_usage::RegisterUsageError::PlatformNotSupportedException(inner) => Error::PlatformNotSupportedException(inner),
            crate::operation::register_usage::RegisterUsageError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::register_usage::RegisterUsageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::resolve_customer::ResolveCustomerError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::resolve_customer::ResolveCustomerError, R>) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::resolve_customer::ResolveCustomerError> for Error {
    fn from(err: crate::operation::resolve_customer::ResolveCustomerError) -> Self {
        match err {
            crate::operation::resolve_customer::ResolveCustomerError::DisabledApiException(inner) => Error::DisabledApiException(inner),
            crate::operation::resolve_customer::ResolveCustomerError::ExpiredTokenException(inner) => Error::ExpiredTokenException(inner),
            crate::operation::resolve_customer::ResolveCustomerError::InternalServiceErrorException(inner) => {
                Error::InternalServiceErrorException(inner)
            }
            crate::operation::resolve_customer::ResolveCustomerError::InvalidTokenException(inner) => Error::InvalidTokenException(inner),
            crate::operation::resolve_customer::ResolveCustomerError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::operation::resolve_customer::ResolveCustomerError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl ::std::error::Error for Error {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Error::CustomerNotEntitledException(inner) => inner.source(),
            Error::DisabledApiException(inner) => inner.source(),
            Error::DuplicateRequestException(inner) => inner.source(),
            Error::ExpiredTokenException(inner) => inner.source(),
            Error::IdempotencyConflictException(inner) => inner.source(),
            Error::InternalServiceErrorException(inner) => inner.source(),
            Error::InvalidCustomerIdentifierException(inner) => inner.source(),
            Error::InvalidEndpointRegionException(inner) => inner.source(),
            Error::InvalidProductCodeException(inner) => inner.source(),
            Error::InvalidPublicKeyVersionException(inner) => inner.source(),
            Error::InvalidRegionException(inner) => inner.source(),
            Error::InvalidTagException(inner) => inner.source(),
            Error::InvalidTokenException(inner) => inner.source(),
            Error::InvalidUsageAllocationsException(inner) => inner.source(),
            Error::InvalidUsageDimensionException(inner) => inner.source(),
            Error::PlatformNotSupportedException(inner) => inner.source(),
            Error::ThrottlingException(inner) => inner.source(),
            Error::TimestampOutOfBoundsException(inner) => inner.source(),
            Error::Unhandled(inner) => ::std::option::Option::Some(&*inner.source),
        }
    }
}
impl ::aws_types::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::CustomerNotEntitledException(e) => e.request_id(),
            Self::DisabledApiException(e) => e.request_id(),
            Self::DuplicateRequestException(e) => e.request_id(),
            Self::ExpiredTokenException(e) => e.request_id(),
            Self::IdempotencyConflictException(e) => e.request_id(),
            Self::InternalServiceErrorException(e) => e.request_id(),
            Self::InvalidCustomerIdentifierException(e) => e.request_id(),
            Self::InvalidEndpointRegionException(e) => e.request_id(),
            Self::InvalidProductCodeException(e) => e.request_id(),
            Self::InvalidPublicKeyVersionException(e) => e.request_id(),
            Self::InvalidRegionException(e) => e.request_id(),
            Self::InvalidTagException(e) => e.request_id(),
            Self::InvalidTokenException(e) => e.request_id(),
            Self::InvalidUsageAllocationsException(e) => e.request_id(),
            Self::InvalidUsageDimensionException(e) => e.request_id(),
            Self::PlatformNotSupportedException(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::TimestampOutOfBoundsException(e) => e.request_id(),
            Self::Unhandled(e) => e.meta.request_id(),
        }
    }
}
