// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResolveCustomerErrorKind = ResolveCustomerError;
/// Error type for the `ResolveCustomerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResolveCustomerError {
    /// <p>The API is disabled in the Region.</p>
    DisabledApiException(crate::error::DisabledApiException),
    /// <p>The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.</p>
    ExpiredTokenException(crate::error::ExpiredTokenException),
    /// <p>An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.</p>
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    /// <p>Registration token is invalid.</p>
    InvalidTokenException(crate::error::InvalidTokenException),
    /// <p>The calls to the API are throttled.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResolveCustomerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResolveCustomerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledApiException(_inner) => _inner.fmt(f),
            Self::ExpiredTokenException(_inner) => _inner.fmt(f),
            Self::InternalServiceErrorException(_inner) => _inner.fmt(f),
            Self::InvalidTokenException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResolveCustomerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledApiException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ExpiredTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServiceErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResolveCustomerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResolveCustomerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResolveCustomerError {
    /// Creates the `ResolveCustomerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResolveCustomerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledApiException(e) => e.meta(),
            Self::ExpiredTokenException(e) => e.meta(),
            Self::InternalServiceErrorException(e) => e.meta(),
            Self::InvalidTokenException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResolveCustomerError::DisabledApiException`.
    pub fn is_disabled_api_exception(&self) -> bool {
        matches!(self, Self::DisabledApiException(_))
    }
    /// Returns `true` if the error kind is `ResolveCustomerError::ExpiredTokenException`.
    pub fn is_expired_token_exception(&self) -> bool {
        matches!(self, Self::ExpiredTokenException(_))
    }
    /// Returns `true` if the error kind is `ResolveCustomerError::InternalServiceErrorException`.
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(self, Self::InternalServiceErrorException(_))
    }
    /// Returns `true` if the error kind is `ResolveCustomerError::InvalidTokenException`.
    pub fn is_invalid_token_exception(&self) -> bool {
        matches!(self, Self::InvalidTokenException(_))
    }
    /// Returns `true` if the error kind is `ResolveCustomerError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
}
impl std::error::Error for ResolveCustomerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledApiException(_inner) => Some(_inner),
            Self::ExpiredTokenException(_inner) => Some(_inner),
            Self::InternalServiceErrorException(_inner) => Some(_inner),
            Self::InvalidTokenException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The calls to the API are throttled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ThrottlingException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
impl aws_http::request_id::RequestId for crate::error::ThrottlingException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ThrottlingException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {

    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Registration token is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTokenException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTokenException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidTokenException`](crate::error::InvalidTokenException).
    pub fn builder() -> crate::error::invalid_token_exception::Builder {
        crate::error::invalid_token_exception::Builder::default()
    }
}

/// See [`InvalidTokenException`](crate::error::InvalidTokenException).
pub mod invalid_token_exception {

    /// A builder for [`InvalidTokenException`](crate::error::InvalidTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTokenException`](crate::error::InvalidTokenException).
        pub fn build(self) -> crate::error::InvalidTokenException {
            crate::error::InvalidTokenException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServiceErrorException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InternalServiceErrorException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceErrorException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceErrorException {}
impl aws_http::request_id::RequestId for crate::error::InternalServiceErrorException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InternalServiceErrorException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InternalServiceErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServiceErrorException`](crate::error::InternalServiceErrorException).
    pub fn builder() -> crate::error::internal_service_error_exception::Builder {
        crate::error::internal_service_error_exception::Builder::default()
    }
}

/// See [`InternalServiceErrorException`](crate::error::InternalServiceErrorException).
pub mod internal_service_error_exception {

    /// A builder for [`InternalServiceErrorException`](crate::error::InternalServiceErrorException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceErrorException`](crate::error::InternalServiceErrorException).
        pub fn build(self) -> crate::error::InternalServiceErrorException {
            crate::error::InternalServiceErrorException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The submitted registration token has expired. This can happen if the buyer's browser takes too long to redirect to your page, the buyer has resubmitted the registration token, or your application has held on to the registration token for too long. Your SaaS registration website should redeem this token as soon as it is submitted by the buyer's browser.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExpiredTokenException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ExpiredTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExpiredTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredTokenException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ExpiredTokenException {}
impl aws_http::request_id::RequestId for crate::error::ExpiredTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ExpiredTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ExpiredTokenException {
    /// Creates a new builder-style object to manufacture [`ExpiredTokenException`](crate::error::ExpiredTokenException).
    pub fn builder() -> crate::error::expired_token_exception::Builder {
        crate::error::expired_token_exception::Builder::default()
    }
}

/// See [`ExpiredTokenException`](crate::error::ExpiredTokenException).
pub mod expired_token_exception {

    /// A builder for [`ExpiredTokenException`](crate::error::ExpiredTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ExpiredTokenException`](crate::error::ExpiredTokenException).
        pub fn build(self) -> crate::error::ExpiredTokenException {
            crate::error::ExpiredTokenException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The API is disabled in the Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisabledApiException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DisabledApiException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DisabledApiException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DisabledApiException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DisabledApiException {}
impl aws_http::request_id::RequestId for crate::error::DisabledApiException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisabledApiException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DisabledApiException {
    /// Creates a new builder-style object to manufacture [`DisabledApiException`](crate::error::DisabledApiException).
    pub fn builder() -> crate::error::disabled_api_exception::Builder {
        crate::error::disabled_api_exception::Builder::default()
    }
}

/// See [`DisabledApiException`](crate::error::DisabledApiException).
pub mod disabled_api_exception {

    /// A builder for [`DisabledApiException`](crate::error::DisabledApiException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DisabledApiException`](crate::error::DisabledApiException).
        pub fn build(self) -> crate::error::DisabledApiException {
            crate::error::DisabledApiException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RegisterUsageErrorKind = RegisterUsageError;
/// Error type for the `RegisterUsageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterUsageError {
    /// <p>Exception thrown when the customer does not have a valid subscription for the product.</p>
    CustomerNotEntitledException(crate::error::CustomerNotEntitledException),
    /// <p>The API is disabled in the Region.</p>
    DisabledApiException(crate::error::DisabledApiException),
    /// <p>An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.</p>
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    /// <p>The product code passed does not match the product code used for publishing the product.</p>
    InvalidProductCodeException(crate::error::InvalidProductCodeException),
    /// <p>Public Key version is invalid.</p>
    InvalidPublicKeyVersionException(crate::error::InvalidPublicKeyVersionException),
    /// <p> <code>RegisterUsage</code> must be called in the same AWS Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling <code>RegisterUsage</code>.</p>
    InvalidRegionException(crate::error::InvalidRegionException),
    /// <p>AWS Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.</p>
    PlatformNotSupportedException(crate::error::PlatformNotSupportedException),
    /// <p>The calls to the API are throttled.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterUsageError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RegisterUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CustomerNotEntitledException(_inner) => _inner.fmt(f),
            Self::DisabledApiException(_inner) => _inner.fmt(f),
            Self::InternalServiceErrorException(_inner) => _inner.fmt(f),
            Self::InvalidProductCodeException(_inner) => _inner.fmt(f),
            Self::InvalidPublicKeyVersionException(_inner) => _inner.fmt(f),
            Self::InvalidRegionException(_inner) => _inner.fmt(f),
            Self::PlatformNotSupportedException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterUsageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CustomerNotEntitledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DisabledApiException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServiceErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidProductCodeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPublicKeyVersionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRegionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PlatformNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterUsageError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterUsageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterUsageError {
    /// Creates the `RegisterUsageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RegisterUsageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CustomerNotEntitledException(e) => e.meta(),
            Self::DisabledApiException(e) => e.meta(),
            Self::InternalServiceErrorException(e) => e.meta(),
            Self::InvalidProductCodeException(e) => e.meta(),
            Self::InvalidPublicKeyVersionException(e) => e.meta(),
            Self::InvalidRegionException(e) => e.meta(),
            Self::PlatformNotSupportedException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterUsageError::CustomerNotEntitledException`.
    pub fn is_customer_not_entitled_exception(&self) -> bool {
        matches!(self, Self::CustomerNotEntitledException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::DisabledApiException`.
    pub fn is_disabled_api_exception(&self) -> bool {
        matches!(self, Self::DisabledApiException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::InternalServiceErrorException`.
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(self, Self::InternalServiceErrorException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::InvalidProductCodeException`.
    pub fn is_invalid_product_code_exception(&self) -> bool {
        matches!(self, Self::InvalidProductCodeException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::InvalidPublicKeyVersionException`.
    pub fn is_invalid_public_key_version_exception(&self) -> bool {
        matches!(self, Self::InvalidPublicKeyVersionException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::InvalidRegionException`.
    pub fn is_invalid_region_exception(&self) -> bool {
        matches!(self, Self::InvalidRegionException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::PlatformNotSupportedException`.
    pub fn is_platform_not_supported_exception(&self) -> bool {
        matches!(self, Self::PlatformNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `RegisterUsageError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
}
impl std::error::Error for RegisterUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CustomerNotEntitledException(_inner) => Some(_inner),
            Self::DisabledApiException(_inner) => Some(_inner),
            Self::InternalServiceErrorException(_inner) => Some(_inner),
            Self::InvalidProductCodeException(_inner) => Some(_inner),
            Self::InvalidPublicKeyVersionException(_inner) => Some(_inner),
            Self::InvalidRegionException(_inner) => Some(_inner),
            Self::PlatformNotSupportedException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>AWS Marketplace does not support metering usage from the underlying platform. Currently, Amazon ECS, Amazon EKS, and AWS Fargate are supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlatformNotSupportedException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PlatformNotSupportedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PlatformNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PlatformNotSupportedException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PlatformNotSupportedException {}
impl aws_http::request_id::RequestId for crate::error::PlatformNotSupportedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PlatformNotSupportedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl PlatformNotSupportedException {
    /// Creates a new builder-style object to manufacture [`PlatformNotSupportedException`](crate::error::PlatformNotSupportedException).
    pub fn builder() -> crate::error::platform_not_supported_exception::Builder {
        crate::error::platform_not_supported_exception::Builder::default()
    }
}

/// See [`PlatformNotSupportedException`](crate::error::PlatformNotSupportedException).
pub mod platform_not_supported_exception {

    /// A builder for [`PlatformNotSupportedException`](crate::error::PlatformNotSupportedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PlatformNotSupportedException`](crate::error::PlatformNotSupportedException).
        pub fn build(self) -> crate::error::PlatformNotSupportedException {
            crate::error::PlatformNotSupportedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> <code>RegisterUsage</code> must be called in the same AWS Region the ECS task was launched in. This prevents a container from hardcoding a Region (e.g. withRegion(“us-east-1”) when calling <code>RegisterUsage</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRegionException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRegionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRegionException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRegionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRegionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRegionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRegionException {
    /// Creates a new builder-style object to manufacture [`InvalidRegionException`](crate::error::InvalidRegionException).
    pub fn builder() -> crate::error::invalid_region_exception::Builder {
        crate::error::invalid_region_exception::Builder::default()
    }
}

/// See [`InvalidRegionException`](crate::error::InvalidRegionException).
pub mod invalid_region_exception {

    /// A builder for [`InvalidRegionException`](crate::error::InvalidRegionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRegionException`](crate::error::InvalidRegionException).
        pub fn build(self) -> crate::error::InvalidRegionException {
            crate::error::InvalidRegionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Public Key version is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPublicKeyVersionException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPublicKeyVersionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPublicKeyVersionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPublicKeyVersionException")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPublicKeyVersionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPublicKeyVersionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPublicKeyVersionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidPublicKeyVersionException {
    /// Creates a new builder-style object to manufacture [`InvalidPublicKeyVersionException`](crate::error::InvalidPublicKeyVersionException).
    pub fn builder() -> crate::error::invalid_public_key_version_exception::Builder {
        crate::error::invalid_public_key_version_exception::Builder::default()
    }
}

/// See [`InvalidPublicKeyVersionException`](crate::error::InvalidPublicKeyVersionException).
pub mod invalid_public_key_version_exception {

    /// A builder for [`InvalidPublicKeyVersionException`](crate::error::InvalidPublicKeyVersionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPublicKeyVersionException`](crate::error::InvalidPublicKeyVersionException).
        pub fn build(self) -> crate::error::InvalidPublicKeyVersionException {
            crate::error::InvalidPublicKeyVersionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The product code passed does not match the product code used for publishing the product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidProductCodeException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidProductCodeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidProductCodeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidProductCodeException")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidProductCodeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidProductCodeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidProductCodeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidProductCodeException {
    /// Creates a new builder-style object to manufacture [`InvalidProductCodeException`](crate::error::InvalidProductCodeException).
    pub fn builder() -> crate::error::invalid_product_code_exception::Builder {
        crate::error::invalid_product_code_exception::Builder::default()
    }
}

/// See [`InvalidProductCodeException`](crate::error::InvalidProductCodeException).
pub mod invalid_product_code_exception {

    /// A builder for [`InvalidProductCodeException`](crate::error::InvalidProductCodeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidProductCodeException`](crate::error::InvalidProductCodeException).
        pub fn build(self) -> crate::error::InvalidProductCodeException {
            crate::error::InvalidProductCodeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Exception thrown when the customer does not have a valid subscription for the product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomerNotEntitledException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CustomerNotEntitledException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CustomerNotEntitledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomerNotEntitledException")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CustomerNotEntitledException {}
impl aws_http::request_id::RequestId for crate::error::CustomerNotEntitledException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CustomerNotEntitledException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl CustomerNotEntitledException {
    /// Creates a new builder-style object to manufacture [`CustomerNotEntitledException`](crate::error::CustomerNotEntitledException).
    pub fn builder() -> crate::error::customer_not_entitled_exception::Builder {
        crate::error::customer_not_entitled_exception::Builder::default()
    }
}

/// See [`CustomerNotEntitledException`](crate::error::CustomerNotEntitledException).
pub mod customer_not_entitled_exception {

    /// A builder for [`CustomerNotEntitledException`](crate::error::CustomerNotEntitledException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CustomerNotEntitledException`](crate::error::CustomerNotEntitledException).
        pub fn build(self) -> crate::error::CustomerNotEntitledException {
            crate::error::CustomerNotEntitledException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MeterUsageErrorKind = MeterUsageError;
/// Error type for the `MeterUsageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MeterUsageError {
    /// <p>Exception thrown when the customer does not have a valid subscription for the product.</p>
    CustomerNotEntitledException(crate::error::CustomerNotEntitledException),
    /// <p>A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {<code>usageDimension</code>, <code>timestamp</code>} with a different <code>usageQuantity</code>.</p>
    DuplicateRequestException(crate::error::DuplicateRequestException),
    /// <p>An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.</p>
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    /// <p>The endpoint being called is in a AWS Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the resource must match.</p>
    InvalidEndpointRegionException(crate::error::InvalidEndpointRegionException),
    /// <p>The product code passed does not match the product code used for publishing the product.</p>
    InvalidProductCodeException(crate::error::InvalidProductCodeException),
    /// <p>The tag is invalid, or the number of tags is greater than 5.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.</p>
    InvalidUsageAllocationsException(crate::error::InvalidUsageAllocationsException),
    /// <p>The usage dimension does not match one of the <code>UsageDimensions</code> associated with products.</p>
    InvalidUsageDimensionException(crate::error::InvalidUsageDimensionException),
    /// <p>The calls to the API are throttled.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The <code>timestamp</code> value passed in the <code>UsageRecord</code> is out of allowed range.</p>
    /// <p>For <code>BatchMeterUsage</code>, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.</p>
    TimestampOutOfBoundsException(crate::error::TimestampOutOfBoundsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MeterUsageError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MeterUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CustomerNotEntitledException(_inner) => _inner.fmt(f),
            Self::DuplicateRequestException(_inner) => _inner.fmt(f),
            Self::InternalServiceErrorException(_inner) => _inner.fmt(f),
            Self::InvalidEndpointRegionException(_inner) => _inner.fmt(f),
            Self::InvalidProductCodeException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::InvalidUsageAllocationsException(_inner) => _inner.fmt(f),
            Self::InvalidUsageDimensionException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TimestampOutOfBoundsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MeterUsageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CustomerNotEntitledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DuplicateRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServiceErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEndpointRegionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidProductCodeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUsageAllocationsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUsageDimensionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TimestampOutOfBoundsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MeterUsageError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MeterUsageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MeterUsageError {
    /// Creates the `MeterUsageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MeterUsageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CustomerNotEntitledException(e) => e.meta(),
            Self::DuplicateRequestException(e) => e.meta(),
            Self::InternalServiceErrorException(e) => e.meta(),
            Self::InvalidEndpointRegionException(e) => e.meta(),
            Self::InvalidProductCodeException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::InvalidUsageAllocationsException(e) => e.meta(),
            Self::InvalidUsageDimensionException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::TimestampOutOfBoundsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MeterUsageError::CustomerNotEntitledException`.
    pub fn is_customer_not_entitled_exception(&self) -> bool {
        matches!(self, Self::CustomerNotEntitledException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::DuplicateRequestException`.
    pub fn is_duplicate_request_exception(&self) -> bool {
        matches!(self, Self::DuplicateRequestException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::InternalServiceErrorException`.
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(self, Self::InternalServiceErrorException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::InvalidEndpointRegionException`.
    pub fn is_invalid_endpoint_region_exception(&self) -> bool {
        matches!(self, Self::InvalidEndpointRegionException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::InvalidProductCodeException`.
    pub fn is_invalid_product_code_exception(&self) -> bool {
        matches!(self, Self::InvalidProductCodeException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::InvalidUsageAllocationsException`.
    pub fn is_invalid_usage_allocations_exception(&self) -> bool {
        matches!(self, Self::InvalidUsageAllocationsException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::InvalidUsageDimensionException`.
    pub fn is_invalid_usage_dimension_exception(&self) -> bool {
        matches!(self, Self::InvalidUsageDimensionException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `MeterUsageError::TimestampOutOfBoundsException`.
    pub fn is_timestamp_out_of_bounds_exception(&self) -> bool {
        matches!(self, Self::TimestampOutOfBoundsException(_))
    }
}
impl std::error::Error for MeterUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CustomerNotEntitledException(_inner) => Some(_inner),
            Self::DuplicateRequestException(_inner) => Some(_inner),
            Self::InternalServiceErrorException(_inner) => Some(_inner),
            Self::InvalidEndpointRegionException(_inner) => Some(_inner),
            Self::InvalidProductCodeException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::InvalidUsageAllocationsException(_inner) => Some(_inner),
            Self::InvalidUsageDimensionException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::TimestampOutOfBoundsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The <code>timestamp</code> value passed in the <code>UsageRecord</code> is out of allowed range.</p>
/// <p>For <code>BatchMeterUsage</code>, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimestampOutOfBoundsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TimestampOutOfBoundsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TimestampOutOfBoundsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TimestampOutOfBoundsException")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TimestampOutOfBoundsException {}
impl aws_http::request_id::RequestId for crate::error::TimestampOutOfBoundsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TimestampOutOfBoundsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TimestampOutOfBoundsException {
    /// Creates a new builder-style object to manufacture [`TimestampOutOfBoundsException`](crate::error::TimestampOutOfBoundsException).
    pub fn builder() -> crate::error::timestamp_out_of_bounds_exception::Builder {
        crate::error::timestamp_out_of_bounds_exception::Builder::default()
    }
}

/// See [`TimestampOutOfBoundsException`](crate::error::TimestampOutOfBoundsException).
pub mod timestamp_out_of_bounds_exception {

    /// A builder for [`TimestampOutOfBoundsException`](crate::error::TimestampOutOfBoundsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TimestampOutOfBoundsException`](crate::error::TimestampOutOfBoundsException).
        pub fn build(self) -> crate::error::TimestampOutOfBoundsException {
            crate::error::TimestampOutOfBoundsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The usage dimension does not match one of the <code>UsageDimensions</code> associated with products.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidUsageDimensionException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidUsageDimensionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUsageDimensionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUsageDimensionException")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUsageDimensionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidUsageDimensionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidUsageDimensionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidUsageDimensionException {
    /// Creates a new builder-style object to manufacture [`InvalidUsageDimensionException`](crate::error::InvalidUsageDimensionException).
    pub fn builder() -> crate::error::invalid_usage_dimension_exception::Builder {
        crate::error::invalid_usage_dimension_exception::Builder::default()
    }
}

/// See [`InvalidUsageDimensionException`](crate::error::InvalidUsageDimensionException).
pub mod invalid_usage_dimension_exception {

    /// A builder for [`InvalidUsageDimensionException`](crate::error::InvalidUsageDimensionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUsageDimensionException`](crate::error::InvalidUsageDimensionException).
        pub fn build(self) -> crate::error::InvalidUsageDimensionException {
            crate::error::InvalidUsageDimensionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidUsageAllocationsException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidUsageAllocationsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUsageAllocationsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUsageAllocationsException")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUsageAllocationsException {}
impl aws_http::request_id::RequestId for crate::error::InvalidUsageAllocationsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidUsageAllocationsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidUsageAllocationsException {
    /// Creates a new builder-style object to manufacture [`InvalidUsageAllocationsException`](crate::error::InvalidUsageAllocationsException).
    pub fn builder() -> crate::error::invalid_usage_allocations_exception::Builder {
        crate::error::invalid_usage_allocations_exception::Builder::default()
    }
}

/// See [`InvalidUsageAllocationsException`](crate::error::InvalidUsageAllocationsException).
pub mod invalid_usage_allocations_exception {

    /// A builder for [`InvalidUsageAllocationsException`](crate::error::InvalidUsageAllocationsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUsageAllocationsException`](crate::error::InvalidUsageAllocationsException).
        pub fn build(self) -> crate::error::InvalidUsageAllocationsException {
            crate::error::InvalidUsageAllocationsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The tag is invalid, or the number of tags is greater than 5.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagException")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTagException {
    /// Creates a new builder-style object to manufacture [`InvalidTagException`](crate::error::InvalidTagException).
    pub fn builder() -> crate::error::invalid_tag_exception::Builder {
        crate::error::invalid_tag_exception::Builder::default()
    }
}

/// See [`InvalidTagException`](crate::error::InvalidTagException).
pub mod invalid_tag_exception {

    /// A builder for [`InvalidTagException`](crate::error::InvalidTagException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagException`](crate::error::InvalidTagException).
        pub fn build(self) -> crate::error::InvalidTagException {
            crate::error::InvalidTagException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The endpoint being called is in a AWS Region different from your EC2 instance, ECS task, or EKS pod. The Region of the Metering Service endpoint and the AWS Region of the resource must match.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEndpointRegionException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEndpointRegionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEndpointRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEndpointRegionException")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEndpointRegionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidEndpointRegionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidEndpointRegionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidEndpointRegionException {
    /// Creates a new builder-style object to manufacture [`InvalidEndpointRegionException`](crate::error::InvalidEndpointRegionException).
    pub fn builder() -> crate::error::invalid_endpoint_region_exception::Builder {
        crate::error::invalid_endpoint_region_exception::Builder::default()
    }
}

/// See [`InvalidEndpointRegionException`](crate::error::InvalidEndpointRegionException).
pub mod invalid_endpoint_region_exception {

    /// A builder for [`InvalidEndpointRegionException`](crate::error::InvalidEndpointRegionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEndpointRegionException`](crate::error::InvalidEndpointRegionException).
        pub fn build(self) -> crate::error::InvalidEndpointRegionException {
            crate::error::InvalidEndpointRegionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A metering record has already been emitted by the same EC2 instance, ECS task, or EKS pod for the given {<code>usageDimension</code>, <code>timestamp</code>} with a different <code>usageQuantity</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DuplicateRequestException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DuplicateRequestException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateRequestException")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateRequestException {}
impl aws_http::request_id::RequestId for crate::error::DuplicateRequestException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DuplicateRequestException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DuplicateRequestException {
    /// Creates a new builder-style object to manufacture [`DuplicateRequestException`](crate::error::DuplicateRequestException).
    pub fn builder() -> crate::error::duplicate_request_exception::Builder {
        crate::error::duplicate_request_exception::Builder::default()
    }
}

/// See [`DuplicateRequestException`](crate::error::DuplicateRequestException).
pub mod duplicate_request_exception {

    /// A builder for [`DuplicateRequestException`](crate::error::DuplicateRequestException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateRequestException`](crate::error::DuplicateRequestException).
        pub fn build(self) -> crate::error::DuplicateRequestException {
            crate::error::DuplicateRequestException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchMeterUsageErrorKind = BatchMeterUsageError;
/// Error type for the `BatchMeterUsageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchMeterUsageError {
    /// <p>The API is disabled in the Region.</p>
    DisabledApiException(crate::error::DisabledApiException),
    /// <p>An internal error has occurred. Retry your request. If the problem persists, post a message with details on the AWS forums.</p>
    InternalServiceErrorException(crate::error::InternalServiceErrorException),
    /// <p>You have metered usage for a <code>CustomerIdentifier</code> that does not exist.</p>
    InvalidCustomerIdentifierException(crate::error::InvalidCustomerIdentifierException),
    /// <p>The product code passed does not match the product code used for publishing the product.</p>
    InvalidProductCodeException(crate::error::InvalidProductCodeException),
    /// <p>The tag is invalid, or the number of tags is greater than 5.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>The usage allocation objects are invalid, or the number of allocations is greater than 500 for a single usage record.</p>
    InvalidUsageAllocationsException(crate::error::InvalidUsageAllocationsException),
    /// <p>The usage dimension does not match one of the <code>UsageDimensions</code> associated with products.</p>
    InvalidUsageDimensionException(crate::error::InvalidUsageDimensionException),
    /// <p>The calls to the API are throttled.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The <code>timestamp</code> value passed in the <code>UsageRecord</code> is out of allowed range.</p>
    /// <p>For <code>BatchMeterUsage</code>, if any of the records are outside of the allowed range, the entire batch is not processed. You must remove invalid records and try again.</p>
    TimestampOutOfBoundsException(crate::error::TimestampOutOfBoundsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchMeterUsageError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchMeterUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledApiException(_inner) => _inner.fmt(f),
            Self::InternalServiceErrorException(_inner) => _inner.fmt(f),
            Self::InvalidCustomerIdentifierException(_inner) => _inner.fmt(f),
            Self::InvalidProductCodeException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::InvalidUsageAllocationsException(_inner) => _inner.fmt(f),
            Self::InvalidUsageDimensionException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TimestampOutOfBoundsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchMeterUsageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledApiException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServiceErrorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCustomerIdentifierException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidProductCodeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUsageAllocationsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUsageDimensionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TimestampOutOfBoundsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchMeterUsageError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchMeterUsageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchMeterUsageError {
    /// Creates the `BatchMeterUsageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchMeterUsageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledApiException(e) => e.meta(),
            Self::InternalServiceErrorException(e) => e.meta(),
            Self::InvalidCustomerIdentifierException(e) => e.meta(),
            Self::InvalidProductCodeException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::InvalidUsageAllocationsException(e) => e.meta(),
            Self::InvalidUsageDimensionException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::TimestampOutOfBoundsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::DisabledApiException`.
    pub fn is_disabled_api_exception(&self) -> bool {
        matches!(self, Self::DisabledApiException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::InternalServiceErrorException`.
    pub fn is_internal_service_error_exception(&self) -> bool {
        matches!(self, Self::InternalServiceErrorException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::InvalidCustomerIdentifierException`.
    pub fn is_invalid_customer_identifier_exception(&self) -> bool {
        matches!(self, Self::InvalidCustomerIdentifierException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::InvalidProductCodeException`.
    pub fn is_invalid_product_code_exception(&self) -> bool {
        matches!(self, Self::InvalidProductCodeException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::InvalidUsageAllocationsException`.
    pub fn is_invalid_usage_allocations_exception(&self) -> bool {
        matches!(self, Self::InvalidUsageAllocationsException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::InvalidUsageDimensionException`.
    pub fn is_invalid_usage_dimension_exception(&self) -> bool {
        matches!(self, Self::InvalidUsageDimensionException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `BatchMeterUsageError::TimestampOutOfBoundsException`.
    pub fn is_timestamp_out_of_bounds_exception(&self) -> bool {
        matches!(self, Self::TimestampOutOfBoundsException(_))
    }
}
impl std::error::Error for BatchMeterUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledApiException(_inner) => Some(_inner),
            Self::InternalServiceErrorException(_inner) => Some(_inner),
            Self::InvalidCustomerIdentifierException(_inner) => Some(_inner),
            Self::InvalidProductCodeException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::InvalidUsageAllocationsException(_inner) => Some(_inner),
            Self::InvalidUsageDimensionException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::TimestampOutOfBoundsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have metered usage for a <code>CustomerIdentifier</code> that does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCustomerIdentifierException {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCustomerIdentifierException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCustomerIdentifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCustomerIdentifierException")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCustomerIdentifierException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCustomerIdentifierException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidCustomerIdentifierException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidCustomerIdentifierException {
    /// Creates a new builder-style object to manufacture [`InvalidCustomerIdentifierException`](crate::error::InvalidCustomerIdentifierException).
    pub fn builder() -> crate::error::invalid_customer_identifier_exception::Builder {
        crate::error::invalid_customer_identifier_exception::Builder::default()
    }
}

/// See [`InvalidCustomerIdentifierException`](crate::error::InvalidCustomerIdentifierException).
pub mod invalid_customer_identifier_exception {

    /// A builder for [`InvalidCustomerIdentifierException`](crate::error::InvalidCustomerIdentifierException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCustomerIdentifierException`](crate::error::InvalidCustomerIdentifierException).
        pub fn build(self) -> crate::error::InvalidCustomerIdentifierException {
            crate::error::InvalidCustomerIdentifierException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
