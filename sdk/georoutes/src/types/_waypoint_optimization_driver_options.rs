// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Driver related options.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct WaypointOptimizationDriverOptions {
    /// <p>Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.</p>
    pub rest_cycles: ::std::option::Option<crate::types::WaypointOptimizationRestCycles>,
    /// <p>Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.</p>
    pub rest_profile: ::std::option::Option<crate::types::WaypointOptimizationRestProfile>,
    /// <p>If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.</p>
    pub treat_service_time_as: ::std::option::Option<crate::types::WaypointOptimizationServiceTimeTreatment>,
}
impl WaypointOptimizationDriverOptions {
    /// <p>Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.</p>
    pub fn rest_cycles(&self) -> ::std::option::Option<&crate::types::WaypointOptimizationRestCycles> {
        self.rest_cycles.as_ref()
    }
    /// <p>Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.</p>
    pub fn rest_profile(&self) -> ::std::option::Option<&crate::types::WaypointOptimizationRestProfile> {
        self.rest_profile.as_ref()
    }
    /// <p>If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.</p>
    pub fn treat_service_time_as(&self) -> ::std::option::Option<&crate::types::WaypointOptimizationServiceTimeTreatment> {
        self.treat_service_time_as.as_ref()
    }
}
impl ::std::fmt::Debug for WaypointOptimizationDriverOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("WaypointOptimizationDriverOptions");
        formatter.field("rest_cycles", &self.rest_cycles);
        formatter.field("rest_profile", &self.rest_profile);
        formatter.field("treat_service_time_as", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl WaypointOptimizationDriverOptions {
    /// Creates a new builder-style object to manufacture [`WaypointOptimizationDriverOptions`](crate::types::WaypointOptimizationDriverOptions).
    pub fn builder() -> crate::types::builders::WaypointOptimizationDriverOptionsBuilder {
        crate::types::builders::WaypointOptimizationDriverOptionsBuilder::default()
    }
}

/// A builder for [`WaypointOptimizationDriverOptions`](crate::types::WaypointOptimizationDriverOptions).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct WaypointOptimizationDriverOptionsBuilder {
    pub(crate) rest_cycles: ::std::option::Option<crate::types::WaypointOptimizationRestCycles>,
    pub(crate) rest_profile: ::std::option::Option<crate::types::WaypointOptimizationRestProfile>,
    pub(crate) treat_service_time_as: ::std::option::Option<crate::types::WaypointOptimizationServiceTimeTreatment>,
}
impl WaypointOptimizationDriverOptionsBuilder {
    /// <p>Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.</p>
    pub fn rest_cycles(mut self, input: crate::types::WaypointOptimizationRestCycles) -> Self {
        self.rest_cycles = ::std::option::Option::Some(input);
        self
    }
    /// <p>Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.</p>
    pub fn set_rest_cycles(mut self, input: ::std::option::Option<crate::types::WaypointOptimizationRestCycles>) -> Self {
        self.rest_cycles = input;
        self
    }
    /// <p>Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.</p>
    pub fn get_rest_cycles(&self) -> &::std::option::Option<crate::types::WaypointOptimizationRestCycles> {
        &self.rest_cycles
    }
    /// <p>Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.</p>
    pub fn rest_profile(mut self, input: crate::types::WaypointOptimizationRestProfile) -> Self {
        self.rest_profile = ::std::option::Option::Some(input);
        self
    }
    /// <p>Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.</p>
    pub fn set_rest_profile(mut self, input: ::std::option::Option<crate::types::WaypointOptimizationRestProfile>) -> Self {
        self.rest_profile = input;
        self
    }
    /// <p>Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.</p>
    pub fn get_rest_profile(&self) -> &::std::option::Option<crate::types::WaypointOptimizationRestProfile> {
        &self.rest_profile
    }
    /// <p>If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.</p>
    pub fn treat_service_time_as(mut self, input: crate::types::WaypointOptimizationServiceTimeTreatment) -> Self {
        self.treat_service_time_as = ::std::option::Option::Some(input);
        self
    }
    /// <p>If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.</p>
    pub fn set_treat_service_time_as(mut self, input: ::std::option::Option<crate::types::WaypointOptimizationServiceTimeTreatment>) -> Self {
        self.treat_service_time_as = input;
        self
    }
    /// <p>If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.</p>
    pub fn get_treat_service_time_as(&self) -> &::std::option::Option<crate::types::WaypointOptimizationServiceTimeTreatment> {
        &self.treat_service_time_as
    }
    /// Consumes the builder and constructs a [`WaypointOptimizationDriverOptions`](crate::types::WaypointOptimizationDriverOptions).
    pub fn build(self) -> crate::types::WaypointOptimizationDriverOptions {
        crate::types::WaypointOptimizationDriverOptions {
            rest_cycles: self.rest_cycles,
            rest_profile: self.rest_profile,
            treat_service_time_as: self.treat_service_time_as,
        }
    }
}
impl ::std::fmt::Debug for WaypointOptimizationDriverOptionsBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("WaypointOptimizationDriverOptionsBuilder");
        formatter.field("rest_cycles", &self.rest_cycles);
        formatter.field("rest_profile", &self.rest_profile);
        formatter.field("treat_service_time_as", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
