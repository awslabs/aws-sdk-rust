// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies options for areas to avoid when calculating the route. This is a best-effort avoidance setting, meaning the router will try to honor the avoidance preferences but may still include restricted areas if no feasible alternative route exists. If avoidance options are not followed, the response will indicate that the avoidance criteria were violated.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct RouteAvoidanceOptions {
    /// <p>Areas to be avoided.</p>
    pub areas: ::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceArea>>,
    /// <p>Avoid car-shuttle-trains while calculating the route.</p>
    pub car_shuttle_trains: ::std::option::Option<bool>,
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub controlled_access_highways: ::std::option::Option<bool>,
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub dirt_roads: ::std::option::Option<bool>,
    /// <p>Avoid ferries while calculating the route.</p>
    pub ferries: ::std::option::Option<bool>,
    /// <p>Avoid roads that have seasonal closure while calculating the route.</p>
    pub seasonal_closure: ::std::option::Option<bool>,
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub toll_roads: ::std::option::Option<bool>,
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub toll_transponders: ::std::option::Option<bool>,
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub truck_road_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>Avoid tunnels while calculating the route.</p>
    pub tunnels: ::std::option::Option<bool>,
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub u_turns: ::std::option::Option<bool>,
    /// <p>Zone categories to be avoided.</p>
    pub zone_categories: ::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceZoneCategory>>,
}
impl RouteAvoidanceOptions {
    /// <p>Areas to be avoided.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.areas.is_none()`.
    pub fn areas(&self) -> &[crate::types::RouteAvoidanceArea] {
        self.areas.as_deref().unwrap_or_default()
    }
    /// <p>Avoid car-shuttle-trains while calculating the route.</p>
    pub fn car_shuttle_trains(&self) -> ::std::option::Option<bool> {
        self.car_shuttle_trains
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn controlled_access_highways(&self) -> ::std::option::Option<bool> {
        self.controlled_access_highways
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn dirt_roads(&self) -> ::std::option::Option<bool> {
        self.dirt_roads
    }
    /// <p>Avoid ferries while calculating the route.</p>
    pub fn ferries(&self) -> ::std::option::Option<bool> {
        self.ferries
    }
    /// <p>Avoid roads that have seasonal closure while calculating the route.</p>
    pub fn seasonal_closure(&self) -> ::std::option::Option<bool> {
        self.seasonal_closure
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn toll_roads(&self) -> ::std::option::Option<bool> {
        self.toll_roads
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn toll_transponders(&self) -> ::std::option::Option<bool> {
        self.toll_transponders
    }
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.truck_road_types.is_none()`.
    pub fn truck_road_types(&self) -> &[::std::string::String] {
        self.truck_road_types.as_deref().unwrap_or_default()
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn tunnels(&self) -> ::std::option::Option<bool> {
        self.tunnels
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn u_turns(&self) -> ::std::option::Option<bool> {
        self.u_turns
    }
    /// <p>Zone categories to be avoided.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.zone_categories.is_none()`.
    pub fn zone_categories(&self) -> &[crate::types::RouteAvoidanceZoneCategory] {
        self.zone_categories.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for RouteAvoidanceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RouteAvoidanceOptions");
        formatter.field("areas", &self.areas);
        formatter.field("car_shuttle_trains", &"*** Sensitive Data Redacted ***");
        formatter.field("controlled_access_highways", &"*** Sensitive Data Redacted ***");
        formatter.field("dirt_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("ferries", &"*** Sensitive Data Redacted ***");
        formatter.field("seasonal_closure", &"*** Sensitive Data Redacted ***");
        formatter.field("toll_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("toll_transponders", &"*** Sensitive Data Redacted ***");
        formatter.field("truck_road_types", &"*** Sensitive Data Redacted ***");
        formatter.field("tunnels", &"*** Sensitive Data Redacted ***");
        formatter.field("u_turns", &"*** Sensitive Data Redacted ***");
        formatter.field("zone_categories", &self.zone_categories);
        formatter.finish()
    }
}
impl RouteAvoidanceOptions {
    /// Creates a new builder-style object to manufacture [`RouteAvoidanceOptions`](crate::types::RouteAvoidanceOptions).
    pub fn builder() -> crate::types::builders::RouteAvoidanceOptionsBuilder {
        crate::types::builders::RouteAvoidanceOptionsBuilder::default()
    }
}

/// A builder for [`RouteAvoidanceOptions`](crate::types::RouteAvoidanceOptions).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct RouteAvoidanceOptionsBuilder {
    pub(crate) areas: ::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceArea>>,
    pub(crate) car_shuttle_trains: ::std::option::Option<bool>,
    pub(crate) controlled_access_highways: ::std::option::Option<bool>,
    pub(crate) dirt_roads: ::std::option::Option<bool>,
    pub(crate) ferries: ::std::option::Option<bool>,
    pub(crate) seasonal_closure: ::std::option::Option<bool>,
    pub(crate) toll_roads: ::std::option::Option<bool>,
    pub(crate) toll_transponders: ::std::option::Option<bool>,
    pub(crate) truck_road_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) tunnels: ::std::option::Option<bool>,
    pub(crate) u_turns: ::std::option::Option<bool>,
    pub(crate) zone_categories: ::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceZoneCategory>>,
}
impl RouteAvoidanceOptionsBuilder {
    /// Appends an item to `areas`.
    ///
    /// To override the contents of this collection use [`set_areas`](Self::set_areas).
    ///
    /// <p>Areas to be avoided.</p>
    pub fn areas(mut self, input: crate::types::RouteAvoidanceArea) -> Self {
        let mut v = self.areas.unwrap_or_default();
        v.push(input);
        self.areas = ::std::option::Option::Some(v);
        self
    }
    /// <p>Areas to be avoided.</p>
    pub fn set_areas(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceArea>>) -> Self {
        self.areas = input;
        self
    }
    /// <p>Areas to be avoided.</p>
    pub fn get_areas(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceArea>> {
        &self.areas
    }
    /// <p>Avoid car-shuttle-trains while calculating the route.</p>
    pub fn car_shuttle_trains(mut self, input: bool) -> Self {
        self.car_shuttle_trains = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid car-shuttle-trains while calculating the route.</p>
    pub fn set_car_shuttle_trains(mut self, input: ::std::option::Option<bool>) -> Self {
        self.car_shuttle_trains = input;
        self
    }
    /// <p>Avoid car-shuttle-trains while calculating the route.</p>
    pub fn get_car_shuttle_trains(&self) -> &::std::option::Option<bool> {
        &self.car_shuttle_trains
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn controlled_access_highways(mut self, input: bool) -> Self {
        self.controlled_access_highways = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn set_controlled_access_highways(mut self, input: ::std::option::Option<bool>) -> Self {
        self.controlled_access_highways = input;
        self
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn get_controlled_access_highways(&self) -> &::std::option::Option<bool> {
        &self.controlled_access_highways
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn dirt_roads(mut self, input: bool) -> Self {
        self.dirt_roads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn set_dirt_roads(mut self, input: ::std::option::Option<bool>) -> Self {
        self.dirt_roads = input;
        self
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn get_dirt_roads(&self) -> &::std::option::Option<bool> {
        &self.dirt_roads
    }
    /// <p>Avoid ferries while calculating the route.</p>
    pub fn ferries(mut self, input: bool) -> Self {
        self.ferries = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid ferries while calculating the route.</p>
    pub fn set_ferries(mut self, input: ::std::option::Option<bool>) -> Self {
        self.ferries = input;
        self
    }
    /// <p>Avoid ferries while calculating the route.</p>
    pub fn get_ferries(&self) -> &::std::option::Option<bool> {
        &self.ferries
    }
    /// <p>Avoid roads that have seasonal closure while calculating the route.</p>
    pub fn seasonal_closure(mut self, input: bool) -> Self {
        self.seasonal_closure = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid roads that have seasonal closure while calculating the route.</p>
    pub fn set_seasonal_closure(mut self, input: ::std::option::Option<bool>) -> Self {
        self.seasonal_closure = input;
        self
    }
    /// <p>Avoid roads that have seasonal closure while calculating the route.</p>
    pub fn get_seasonal_closure(&self) -> &::std::option::Option<bool> {
        &self.seasonal_closure
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn toll_roads(mut self, input: bool) -> Self {
        self.toll_roads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn set_toll_roads(mut self, input: ::std::option::Option<bool>) -> Self {
        self.toll_roads = input;
        self
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn get_toll_roads(&self) -> &::std::option::Option<bool> {
        &self.toll_roads
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn toll_transponders(mut self, input: bool) -> Self {
        self.toll_transponders = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn set_toll_transponders(mut self, input: ::std::option::Option<bool>) -> Self {
        self.toll_transponders = input;
        self
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn get_toll_transponders(&self) -> &::std::option::Option<bool> {
        &self.toll_transponders
    }
    /// Appends an item to `truck_road_types`.
    ///
    /// To override the contents of this collection use [`set_truck_road_types`](Self::set_truck_road_types).
    ///
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub fn truck_road_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.truck_road_types.unwrap_or_default();
        v.push(input.into());
        self.truck_road_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub fn set_truck_road_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.truck_road_types = input;
        self
    }
    /// <p>Truck road type identifiers. <code>BK1</code> through <code>BK4</code> apply only to Sweden. <code>A2,A4,B2,B4,C,D,ET2,ET4</code> apply only to Mexico.</p><note>
    /// <p>There are currently no other supported values as of 26th April 2024.</p>
    /// </note>
    pub fn get_truck_road_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.truck_road_types
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn tunnels(mut self, input: bool) -> Self {
        self.tunnels = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn set_tunnels(mut self, input: ::std::option::Option<bool>) -> Self {
        self.tunnels = input;
        self
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn get_tunnels(&self) -> &::std::option::Option<bool> {
        &self.tunnels
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn u_turns(mut self, input: bool) -> Self {
        self.u_turns = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn set_u_turns(mut self, input: ::std::option::Option<bool>) -> Self {
        self.u_turns = input;
        self
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn get_u_turns(&self) -> &::std::option::Option<bool> {
        &self.u_turns
    }
    /// Appends an item to `zone_categories`.
    ///
    /// To override the contents of this collection use [`set_zone_categories`](Self::set_zone_categories).
    ///
    /// <p>Zone categories to be avoided.</p>
    pub fn zone_categories(mut self, input: crate::types::RouteAvoidanceZoneCategory) -> Self {
        let mut v = self.zone_categories.unwrap_or_default();
        v.push(input);
        self.zone_categories = ::std::option::Option::Some(v);
        self
    }
    /// <p>Zone categories to be avoided.</p>
    pub fn set_zone_categories(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceZoneCategory>>) -> Self {
        self.zone_categories = input;
        self
    }
    /// <p>Zone categories to be avoided.</p>
    pub fn get_zone_categories(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteAvoidanceZoneCategory>> {
        &self.zone_categories
    }
    /// Consumes the builder and constructs a [`RouteAvoidanceOptions`](crate::types::RouteAvoidanceOptions).
    pub fn build(self) -> crate::types::RouteAvoidanceOptions {
        crate::types::RouteAvoidanceOptions {
            areas: self.areas,
            car_shuttle_trains: self.car_shuttle_trains,
            controlled_access_highways: self.controlled_access_highways,
            dirt_roads: self.dirt_roads,
            ferries: self.ferries,
            seasonal_closure: self.seasonal_closure,
            toll_roads: self.toll_roads,
            toll_transponders: self.toll_transponders,
            truck_road_types: self.truck_road_types,
            tunnels: self.tunnels,
            u_turns: self.u_turns,
            zone_categories: self.zone_categories,
        }
    }
}
impl ::std::fmt::Debug for RouteAvoidanceOptionsBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RouteAvoidanceOptionsBuilder");
        formatter.field("areas", &self.areas);
        formatter.field("car_shuttle_trains", &"*** Sensitive Data Redacted ***");
        formatter.field("controlled_access_highways", &"*** Sensitive Data Redacted ***");
        formatter.field("dirt_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("ferries", &"*** Sensitive Data Redacted ***");
        formatter.field("seasonal_closure", &"*** Sensitive Data Redacted ***");
        formatter.field("toll_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("toll_transponders", &"*** Sensitive Data Redacted ***");
        formatter.field("truck_road_types", &"*** Sensitive Data Redacted ***");
        formatter.field("tunnels", &"*** Sensitive Data Redacted ***");
        formatter.field("u_turns", &"*** Sensitive Data Redacted ***");
        formatter.field("zone_categories", &self.zone_categories);
        formatter.finish()
    }
}
