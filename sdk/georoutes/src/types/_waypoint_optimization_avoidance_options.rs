// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies options for areas to avoid. This is a best-effort avoidance setting, meaning the router will try to honor the avoidance preferences but may still include restricted areas if no feasible alternative route exists. If avoidance options are not followed, the response will indicate that the avoidance criteria were violated.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct WaypointOptimizationAvoidanceOptions {
    /// <p>Areas to be avoided.</p>
    pub areas: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationAvoidanceArea>>,
    /// <p>Avoidance options for cars-shuttles-trains.</p>
    pub car_shuttle_trains: ::std::option::Option<bool>,
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub controlled_access_highways: ::std::option::Option<bool>,
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub dirt_roads: ::std::option::Option<bool>,
    /// <p>Avoidance options for ferries.</p>
    pub ferries: ::std::option::Option<bool>,
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub toll_roads: ::std::option::Option<bool>,
    /// <p>Avoid tunnels while calculating the route.</p>
    pub tunnels: ::std::option::Option<bool>,
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub u_turns: ::std::option::Option<bool>,
}
impl WaypointOptimizationAvoidanceOptions {
    /// <p>Areas to be avoided.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.areas.is_none()`.
    pub fn areas(&self) -> &[crate::types::WaypointOptimizationAvoidanceArea] {
        self.areas.as_deref().unwrap_or_default()
    }
    /// <p>Avoidance options for cars-shuttles-trains.</p>
    pub fn car_shuttle_trains(&self) -> ::std::option::Option<bool> {
        self.car_shuttle_trains
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn controlled_access_highways(&self) -> ::std::option::Option<bool> {
        self.controlled_access_highways
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn dirt_roads(&self) -> ::std::option::Option<bool> {
        self.dirt_roads
    }
    /// <p>Avoidance options for ferries.</p>
    pub fn ferries(&self) -> ::std::option::Option<bool> {
        self.ferries
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn toll_roads(&self) -> ::std::option::Option<bool> {
        self.toll_roads
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn tunnels(&self) -> ::std::option::Option<bool> {
        self.tunnels
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn u_turns(&self) -> ::std::option::Option<bool> {
        self.u_turns
    }
}
impl ::std::fmt::Debug for WaypointOptimizationAvoidanceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("WaypointOptimizationAvoidanceOptions");
        formatter.field("areas", &self.areas);
        formatter.field("car_shuttle_trains", &"*** Sensitive Data Redacted ***");
        formatter.field("controlled_access_highways", &"*** Sensitive Data Redacted ***");
        formatter.field("dirt_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("ferries", &"*** Sensitive Data Redacted ***");
        formatter.field("toll_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("tunnels", &"*** Sensitive Data Redacted ***");
        formatter.field("u_turns", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl WaypointOptimizationAvoidanceOptions {
    /// Creates a new builder-style object to manufacture [`WaypointOptimizationAvoidanceOptions`](crate::types::WaypointOptimizationAvoidanceOptions).
    pub fn builder() -> crate::types::builders::WaypointOptimizationAvoidanceOptionsBuilder {
        crate::types::builders::WaypointOptimizationAvoidanceOptionsBuilder::default()
    }
}

/// A builder for [`WaypointOptimizationAvoidanceOptions`](crate::types::WaypointOptimizationAvoidanceOptions).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct WaypointOptimizationAvoidanceOptionsBuilder {
    pub(crate) areas: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationAvoidanceArea>>,
    pub(crate) car_shuttle_trains: ::std::option::Option<bool>,
    pub(crate) controlled_access_highways: ::std::option::Option<bool>,
    pub(crate) dirt_roads: ::std::option::Option<bool>,
    pub(crate) ferries: ::std::option::Option<bool>,
    pub(crate) toll_roads: ::std::option::Option<bool>,
    pub(crate) tunnels: ::std::option::Option<bool>,
    pub(crate) u_turns: ::std::option::Option<bool>,
}
impl WaypointOptimizationAvoidanceOptionsBuilder {
    /// Appends an item to `areas`.
    ///
    /// To override the contents of this collection use [`set_areas`](Self::set_areas).
    ///
    /// <p>Areas to be avoided.</p>
    pub fn areas(mut self, input: crate::types::WaypointOptimizationAvoidanceArea) -> Self {
        let mut v = self.areas.unwrap_or_default();
        v.push(input);
        self.areas = ::std::option::Option::Some(v);
        self
    }
    /// <p>Areas to be avoided.</p>
    pub fn set_areas(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationAvoidanceArea>>) -> Self {
        self.areas = input;
        self
    }
    /// <p>Areas to be avoided.</p>
    pub fn get_areas(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationAvoidanceArea>> {
        &self.areas
    }
    /// <p>Avoidance options for cars-shuttles-trains.</p>
    pub fn car_shuttle_trains(mut self, input: bool) -> Self {
        self.car_shuttle_trains = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoidance options for cars-shuttles-trains.</p>
    pub fn set_car_shuttle_trains(mut self, input: ::std::option::Option<bool>) -> Self {
        self.car_shuttle_trains = input;
        self
    }
    /// <p>Avoidance options for cars-shuttles-trains.</p>
    pub fn get_car_shuttle_trains(&self) -> &::std::option::Option<bool> {
        &self.car_shuttle_trains
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn controlled_access_highways(mut self, input: bool) -> Self {
        self.controlled_access_highways = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn set_controlled_access_highways(mut self, input: ::std::option::Option<bool>) -> Self {
        self.controlled_access_highways = input;
        self
    }
    /// <p>Avoid controlled access highways while calculating the route.</p>
    pub fn get_controlled_access_highways(&self) -> &::std::option::Option<bool> {
        &self.controlled_access_highways
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn dirt_roads(mut self, input: bool) -> Self {
        self.dirt_roads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn set_dirt_roads(mut self, input: ::std::option::Option<bool>) -> Self {
        self.dirt_roads = input;
        self
    }
    /// <p>Avoid dirt roads while calculating the route.</p>
    pub fn get_dirt_roads(&self) -> &::std::option::Option<bool> {
        &self.dirt_roads
    }
    /// <p>Avoidance options for ferries.</p>
    pub fn ferries(mut self, input: bool) -> Self {
        self.ferries = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoidance options for ferries.</p>
    pub fn set_ferries(mut self, input: ::std::option::Option<bool>) -> Self {
        self.ferries = input;
        self
    }
    /// <p>Avoidance options for ferries.</p>
    pub fn get_ferries(&self) -> &::std::option::Option<bool> {
        &self.ferries
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn toll_roads(mut self, input: bool) -> Self {
        self.toll_roads = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn set_toll_roads(mut self, input: ::std::option::Option<bool>) -> Self {
        self.toll_roads = input;
        self
    }
    /// <p>Avoids roads where the specified toll transponders are the only mode of payment.</p>
    pub fn get_toll_roads(&self) -> &::std::option::Option<bool> {
        &self.toll_roads
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn tunnels(mut self, input: bool) -> Self {
        self.tunnels = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn set_tunnels(mut self, input: ::std::option::Option<bool>) -> Self {
        self.tunnels = input;
        self
    }
    /// <p>Avoid tunnels while calculating the route.</p>
    pub fn get_tunnels(&self) -> &::std::option::Option<bool> {
        &self.tunnels
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn u_turns(mut self, input: bool) -> Self {
        self.u_turns = ::std::option::Option::Some(input);
        self
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn set_u_turns(mut self, input: ::std::option::Option<bool>) -> Self {
        self.u_turns = input;
        self
    }
    /// <p>Avoid U-turns for calculation on highways and motorways.</p>
    pub fn get_u_turns(&self) -> &::std::option::Option<bool> {
        &self.u_turns
    }
    /// Consumes the builder and constructs a [`WaypointOptimizationAvoidanceOptions`](crate::types::WaypointOptimizationAvoidanceOptions).
    pub fn build(self) -> crate::types::WaypointOptimizationAvoidanceOptions {
        crate::types::WaypointOptimizationAvoidanceOptions {
            areas: self.areas,
            car_shuttle_trains: self.car_shuttle_trains,
            controlled_access_highways: self.controlled_access_highways,
            dirt_roads: self.dirt_roads,
            ferries: self.ferries,
            toll_roads: self.toll_roads,
            tunnels: self.tunnels,
            u_turns: self.u_turns,
        }
    }
}
impl ::std::fmt::Debug for WaypointOptimizationAvoidanceOptionsBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("WaypointOptimizationAvoidanceOptionsBuilder");
        formatter.field("areas", &self.areas);
        formatter.field("car_shuttle_trains", &"*** Sensitive Data Redacted ***");
        formatter.field("controlled_access_highways", &"*** Sensitive Data Redacted ***");
        formatter.field("dirt_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("ferries", &"*** Sensitive Data Redacted ***");
        formatter.field("toll_roads", &"*** Sensitive Data Redacted ***");
        formatter.field("tunnels", &"*** Sensitive Data Redacted ***");
        formatter.field("u_turns", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
