// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Span computed for the requested SpanAdditionalFeatures.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct RoutePedestrianSpan {
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub best_case_duration: i64,
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub country: ::std::option::Option<::std::string::String>,
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub distance: i64,
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub duration: i64,
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub dynamic_speed: ::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails>,
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub functional_classification: ::std::option::Option<i32>,
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub geometry_offset: ::std::option::Option<i32>,
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub incidents: ::std::option::Option<::std::vec::Vec<i32>>,
    /// <p>Provides an array of names of the pedestrian span in available languages.</p>
    pub names: ::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>>,
    /// <p>Access attributes for a pedestrian corresponding to the span.</p>
    pub pedestrian_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanPedestrianAccessAttribute>>,
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub region: ::std::option::Option<::std::string::String>,
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub road_attributes: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>>,
    /// <p>Designated route name or number corresponding to the span.</p>
    pub route_numbers: ::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>>,
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub speed_limit: ::std::option::Option<crate::types::RouteSpanSpeedLimitDetails>,
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub typical_duration: i64,
}
impl RoutePedestrianSpan {
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn best_case_duration(&self) -> i64 {
        self.best_case_duration
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn country(&self) -> ::std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn distance(&self) -> i64 {
        self.distance
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn duration(&self) -> i64 {
        self.duration
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn dynamic_speed(&self) -> ::std::option::Option<&crate::types::RouteSpanDynamicSpeedDetails> {
        self.dynamic_speed.as_ref()
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn functional_classification(&self) -> ::std::option::Option<i32> {
        self.functional_classification
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn geometry_offset(&self) -> ::std::option::Option<i32> {
        self.geometry_offset
    }
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.incidents.is_none()`.
    pub fn incidents(&self) -> &[i32] {
        self.incidents.as_deref().unwrap_or_default()
    }
    /// <p>Provides an array of names of the pedestrian span in available languages.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.names.is_none()`.
    pub fn names(&self) -> &[crate::types::LocalizedString] {
        self.names.as_deref().unwrap_or_default()
    }
    /// <p>Access attributes for a pedestrian corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.pedestrian_access.is_none()`.
    pub fn pedestrian_access(&self) -> &[crate::types::RouteSpanPedestrianAccessAttribute] {
        self.pedestrian_access.as_deref().unwrap_or_default()
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn region(&self) -> ::std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>Attributes for the road segment corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.road_attributes.is_none()`.
    pub fn road_attributes(&self) -> &[crate::types::RouteSpanRoadAttribute] {
        self.road_attributes.as_deref().unwrap_or_default()
    }
    /// <p>Designated route name or number corresponding to the span.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.route_numbers.is_none()`.
    pub fn route_numbers(&self) -> &[crate::types::RouteNumber] {
        self.route_numbers.as_deref().unwrap_or_default()
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn speed_limit(&self) -> ::std::option::Option<&crate::types::RouteSpanSpeedLimitDetails> {
        self.speed_limit.as_ref()
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn typical_duration(&self) -> i64 {
        self.typical_duration
    }
}
impl ::std::fmt::Debug for RoutePedestrianSpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RoutePedestrianSpan");
        formatter.field("best_case_duration", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("distance", &"*** Sensitive Data Redacted ***");
        formatter.field("duration", &"*** Sensitive Data Redacted ***");
        formatter.field("dynamic_speed", &self.dynamic_speed);
        formatter.field("functional_classification", &"*** Sensitive Data Redacted ***");
        formatter.field("geometry_offset", &self.geometry_offset);
        formatter.field("incidents", &self.incidents);
        formatter.field("names", &self.names);
        formatter.field("pedestrian_access", &"*** Sensitive Data Redacted ***");
        formatter.field("region", &"*** Sensitive Data Redacted ***");
        formatter.field("road_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("route_numbers", &self.route_numbers);
        formatter.field("speed_limit", &self.speed_limit);
        formatter.field("typical_duration", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl RoutePedestrianSpan {
    /// Creates a new builder-style object to manufacture [`RoutePedestrianSpan`](crate::types::RoutePedestrianSpan).
    pub fn builder() -> crate::types::builders::RoutePedestrianSpanBuilder {
        crate::types::builders::RoutePedestrianSpanBuilder::default()
    }
}

/// A builder for [`RoutePedestrianSpan`](crate::types::RoutePedestrianSpan).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct RoutePedestrianSpanBuilder {
    pub(crate) best_case_duration: ::std::option::Option<i64>,
    pub(crate) country: ::std::option::Option<::std::string::String>,
    pub(crate) distance: ::std::option::Option<i64>,
    pub(crate) duration: ::std::option::Option<i64>,
    pub(crate) dynamic_speed: ::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails>,
    pub(crate) functional_classification: ::std::option::Option<i32>,
    pub(crate) geometry_offset: ::std::option::Option<i32>,
    pub(crate) incidents: ::std::option::Option<::std::vec::Vec<i32>>,
    pub(crate) names: ::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>>,
    pub(crate) pedestrian_access: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanPedestrianAccessAttribute>>,
    pub(crate) region: ::std::option::Option<::std::string::String>,
    pub(crate) road_attributes: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>>,
    pub(crate) route_numbers: ::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>>,
    pub(crate) speed_limit: ::std::option::Option<crate::types::RouteSpanSpeedLimitDetails>,
    pub(crate) typical_duration: ::std::option::Option<i64>,
}
impl RoutePedestrianSpanBuilder {
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn best_case_duration(mut self, input: i64) -> Self {
        self.best_case_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_best_case_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.best_case_duration = input;
        self
    }
    /// <p>Duration of the computed span without traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_best_case_duration(&self) -> &::std::option::Option<i64> {
        &self.best_case_duration
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn country(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.country = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn set_country(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.country = input;
        self
    }
    /// <p>3 letter Country code corresponding to the Span.</p>
    pub fn get_country(&self) -> &::std::option::Option<::std::string::String> {
        &self.country
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn distance(mut self, input: i64) -> Self {
        self.distance = ::std::option::Option::Some(input);
        self
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn set_distance(mut self, input: ::std::option::Option<i64>) -> Self {
        self.distance = input;
        self
    }
    /// <p>Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    pub fn get_distance(&self) -> &::std::option::Option<i64> {
        &self.distance
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn duration(mut self, input: i64) -> Self {
        self.duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.duration = input;
        self
    }
    /// <p>Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_duration(&self) -> &::std::option::Option<i64> {
        &self.duration
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn dynamic_speed(mut self, input: crate::types::RouteSpanDynamicSpeedDetails) -> Self {
        self.dynamic_speed = ::std::option::Option::Some(input);
        self
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn set_dynamic_speed(mut self, input: ::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails>) -> Self {
        self.dynamic_speed = input;
        self
    }
    /// <p>Dynamic speed details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn get_dynamic_speed(&self) -> &::std::option::Option<crate::types::RouteSpanDynamicSpeedDetails> {
        &self.dynamic_speed
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn functional_classification(mut self, input: i32) -> Self {
        self.functional_classification = ::std::option::Option::Some(input);
        self
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn set_functional_classification(mut self, input: ::std::option::Option<i32>) -> Self {
        self.functional_classification = input;
        self
    }
    /// <p>Functional classification of the road segment corresponding to the span.</p>
    pub fn get_functional_classification(&self) -> &::std::option::Option<i32> {
        &self.functional_classification
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn geometry_offset(mut self, input: i32) -> Self {
        self.geometry_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn set_geometry_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.geometry_offset = input;
        self
    }
    /// <p>Offset in the leg geometry corresponding to the start of this span.</p>
    pub fn get_geometry_offset(&self) -> &::std::option::Option<i32> {
        &self.geometry_offset
    }
    /// Appends an item to `incidents`.
    ///
    /// To override the contents of this collection use [`set_incidents`](Self::set_incidents).
    ///
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub fn incidents(mut self, input: i32) -> Self {
        let mut v = self.incidents.unwrap_or_default();
        v.push(input);
        self.incidents = ::std::option::Option::Some(v);
        self
    }
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub fn set_incidents(mut self, input: ::std::option::Option<::std::vec::Vec<i32>>) -> Self {
        self.incidents = input;
        self
    }
    /// <p>Incidents corresponding to the span. These index into the Incidents in the parent Leg.</p>
    pub fn get_incidents(&self) -> &::std::option::Option<::std::vec::Vec<i32>> {
        &self.incidents
    }
    /// Appends an item to `names`.
    ///
    /// To override the contents of this collection use [`set_names`](Self::set_names).
    ///
    /// <p>Provides an array of names of the pedestrian span in available languages.</p>
    pub fn names(mut self, input: crate::types::LocalizedString) -> Self {
        let mut v = self.names.unwrap_or_default();
        v.push(input);
        self.names = ::std::option::Option::Some(v);
        self
    }
    /// <p>Provides an array of names of the pedestrian span in available languages.</p>
    pub fn set_names(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>>) -> Self {
        self.names = input;
        self
    }
    /// <p>Provides an array of names of the pedestrian span in available languages.</p>
    pub fn get_names(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LocalizedString>> {
        &self.names
    }
    /// Appends an item to `pedestrian_access`.
    ///
    /// To override the contents of this collection use [`set_pedestrian_access`](Self::set_pedestrian_access).
    ///
    /// <p>Access attributes for a pedestrian corresponding to the span.</p>
    pub fn pedestrian_access(mut self, input: crate::types::RouteSpanPedestrianAccessAttribute) -> Self {
        let mut v = self.pedestrian_access.unwrap_or_default();
        v.push(input);
        self.pedestrian_access = ::std::option::Option::Some(v);
        self
    }
    /// <p>Access attributes for a pedestrian corresponding to the span.</p>
    pub fn set_pedestrian_access(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanPedestrianAccessAttribute>>) -> Self {
        self.pedestrian_access = input;
        self
    }
    /// <p>Access attributes for a pedestrian corresponding to the span.</p>
    pub fn get_pedestrian_access(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteSpanPedestrianAccessAttribute>> {
        &self.pedestrian_access
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn region(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.region = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn set_region(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.region = input;
        self
    }
    /// <p>2-3 letter Region code corresponding to the Span. This is either a province or a state.</p>
    pub fn get_region(&self) -> &::std::option::Option<::std::string::String> {
        &self.region
    }
    /// Appends an item to `road_attributes`.
    ///
    /// To override the contents of this collection use [`set_road_attributes`](Self::set_road_attributes).
    ///
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub fn road_attributes(mut self, input: crate::types::RouteSpanRoadAttribute) -> Self {
        let mut v = self.road_attributes.unwrap_or_default();
        v.push(input);
        self.road_attributes = ::std::option::Option::Some(v);
        self
    }
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub fn set_road_attributes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>>) -> Self {
        self.road_attributes = input;
        self
    }
    /// <p>Attributes for the road segment corresponding to the span.</p>
    pub fn get_road_attributes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteSpanRoadAttribute>> {
        &self.road_attributes
    }
    /// Appends an item to `route_numbers`.
    ///
    /// To override the contents of this collection use [`set_route_numbers`](Self::set_route_numbers).
    ///
    /// <p>Designated route name or number corresponding to the span.</p>
    pub fn route_numbers(mut self, input: crate::types::RouteNumber) -> Self {
        let mut v = self.route_numbers.unwrap_or_default();
        v.push(input);
        self.route_numbers = ::std::option::Option::Some(v);
        self
    }
    /// <p>Designated route name or number corresponding to the span.</p>
    pub fn set_route_numbers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>>) -> Self {
        self.route_numbers = input;
        self
    }
    /// <p>Designated route name or number corresponding to the span.</p>
    pub fn get_route_numbers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RouteNumber>> {
        &self.route_numbers
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn speed_limit(mut self, input: crate::types::RouteSpanSpeedLimitDetails) -> Self {
        self.speed_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn set_speed_limit(mut self, input: ::std::option::Option<crate::types::RouteSpanSpeedLimitDetails>) -> Self {
        self.speed_limit = input;
        self
    }
    /// <p>Speed limit details corresponding to the span.</p>
    /// <p><b>Unit</b>: <code>KilometersPerHour</code></p>
    pub fn get_speed_limit(&self) -> &::std::option::Option<crate::types::RouteSpanSpeedLimitDetails> {
        &self.speed_limit
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn typical_duration(mut self, input: i64) -> Self {
        self.typical_duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_typical_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.typical_duration = input;
        self
    }
    /// <p>Duration of the computed span under typical traffic congestion.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_typical_duration(&self) -> &::std::option::Option<i64> {
        &self.typical_duration
    }
    /// Consumes the builder and constructs a [`RoutePedestrianSpan`](crate::types::RoutePedestrianSpan).
    pub fn build(self) -> crate::types::RoutePedestrianSpan {
        crate::types::RoutePedestrianSpan {
            best_case_duration: self.best_case_duration.unwrap_or_default(),
            country: self.country,
            distance: self.distance.unwrap_or_default(),
            duration: self.duration.unwrap_or_default(),
            dynamic_speed: self.dynamic_speed,
            functional_classification: self.functional_classification,
            geometry_offset: self.geometry_offset,
            incidents: self.incidents,
            names: self.names,
            pedestrian_access: self.pedestrian_access,
            region: self.region,
            road_attributes: self.road_attributes,
            route_numbers: self.route_numbers,
            speed_limit: self.speed_limit,
            typical_duration: self.typical_duration.unwrap_or_default(),
        }
    }
}
impl ::std::fmt::Debug for RoutePedestrianSpanBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RoutePedestrianSpanBuilder");
        formatter.field("best_case_duration", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("distance", &"*** Sensitive Data Redacted ***");
        formatter.field("duration", &"*** Sensitive Data Redacted ***");
        formatter.field("dynamic_speed", &self.dynamic_speed);
        formatter.field("functional_classification", &"*** Sensitive Data Redacted ***");
        formatter.field("geometry_offset", &self.geometry_offset);
        formatter.field("incidents", &self.incidents);
        formatter.field("names", &self.names);
        formatter.field("pedestrian_access", &"*** Sensitive Data Redacted ***");
        formatter.field("region", &"*** Sensitive Data Redacted ***");
        formatter.field("road_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("route_numbers", &self.route_numbers);
        formatter.field("speed_limit", &self.speed_limit);
        formatter.field("typical_duration", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
