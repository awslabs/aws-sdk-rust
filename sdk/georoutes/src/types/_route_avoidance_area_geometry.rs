// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Geometry of the area to be avoided.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct RouteAvoidanceAreaGeometry {
    /// <p>Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.</p>
    pub corridor: ::std::option::Option<crate::types::Corridor>,
    /// <p>Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.</p>
    pub bounding_box: ::std::option::Option<::std::vec::Vec<f64>>,
    /// <p>Geometry defined as a polygon with only one linear ring.</p>
    pub polygon: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>>,
    /// <p>Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.</p>
    pub polyline_corridor: ::std::option::Option<crate::types::PolylineCorridor>,
    /// <p>A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see <a href="https://github.com/heremaps/flexiblepolyline/blob/master/README.md">https://github.com/heremaps/flexiblepolyline/blob/master/README.md</a>.</p>
    pub polyline_polygon: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl RouteAvoidanceAreaGeometry {
    /// <p>Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.</p>
    pub fn corridor(&self) -> ::std::option::Option<&crate::types::Corridor> {
        self.corridor.as_ref()
    }
    /// <p>Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.bounding_box.is_none()`.
    pub fn bounding_box(&self) -> &[f64] {
        self.bounding_box.as_deref().unwrap_or_default()
    }
    /// <p>Geometry defined as a polygon with only one linear ring.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.polygon.is_none()`.
    pub fn polygon(&self) -> &[::std::vec::Vec<::std::vec::Vec<f64>>] {
        self.polygon.as_deref().unwrap_or_default()
    }
    /// <p>Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.</p>
    pub fn polyline_corridor(&self) -> ::std::option::Option<&crate::types::PolylineCorridor> {
        self.polyline_corridor.as_ref()
    }
    /// <p>A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see <a href="https://github.com/heremaps/flexiblepolyline/blob/master/README.md">https://github.com/heremaps/flexiblepolyline/blob/master/README.md</a>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.polyline_polygon.is_none()`.
    pub fn polyline_polygon(&self) -> &[::std::string::String] {
        self.polyline_polygon.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for RouteAvoidanceAreaGeometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RouteAvoidanceAreaGeometry");
        formatter.field("corridor", &"*** Sensitive Data Redacted ***");
        formatter.field("bounding_box", &"*** Sensitive Data Redacted ***");
        formatter.field("polygon", &"*** Sensitive Data Redacted ***");
        formatter.field("polyline_corridor", &"*** Sensitive Data Redacted ***");
        formatter.field("polyline_polygon", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl RouteAvoidanceAreaGeometry {
    /// Creates a new builder-style object to manufacture [`RouteAvoidanceAreaGeometry`](crate::types::RouteAvoidanceAreaGeometry).
    pub fn builder() -> crate::types::builders::RouteAvoidanceAreaGeometryBuilder {
        crate::types::builders::RouteAvoidanceAreaGeometryBuilder::default()
    }
}

/// A builder for [`RouteAvoidanceAreaGeometry`](crate::types::RouteAvoidanceAreaGeometry).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct RouteAvoidanceAreaGeometryBuilder {
    pub(crate) corridor: ::std::option::Option<crate::types::Corridor>,
    pub(crate) bounding_box: ::std::option::Option<::std::vec::Vec<f64>>,
    pub(crate) polygon: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>>,
    pub(crate) polyline_corridor: ::std::option::Option<crate::types::PolylineCorridor>,
    pub(crate) polyline_polygon: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}
impl RouteAvoidanceAreaGeometryBuilder {
    /// <p>Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.</p>
    pub fn corridor(mut self, input: crate::types::Corridor) -> Self {
        self.corridor = ::std::option::Option::Some(input);
        self
    }
    /// <p>Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.</p>
    pub fn set_corridor(mut self, input: ::std::option::Option<crate::types::Corridor>) -> Self {
        self.corridor = input;
        self
    }
    /// <p>Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.</p>
    pub fn get_corridor(&self) -> &::std::option::Option<crate::types::Corridor> {
        &self.corridor
    }
    /// Appends an item to `bounding_box`.
    ///
    /// To override the contents of this collection use [`set_bounding_box`](Self::set_bounding_box).
    ///
    /// <p>Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.</p>
    pub fn bounding_box(mut self, input: f64) -> Self {
        let mut v = self.bounding_box.unwrap_or_default();
        v.push(input);
        self.bounding_box = ::std::option::Option::Some(v);
        self
    }
    /// <p>Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.</p>
    pub fn set_bounding_box(mut self, input: ::std::option::Option<::std::vec::Vec<f64>>) -> Self {
        self.bounding_box = input;
        self
    }
    /// <p>Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.</p>
    pub fn get_bounding_box(&self) -> &::std::option::Option<::std::vec::Vec<f64>> {
        &self.bounding_box
    }
    /// Appends an item to `polygon`.
    ///
    /// To override the contents of this collection use [`set_polygon`](Self::set_polygon).
    ///
    /// <p>Geometry defined as a polygon with only one linear ring.</p>
    pub fn polygon(mut self, input: ::std::vec::Vec<::std::vec::Vec<f64>>) -> Self {
        let mut v = self.polygon.unwrap_or_default();
        v.push(input);
        self.polygon = ::std::option::Option::Some(v);
        self
    }
    /// <p>Geometry defined as a polygon with only one linear ring.</p>
    pub fn set_polygon(mut self, input: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>>) -> Self {
        self.polygon = input;
        self
    }
    /// <p>Geometry defined as a polygon with only one linear ring.</p>
    pub fn get_polygon(&self) -> &::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>> {
        &self.polygon
    }
    /// <p>Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.</p>
    pub fn polyline_corridor(mut self, input: crate::types::PolylineCorridor) -> Self {
        self.polyline_corridor = ::std::option::Option::Some(input);
        self
    }
    /// <p>Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.</p>
    pub fn set_polyline_corridor(mut self, input: ::std::option::Option<crate::types::PolylineCorridor>) -> Self {
        self.polyline_corridor = input;
        self
    }
    /// <p>Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.</p>
    pub fn get_polyline_corridor(&self) -> &::std::option::Option<crate::types::PolylineCorridor> {
        &self.polyline_corridor
    }
    /// Appends an item to `polyline_polygon`.
    ///
    /// To override the contents of this collection use [`set_polyline_polygon`](Self::set_polyline_polygon).
    ///
    /// <p>A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see <a href="https://github.com/heremaps/flexiblepolyline/blob/master/README.md">https://github.com/heremaps/flexiblepolyline/blob/master/README.md</a>.</p>
    pub fn polyline_polygon(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.polyline_polygon.unwrap_or_default();
        v.push(input.into());
        self.polyline_polygon = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see <a href="https://github.com/heremaps/flexiblepolyline/blob/master/README.md">https://github.com/heremaps/flexiblepolyline/blob/master/README.md</a>.</p>
    pub fn set_polyline_polygon(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.polyline_polygon = input;
        self
    }
    /// <p>A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see <a href="https://github.com/heremaps/flexiblepolyline/blob/master/README.md">https://github.com/heremaps/flexiblepolyline/blob/master/README.md</a>.</p>
    pub fn get_polyline_polygon(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.polyline_polygon
    }
    /// Consumes the builder and constructs a [`RouteAvoidanceAreaGeometry`](crate::types::RouteAvoidanceAreaGeometry).
    pub fn build(self) -> crate::types::RouteAvoidanceAreaGeometry {
        crate::types::RouteAvoidanceAreaGeometry {
            corridor: self.corridor,
            bounding_box: self.bounding_box,
            polygon: self.polygon,
            polyline_corridor: self.polyline_corridor,
            polyline_polygon: self.polyline_polygon,
        }
    }
}
impl ::std::fmt::Debug for RouteAvoidanceAreaGeometryBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("RouteAvoidanceAreaGeometryBuilder");
        formatter.field("corridor", &"*** Sensitive Data Redacted ***");
        formatter.field("bounding_box", &"*** Sensitive Data Redacted ***");
        formatter.field("polygon", &"*** Sensitive Data Redacted ***");
        formatter.field("polyline_corridor", &"*** Sensitive Data Redacted ***");
        formatter.field("polyline_polygon", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
