// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct OptimizeWaypointsOutput {
    /// <p>Details about the connection from one waypoint to the next, within the optimized sequence.</p>
    pub connections: ::std::vec::Vec<crate::types::WaypointOptimizationConnection>,
    /// <p>Overall distance to travel the whole sequence.</p>
    pub distance: i64,
    /// <p>Overall duration to travel the whole sequence.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub duration: i64,
    /// <p>Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.</p>
    pub impeding_waypoints: ::std::vec::Vec<crate::types::WaypointOptimizationImpedingWaypoint>,
    /// <p>Waypoints in the order of the optimized sequence.</p>
    pub optimized_waypoints: ::std::vec::Vec<crate::types::WaypointOptimizationOptimizedWaypoint>,
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub pricing_bucket: ::std::string::String,
    /// <p>Time breakdown for the sequence.</p>
    pub time_breakdown: ::std::option::Option<crate::types::WaypointOptimizationTimeBreakdown>,
    _request_id: Option<String>,
}
impl OptimizeWaypointsOutput {
    /// <p>Details about the connection from one waypoint to the next, within the optimized sequence.</p>
    pub fn connections(&self) -> &[crate::types::WaypointOptimizationConnection] {
        use std::ops::Deref;
        self.connections.deref()
    }
    /// <p>Overall distance to travel the whole sequence.</p>
    pub fn distance(&self) -> i64 {
        self.distance
    }
    /// <p>Overall duration to travel the whole sequence.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn duration(&self) -> i64 {
        self.duration
    }
    /// <p>Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.</p>
    pub fn impeding_waypoints(&self) -> &[crate::types::WaypointOptimizationImpedingWaypoint] {
        use std::ops::Deref;
        self.impeding_waypoints.deref()
    }
    /// <p>Waypoints in the order of the optimized sequence.</p>
    pub fn optimized_waypoints(&self) -> &[crate::types::WaypointOptimizationOptimizedWaypoint] {
        use std::ops::Deref;
        self.optimized_waypoints.deref()
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub fn pricing_bucket(&self) -> &str {
        use std::ops::Deref;
        self.pricing_bucket.deref()
    }
    /// <p>Time breakdown for the sequence.</p>
    pub fn time_breakdown(&self) -> ::std::option::Option<&crate::types::WaypointOptimizationTimeBreakdown> {
        self.time_breakdown.as_ref()
    }
}
impl ::std::fmt::Debug for OptimizeWaypointsOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("OptimizeWaypointsOutput");
        formatter.field("connections", &self.connections);
        formatter.field("distance", &"*** Sensitive Data Redacted ***");
        formatter.field("duration", &"*** Sensitive Data Redacted ***");
        formatter.field("impeding_waypoints", &self.impeding_waypoints);
        formatter.field("optimized_waypoints", &self.optimized_waypoints);
        formatter.field("pricing_bucket", &self.pricing_bucket);
        formatter.field("time_breakdown", &self.time_breakdown);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl ::aws_types::request_id::RequestId for OptimizeWaypointsOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl OptimizeWaypointsOutput {
    /// Creates a new builder-style object to manufacture [`OptimizeWaypointsOutput`](crate::operation::optimize_waypoints::OptimizeWaypointsOutput).
    pub fn builder() -> crate::operation::optimize_waypoints::builders::OptimizeWaypointsOutputBuilder {
        crate::operation::optimize_waypoints::builders::OptimizeWaypointsOutputBuilder::default()
    }
}

/// A builder for [`OptimizeWaypointsOutput`](crate::operation::optimize_waypoints::OptimizeWaypointsOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct OptimizeWaypointsOutputBuilder {
    pub(crate) connections: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationConnection>>,
    pub(crate) distance: ::std::option::Option<i64>,
    pub(crate) duration: ::std::option::Option<i64>,
    pub(crate) impeding_waypoints: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationImpedingWaypoint>>,
    pub(crate) optimized_waypoints: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationOptimizedWaypoint>>,
    pub(crate) pricing_bucket: ::std::option::Option<::std::string::String>,
    pub(crate) time_breakdown: ::std::option::Option<crate::types::WaypointOptimizationTimeBreakdown>,
    _request_id: Option<String>,
}
impl OptimizeWaypointsOutputBuilder {
    /// Appends an item to `connections`.
    ///
    /// To override the contents of this collection use [`set_connections`](Self::set_connections).
    ///
    /// <p>Details about the connection from one waypoint to the next, within the optimized sequence.</p>
    pub fn connections(mut self, input: crate::types::WaypointOptimizationConnection) -> Self {
        let mut v = self.connections.unwrap_or_default();
        v.push(input);
        self.connections = ::std::option::Option::Some(v);
        self
    }
    /// <p>Details about the connection from one waypoint to the next, within the optimized sequence.</p>
    pub fn set_connections(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationConnection>>) -> Self {
        self.connections = input;
        self
    }
    /// <p>Details about the connection from one waypoint to the next, within the optimized sequence.</p>
    pub fn get_connections(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationConnection>> {
        &self.connections
    }
    /// <p>Overall distance to travel the whole sequence.</p>
    /// This field is required.
    pub fn distance(mut self, input: i64) -> Self {
        self.distance = ::std::option::Option::Some(input);
        self
    }
    /// <p>Overall distance to travel the whole sequence.</p>
    pub fn set_distance(mut self, input: ::std::option::Option<i64>) -> Self {
        self.distance = input;
        self
    }
    /// <p>Overall distance to travel the whole sequence.</p>
    pub fn get_distance(&self) -> &::std::option::Option<i64> {
        &self.distance
    }
    /// <p>Overall duration to travel the whole sequence.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    /// This field is required.
    pub fn duration(mut self, input: i64) -> Self {
        self.duration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Overall duration to travel the whole sequence.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn set_duration(mut self, input: ::std::option::Option<i64>) -> Self {
        self.duration = input;
        self
    }
    /// <p>Overall duration to travel the whole sequence.</p>
    /// <p><b>Unit</b>: <code>seconds</code></p>
    pub fn get_duration(&self) -> &::std::option::Option<i64> {
        &self.duration
    }
    /// Appends an item to `impeding_waypoints`.
    ///
    /// To override the contents of this collection use [`set_impeding_waypoints`](Self::set_impeding_waypoints).
    ///
    /// <p>Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.</p>
    pub fn impeding_waypoints(mut self, input: crate::types::WaypointOptimizationImpedingWaypoint) -> Self {
        let mut v = self.impeding_waypoints.unwrap_or_default();
        v.push(input);
        self.impeding_waypoints = ::std::option::Option::Some(v);
        self
    }
    /// <p>Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.</p>
    pub fn set_impeding_waypoints(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationImpedingWaypoint>>,
    ) -> Self {
        self.impeding_waypoints = input;
        self
    }
    /// <p>Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.</p>
    pub fn get_impeding_waypoints(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationImpedingWaypoint>> {
        &self.impeding_waypoints
    }
    /// Appends an item to `optimized_waypoints`.
    ///
    /// To override the contents of this collection use [`set_optimized_waypoints`](Self::set_optimized_waypoints).
    ///
    /// <p>Waypoints in the order of the optimized sequence.</p>
    pub fn optimized_waypoints(mut self, input: crate::types::WaypointOptimizationOptimizedWaypoint) -> Self {
        let mut v = self.optimized_waypoints.unwrap_or_default();
        v.push(input);
        self.optimized_waypoints = ::std::option::Option::Some(v);
        self
    }
    /// <p>Waypoints in the order of the optimized sequence.</p>
    pub fn set_optimized_waypoints(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationOptimizedWaypoint>>,
    ) -> Self {
        self.optimized_waypoints = input;
        self
    }
    /// <p>Waypoints in the order of the optimized sequence.</p>
    pub fn get_optimized_waypoints(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WaypointOptimizationOptimizedWaypoint>> {
        &self.optimized_waypoints
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    /// This field is required.
    pub fn pricing_bucket(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pricing_bucket = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub fn set_pricing_bucket(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pricing_bucket = input;
        self
    }
    /// <p>The pricing bucket for which the query is charged at.</p>
    pub fn get_pricing_bucket(&self) -> &::std::option::Option<::std::string::String> {
        &self.pricing_bucket
    }
    /// <p>Time breakdown for the sequence.</p>
    /// This field is required.
    pub fn time_breakdown(mut self, input: crate::types::WaypointOptimizationTimeBreakdown) -> Self {
        self.time_breakdown = ::std::option::Option::Some(input);
        self
    }
    /// <p>Time breakdown for the sequence.</p>
    pub fn set_time_breakdown(mut self, input: ::std::option::Option<crate::types::WaypointOptimizationTimeBreakdown>) -> Self {
        self.time_breakdown = input;
        self
    }
    /// <p>Time breakdown for the sequence.</p>
    pub fn get_time_breakdown(&self) -> &::std::option::Option<crate::types::WaypointOptimizationTimeBreakdown> {
        &self.time_breakdown
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`OptimizeWaypointsOutput`](crate::operation::optimize_waypoints::OptimizeWaypointsOutput).
    /// This method will fail if any of the following fields are not set:
    /// - [`connections`](crate::operation::optimize_waypoints::builders::OptimizeWaypointsOutputBuilder::connections)
    /// - [`impeding_waypoints`](crate::operation::optimize_waypoints::builders::OptimizeWaypointsOutputBuilder::impeding_waypoints)
    /// - [`optimized_waypoints`](crate::operation::optimize_waypoints::builders::OptimizeWaypointsOutputBuilder::optimized_waypoints)
    /// - [`pricing_bucket`](crate::operation::optimize_waypoints::builders::OptimizeWaypointsOutputBuilder::pricing_bucket)
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::optimize_waypoints::OptimizeWaypointsOutput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::optimize_waypoints::OptimizeWaypointsOutput {
            connections: self.connections.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "connections",
                    "connections was not specified but it is required when building OptimizeWaypointsOutput",
                )
            })?,
            distance: self.distance.unwrap_or_default(),
            duration: self.duration.unwrap_or_default(),
            impeding_waypoints: self.impeding_waypoints.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "impeding_waypoints",
                    "impeding_waypoints was not specified but it is required when building OptimizeWaypointsOutput",
                )
            })?,
            optimized_waypoints: self.optimized_waypoints.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "optimized_waypoints",
                    "optimized_waypoints was not specified but it is required when building OptimizeWaypointsOutput",
                )
            })?,
            pricing_bucket: self.pricing_bucket.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "pricing_bucket",
                    "pricing_bucket was not specified but it is required when building OptimizeWaypointsOutput",
                )
            })?,
            time_breakdown: self.time_breakdown,
            _request_id: self._request_id,
        })
    }
}
impl ::std::fmt::Debug for OptimizeWaypointsOutputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("OptimizeWaypointsOutputBuilder");
        formatter.field("connections", &self.connections);
        formatter.field("distance", &"*** Sensitive Data Redacted ***");
        formatter.field("duration", &"*** Sensitive Data Redacted ***");
        formatter.field("impeding_waypoints", &self.impeding_waypoints);
        formatter.field("optimized_waypoints", &self.optimized_waypoints);
        formatter.field("pricing_bucket", &self.pricing_bucket);
        formatter.field("time_breakdown", &self.time_breakdown);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
