// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CreateHttpNamespaceInput`](crate::input::CreateHttpNamespaceInput)
pub mod create_http_namespace_input {
    /// A builder for [`CreateHttpNamespaceInput`](crate::input::CreateHttpNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name that you want to assign to this namespace.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreateHttpNamespace</code> requests to
        /// be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string
        /// (for example, a date/time stamp).</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// <p>A description for the namespace.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateHttpNamespaceInput`](crate::input::CreateHttpNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateHttpNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateHttpNamespaceInput {
                name: self.name,
                creator_request_id: self.creator_request_id,
                description: self.description,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateHttpNamespaceInputOperationOutputAlias = crate::operation::CreateHttpNamespace;
#[doc(hidden)]
pub type CreateHttpNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateHttpNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`CreateHttpNamespace`](crate::operation::CreateHttpNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateHttpNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateHttpNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateHttpNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateHttpNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.CreateHttpNamespace",
            );
            Ok(builder)
        }
        if self.creator_request_id.is_none() {
            self.creator_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_http_namespace(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateHttpNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateHttpNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateHttpNamespaceInput`](crate::input::CreateHttpNamespaceInput)
    pub fn builder() -> crate::input::create_http_namespace_input::Builder {
        crate::input::create_http_namespace_input::Builder::default()
    }
}

/// See [`CreatePrivateDnsNamespaceInput`](crate::input::CreatePrivateDnsNamespaceInput)
pub mod create_private_dns_namespace_input {
    /// A builder for [`CreatePrivateDnsNamespaceInput`](crate::input::CreatePrivateDnsNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) vpc: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) properties: std::option::Option<crate::model::PrivateDnsNamespaceProperties>,
    }
    impl Builder {
        /// <p>The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map
        /// automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreatePrivateDnsNamespace</code>
        /// requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
        /// unique string (for example, a date/timestamp).</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// <p>A description for the namespace.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of the Amazon VPC that you want to associate the namespace with.</p>
        pub fn vpc(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc = Some(input.into());
            self
        }
        pub fn set_vpc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Properties for the private DNS
        /// namespace.</p>
        pub fn properties(mut self, input: crate::model::PrivateDnsNamespaceProperties) -> Self {
            self.properties = Some(input);
            self
        }
        pub fn set_properties(
            mut self,
            input: std::option::Option<crate::model::PrivateDnsNamespaceProperties>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePrivateDnsNamespaceInput`](crate::input::CreatePrivateDnsNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePrivateDnsNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePrivateDnsNamespaceInput {
                name: self.name,
                creator_request_id: self.creator_request_id,
                description: self.description,
                vpc: self.vpc,
                tags: self.tags,
                properties: self.properties,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePrivateDnsNamespaceInputOperationOutputAlias =
    crate::operation::CreatePrivateDnsNamespace;
#[doc(hidden)]
pub type CreatePrivateDnsNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePrivateDnsNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`CreatePrivateDnsNamespace`](crate::operation::CreatePrivateDnsNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreatePrivateDnsNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreatePrivateDnsNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreatePrivateDnsNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreatePrivateDnsNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.CreatePrivateDnsNamespace",
            );
            Ok(builder)
        }
        if self.creator_request_id.is_none() {
            self.creator_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_private_dns_namespace(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreatePrivateDnsNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreatePrivateDnsNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePrivateDnsNamespaceInput`](crate::input::CreatePrivateDnsNamespaceInput)
    pub fn builder() -> crate::input::create_private_dns_namespace_input::Builder {
        crate::input::create_private_dns_namespace_input::Builder::default()
    }
}

/// See [`CreatePublicDnsNamespaceInput`](crate::input::CreatePublicDnsNamespaceInput)
pub mod create_public_dns_namespace_input {
    /// A builder for [`CreatePublicDnsNamespaceInput`](crate::input::CreatePublicDnsNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) properties: std::option::Option<crate::model::PublicDnsNamespaceProperties>,
    }
    impl Builder {
        /// <p>The name that you want to assign to this namespace.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreatePublicDnsNamespace</code>
        /// requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
        /// unique string (for example, a date/timestamp).</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// <p>A description for the namespace.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Properties for the public DNS
        /// namespace.</p>
        pub fn properties(mut self, input: crate::model::PublicDnsNamespaceProperties) -> Self {
            self.properties = Some(input);
            self
        }
        pub fn set_properties(
            mut self,
            input: std::option::Option<crate::model::PublicDnsNamespaceProperties>,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatePublicDnsNamespaceInput`](crate::input::CreatePublicDnsNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreatePublicDnsNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreatePublicDnsNamespaceInput {
                name: self.name,
                creator_request_id: self.creator_request_id,
                description: self.description,
                tags: self.tags,
                properties: self.properties,
            })
        }
    }
}
#[doc(hidden)]
pub type CreatePublicDnsNamespaceInputOperationOutputAlias =
    crate::operation::CreatePublicDnsNamespace;
#[doc(hidden)]
pub type CreatePublicDnsNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreatePublicDnsNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`CreatePublicDnsNamespace`](crate::operation::CreatePublicDnsNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreatePublicDnsNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreatePublicDnsNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreatePublicDnsNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreatePublicDnsNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.CreatePublicDnsNamespace",
            );
            Ok(builder)
        }
        if self.creator_request_id.is_none() {
            self.creator_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_public_dns_namespace(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreatePublicDnsNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreatePublicDnsNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreatePublicDnsNamespaceInput`](crate::input::CreatePublicDnsNamespaceInput)
    pub fn builder() -> crate::input::create_public_dns_namespace_input::Builder {
        crate::input::create_public_dns_namespace_input::Builder::default()
    }
}

/// See [`CreateServiceInput`](crate::input::CreateServiceInput)
pub mod create_service_input {
    /// A builder for [`CreateServiceInput`](crate::input::CreateServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) namespace_id: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) dns_config: std::option::Option<crate::model::DnsConfig>,
        pub(crate) health_check_config: std::option::Option<crate::model::HealthCheckConfig>,
        pub(crate) health_check_custom_config:
            std::option::Option<crate::model::HealthCheckCustomConfig>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) r#type: std::option::Option<crate::model::ServiceTypeOption>,
    }
    impl Builder {
        /// <p>The name that you want to assign to the service.</p>
        /// <p>If you want Cloud Map to create an <code>SRV</code> record when you register an instance and you're using a
        /// system that requires a specific <code>SRV</code> format, such as <a href="http://www.haproxy.org/">HAProxy</a>, specify the following for <code>Name</code>:</p>
        /// <ul>
        /// <li>
        /// <p>Start the name with an underscore (_), such as <code>_exampleservice</code>.</p>
        /// </li>
        /// <li>
        /// <p>End the name with <i>._protocol</i>, such as <code>._tcp</code>.</p>
        /// </li>
        /// </ul>
        /// <p>When you register an instance, Cloud Map creates an <code>SRV</code> record and assigns a name to the record by
        /// concatenating the service name and the namespace name (for example,</p>
        /// <p>
        /// <code>_exampleservice._tcp.example.com</code>).</p>
        /// <note>
        /// <p>For services that are accessible by DNS queries, you can't create multiple services with names that differ only
        /// by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
        /// However, if you use a namespace that's only accessible by API calls, then you can create services that with names
        /// that differ only by case.</p>
        /// </note>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
        /// can be specified either here or in the <code>DnsConfig</code> object.</p>
        pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_id = Some(input.into());
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace_id = input;
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreateService</code> requests to be
        /// retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string (for
        /// example, a date/timestamp).</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        /// <p>A description for the service.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you
        /// register an instance. </p>
        pub fn dns_config(mut self, input: crate::model::DnsConfig) -> Self {
            self.dns_config = Some(input);
            self
        }
        pub fn set_dns_config(
            mut self,
            input: std::option::Option<crate::model::DnsConfig>,
        ) -> Self {
            self.dns_config = input;
            self
        }
        /// <p>
        /// <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
        /// Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the
        /// Route 53 DNS records that you specify in <code>DnsConfig</code>.</p>
        /// <important>
        /// <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        /// <code>HealthCheckConfig</code> but not both.</p>
        /// </important>
        /// <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">Cloud Map Pricing</a>.</p>
        pub fn health_check_config(mut self, input: crate::model::HealthCheckConfig) -> Self {
            self.health_check_config = Some(input);
            self
        }
        pub fn set_health_check_config(
            mut self,
            input: std::option::Option<crate::model::HealthCheckConfig>,
        ) -> Self {
            self.health_check_config = input;
            self
        }
        /// <p>A complex type that contains information about an optional custom health check.</p>
        /// <important>
        /// <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        /// <code>HealthCheckConfig</code> but not both.</p>
        /// </important>
        /// <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration from an existing
        /// service.</p>
        pub fn health_check_custom_config(
            mut self,
            input: crate::model::HealthCheckCustomConfig,
        ) -> Self {
            self.health_check_custom_config = Some(input);
            self
        }
        pub fn set_health_check_custom_config(
            mut self,
            input: std::option::Option<crate::model::HealthCheckCustomConfig>,
        ) -> Self {
            self.health_check_custom_config = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>If present, specifies that the service instances are only discoverable using the <code>DiscoverInstances</code>
        /// API operation. No DNS records is registered for the service instances. The only valid value is
        /// <code>HTTP</code>.</p>
        pub fn r#type(mut self, input: crate::model::ServiceTypeOption) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ServiceTypeOption>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateServiceInput`](crate::input::CreateServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateServiceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateServiceInput {
                name: self.name,
                namespace_id: self.namespace_id,
                creator_request_id: self.creator_request_id,
                description: self.description,
                dns_config: self.dns_config,
                health_check_config: self.health_check_config,
                health_check_custom_config: self.health_check_custom_config,
                tags: self.tags,
                r#type: self.r#type,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateServiceInputOperationOutputAlias = crate::operation::CreateService;
#[doc(hidden)]
pub type CreateServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateServiceInput {
    /// Consumes the builder and constructs an Operation<[`CreateService`](crate::operation::CreateService)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateService,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateServiceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateServiceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.CreateService",
            );
            Ok(builder)
        }
        if self.creator_request_id.is_none() {
            self.creator_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_service(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::CreateService::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "CreateService",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateServiceInput`](crate::input::CreateServiceInput)
    pub fn builder() -> crate::input::create_service_input::Builder {
        crate::input::create_service_input::Builder::default()
    }
}

/// See [`DeleteNamespaceInput`](crate::input::DeleteNamespaceInput)
pub mod delete_namespace_input {
    /// A builder for [`DeleteNamespaceInput`](crate::input::DeleteNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the namespace that you want to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteNamespaceInput`](crate::input::DeleteNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteNamespaceInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type DeleteNamespaceInputOperationOutputAlias = crate::operation::DeleteNamespace;
#[doc(hidden)]
pub type DeleteNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteNamespace`](crate::operation::DeleteNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.DeleteNamespace",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_namespace(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteNamespaceInput`](crate::input::DeleteNamespaceInput)
    pub fn builder() -> crate::input::delete_namespace_input::Builder {
        crate::input::delete_namespace_input::Builder::default()
    }
}

/// See [`DeleteServiceInput`](crate::input::DeleteServiceInput)
pub mod delete_service_input {
    /// A builder for [`DeleteServiceInput`](crate::input::DeleteServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the service that you want to delete.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteServiceInput`](crate::input::DeleteServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteServiceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteServiceInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type DeleteServiceInputOperationOutputAlias = crate::operation::DeleteService;
#[doc(hidden)]
pub type DeleteServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteServiceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteService`](crate::operation::DeleteService)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteService,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteServiceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteServiceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.DeleteService",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_service(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::DeleteService::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "DeleteService",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteServiceInput`](crate::input::DeleteServiceInput)
    pub fn builder() -> crate::input::delete_service_input::Builder {
        crate::input::delete_service_input::Builder::default()
    }
}

/// See [`DeregisterInstanceInput`](crate::input::DeregisterInstanceInput)
pub mod deregister_instance_input {
    /// A builder for [`DeregisterInstanceInput`](crate::input::DeregisterInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the service that the instance is associated with.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The value that you specified for <code>Id</code> in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeregisterInstanceInput`](crate::input::DeregisterInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeregisterInstanceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeregisterInstanceInput {
                service_id: self.service_id,
                instance_id: self.instance_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeregisterInstanceInputOperationOutputAlias = crate::operation::DeregisterInstance;
#[doc(hidden)]
pub type DeregisterInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeregisterInstanceInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterInstance`](crate::operation::DeregisterInstance)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeregisterInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeregisterInstanceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeregisterInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeregisterInstanceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.DeregisterInstance",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_deregister_instance(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeregisterInstance::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeregisterInstance",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeregisterInstanceInput`](crate::input::DeregisterInstanceInput)
    pub fn builder() -> crate::input::deregister_instance_input::Builder {
        crate::input::deregister_instance_input::Builder::default()
    }
}

/// See [`DiscoverInstancesInput`](crate::input::DiscoverInstancesInput)
pub mod discover_instances_input {
    /// A builder for [`DiscoverInstancesInput`](crate::input::DiscoverInstancesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace_name: std::option::Option<std::string::String>,
        pub(crate) service_name: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) query_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) optional_parameters: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) health_status: std::option::Option<crate::model::HealthStatusFilter>,
    }
    impl Builder {
        /// <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
        /// <code>Properties</code> member of the namespace.</p>
        pub fn namespace_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace_name = Some(input.into());
            self
        }
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.namespace_name = input;
            self
        }
        /// <p>The name of the service that you specified when you registered the instance.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_name = Some(input.into());
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_name = input;
            self
        }
        /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
        /// <code>DiscoverInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
        /// to 100 instances.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        pub fn query_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.query_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.query_parameters = Some(hash_map);
            self
        }
        pub fn set_query_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.query_parameters = input;
            self
        }
        pub fn optional_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.optional_parameters.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.optional_parameters = Some(hash_map);
            self
        }
        pub fn set_optional_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.optional_parameters = input;
            self
        }
        /// <p>The health status of the instances that you want to discover. This parameter is ignored for services that don't
        /// have a health check configured, and
        /// all
        /// instances are returned.</p>
        /// <dl>
        /// <dt>HEALTHY</dt>
        /// <dd>
        /// <p>Returns healthy instances.</p>
        /// </dd>
        /// <dt>UNHEALTHY</dt>
        /// <dd>
        /// <p>Returns unhealthy instances.</p>
        /// </dd>
        /// <dt>ALL</dt>
        /// <dd>
        /// <p>Returns all instances.</p>
        /// </dd>
        /// <dt>HEALTHY_OR_ELSE_ALL</dt>
        /// <dd>
        /// <p>Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
        /// This is also called failing open.</p>
        /// </dd>
        /// </dl>
        pub fn health_status(mut self, input: crate::model::HealthStatusFilter) -> Self {
            self.health_status = Some(input);
            self
        }
        pub fn set_health_status(
            mut self,
            input: std::option::Option<crate::model::HealthStatusFilter>,
        ) -> Self {
            self.health_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DiscoverInstancesInput`](crate::input::DiscoverInstancesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DiscoverInstancesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DiscoverInstancesInput {
                namespace_name: self.namespace_name,
                service_name: self.service_name,
                max_results: self.max_results,
                query_parameters: self.query_parameters,
                optional_parameters: self.optional_parameters,
                health_status: self.health_status,
            })
        }
    }
}
#[doc(hidden)]
pub type DiscoverInstancesInputOperationOutputAlias = crate::operation::DiscoverInstances;
#[doc(hidden)]
pub type DiscoverInstancesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DiscoverInstancesInput {
    /// Consumes the builder and constructs an Operation<[`DiscoverInstances`](crate::operation::DiscoverInstances)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DiscoverInstances,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DiscoverInstancesInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DiscoverInstancesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DiscoverInstancesInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.DiscoverInstances",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_discover_instances(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        let endpoint_prefix = smithy_http::endpoint::EndpointPrefix::new("data-");
        match endpoint_prefix {
            Ok(prefix) => {
                request.properties_mut().insert(prefix);
            }
            Err(err) => {
                return Err(smithy_http::operation::BuildError::SerializationError(
                    err.into(),
                ))
            }
        }
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DiscoverInstances::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DiscoverInstances",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DiscoverInstancesInput`](crate::input::DiscoverInstancesInput)
    pub fn builder() -> crate::input::discover_instances_input::Builder {
        crate::input::discover_instances_input::Builder::default()
    }
}

/// See [`GetInstanceInput`](crate::input::GetInstanceInput)
pub mod get_instance_input {
    /// A builder for [`GetInstanceInput`](crate::input::GetInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the service that the instance is associated with.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The ID of the instance that you want to get information about.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstanceInput`](crate::input::GetInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetInstanceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetInstanceInput {
                service_id: self.service_id,
                instance_id: self.instance_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstanceInputOperationOutputAlias = crate::operation::GetInstance;
#[doc(hidden)]
pub type GetInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstanceInput {
    /// Consumes the builder and constructs an Operation<[`GetInstance`](crate::operation::GetInstance)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstanceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstanceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.GetInstance",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_instance(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetInstance::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "GetInstance",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstanceInput`](crate::input::GetInstanceInput)
    pub fn builder() -> crate::input::get_instance_input::Builder {
        crate::input::get_instance_input::Builder::default()
    }
}

/// See [`GetInstancesHealthStatusInput`](crate::input::GetInstancesHealthStatusInput)
pub mod get_instances_health_status_input {
    /// A builder for [`GetInstancesHealthStatusInput`](crate::input::GetInstancesHealthStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) instances: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the service that the instance is associated with.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        pub fn instances(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input.into());
            self.instances = Some(v);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
        /// <code>GetInstancesHealthStatus</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map
        /// returns up to 100 instances.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>For the first <code>GetInstancesHealthStatus</code> request, omit this value.</p>
        /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
        /// <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
        /// <code>NextToken</code> from the previous response in the next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInstancesHealthStatusInput`](crate::input::GetInstancesHealthStatusInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInstancesHealthStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInstancesHealthStatusInput {
                service_id: self.service_id,
                instances: self.instances,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInstancesHealthStatusInputOperationOutputAlias =
    crate::operation::GetInstancesHealthStatus;
#[doc(hidden)]
pub type GetInstancesHealthStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInstancesHealthStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetInstancesHealthStatus`](crate::operation::GetInstancesHealthStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetInstancesHealthStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInstancesHealthStatusInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInstancesHealthStatusInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInstancesHealthStatusInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.GetInstancesHealthStatus",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_instances_health_status(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInstancesHealthStatus::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetInstancesHealthStatus",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInstancesHealthStatusInput`](crate::input::GetInstancesHealthStatusInput)
    pub fn builder() -> crate::input::get_instances_health_status_input::Builder {
        crate::input::get_instances_health_status_input::Builder::default()
    }
}

/// See [`GetNamespaceInput`](crate::input::GetNamespaceInput)
pub mod get_namespace_input {
    /// A builder for [`GetNamespaceInput`](crate::input::GetNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the namespace that you want to get information about.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNamespaceInput`](crate::input::GetNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetNamespaceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetNamespaceInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type GetNamespaceInputOperationOutputAlias = crate::operation::GetNamespace;
#[doc(hidden)]
pub type GetNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`GetNamespace`](crate::operation::GetNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.GetNamespace",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_namespace(&self)
            .map_err(|err| {
            smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetNamespace::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "GetNamespace",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetNamespaceInput`](crate::input::GetNamespaceInput)
    pub fn builder() -> crate::input::get_namespace_input::Builder {
        crate::input::get_namespace_input::Builder::default()
    }
}

/// See [`GetOperationInput`](crate::input::GetOperationInput)
pub mod get_operation_input {
    /// A builder for [`GetOperationInput`](crate::input::GetOperationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operation_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the operation that you want to get more information about.</p>
        pub fn operation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_id = Some(input.into());
            self
        }
        pub fn set_operation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.operation_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetOperationInput`](crate::input::GetOperationInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetOperationInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetOperationInput {
                operation_id: self.operation_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetOperationInputOperationOutputAlias = crate::operation::GetOperation;
#[doc(hidden)]
pub type GetOperationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetOperationInput {
    /// Consumes the builder and constructs an Operation<[`GetOperation`](crate::operation::GetOperation)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetOperation,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetOperationInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetOperationInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetOperationInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.GetOperation",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_operation(&self)
            .map_err(|err| {
            smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetOperation::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "GetOperation",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetOperationInput`](crate::input::GetOperationInput)
    pub fn builder() -> crate::input::get_operation_input::Builder {
        crate::input::get_operation_input::Builder::default()
    }
}

/// See [`GetServiceInput`](crate::input::GetServiceInput)
pub mod get_service_input {
    /// A builder for [`GetServiceInput`](crate::input::GetServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the service that you want to get settings for.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetServiceInput`](crate::input::GetServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetServiceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetServiceInput { id: self.id })
        }
    }
}
#[doc(hidden)]
pub type GetServiceInputOperationOutputAlias = crate::operation::GetService;
#[doc(hidden)]
pub type GetServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetServiceInput {
    /// Consumes the builder and constructs an Operation<[`GetService`](crate::operation::GetService)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetService,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetServiceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetServiceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.GetService",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_service(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::GetService::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "GetService",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetServiceInput`](crate::input::GetServiceInput)
    pub fn builder() -> crate::input::get_service_input::Builder {
        crate::input::get_service_input::Builder::default()
    }
}

/// See [`ListInstancesInput`](crate::input::ListInstancesInput)
pub mod list_instances_input {
    /// A builder for [`ListInstancesInput`](crate::input::ListInstancesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the service that you want to list instances for.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>For the first <code>ListInstances</code> request, omit this value.</p>
        /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
        /// <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
        /// from the previous response in the next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
        /// <code>ListInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
        /// to 100 instances.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListInstancesInput`](crate::input::ListInstancesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListInstancesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListInstancesInput {
                service_id: self.service_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListInstancesInputOperationOutputAlias = crate::operation::ListInstances;
#[doc(hidden)]
pub type ListInstancesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListInstancesInput {
    /// Consumes the builder and constructs an Operation<[`ListInstances`](crate::operation::ListInstances)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListInstances,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListInstancesInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListInstancesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListInstancesInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.ListInstances",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_instances(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListInstances::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "ListInstances",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListInstancesInput`](crate::input::ListInstancesInput)
    pub fn builder() -> crate::input::list_instances_input::Builder {
        crate::input::list_instances_input::Builder::default()
    }
}

/// See [`ListNamespacesInput`](crate::input::ListNamespacesInput)
pub mod list_namespaces_input {
    /// A builder for [`ListNamespacesInput`](crate::input::ListNamespacesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::NamespaceFilter>>,
    }
    impl Builder {
        /// <p>For the first <code>ListNamespaces</code> request, omit this value.</p>
        /// <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
        /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
        /// request.</p>
        /// <note>
        /// <p>Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
        /// possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
        /// subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of namespaces that you want Cloud Map to return in the response to a
        /// <code>ListNamespaces</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
        /// to 100 namespaces.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        pub fn filters(mut self, input: impl Into<crate::model::NamespaceFilter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NamespaceFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ListNamespacesInput`](crate::input::ListNamespacesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListNamespacesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListNamespacesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                filters: self.filters,
            })
        }
    }
}
#[doc(hidden)]
pub type ListNamespacesInputOperationOutputAlias = crate::operation::ListNamespaces;
#[doc(hidden)]
pub type ListNamespacesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListNamespacesInput {
    /// Consumes the builder and constructs an Operation<[`ListNamespaces`](crate::operation::ListNamespaces)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListNamespaces,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListNamespacesInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListNamespacesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListNamespacesInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.ListNamespaces",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_namespaces(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListNamespaces::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListNamespaces",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListNamespacesInput`](crate::input::ListNamespacesInput)
    pub fn builder() -> crate::input::list_namespaces_input::Builder {
        crate::input::list_namespaces_input::Builder::default()
    }
}

/// See [`ListOperationsInput`](crate::input::ListOperationsInput)
pub mod list_operations_input {
    /// A builder for [`ListOperationsInput`](crate::input::ListOperationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::OperationFilter>>,
    }
    impl Builder {
        /// <p>For the first <code>ListOperations</code> request, omit this value.</p>
        /// <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
        /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
        /// request.</p>
        /// <note>
        /// <p>Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
        /// possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
        /// subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items that you want Cloud Map to return in the response to a <code>ListOperations</code>
        /// request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 operations.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        pub fn filters(mut self, input: impl Into<crate::model::OperationFilter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OperationFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ListOperationsInput`](crate::input::ListOperationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListOperationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListOperationsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                filters: self.filters,
            })
        }
    }
}
#[doc(hidden)]
pub type ListOperationsInputOperationOutputAlias = crate::operation::ListOperations;
#[doc(hidden)]
pub type ListOperationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListOperationsInput {
    /// Consumes the builder and constructs an Operation<[`ListOperations`](crate::operation::ListOperations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListOperations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListOperationsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListOperationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListOperationsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.ListOperations",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_operations(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListOperations::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListOperations",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListOperationsInput`](crate::input::ListOperationsInput)
    pub fn builder() -> crate::input::list_operations_input::Builder {
        crate::input::list_operations_input::Builder::default()
    }
}

/// See [`ListServicesInput`](crate::input::ListServicesInput)
pub mod list_services_input {
    /// A builder for [`ListServicesInput`](crate::input::ListServicesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::ServiceFilter>>,
    }
    impl Builder {
        /// <p>For the first <code>ListServices</code> request, omit this value.</p>
        /// <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
        /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
        /// request.</p>
        /// <note>
        /// <p>Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
        /// possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
        /// subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of services that you want Cloud Map to return in the response to a <code>ListServices</code>
        /// request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 services.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        pub fn filters(mut self, input: impl Into<crate::model::ServiceFilter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ListServicesInput`](crate::input::ListServicesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListServicesInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListServicesInput {
                next_token: self.next_token,
                max_results: self.max_results,
                filters: self.filters,
            })
        }
    }
}
#[doc(hidden)]
pub type ListServicesInputOperationOutputAlias = crate::operation::ListServices;
#[doc(hidden)]
pub type ListServicesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListServicesInput {
    /// Consumes the builder and constructs an Operation<[`ListServices`](crate::operation::ListServices)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListServices,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListServicesInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListServicesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListServicesInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.ListServices",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_services(&self)
            .map_err(|err| {
            smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListServices::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "ListServices",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListServicesInput`](crate::input::ListServicesInput)
    pub fn builder() -> crate::input::list_services_input::Builder {
        crate::input::list_services_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.ListTagsForResource",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_tags_for_resource(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`RegisterInstanceInput`](crate::input::RegisterInstanceInput)
pub mod register_instance_input {
    /// A builder for [`RegisterInstanceInput`](crate::input::RegisterInstanceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) creator_request_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID of the service that you want to use for settings for the instance.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>An identifier that you want to associate with the instance. Note the following:</p>
        /// <ul>
        /// <li>
        /// <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
        /// the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
        /// record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
        /// </li>
        /// <li>
        /// <p>You can use this value to update an existing instance.</p>
        /// </li>
        /// <li>
        /// <p>To register a new instance, you must specify a value that's unique among instances that you register by using
        /// the same service. </p>
        /// </li>
        /// <li>
        /// <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, Cloud Map updates the existing
        /// DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates
        /// a new one. </p>
        /// <note>
        /// <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
        /// <code>ListHealthChecks</code> request, for example.</p>
        /// </note>
        /// </li>
        /// </ul>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
        /// retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
        /// every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
        /// namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
        /// stamp).</p>
        pub fn creator_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.creator_request_id = Some(input.into());
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creator_request_id = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterInstanceInput`](crate::input::RegisterInstanceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterInstanceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterInstanceInput {
                service_id: self.service_id,
                instance_id: self.instance_id,
                creator_request_id: self.creator_request_id,
                attributes: self.attributes,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterInstanceInputOperationOutputAlias = crate::operation::RegisterInstance;
#[doc(hidden)]
pub type RegisterInstanceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RegisterInstanceInput {
    /// Consumes the builder and constructs an Operation<[`RegisterInstance`](crate::operation::RegisterInstance)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::RegisterInstance,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RegisterInstanceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RegisterInstanceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RegisterInstanceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.RegisterInstance",
            );
            Ok(builder)
        }
        if self.creator_request_id.is_none() {
            self.creator_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_register_instance(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterInstance::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "RegisterInstance",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RegisterInstanceInput`](crate::input::RegisterInstanceInput)
    pub fn builder() -> crate::input::register_instance_input::Builder {
        crate::input::register_instance_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.TagResource",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "TagResource",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.UntagResource",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "UntagResource",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateHttpNamespaceInput`](crate::input::UpdateHttpNamespaceInput)
pub mod update_http_namespace_input {
    /// A builder for [`UpdateHttpNamespaceInput`](crate::input::UpdateHttpNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) updater_request_id: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<crate::model::HttpNamespaceChange>,
    }
    impl Builder {
        /// <p>The ID of the namespace that you want to
        /// update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A unique string that identifies the
        /// request and that allows failed <code>UpdateHttpNamespace</code> requests to be retried without the risk of running
        /// the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
        /// date/timestamp).</p>
        pub fn updater_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.updater_request_id = Some(input.into());
            self
        }
        pub fn set_updater_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updater_request_id = input;
            self
        }
        /// <p>Updated properties for the the HTTP
        /// namespace.</p>
        pub fn namespace(mut self, input: crate::model::HttpNamespaceChange) -> Self {
            self.namespace = Some(input);
            self
        }
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::HttpNamespaceChange>,
        ) -> Self {
            self.namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateHttpNamespaceInput`](crate::input::UpdateHttpNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateHttpNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateHttpNamespaceInput {
                id: self.id,
                updater_request_id: self.updater_request_id,
                namespace: self.namespace,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateHttpNamespaceInputOperationOutputAlias = crate::operation::UpdateHttpNamespace;
#[doc(hidden)]
pub type UpdateHttpNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateHttpNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateHttpNamespace`](crate::operation::UpdateHttpNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateHttpNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateHttpNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateHttpNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateHttpNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.UpdateHttpNamespace",
            );
            Ok(builder)
        }
        if self.updater_request_id.is_none() {
            self.updater_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_http_namespace(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateHttpNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateHttpNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateHttpNamespaceInput`](crate::input::UpdateHttpNamespaceInput)
    pub fn builder() -> crate::input::update_http_namespace_input::Builder {
        crate::input::update_http_namespace_input::Builder::default()
    }
}

/// See [`UpdateInstanceCustomHealthStatusInput`](crate::input::UpdateInstanceCustomHealthStatusInput)
pub mod update_instance_custom_health_status_input {
    /// A builder for [`UpdateInstanceCustomHealthStatusInput`](crate::input::UpdateInstanceCustomHealthStatusInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_id: std::option::Option<std::string::String>,
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CustomHealthStatus>,
    }
    impl Builder {
        /// <p>The ID of the service that includes the configuration for the custom health check that you want to change the
        /// status for.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_id = Some(input.into());
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service_id = input;
            self
        }
        /// <p>The ID of the instance that you want to change the health status for.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The new status of the instance, <code>HEALTHY</code> or <code>UNHEALTHY</code>.</p>
        pub fn status(mut self, input: crate::model::CustomHealthStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CustomHealthStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateInstanceCustomHealthStatusInput`](crate::input::UpdateInstanceCustomHealthStatusInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateInstanceCustomHealthStatusInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateInstanceCustomHealthStatusInput {
                service_id: self.service_id,
                instance_id: self.instance_id,
                status: self.status,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateInstanceCustomHealthStatusInputOperationOutputAlias =
    crate::operation::UpdateInstanceCustomHealthStatus;
#[doc(hidden)]
pub type UpdateInstanceCustomHealthStatusInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateInstanceCustomHealthStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateInstanceCustomHealthStatus`](crate::operation::UpdateInstanceCustomHealthStatus)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateInstanceCustomHealthStatus,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateInstanceCustomHealthStatusInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateInstanceCustomHealthStatusInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateInstanceCustomHealthStatusInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.UpdateInstanceCustomHealthStatus",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_instance_custom_health_status(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateInstanceCustomHealthStatus::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateInstanceCustomHealthStatus",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateInstanceCustomHealthStatusInput`](crate::input::UpdateInstanceCustomHealthStatusInput)
    pub fn builder() -> crate::input::update_instance_custom_health_status_input::Builder {
        crate::input::update_instance_custom_health_status_input::Builder::default()
    }
}

/// See [`UpdatePrivateDnsNamespaceInput`](crate::input::UpdatePrivateDnsNamespaceInput)
pub mod update_private_dns_namespace_input {
    /// A builder for [`UpdatePrivateDnsNamespaceInput`](crate::input::UpdatePrivateDnsNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) updater_request_id: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<crate::model::PrivateDnsNamespaceChange>,
    }
    impl Builder {
        /// <p>The ID of the namespace that you want to
        /// update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A unique string that identifies the
        /// request and that allows failed <code>UpdatePrivateDnsNamespace</code> requests to be retried without the risk of
        /// running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
        /// date/timestamp).</p>
        pub fn updater_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.updater_request_id = Some(input.into());
            self
        }
        pub fn set_updater_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updater_request_id = input;
            self
        }
        /// <p>Updated properties for the private DNS
        /// namespace.</p>
        pub fn namespace(mut self, input: crate::model::PrivateDnsNamespaceChange) -> Self {
            self.namespace = Some(input);
            self
        }
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::PrivateDnsNamespaceChange>,
        ) -> Self {
            self.namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePrivateDnsNamespaceInput`](crate::input::UpdatePrivateDnsNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePrivateDnsNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePrivateDnsNamespaceInput {
                id: self.id,
                updater_request_id: self.updater_request_id,
                namespace: self.namespace,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePrivateDnsNamespaceInputOperationOutputAlias =
    crate::operation::UpdatePrivateDnsNamespace;
#[doc(hidden)]
pub type UpdatePrivateDnsNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdatePrivateDnsNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePrivateDnsNamespace`](crate::operation::UpdatePrivateDnsNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdatePrivateDnsNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdatePrivateDnsNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdatePrivateDnsNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdatePrivateDnsNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.UpdatePrivateDnsNamespace",
            );
            Ok(builder)
        }
        if self.updater_request_id.is_none() {
            self.updater_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_private_dns_namespace(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdatePrivateDnsNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdatePrivateDnsNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdatePrivateDnsNamespaceInput`](crate::input::UpdatePrivateDnsNamespaceInput)
    pub fn builder() -> crate::input::update_private_dns_namespace_input::Builder {
        crate::input::update_private_dns_namespace_input::Builder::default()
    }
}

/// See [`UpdatePublicDnsNamespaceInput`](crate::input::UpdatePublicDnsNamespaceInput)
pub mod update_public_dns_namespace_input {
    /// A builder for [`UpdatePublicDnsNamespaceInput`](crate::input::UpdatePublicDnsNamespaceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) updater_request_id: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<crate::model::PublicDnsNamespaceChange>,
    }
    impl Builder {
        /// <p>The ID of the namespace being
        /// updated.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A unique string that identifies the
        /// request and that allows failed <code>UpdatePublicDnsNamespace</code> requests to be retried without the risk of
        /// running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
        /// date/timestamp).</p>
        pub fn updater_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.updater_request_id = Some(input.into());
            self
        }
        pub fn set_updater_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updater_request_id = input;
            self
        }
        /// <p>Updated properties for the public DNS
        /// namespace.</p>
        pub fn namespace(mut self, input: crate::model::PublicDnsNamespaceChange) -> Self {
            self.namespace = Some(input);
            self
        }
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::PublicDnsNamespaceChange>,
        ) -> Self {
            self.namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdatePublicDnsNamespaceInput`](crate::input::UpdatePublicDnsNamespaceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdatePublicDnsNamespaceInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdatePublicDnsNamespaceInput {
                id: self.id,
                updater_request_id: self.updater_request_id,
                namespace: self.namespace,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdatePublicDnsNamespaceInputOperationOutputAlias =
    crate::operation::UpdatePublicDnsNamespace;
#[doc(hidden)]
pub type UpdatePublicDnsNamespaceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdatePublicDnsNamespaceInput {
    /// Consumes the builder and constructs an Operation<[`UpdatePublicDnsNamespace`](crate::operation::UpdatePublicDnsNamespace)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdatePublicDnsNamespace,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdatePublicDnsNamespaceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdatePublicDnsNamespaceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdatePublicDnsNamespaceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.UpdatePublicDnsNamespace",
            );
            Ok(builder)
        }
        if self.updater_request_id.is_none() {
            self.updater_request_id = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_public_dns_namespace(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdatePublicDnsNamespace::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdatePublicDnsNamespace",
            "servicediscovery",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdatePublicDnsNamespaceInput`](crate::input::UpdatePublicDnsNamespaceInput)
    pub fn builder() -> crate::input::update_public_dns_namespace_input::Builder {
        crate::input::update_public_dns_namespace_input::Builder::default()
    }
}

/// See [`UpdateServiceInput`](crate::input::UpdateServiceInput)
pub mod update_service_input {
    /// A builder for [`UpdateServiceInput`](crate::input::UpdateServiceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) service: std::option::Option<crate::model::ServiceChange>,
    }
    impl Builder {
        /// <p>The ID of the service that you want to update.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>A complex type that contains the new settings for the service.</p>
        pub fn service(mut self, input: crate::model::ServiceChange) -> Self {
            self.service = Some(input);
            self
        }
        pub fn set_service(
            mut self,
            input: std::option::Option<crate::model::ServiceChange>,
        ) -> Self {
            self.service = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateServiceInput`](crate::input::UpdateServiceInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateServiceInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateServiceInput {
                id: self.id,
                service: self.service,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateServiceInputOperationOutputAlias = crate::operation::UpdateService;
#[doc(hidden)]
pub type UpdateServiceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateServiceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateService`](crate::operation::UpdateService)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateService,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateServiceInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateServiceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateServiceInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-amz-json-1.1",
            );
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "Route53AutoNaming_v20170314.UpdateService",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_service(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::UpdateService::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "UpdateService",
                    "servicediscovery",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateServiceInput`](crate::input::UpdateServiceInput)
    pub fn builder() -> crate::input::update_service_input::Builder {
        crate::input::update_service_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateServiceInput {
    /// <p>The ID of the service that you want to update.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A complex type that contains the new settings for the service.</p>
    pub service: std::option::Option<crate::model::ServiceChange>,
}
impl std::fmt::Debug for UpdateServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateServiceInput");
        formatter.field("id", &self.id);
        formatter.field("service", &self.service);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePublicDnsNamespaceInput {
    /// <p>The ID of the namespace being
    /// updated.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the
    /// request and that allows failed <code>UpdatePublicDnsNamespace</code> requests to be retried without the risk of
    /// running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
    /// date/timestamp).</p>
    pub updater_request_id: std::option::Option<std::string::String>,
    /// <p>Updated properties for the public DNS
    /// namespace.</p>
    pub namespace: std::option::Option<crate::model::PublicDnsNamespaceChange>,
}
impl std::fmt::Debug for UpdatePublicDnsNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePublicDnsNamespaceInput");
        formatter.field("id", &self.id);
        formatter.field("updater_request_id", &self.updater_request_id);
        formatter.field("namespace", &self.namespace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdatePrivateDnsNamespaceInput {
    /// <p>The ID of the namespace that you want to
    /// update.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the
    /// request and that allows failed <code>UpdatePrivateDnsNamespace</code> requests to be retried without the risk of
    /// running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
    /// date/timestamp).</p>
    pub updater_request_id: std::option::Option<std::string::String>,
    /// <p>Updated properties for the private DNS
    /// namespace.</p>
    pub namespace: std::option::Option<crate::model::PrivateDnsNamespaceChange>,
}
impl std::fmt::Debug for UpdatePrivateDnsNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdatePrivateDnsNamespaceInput");
        formatter.field("id", &self.id);
        formatter.field("updater_request_id", &self.updater_request_id);
        formatter.field("namespace", &self.namespace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateInstanceCustomHealthStatusInput {
    /// <p>The ID of the service that includes the configuration for the custom health check that you want to change the
    /// status for.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The ID of the instance that you want to change the health status for.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The new status of the instance, <code>HEALTHY</code> or <code>UNHEALTHY</code>.</p>
    pub status: std::option::Option<crate::model::CustomHealthStatus>,
}
impl std::fmt::Debug for UpdateInstanceCustomHealthStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateInstanceCustomHealthStatusInput");
        formatter.field("service_id", &self.service_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateHttpNamespaceInput {
    /// <p>The ID of the namespace that you want to
    /// update.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the
    /// request and that allows failed <code>UpdateHttpNamespace</code> requests to be retried without the risk of running
    /// the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
    /// date/timestamp).</p>
    pub updater_request_id: std::option::Option<std::string::String>,
    /// <p>Updated properties for the the HTTP
    /// namespace.</p>
    pub namespace: std::option::Option<crate::model::HttpNamespaceChange>,
}
impl std::fmt::Debug for UpdateHttpNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateHttpNamespaceInput");
        formatter.field("id", &self.id);
        formatter.field("updater_request_id", &self.updater_request_id);
        formatter.field("namespace", &self.namespace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag keys to remove from the specified resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to
    /// an empty string, but you can't set the value of a tag to null.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterInstanceInput {
    /// <p>The ID of the service that you want to use for settings for the instance.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>An identifier that you want to associate with the instance. Note the following:</p>
    /// <ul>
    /// <li>
    /// <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
    /// the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
    /// record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
    /// </li>
    /// <li>
    /// <p>You can use this value to update an existing instance.</p>
    /// </li>
    /// <li>
    /// <p>To register a new instance, you must specify a value that's unique among instances that you register by using
    /// the same service. </p>
    /// </li>
    /// <li>
    /// <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, Cloud Map updates the existing
    /// DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates
    /// a new one. </p>
    /// <note>
    /// <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
    /// <code>ListHealthChecks</code> request, for example.</p>
    /// </note>
    /// </li>
    /// </ul>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
    /// retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
    /// every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
    /// namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
    /// stamp).</p>
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>A string map that contains the following information for the service that you specify in
    /// <code>ServiceId</code>:</p>
    /// <ul>
    /// <li>
    /// <p>The attributes that apply to the records that are defined in the service. </p>
    /// </li>
    /// <li>
    /// <p>For each attribute, the applicable value.</p>
    /// </li>
    /// </ul>
    /// <p>Supported attribute keys include the following:</p>
    /// <dl>
    /// <dt>AWS_ALIAS_DNS_NAME</dt>
    /// <dd>
    /// <p>If you want Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer,
    /// specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see
    /// "DNSName" in the topic <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html">AliasTarget</a> in the <i>Route 53 API Reference</i>.</p>
    /// <p>Note the following:</p>
    /// <ul>
    /// <li>
    /// <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
    /// <code>A</code> record, an <code>AAAA</code> record, or both.</p>
    /// </li>
    /// <li>
    /// <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
    /// <code>WEIGHTED</code>.</p>
    /// </li>
    /// <li>
    /// <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
    /// Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias
    /// record.</p>
    /// </li>
    /// <li>
    /// <p>Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services
    /// resources other than Elastic Load Balancing load balancers.</p>
    /// </li>
    /// <li>
    /// <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
    /// <code>AWS_INSTANCE</code> attributes.</p>
    /// </li>
    /// </ul>
    /// </dd>
    /// <dt>AWS_EC2_INSTANCE_ID</dt>
    /// <dd>
    /// <p>
    /// <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. If the
    /// <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the only other attribute that can be specified is
    /// <code>AWS_INIT_HEALTH_STATUS</code>. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the
    /// <code>AWS_INSTANCE_IPV4</code> attribute will be filled out with the primary private IPv4 address.</p>
    /// </dd>
    /// <dt>AWS_INIT_HEALTH_STATUS</dt>
    /// <dd>
    /// <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
    /// <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
    /// <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
    /// <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
    /// </dd>
    /// <dt>AWS_INSTANCE_CNAME</dt>
    /// <dd>
    /// <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
    /// return in response to DNS queries (for example, <code>example.com</code>).</p>
    /// <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    /// <code>CNAME</code> record.</p>
    /// </dd>
    /// <dt>AWS_INSTANCE_IPV4</dt>
    /// <dd>
    /// <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
    /// return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
    /// <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    /// <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
    /// for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    /// </dd>
    /// <dt>AWS_INSTANCE_IPV6</dt>
    /// <dd>
    /// <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
    /// return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
    /// <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
    /// <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
    /// value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
    /// </dd>
    /// <dt>AWS_INSTANCE_PORT</dt>
    /// <dd>
    /// <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
    /// port.</p>
    /// <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
    /// requests to. </p>
    /// <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
    /// you created the service.</p>
    /// </dd>
    /// <dt>Custom attributes</dt>
    /// <dd>
    /// <p>You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is
    /// 255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided
    /// attributes (sum of all keys and values) must not exceed 5,000 characters.</p>
    /// </dd>
    /// </dl>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for RegisterInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterInstanceInput");
        formatter.field("service_id", &self.service_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListServicesInput {
    /// <p>For the first <code>ListServices</code> request, omit this value.</p>
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
    /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    /// request.</p>
    /// <note>
    /// <p>Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
    /// possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
    /// subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
    /// </note>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of services that you want Cloud Map to return in the response to a <code>ListServices</code>
    /// request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 services.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A complex type that contains specifications for the namespaces that you want to list services for. </p>
    /// <p>If you specify more than one filter, an operation must match all filters to be returned by
    /// <code>ListServices</code>.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::ServiceFilter>>,
}
impl std::fmt::Debug for ListServicesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListServicesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListOperationsInput {
    /// <p>For the first <code>ListOperations</code> request, omit this value.</p>
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
    /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    /// request.</p>
    /// <note>
    /// <p>Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
    /// possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
    /// subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
    /// </note>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items that you want Cloud Map to return in the response to a <code>ListOperations</code>
    /// request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 operations.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A complex type that contains specifications for the operations that you want to list, for example, operations
    /// that you started between a specified start date and end date.</p>
    /// <p>If you specify more than one filter, an operation must match all filters to be returned by
    /// <code>ListOperations</code>.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::OperationFilter>>,
}
impl std::fmt::Debug for ListOperationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListOperationsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNamespacesInput {
    /// <p>For the first <code>ListNamespaces</code> request, omit this value.</p>
    /// <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
    /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
    /// request.</p>
    /// <note>
    /// <p>Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
    /// possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
    /// subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
    /// </note>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of namespaces that you want Cloud Map to return in the response to a
    /// <code>ListNamespaces</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
    /// to 100 namespaces.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>A complex type that contains specifications for the namespaces that you want to list.</p>
    /// <p>If you specify more than one filter, a namespace must match all filters to be returned by
    /// <code>ListNamespaces</code>.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::NamespaceFilter>>,
}
impl std::fmt::Debug for ListNamespacesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListNamespacesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListInstancesInput {
    /// <p>The ID of the service that you want to list instances for.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>For the first <code>ListInstances</code> request, omit this value.</p>
    /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    /// <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
    /// from the previous response in the next request.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
    /// <code>ListInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
    /// to 100 instances.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListInstancesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListInstancesInput");
        formatter.field("service_id", &self.service_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetServiceInput {
    /// <p>The ID of the service that you want to get settings for.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetServiceInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetOperationInput {
    /// <p>The ID of the operation that you want to get more information about.</p>
    pub operation_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetOperationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetOperationInput");
        formatter.field("operation_id", &self.operation_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNamespaceInput {
    /// <p>The ID of the namespace that you want to get information about.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetNamespaceInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstancesHealthStatusInput {
    /// <p>The ID of the service that the instance is associated with.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>An array that contains the IDs of all the instances that you want to get the health status for.</p>
    /// <p>If you omit <code>Instances</code>, Cloud Map returns the health status for all the instances that are
    /// associated with the specified service.</p>
    /// <note>
    /// <p>To get the IDs for the instances that you've registered by using a specified service, submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html">ListInstances</a> request.</p>
    /// </note>
    pub instances: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
    /// <code>GetInstancesHealthStatus</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map
    /// returns up to 100 instances.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>For the first <code>GetInstancesHealthStatus</code> request, omit this value.</p>
    /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
    /// <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
    /// <code>NextToken</code> from the previous response in the next request.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetInstancesHealthStatusInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstancesHealthStatusInput");
        formatter.field("service_id", &self.service_id);
        formatter.field("instances", &self.instances);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInstanceInput {
    /// <p>The ID of the service that the instance is associated with.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The ID of the instance that you want to get information about.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInstanceInput");
        formatter.field("service_id", &self.service_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiscoverInstancesInput {
    /// <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
    /// <code>Properties</code> member of the namespace.</p>
    pub namespace_name: std::option::Option<std::string::String>,
    /// <p>The name of the service that you specified when you registered the instance.</p>
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
    /// <code>DiscoverInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
    /// to 100 instances.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Filters to scope the results based on custom attributes for the instance (for example, <code>{version=v1,
    /// az=1a}</code>). Only instances that match all the specified key-value pairs are returned.</p>
    pub query_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Opportunistic filters to scope the results based on custom attributes. If there are instances that match both
    /// the filters specified in both the <code>QueryParameters</code> parameter and this parameter, all of these instances
    /// are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the
    /// <code>QueryParameters</code> parameter are returned.</p>
    pub optional_parameters:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The health status of the instances that you want to discover. This parameter is ignored for services that don't
    /// have a health check configured, and
    /// all
    /// instances are returned.</p>
    /// <dl>
    /// <dt>HEALTHY</dt>
    /// <dd>
    /// <p>Returns healthy instances.</p>
    /// </dd>
    /// <dt>UNHEALTHY</dt>
    /// <dd>
    /// <p>Returns unhealthy instances.</p>
    /// </dd>
    /// <dt>ALL</dt>
    /// <dd>
    /// <p>Returns all instances.</p>
    /// </dd>
    /// <dt>HEALTHY_OR_ELSE_ALL</dt>
    /// <dd>
    /// <p>Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
    /// This is also called failing open.</p>
    /// </dd>
    /// </dl>
    pub health_status: std::option::Option<crate::model::HealthStatusFilter>,
}
impl std::fmt::Debug for DiscoverInstancesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiscoverInstancesInput");
        formatter.field("namespace_name", &self.namespace_name);
        formatter.field("service_name", &self.service_name);
        formatter.field("max_results", &self.max_results);
        formatter.field("query_parameters", &self.query_parameters);
        formatter.field("optional_parameters", &self.optional_parameters);
        formatter.field("health_status", &self.health_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterInstanceInput {
    /// <p>The ID of the service that the instance is associated with.</p>
    pub service_id: std::option::Option<std::string::String>,
    /// <p>The value that you specified for <code>Id</code> in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
    pub instance_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeregisterInstanceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterInstanceInput");
        formatter.field("service_id", &self.service_id);
        formatter.field("instance_id", &self.instance_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteServiceInput {
    /// <p>The ID of the service that you want to delete.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteServiceInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteNamespaceInput {
    /// <p>The ID of the namespace that you want to delete.</p>
    pub id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteNamespaceInput");
        formatter.field("id", &self.id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateServiceInput {
    /// <p>The name that you want to assign to the service.</p>
    /// <p>If you want Cloud Map to create an <code>SRV</code> record when you register an instance and you're using a
    /// system that requires a specific <code>SRV</code> format, such as <a href="http://www.haproxy.org/">HAProxy</a>, specify the following for <code>Name</code>:</p>
    /// <ul>
    /// <li>
    /// <p>Start the name with an underscore (_), such as <code>_exampleservice</code>.</p>
    /// </li>
    /// <li>
    /// <p>End the name with <i>._protocol</i>, such as <code>._tcp</code>.</p>
    /// </li>
    /// </ul>
    /// <p>When you register an instance, Cloud Map creates an <code>SRV</code> record and assigns a name to the record by
    /// concatenating the service name and the namespace name (for example,</p>
    /// <p>
    /// <code>_exampleservice._tcp.example.com</code>).</p>
    /// <note>
    /// <p>For services that are accessible by DNS queries, you can't create multiple services with names that differ only
    /// by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
    /// However, if you use a namespace that's only accessible by API calls, then you can create services that with names
    /// that differ only by case.</p>
    /// </note>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
    /// can be specified either here or in the <code>DnsConfig</code> object.</p>
    pub namespace_id: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the request and that allows failed <code>CreateService</code> requests to be
    /// retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string (for
    /// example, a date/timestamp).</p>
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>A description for the service.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you
    /// register an instance. </p>
    pub dns_config: std::option::Option<crate::model::DnsConfig>,
    /// <p>
    /// <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
    /// Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the
    /// Route 53 DNS records that you specify in <code>DnsConfig</code>.</p>
    /// <important>
    /// <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    /// <code>HealthCheckConfig</code> but not both.</p>
    /// </important>
    /// <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">Cloud Map Pricing</a>.</p>
    pub health_check_config: std::option::Option<crate::model::HealthCheckConfig>,
    /// <p>A complex type that contains information about an optional custom health check.</p>
    /// <important>
    /// <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
    /// <code>HealthCheckConfig</code> but not both.</p>
    /// </important>
    /// <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration from an existing
    /// service.</p>
    pub health_check_custom_config: std::option::Option<crate::model::HealthCheckCustomConfig>,
    /// <p>The tags to add to the service. Each tag consists of a key and an optional value that you define.
    /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
    /// characters in length.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>If present, specifies that the service instances are only discoverable using the <code>DiscoverInstances</code>
    /// API operation. No DNS records is registered for the service instances. The only valid value is
    /// <code>HTTP</code>.</p>
    pub r#type: std::option::Option<crate::model::ServiceTypeOption>,
}
impl std::fmt::Debug for CreateServiceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateServiceInput");
        formatter.field("name", &self.name);
        formatter.field("namespace_id", &self.namespace_id);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.field("description", &self.description);
        formatter.field("dns_config", &self.dns_config);
        formatter.field("health_check_config", &self.health_check_config);
        formatter.field(
            "health_check_custom_config",
            &self.health_check_custom_config,
        );
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePublicDnsNamespaceInput {
    /// <p>The name that you want to assign to this namespace.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the request and that allows failed <code>CreatePublicDnsNamespace</code>
    /// requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
    /// unique string (for example, a date/timestamp).</p>
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>A description for the namespace.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
    /// characters in length.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Properties for the public DNS
    /// namespace.</p>
    pub properties: std::option::Option<crate::model::PublicDnsNamespaceProperties>,
}
impl std::fmt::Debug for CreatePublicDnsNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePublicDnsNamespaceInput");
        formatter.field("name", &self.name);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.field("properties", &self.properties);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePrivateDnsNamespaceInput {
    /// <p>The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map
    /// automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the request and that allows failed <code>CreatePrivateDnsNamespace</code>
    /// requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
    /// unique string (for example, a date/timestamp).</p>
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>A description for the namespace.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon VPC that you want to associate the namespace with.</p>
    pub vpc: std::option::Option<std::string::String>,
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
    /// characters in length.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Properties for the private DNS
    /// namespace.</p>
    pub properties: std::option::Option<crate::model::PrivateDnsNamespaceProperties>,
}
impl std::fmt::Debug for CreatePrivateDnsNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePrivateDnsNamespaceInput");
        formatter.field("name", &self.name);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.field("description", &self.description);
        formatter.field("vpc", &self.vpc);
        formatter.field("tags", &self.tags);
        formatter.field("properties", &self.properties);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateHttpNamespaceInput {
    /// <p>The name that you want to assign to this namespace.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A unique string that identifies the request and that allows failed <code>CreateHttpNamespace</code> requests to
    /// be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string
    /// (for example, a date/time stamp).</p>
    pub creator_request_id: std::option::Option<std::string::String>,
    /// <p>A description for the namespace.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
    /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
    /// characters in length.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for CreateHttpNamespaceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateHttpNamespaceInput");
        formatter.field("name", &self.name);
        formatter.field("creator_request_id", &self.creator_request_id);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
