// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates an HTTP namespace. Service instances registered using an HTTP namespace can be discovered using a
/// <code>DiscoverInstances</code> request but can't be discovered using DNS.</p>
/// <p>For the current quota on the number of namespaces that you can create using the same account,
/// see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map quotas</a> in the
/// <i>Cloud Map Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateHttpNamespace {
    _private: (),
}
impl CreateHttpNamespace {
    /// Creates a new builder-style object to manufacture [`CreateHttpNamespaceInput`](crate::input::CreateHttpNamespaceInput)
    pub fn builder() -> crate::input::create_http_namespace_input::Builder {
        crate::input::create_http_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateHttpNamespace {
    type Output = std::result::Result<
        crate::output::CreateHttpNamespaceOutput,
        crate::error::CreateHttpNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_http_namespace_error(response)
        } else {
            crate::operation_deser::parse_create_http_namespace_response(response)
        }
    }
}

/// <p>Creates a private namespace based on DNS, which is visible only inside a specified Amazon VPC. The namespace
/// defines your service naming scheme. For example, if you name your namespace <code>example.com</code> and name your
/// service <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. Service
/// instances that are registered using a private DNS namespace can be discovered using either a
/// <code>DiscoverInstances</code> request or using DNS. For the current quota on the number of namespaces that you can
/// create using the same account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map quotas</a> in the
/// <i>Cloud Map Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePrivateDnsNamespace {
    _private: (),
}
impl CreatePrivateDnsNamespace {
    /// Creates a new builder-style object to manufacture [`CreatePrivateDnsNamespaceInput`](crate::input::CreatePrivateDnsNamespaceInput)
    pub fn builder() -> crate::input::create_private_dns_namespace_input::Builder {
        crate::input::create_private_dns_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePrivateDnsNamespace {
    type Output = std::result::Result<
        crate::output::CreatePrivateDnsNamespaceOutput,
        crate::error::CreatePrivateDnsNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_private_dns_namespace_error(response)
        } else {
            crate::operation_deser::parse_create_private_dns_namespace_response(response)
        }
    }
}

/// <p>Creates a public namespace based on DNS, which is visible on the internet. The namespace defines your service
/// naming scheme. For example, if you name your namespace <code>example.com</code> and name your service
/// <code>backend</code>, the resulting DNS name for the service is <code>backend.example.com</code>. You can discover
/// instances that were registered with a public DNS namespace by using either a <code>DiscoverInstances</code> request
/// or using DNS. For the current quota on the number of namespaces that you can create using the same account, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
/// quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePublicDnsNamespace {
    _private: (),
}
impl CreatePublicDnsNamespace {
    /// Creates a new builder-style object to manufacture [`CreatePublicDnsNamespaceInput`](crate::input::CreatePublicDnsNamespaceInput)
    pub fn builder() -> crate::input::create_public_dns_namespace_input::Builder {
        crate::input::create_public_dns_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePublicDnsNamespace {
    type Output = std::result::Result<
        crate::output::CreatePublicDnsNamespaceOutput,
        crate::error::CreatePublicDnsNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_public_dns_namespace_error(response)
        } else {
            crate::operation_deser::parse_create_public_dns_namespace_response(response)
        }
    }
}

/// <p>Creates a service. This action defines the configuration for the following entities:</p>
/// <ul>
/// <li>
/// <p>For public and private DNS namespaces, one of the following combinations of DNS records in Amazon Route 53:</p>
/// <ul>
/// <li>
/// <p>
/// <code>A</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>AAAA</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>A</code> and <code>AAAA</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>SRV</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>CNAME</code>
/// </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Optionally, a health check</p>
/// </li>
/// </ul>
/// <p>After you create the service, you can submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request, and Cloud Map uses the
/// values in the configuration to create the specified entities.</p>
/// <p>For the current quota on the number of instances that you can register using the same namespace and using the
/// same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
/// quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateService {
    _private: (),
}
impl CreateService {
    /// Creates a new builder-style object to manufacture [`CreateServiceInput`](crate::input::CreateServiceInput)
    pub fn builder() -> crate::input::create_service_input::Builder {
        crate::input::create_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateService {
    type Output =
        std::result::Result<crate::output::CreateServiceOutput, crate::error::CreateServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_service_error(response)
        } else {
            crate::operation_deser::parse_create_service_response(response)
        }
    }
}

/// <p>Deletes a namespace from the current account. If the namespace still contains one or more services, the request
/// fails.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteNamespace {
    _private: (),
}
impl DeleteNamespace {
    /// Creates a new builder-style object to manufacture [`DeleteNamespaceInput`](crate::input::DeleteNamespaceInput)
    pub fn builder() -> crate::input::delete_namespace_input::Builder {
        crate::input::delete_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteNamespace {
    type Output = std::result::Result<
        crate::output::DeleteNamespaceOutput,
        crate::error::DeleteNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_namespace_error(response)
        } else {
            crate::operation_deser::parse_delete_namespace_response(response)
        }
    }
}

/// <p>Deletes a specified service. If the service still contains one or more registered instances, the request
/// fails.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteService {
    _private: (),
}
impl DeleteService {
    /// Creates a new builder-style object to manufacture [`DeleteServiceInput`](crate::input::DeleteServiceInput)
    pub fn builder() -> crate::input::delete_service_input::Builder {
        crate::input::delete_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteService {
    type Output =
        std::result::Result<crate::output::DeleteServiceOutput, crate::error::DeleteServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_service_error(response)
        } else {
            crate::operation_deser::parse_delete_service_response(response)
        }
    }
}

/// <p>Deletes the Amazon Route 53 DNS records and health check, if any, that Cloud Map created for the specified
/// instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterInstance {
    _private: (),
}
impl DeregisterInstance {
    /// Creates a new builder-style object to manufacture [`DeregisterInstanceInput`](crate::input::DeregisterInstanceInput)
    pub fn builder() -> crate::input::deregister_instance_input::Builder {
        crate::input::deregister_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterInstance {
    type Output = std::result::Result<
        crate::output::DeregisterInstanceOutput,
        crate::error::DeregisterInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deregister_instance_error(response)
        } else {
            crate::operation_deser::parse_deregister_instance_response(response)
        }
    }
}

/// <p>Discovers registered instances for a specified namespace and service. You can use <code>DiscoverInstances</code>
/// to discover instances for any type of namespace. For public and private DNS namespaces, you can also use DNS queries
/// to discover instances.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DiscoverInstances {
    _private: (),
}
impl DiscoverInstances {
    /// Creates a new builder-style object to manufacture [`DiscoverInstancesInput`](crate::input::DiscoverInstancesInput)
    pub fn builder() -> crate::input::discover_instances_input::Builder {
        crate::input::discover_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DiscoverInstances {
    type Output = std::result::Result<
        crate::output::DiscoverInstancesOutput,
        crate::error::DiscoverInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_discover_instances_error(response)
        } else {
            crate::operation_deser::parse_discover_instances_response(response)
        }
    }
}

/// <p>Gets information about a specified instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstance {
    _private: (),
}
impl GetInstance {
    /// Creates a new builder-style object to manufacture [`GetInstanceInput`](crate::input::GetInstanceInput)
    pub fn builder() -> crate::input::get_instance_input::Builder {
        crate::input::get_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstance {
    type Output =
        std::result::Result<crate::output::GetInstanceOutput, crate::error::GetInstanceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instance_error(response)
        } else {
            crate::operation_deser::parse_get_instance_response(response)
        }
    }
}

/// <p>Gets the current health status (<code>Healthy</code>, <code>Unhealthy</code>, or <code>Unknown</code>) of one or
/// more instances that are associated with a specified service.</p>
/// <note>
/// <p>There's a brief delay between when you register an instance and when the health status for the instance is
/// available. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInstancesHealthStatus {
    _private: (),
}
impl GetInstancesHealthStatus {
    /// Creates a new builder-style object to manufacture [`GetInstancesHealthStatusInput`](crate::input::GetInstancesHealthStatusInput)
    pub fn builder() -> crate::input::get_instances_health_status_input::Builder {
        crate::input::get_instances_health_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInstancesHealthStatus {
    type Output = std::result::Result<
        crate::output::GetInstancesHealthStatusOutput,
        crate::error::GetInstancesHealthStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_instances_health_status_error(response)
        } else {
            crate::operation_deser::parse_get_instances_health_status_response(response)
        }
    }
}

/// <p>Gets information about a namespace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetNamespace {
    _private: (),
}
impl GetNamespace {
    /// Creates a new builder-style object to manufacture [`GetNamespaceInput`](crate::input::GetNamespaceInput)
    pub fn builder() -> crate::input::get_namespace_input::Builder {
        crate::input::get_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetNamespace {
    type Output =
        std::result::Result<crate::output::GetNamespaceOutput, crate::error::GetNamespaceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_namespace_error(response)
        } else {
            crate::operation_deser::parse_get_namespace_response(response)
        }
    }
}

/// <p>Gets information about any operation that returns an operation ID in the response, such as a
/// <code>CreateService</code> request.</p>
/// <note>
/// <p>To get a list of operations that match specified criteria, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html">ListOperations</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOperation {
    _private: (),
}
impl GetOperation {
    /// Creates a new builder-style object to manufacture [`GetOperationInput`](crate::input::GetOperationInput)
    pub fn builder() -> crate::input::get_operation_input::Builder {
        crate::input::get_operation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOperation {
    type Output =
        std::result::Result<crate::output::GetOperationOutput, crate::error::GetOperationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_operation_error(response)
        } else {
            crate::operation_deser::parse_get_operation_response(response)
        }
    }
}

/// <p>Gets the settings for a specified service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetService {
    _private: (),
}
impl GetService {
    /// Creates a new builder-style object to manufacture [`GetServiceInput`](crate::input::GetServiceInput)
    pub fn builder() -> crate::input::get_service_input::Builder {
        crate::input::get_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetService {
    type Output =
        std::result::Result<crate::output::GetServiceOutput, crate::error::GetServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_service_error(response)
        } else {
            crate::operation_deser::parse_get_service_response(response)
        }
    }
}

/// <p>Lists summary information about the instances that you registered by using a specified service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListInstances {
    _private: (),
}
impl ListInstances {
    /// Creates a new builder-style object to manufacture [`ListInstancesInput`](crate::input::ListInstancesInput)
    pub fn builder() -> crate::input::list_instances_input::Builder {
        crate::input::list_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListInstances {
    type Output =
        std::result::Result<crate::output::ListInstancesOutput, crate::error::ListInstancesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_instances_error(response)
        } else {
            crate::operation_deser::parse_list_instances_response(response)
        }
    }
}

/// <p>Lists summary information about the namespaces that were created by the current account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListNamespaces {
    _private: (),
}
impl ListNamespaces {
    /// Creates a new builder-style object to manufacture [`ListNamespacesInput`](crate::input::ListNamespacesInput)
    pub fn builder() -> crate::input::list_namespaces_input::Builder {
        crate::input::list_namespaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListNamespaces {
    type Output =
        std::result::Result<crate::output::ListNamespacesOutput, crate::error::ListNamespacesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_namespaces_error(response)
        } else {
            crate::operation_deser::parse_list_namespaces_response(response)
        }
    }
}

/// <p>Lists operations that match the criteria that you specify.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListOperations {
    _private: (),
}
impl ListOperations {
    /// Creates a new builder-style object to manufacture [`ListOperationsInput`](crate::input::ListOperationsInput)
    pub fn builder() -> crate::input::list_operations_input::Builder {
        crate::input::list_operations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListOperations {
    type Output =
        std::result::Result<crate::output::ListOperationsOutput, crate::error::ListOperationsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_operations_error(response)
        } else {
            crate::operation_deser::parse_list_operations_response(response)
        }
    }
}

/// <p>Lists summary information for all the services that are associated with one or more specified namespaces.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListServices {
    _private: (),
}
impl ListServices {
    /// Creates a new builder-style object to manufacture [`ListServicesInput`](crate::input::ListServicesInput)
    pub fn builder() -> crate::input::list_services_input::Builder {
        crate::input::list_services_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListServices {
    type Output =
        std::result::Result<crate::output::ListServicesOutput, crate::error::ListServicesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_services_error(response)
        } else {
            crate::operation_deser::parse_list_services_response(response)
        }
    }
}

/// <p>Lists tags for the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Creates or updates one or more records and, optionally, creates a health check based on the settings in a
/// specified service. When you submit a <code>RegisterInstance</code> request, the following occurs:</p>
/// <ul>
/// <li>
/// <p>For each DNS record that you define in the service that's specified by <code>ServiceId</code>, a record is
/// created or updated in the hosted zone that's associated with the corresponding namespace.</p>
/// </li>
/// <li>
/// <p>If the service includes <code>HealthCheckConfig</code>, a health check is created based on the settings in the
/// health check configuration.</p>
/// </li>
/// <li>
/// <p>The health check, if any, is associated with each of the new or updated records.</p>
/// </li>
/// </ul>
/// <important>
/// <p>One <code>RegisterInstance</code> request must complete before you can submit another request and specify the
/// same service ID and instance ID.</p>
/// </important>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html">CreateService</a>.</p>
/// <p>When Cloud Map receives a DNS query for the specified DNS name, it returns the applicable value:</p>
/// <ul>
/// <li>
/// <p>
/// <b>If the health check is healthy</b>: returns all the records</p>
/// </li>
/// <li>
/// <p>
/// <b>If the health check is unhealthy</b>: returns the applicable value for the last
/// healthy instance</p>
/// </li>
/// <li>
/// <p>
/// <b>If you didn't specify a health check configuration</b>: returns all the
/// records</p>
/// </li>
/// </ul>
/// <p>For the current quota on the number of instances that you can register using the same namespace and using the
/// same service, see <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/cloud-map-limits.html">Cloud Map
/// quotas</a> in the <i>Cloud Map Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterInstance {
    _private: (),
}
impl RegisterInstance {
    /// Creates a new builder-style object to manufacture [`RegisterInstanceInput`](crate::input::RegisterInstanceInput)
    pub fn builder() -> crate::input::register_instance_input::Builder {
        crate::input::register_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterInstance {
    type Output = std::result::Result<
        crate::output::RegisterInstanceOutput,
        crate::error::RegisterInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_instance_error(response)
        } else {
            crate::operation_deser::parse_register_instance_response(response)
        }
    }
}

/// <p>Adds one or more tags to the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from the specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates an HTTP
/// namespace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateHttpNamespace {
    _private: (),
}
impl UpdateHttpNamespace {
    /// Creates a new builder-style object to manufacture [`UpdateHttpNamespaceInput`](crate::input::UpdateHttpNamespaceInput)
    pub fn builder() -> crate::input::update_http_namespace_input::Builder {
        crate::input::update_http_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateHttpNamespace {
    type Output = std::result::Result<
        crate::output::UpdateHttpNamespaceOutput,
        crate::error::UpdateHttpNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_http_namespace_error(response)
        } else {
            crate::operation_deser::parse_update_http_namespace_response(response)
        }
    }
}

/// <p>Submits a request to change the health status of a custom health check to healthy or unhealthy.</p>
/// <p>You can use <code>UpdateInstanceCustomHealthStatus</code> to change the status only for custom health checks,
/// which you define using <code>HealthCheckCustomConfig</code> when you create a service. You can't use it to change the
/// status for Route 53 health checks, which you define using <code>HealthCheckConfig</code>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html">HealthCheckCustomConfig</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateInstanceCustomHealthStatus {
    _private: (),
}
impl UpdateInstanceCustomHealthStatus {
    /// Creates a new builder-style object to manufacture [`UpdateInstanceCustomHealthStatusInput`](crate::input::UpdateInstanceCustomHealthStatusInput)
    pub fn builder() -> crate::input::update_instance_custom_health_status_input::Builder {
        crate::input::update_instance_custom_health_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateInstanceCustomHealthStatus {
    type Output = std::result::Result<
        crate::output::UpdateInstanceCustomHealthStatusOutput,
        crate::error::UpdateInstanceCustomHealthStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_instance_custom_health_status_error(response)
        } else {
            crate::operation_deser::parse_update_instance_custom_health_status_response(response)
        }
    }
}

/// <p>Updates a private DNS
/// namespace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePrivateDnsNamespace {
    _private: (),
}
impl UpdatePrivateDnsNamespace {
    /// Creates a new builder-style object to manufacture [`UpdatePrivateDnsNamespaceInput`](crate::input::UpdatePrivateDnsNamespaceInput)
    pub fn builder() -> crate::input::update_private_dns_namespace_input::Builder {
        crate::input::update_private_dns_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePrivateDnsNamespace {
    type Output = std::result::Result<
        crate::output::UpdatePrivateDnsNamespaceOutput,
        crate::error::UpdatePrivateDnsNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_private_dns_namespace_error(response)
        } else {
            crate::operation_deser::parse_update_private_dns_namespace_response(response)
        }
    }
}

/// <p>Updates a public DNS
/// namespace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePublicDnsNamespace {
    _private: (),
}
impl UpdatePublicDnsNamespace {
    /// Creates a new builder-style object to manufacture [`UpdatePublicDnsNamespaceInput`](crate::input::UpdatePublicDnsNamespaceInput)
    pub fn builder() -> crate::input::update_public_dns_namespace_input::Builder {
        crate::input::update_public_dns_namespace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePublicDnsNamespace {
    type Output = std::result::Result<
        crate::output::UpdatePublicDnsNamespaceOutput,
        crate::error::UpdatePublicDnsNamespaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_public_dns_namespace_error(response)
        } else {
            crate::operation_deser::parse_update_public_dns_namespace_response(response)
        }
    }
}

/// <p>Submits a request to perform the following operations:</p>
/// <ul>
/// <li>
/// <p>Update the TTL setting for existing <code>DnsRecords</code> configurations</p>
/// </li>
/// <li>
/// <p>Add, update, or delete <code>HealthCheckConfig</code> for a specified service</p>
/// <note>
/// <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration.</p>
/// </note>
/// </li>
/// </ul>
/// <p>For public and private DNS namespaces, note the following:</p>
/// <ul>
/// <li>
/// <p>If you omit any existing <code>DnsRecords</code> or <code>HealthCheckConfig</code> configurations from an
/// <code>UpdateService</code> request, the configurations are deleted from the service.</p>
/// </li>
/// <li>
/// <p>If you omit an existing <code>HealthCheckCustomConfig</code> configuration from an <code>UpdateService</code>
/// request, the configuration isn't deleted from the service.</p>
/// </li>
/// </ul>
/// <p>When you update settings for a service, Cloud Map also updates the corresponding settings in all the records
/// and health checks that were created by using the specified service.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateService {
    _private: (),
}
impl UpdateService {
    /// Creates a new builder-style object to manufacture [`UpdateServiceInput`](crate::input::UpdateServiceInput)
    pub fn builder() -> crate::input::update_service_input::Builder {
        crate::input::update_service_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateService {
    type Output =
        std::result::Result<crate::output::UpdateServiceOutput, crate::error::UpdateServiceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_service_error(response)
        } else {
            crate::operation_deser::parse_update_service_response(response)
        }
    }
}
