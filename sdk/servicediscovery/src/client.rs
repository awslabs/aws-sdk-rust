// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `Route53AutoNaming_v20170314`.
///
/// This client allows ergonomic access to a `Route53AutoNaming_v20170314`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn create_http_namespace(&self) -> fluent_builders::CreateHttpNamespace<C, M, R> {
        fluent_builders::CreateHttpNamespace::new(self.handle.clone())
    }
    pub fn create_private_dns_namespace(
        &self,
    ) -> fluent_builders::CreatePrivateDnsNamespace<C, M, R> {
        fluent_builders::CreatePrivateDnsNamespace::new(self.handle.clone())
    }
    pub fn create_public_dns_namespace(
        &self,
    ) -> fluent_builders::CreatePublicDnsNamespace<C, M, R> {
        fluent_builders::CreatePublicDnsNamespace::new(self.handle.clone())
    }
    pub fn create_service(&self) -> fluent_builders::CreateService<C, M, R> {
        fluent_builders::CreateService::new(self.handle.clone())
    }
    pub fn delete_namespace(&self) -> fluent_builders::DeleteNamespace<C, M, R> {
        fluent_builders::DeleteNamespace::new(self.handle.clone())
    }
    pub fn delete_service(&self) -> fluent_builders::DeleteService<C, M, R> {
        fluent_builders::DeleteService::new(self.handle.clone())
    }
    pub fn deregister_instance(&self) -> fluent_builders::DeregisterInstance<C, M, R> {
        fluent_builders::DeregisterInstance::new(self.handle.clone())
    }
    pub fn discover_instances(&self) -> fluent_builders::DiscoverInstances<C, M, R> {
        fluent_builders::DiscoverInstances::new(self.handle.clone())
    }
    pub fn get_instance(&self) -> fluent_builders::GetInstance<C, M, R> {
        fluent_builders::GetInstance::new(self.handle.clone())
    }
    pub fn get_instances_health_status(
        &self,
    ) -> fluent_builders::GetInstancesHealthStatus<C, M, R> {
        fluent_builders::GetInstancesHealthStatus::new(self.handle.clone())
    }
    pub fn get_namespace(&self) -> fluent_builders::GetNamespace<C, M, R> {
        fluent_builders::GetNamespace::new(self.handle.clone())
    }
    pub fn get_operation(&self) -> fluent_builders::GetOperation<C, M, R> {
        fluent_builders::GetOperation::new(self.handle.clone())
    }
    pub fn get_service(&self) -> fluent_builders::GetService<C, M, R> {
        fluent_builders::GetService::new(self.handle.clone())
    }
    pub fn list_instances(&self) -> fluent_builders::ListInstances<C, M, R> {
        fluent_builders::ListInstances::new(self.handle.clone())
    }
    pub fn list_namespaces(&self) -> fluent_builders::ListNamespaces<C, M, R> {
        fluent_builders::ListNamespaces::new(self.handle.clone())
    }
    pub fn list_operations(&self) -> fluent_builders::ListOperations<C, M, R> {
        fluent_builders::ListOperations::new(self.handle.clone())
    }
    pub fn list_services(&self) -> fluent_builders::ListServices<C, M, R> {
        fluent_builders::ListServices::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn register_instance(&self) -> fluent_builders::RegisterInstance<C, M, R> {
        fluent_builders::RegisterInstance::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_http_namespace(&self) -> fluent_builders::UpdateHttpNamespace<C, M, R> {
        fluent_builders::UpdateHttpNamespace::new(self.handle.clone())
    }
    pub fn update_instance_custom_health_status(
        &self,
    ) -> fluent_builders::UpdateInstanceCustomHealthStatus<C, M, R> {
        fluent_builders::UpdateInstanceCustomHealthStatus::new(self.handle.clone())
    }
    pub fn update_private_dns_namespace(
        &self,
    ) -> fluent_builders::UpdatePrivateDnsNamespace<C, M, R> {
        fluent_builders::UpdatePrivateDnsNamespace::new(self.handle.clone())
    }
    pub fn update_public_dns_namespace(
        &self,
    ) -> fluent_builders::UpdatePublicDnsNamespace<C, M, R> {
        fluent_builders::UpdatePublicDnsNamespace::new(self.handle.clone())
    }
    pub fn update_service(&self) -> fluent_builders::UpdateService<C, M, R> {
        fluent_builders::UpdateService::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateHttpNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_http_namespace_input::Builder,
    }
    impl<C, M, R> CreateHttpNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateHttpNamespaceOutput,
            smithy_http::result::SdkError<crate::error::CreateHttpNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateHttpNamespaceInputOperationOutputAlias,
                crate::output::CreateHttpNamespaceOutput,
                crate::error::CreateHttpNamespaceError,
                crate::input::CreateHttpNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name that you want to assign to this namespace.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreateHttpNamespace</code> requests to
        /// be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string
        /// (for example, a date/time stamp).</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A description for the namespace.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
        /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
        /// characters in length.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePrivateDnsNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_private_dns_namespace_input::Builder,
    }
    impl<C, M, R> CreatePrivateDnsNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePrivateDnsNamespaceOutput,
            smithy_http::result::SdkError<crate::error::CreatePrivateDnsNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreatePrivateDnsNamespaceInputOperationOutputAlias,
                crate::output::CreatePrivateDnsNamespaceOutput,
                crate::error::CreatePrivateDnsNamespaceError,
                crate::input::CreatePrivateDnsNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map
        /// automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreatePrivateDnsNamespace</code>
        /// requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
        /// unique string (for example, a date/timestamp).</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A description for the namespace.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID of the Amazon VPC that you want to associate the namespace with.</p>
        pub fn vpc(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc(inp);
            self
        }
        pub fn set_vpc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
        /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
        /// characters in length.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Properties for the private DNS
        /// namespace.</p>
        pub fn properties(mut self, inp: crate::model::PrivateDnsNamespaceProperties) -> Self {
            self.inner = self.inner.properties(inp);
            self
        }
        pub fn set_properties(
            mut self,
            input: std::option::Option<crate::model::PrivateDnsNamespaceProperties>,
        ) -> Self {
            self.inner = self.inner.set_properties(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePublicDnsNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_public_dns_namespace_input::Builder,
    }
    impl<C, M, R> CreatePublicDnsNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePublicDnsNamespaceOutput,
            smithy_http::result::SdkError<crate::error::CreatePublicDnsNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreatePublicDnsNamespaceInputOperationOutputAlias,
                crate::output::CreatePublicDnsNamespaceOutput,
                crate::error::CreatePublicDnsNamespaceError,
                crate::input::CreatePublicDnsNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name that you want to assign to this namespace.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreatePublicDnsNamespace</code>
        /// requests to be retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any
        /// unique string (for example, a date/timestamp).</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A description for the namespace.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to add to the namespace. Each tag consists of a key and an optional value that you define.
        /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
        /// characters in length.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Properties for the public DNS
        /// namespace.</p>
        pub fn properties(mut self, inp: crate::model::PublicDnsNamespaceProperties) -> Self {
            self.inner = self.inner.properties(inp);
            self
        }
        pub fn set_properties(
            mut self,
            input: std::option::Option<crate::model::PublicDnsNamespaceProperties>,
        ) -> Self {
            self.inner = self.inner.set_properties(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateService<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_service_input::Builder,
    }
    impl<C, M, R> CreateService<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateServiceOutput,
            smithy_http::result::SdkError<crate::error::CreateServiceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateServiceInputOperationOutputAlias,
                crate::output::CreateServiceOutput,
                crate::error::CreateServiceError,
                crate::input::CreateServiceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name that you want to assign to the service.</p>
        /// <p>If you want Cloud Map to create an <code>SRV</code> record when you register an instance and you're using a
        /// system that requires a specific <code>SRV</code> format, such as <a href="http://www.haproxy.org/">HAProxy</a>, specify the following for <code>Name</code>:</p>
        /// <ul>
        /// <li>
        /// <p>Start the name with an underscore (_), such as <code>_exampleservice</code>.</p>
        /// </li>
        /// <li>
        /// <p>End the name with <i>._protocol</i>, such as <code>._tcp</code>.</p>
        /// </li>
        /// </ul>
        /// <p>When you register an instance, Cloud Map creates an <code>SRV</code> record and assigns a name to the record by
        /// concatenating the service name and the namespace name (for example,</p>
        /// <p>
        /// <code>_exampleservice._tcp.example.com</code>).</p>
        /// <note>
        /// <p>For services that are accessible by DNS queries, you can't create multiple services with names that differ only
        /// by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished.
        /// However, if you use a namespace that's only accessible by API calls, then you can create services that with names
        /// that differ only by case.</p>
        /// </note>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it
        /// can be specified either here or in the <code>DnsConfig</code> object.</p>
        pub fn namespace_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_id(inp);
            self
        }
        pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace_id(input);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>CreateService</code> requests to be
        /// retried without the risk of running the operation twice. <code>CreatorRequestId</code> can be any unique string (for
        /// example, a date/timestamp).</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// <p>A description for the service.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you
        /// register an instance. </p>
        pub fn dns_config(mut self, inp: crate::model::DnsConfig) -> Self {
            self.inner = self.inner.dns_config(inp);
            self
        }
        pub fn set_dns_config(
            mut self,
            input: std::option::Option<crate::model::DnsConfig>,
        ) -> Self {
            self.inner = self.inner.set_dns_config(input);
            self
        }
        /// <p>
        /// <i>Public DNS and HTTP namespaces only.</i> A complex type that contains settings for an optional
        /// Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the
        /// Route 53 DNS records that you specify in <code>DnsConfig</code>.</p>
        /// <important>
        /// <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        /// <code>HealthCheckConfig</code> but not both.</p>
        /// </important>
        /// <p>For information about the charges for health checks, see <a href="http://aws.amazon.com/cloud-map/pricing/">Cloud Map Pricing</a>.</p>
        pub fn health_check_config(mut self, inp: crate::model::HealthCheckConfig) -> Self {
            self.inner = self.inner.health_check_config(inp);
            self
        }
        pub fn set_health_check_config(
            mut self,
            input: std::option::Option<crate::model::HealthCheckConfig>,
        ) -> Self {
            self.inner = self.inner.set_health_check_config(input);
            self
        }
        /// <p>A complex type that contains information about an optional custom health check.</p>
        /// <important>
        /// <p>If you specify a health check configuration, you can specify either <code>HealthCheckCustomConfig</code> or
        /// <code>HealthCheckConfig</code> but not both.</p>
        /// </important>
        /// <p>You can't add, update, or delete a <code>HealthCheckCustomConfig</code> configuration from an existing
        /// service.</p>
        pub fn health_check_custom_config(
            mut self,
            inp: crate::model::HealthCheckCustomConfig,
        ) -> Self {
            self.inner = self.inner.health_check_custom_config(inp);
            self
        }
        pub fn set_health_check_custom_config(
            mut self,
            input: std::option::Option<crate::model::HealthCheckCustomConfig>,
        ) -> Self {
            self.inner = self.inner.set_health_check_custom_config(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to add to the service. Each tag consists of a key and an optional value that you define.
        /// Tags keys can be up to 128 characters in length, and tag values can be up to 256
        /// characters in length.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>If present, specifies that the service instances are only discoverable using the <code>DiscoverInstances</code>
        /// API operation. No DNS records is registered for the service instances. The only valid value is
        /// <code>HTTP</code>.</p>
        pub fn r#type(mut self, inp: crate::model::ServiceTypeOption) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ServiceTypeOption>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_namespace_input::Builder,
    }
    impl<C, M, R> DeleteNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNamespaceOutput,
            smithy_http::result::SdkError<crate::error::DeleteNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteNamespaceInputOperationOutputAlias,
                crate::output::DeleteNamespaceOutput,
                crate::error::DeleteNamespaceError,
                crate::input::DeleteNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the namespace that you want to delete.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteService<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_service_input::Builder,
    }
    impl<C, M, R> DeleteService<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteServiceOutput,
            smithy_http::result::SdkError<crate::error::DeleteServiceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteServiceInputOperationOutputAlias,
                crate::output::DeleteServiceOutput,
                crate::error::DeleteServiceError,
                crate::input::DeleteServiceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that you want to delete.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterInstance<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deregister_instance_input::Builder,
    }
    impl<C, M, R> DeregisterInstance<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeregisterInstanceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeregisterInstanceInputOperationOutputAlias,
                crate::output::DeregisterInstanceOutput,
                crate::error::DeregisterInstanceError,
                crate::input::DeregisterInstanceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that the instance is associated with.</p>
        pub fn service_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(inp);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The value that you specified for <code>Id</code> in the <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html">RegisterInstance</a> request.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DiscoverInstances<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::discover_instances_input::Builder,
    }
    impl<C, M, R> DiscoverInstances<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DiscoverInstancesOutput,
            smithy_http::result::SdkError<crate::error::DiscoverInstancesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DiscoverInstancesInputOperationOutputAlias,
                crate::output::DiscoverInstancesOutput,
                crate::error::DiscoverInstancesError,
                crate::input::DiscoverInstancesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>HttpName</code> name of the namespace. It's found in the <code>HttpProperties</code> member of the
        /// <code>Properties</code> member of the namespace.</p>
        pub fn namespace_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace_name(inp);
            self
        }
        pub fn set_namespace_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_namespace_name(input);
            self
        }
        /// <p>The name of the service that you specified when you registered the instance.</p>
        pub fn service_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(inp);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
        /// <code>DiscoverInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
        /// to 100 instances.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// Adds a key-value pair to `QueryParameters`.
        ///
        /// To override the contents of this collection use [`set_query_parameters`](Self::set_query_parameters).
        /// <p>Filters to scope the results based on custom attributes for the instance (for example, <code>{version=v1,
        /// az=1a}</code>). Only instances that match all the specified key-value pairs are returned.</p>
        pub fn query_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.query_parameters(k, v);
            self
        }
        pub fn set_query_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_query_parameters(input);
            self
        }
        /// Adds a key-value pair to `OptionalParameters`.
        ///
        /// To override the contents of this collection use [`set_optional_parameters`](Self::set_optional_parameters).
        /// <p>Opportunistic filters to scope the results based on custom attributes. If there are instances that match both
        /// the filters specified in both the <code>QueryParameters</code> parameter and this parameter, all of these instances
        /// are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the
        /// <code>QueryParameters</code> parameter are returned.</p>
        pub fn optional_parameters(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.optional_parameters(k, v);
            self
        }
        pub fn set_optional_parameters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_optional_parameters(input);
            self
        }
        /// <p>The health status of the instances that you want to discover. This parameter is ignored for services that don't
        /// have a health check configured, and
        /// all
        /// instances are returned.</p>
        /// <dl>
        /// <dt>HEALTHY</dt>
        /// <dd>
        /// <p>Returns healthy instances.</p>
        /// </dd>
        /// <dt>UNHEALTHY</dt>
        /// <dd>
        /// <p>Returns unhealthy instances.</p>
        /// </dd>
        /// <dt>ALL</dt>
        /// <dd>
        /// <p>Returns all instances.</p>
        /// </dd>
        /// <dt>HEALTHY_OR_ELSE_ALL</dt>
        /// <dd>
        /// <p>Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances.
        /// This is also called failing open.</p>
        /// </dd>
        /// </dl>
        pub fn health_status(mut self, inp: crate::model::HealthStatusFilter) -> Self {
            self.inner = self.inner.health_status(inp);
            self
        }
        pub fn set_health_status(
            mut self,
            input: std::option::Option<crate::model::HealthStatusFilter>,
        ) -> Self {
            self.inner = self.inner.set_health_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstance<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_instance_input::Builder,
    }
    impl<C, M, R> GetInstance<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetInstanceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetInstanceInputOperationOutputAlias,
                crate::output::GetInstanceOutput,
                crate::error::GetInstanceError,
                crate::input::GetInstanceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that the instance is associated with.</p>
        pub fn service_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(inp);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The ID of the instance that you want to get information about.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInstancesHealthStatus<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_instances_health_status_input::Builder,
    }
    impl<C, M, R> GetInstancesHealthStatus<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInstancesHealthStatusOutput,
            smithy_http::result::SdkError<crate::error::GetInstancesHealthStatusError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetInstancesHealthStatusInputOperationOutputAlias,
                crate::output::GetInstancesHealthStatusOutput,
                crate::error::GetInstancesHealthStatusError,
                crate::input::GetInstancesHealthStatusInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that the instance is associated with.</p>
        pub fn service_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(inp);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// Appends an item to `Instances`.
        ///
        /// To override the contents of this collection use [`set_instances`](Self::set_instances).
        /// <p>An array that contains the IDs of all the instances that you want to get the health status for.</p>
        /// <p>If you omit <code>Instances</code>, Cloud Map returns the health status for all the instances that are
        /// associated with the specified service.</p>
        /// <note>
        /// <p>To get the IDs for the instances that you've registered by using a specified service, submit a <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html">ListInstances</a> request.</p>
        /// </note>
        pub fn instances(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instances(inp);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instances(input);
            self
        }
        /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
        /// <code>GetInstancesHealthStatus</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map
        /// returns up to 100 instances.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>For the first <code>GetInstancesHealthStatus</code> request, omit this value.</p>
        /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
        /// <code>GetInstancesHealthStatus</code> request to get the next group of results. Specify the value of
        /// <code>NextToken</code> from the previous response in the next request.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_namespace_input::Builder,
    }
    impl<C, M, R> GetNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetNamespaceOutput,
            smithy_http::result::SdkError<crate::error::GetNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetNamespaceInputOperationOutputAlias,
                crate::output::GetNamespaceOutput,
                crate::error::GetNamespaceError,
                crate::input::GetNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the namespace that you want to get information about.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOperation<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_operation_input::Builder,
    }
    impl<C, M, R> GetOperation<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOperationOutput,
            smithy_http::result::SdkError<crate::error::GetOperationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetOperationInputOperationOutputAlias,
                crate::output::GetOperationOutput,
                crate::error::GetOperationError,
                crate::input::GetOperationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the operation that you want to get more information about.</p>
        pub fn operation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.operation_id(inp);
            self
        }
        pub fn set_operation_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_operation_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetService<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_service_input::Builder,
    }
    impl<C, M, R> GetService<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetServiceOutput,
            smithy_http::result::SdkError<crate::error::GetServiceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetServiceInputOperationOutputAlias,
                crate::output::GetServiceOutput,
                crate::error::GetServiceError,
                crate::input::GetServiceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that you want to get settings for.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListInstances<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_instances_input::Builder,
    }
    impl<C, M, R> ListInstances<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListInstancesOutput,
            smithy_http::result::SdkError<crate::error::ListInstancesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListInstancesInputOperationOutputAlias,
                crate::output::ListInstancesOutput,
                crate::error::ListInstancesError,
                crate::input::ListInstancesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that you want to list instances for.</p>
        pub fn service_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(inp);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>For the first <code>ListInstances</code> request, omit this value.</p>
        /// <p>If more than <code>MaxResults</code> instances match the specified criteria, you can submit another
        /// <code>ListInstances</code> request to get the next group of results. Specify the value of <code>NextToken</code>
        /// from the previous response in the next request.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of instances that you want Cloud Map to return in the response to a
        /// <code>ListInstances</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
        /// to 100 instances.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListNamespaces<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_namespaces_input::Builder,
    }
    impl<C, M, R> ListNamespaces<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListNamespacesOutput,
            smithy_http::result::SdkError<crate::error::ListNamespacesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListNamespacesInputOperationOutputAlias,
                crate::output::ListNamespacesOutput,
                crate::error::ListNamespacesError,
                crate::input::ListNamespacesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For the first <code>ListNamespaces</code> request, omit this value.</p>
        /// <p>If the response contains <code>NextToken</code>, submit another <code>ListNamespaces</code> request to get the
        /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
        /// request.</p>
        /// <note>
        /// <p>Cloud Map gets <code>MaxResults</code> namespaces and then filters them based on the specified criteria. It's
        /// possible that no namespaces in the first <code>MaxResults</code> namespaces matched the specified criteria but that
        /// subsequent groups of <code>MaxResults</code> namespaces do contain namespaces that match the criteria.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of namespaces that you want Cloud Map to return in the response to a
        /// <code>ListNamespaces</code> request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up
        /// to 100 namespaces.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// Appends an item to `Filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        /// <p>A complex type that contains specifications for the namespaces that you want to list.</p>
        /// <p>If you specify more than one filter, a namespace must match all filters to be returned by
        /// <code>ListNamespaces</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::NamespaceFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NamespaceFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOperations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_operations_input::Builder,
    }
    impl<C, M, R> ListOperations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOperationsOutput,
            smithy_http::result::SdkError<crate::error::ListOperationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListOperationsInputOperationOutputAlias,
                crate::output::ListOperationsOutput,
                crate::error::ListOperationsError,
                crate::input::ListOperationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For the first <code>ListOperations</code> request, omit this value.</p>
        /// <p>If the response contains <code>NextToken</code>, submit another <code>ListOperations</code> request to get the
        /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
        /// request.</p>
        /// <note>
        /// <p>Cloud Map gets <code>MaxResults</code> operations and then filters them based on the specified criteria. It's
        /// possible that no operations in the first <code>MaxResults</code> operations matched the specified criteria but that
        /// subsequent groups of <code>MaxResults</code> operations do contain operations that match the criteria.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items that you want Cloud Map to return in the response to a <code>ListOperations</code>
        /// request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 operations.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// Appends an item to `Filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        /// <p>A complex type that contains specifications for the operations that you want to list, for example, operations
        /// that you started between a specified start date and end date.</p>
        /// <p>If you specify more than one filter, an operation must match all filters to be returned by
        /// <code>ListOperations</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::OperationFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OperationFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServices<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_services_input::Builder,
    }
    impl<C, M, R> ListServices<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListServicesOutput,
            smithy_http::result::SdkError<crate::error::ListServicesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListServicesInputOperationOutputAlias,
                crate::output::ListServicesOutput,
                crate::error::ListServicesError,
                crate::input::ListServicesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For the first <code>ListServices</code> request, omit this value.</p>
        /// <p>If the response contains <code>NextToken</code>, submit another <code>ListServices</code> request to get the
        /// next group of results. Specify the value of <code>NextToken</code> from the previous response in the next
        /// request.</p>
        /// <note>
        /// <p>Cloud Map gets <code>MaxResults</code> services and then filters them based on the specified criteria. It's
        /// possible that no services in the first <code>MaxResults</code> services matched the specified criteria but that
        /// subsequent groups of <code>MaxResults</code> services do contain services that match the criteria.</p>
        /// </note>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of services that you want Cloud Map to return in the response to a <code>ListServices</code>
        /// request. If you don't specify a value for <code>MaxResults</code>, Cloud Map returns up to 100 services.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// Appends an item to `Filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        /// <p>A complex type that contains specifications for the namespaces that you want to list services for. </p>
        /// <p>If you specify more than one filter, an operation must match all filters to be returned by
        /// <code>ListServices</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::ServiceFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ServiceFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterInstance<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_instance_input::Builder,
    }
    impl<C, M, R> RegisterInstance<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterInstanceOutput,
            smithy_http::result::SdkError<crate::error::RegisterInstanceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterInstanceInputOperationOutputAlias,
                crate::output::RegisterInstanceOutput,
                crate::error::RegisterInstanceError,
                crate::input::RegisterInstanceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that you want to use for settings for the instance.</p>
        pub fn service_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(inp);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>An identifier that you want to associate with the instance. Note the following:</p>
        /// <ul>
        /// <li>
        /// <p>If the service that's specified by <code>ServiceId</code> includes settings for an <code>SRV</code> record,
        /// the value of <code>InstanceId</code> is automatically included as part of the value for the <code>SRV</code>
        /// record. For more information, see <a href="https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type">DnsRecord > Type</a>.</p>
        /// </li>
        /// <li>
        /// <p>You can use this value to update an existing instance.</p>
        /// </li>
        /// <li>
        /// <p>To register a new instance, you must specify a value that's unique among instances that you register by using
        /// the same service. </p>
        /// </li>
        /// <li>
        /// <p>If you specify an existing <code>InstanceId</code> and <code>ServiceId</code>, Cloud Map updates the existing
        /// DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates
        /// a new one. </p>
        /// <note>
        /// <p>The health check isn't deleted immediately, so it will still appear for a while if you submit a
        /// <code>ListHealthChecks</code> request, for example.</p>
        /// </note>
        /// </li>
        /// </ul>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>A unique string that identifies the request and that allows failed <code>RegisterInstance</code> requests to be
        /// retried without the risk of executing the operation twice. You must use a unique <code>CreatorRequestId</code> string
        /// every time you submit a <code>RegisterInstance</code> request if you're registering additional instances for the same
        /// namespace and service. <code>CreatorRequestId</code> can be any unique string (for example, a date/time
        /// stamp).</p>
        pub fn creator_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creator_request_id(inp);
            self
        }
        pub fn set_creator_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creator_request_id(input);
            self
        }
        /// Adds a key-value pair to `Attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        /// <p>A string map that contains the following information for the service that you specify in
        /// <code>ServiceId</code>:</p>
        /// <ul>
        /// <li>
        /// <p>The attributes that apply to the records that are defined in the service. </p>
        /// </li>
        /// <li>
        /// <p>For each attribute, the applicable value.</p>
        /// </li>
        /// </ul>
        /// <p>Supported attribute keys include the following:</p>
        /// <dl>
        /// <dt>AWS_ALIAS_DNS_NAME</dt>
        /// <dd>
        /// <p>If you want Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer,
        /// specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see
        /// "DNSName" in the topic <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html">AliasTarget</a> in the <i>Route 53 API Reference</i>.</p>
        /// <p>Note the following:</p>
        /// <ul>
        /// <li>
        /// <p>The configuration for the service that's specified by <code>ServiceId</code> must include settings for an
        /// <code>A</code> record, an <code>AAAA</code> record, or both.</p>
        /// </li>
        /// <li>
        /// <p>In the service that's specified by <code>ServiceId</code>, the value of <code>RoutingPolicy</code> must be
        /// <code>WEIGHTED</code>.</p>
        /// </li>
        /// <li>
        /// <p>If the service that's specified by <code>ServiceId</code> includes <code>HealthCheckConfig</code> settings,
        /// Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias
        /// record.</p>
        /// </li>
        /// <li>
        /// <p>Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services
        /// resources other than Elastic Load Balancing load balancers.</p>
        /// </li>
        /// <li>
        /// <p>If you specify a value for <code>AWS_ALIAS_DNS_NAME</code>, don't specify values for any of the
        /// <code>AWS_INSTANCE</code> attributes.</p>
        /// </li>
        /// </ul>
        /// </dd>
        /// <dt>AWS_EC2_INSTANCE_ID</dt>
        /// <dd>
        /// <p>
        /// <i>HTTP namespaces only.</i> The Amazon EC2 instance ID for the instance. If the
        /// <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the only other attribute that can be specified is
        /// <code>AWS_INIT_HEALTH_STATUS</code>. When the <code>AWS_EC2_INSTANCE_ID</code> attribute is specified, then the
        /// <code>AWS_INSTANCE_IPV4</code> attribute will be filled out with the primary private IPv4 address.</p>
        /// </dd>
        /// <dt>AWS_INIT_HEALTH_STATUS</dt>
        /// <dd>
        /// <p>If the service configuration includes <code>HealthCheckCustomConfig</code>, you can optionally use
        /// <code>AWS_INIT_HEALTH_STATUS</code> to specify the initial status of the custom health check,
        /// <code>HEALTHY</code> or <code>UNHEALTHY</code>. If you don't specify a value for
        /// <code>AWS_INIT_HEALTH_STATUS</code>, the initial status is <code>HEALTHY</code>.</p>
        /// </dd>
        /// <dt>AWS_INSTANCE_CNAME</dt>
        /// <dd>
        /// <p>If the service configuration includes a <code>CNAME</code> record, the domain name that you want Route 53 to
        /// return in response to DNS queries (for example, <code>example.com</code>).</p>
        /// <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
        /// <code>CNAME</code> record.</p>
        /// </dd>
        /// <dt>AWS_INSTANCE_IPV4</dt>
        /// <dd>
        /// <p>If the service configuration includes an <code>A</code> record, the IPv4 address that you want Route 53 to
        /// return in response to DNS queries (for example, <code>192.0.2.44</code>).</p>
        /// <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
        /// <code>A</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a value
        /// for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
        /// </dd>
        /// <dt>AWS_INSTANCE_IPV6</dt>
        /// <dd>
        /// <p>If the service configuration includes an <code>AAAA</code> record, the IPv6 address that you want Route 53 to
        /// return in response to DNS queries (for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>).</p>
        /// <p>This value is required if the service specified by <code>ServiceId</code> includes settings for an
        /// <code>AAAA</code> record. If the service includes settings for an <code>SRV</code> record, you must specify a
        /// value for <code>AWS_INSTANCE_IPV4</code>, <code>AWS_INSTANCE_IPV6</code>, or both.</p>
        /// </dd>
        /// <dt>AWS_INSTANCE_PORT</dt>
        /// <dd>
        /// <p>If the service includes an <code>SRV</code> record, the value that you want Route 53 to return for the
        /// port.</p>
        /// <p>If the service includes <code>HealthCheckConfig</code>, the port on the endpoint that you want Route 53 to send
        /// requests to. </p>
        /// <p>This value is required if you specified settings for an <code>SRV</code> record or a Route 53 health check when
        /// you created the service.</p>
        /// </dd>
        /// <dt>Custom attributes</dt>
        /// <dd>
        /// <p>You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is
        /// 255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided
        /// attributes (sum of all keys and values) must not exceed 5,000 characters.</p>
        /// </dd>
        /// </dl>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.attributes(k, v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to
        /// an empty string, but you can't set the value of a tag to null.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>The tag keys to remove from the specified resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateHttpNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_http_namespace_input::Builder,
    }
    impl<C, M, R> UpdateHttpNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateHttpNamespaceOutput,
            smithy_http::result::SdkError<crate::error::UpdateHttpNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateHttpNamespaceInputOperationOutputAlias,
                crate::output::UpdateHttpNamespaceOutput,
                crate::error::UpdateHttpNamespaceError,
                crate::input::UpdateHttpNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the namespace that you want to
        /// update.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A unique string that identifies the
        /// request and that allows failed <code>UpdateHttpNamespace</code> requests to be retried without the risk of running
        /// the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
        /// date/timestamp).</p>
        pub fn updater_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.updater_request_id(inp);
            self
        }
        pub fn set_updater_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_updater_request_id(input);
            self
        }
        /// <p>Updated properties for the the HTTP
        /// namespace.</p>
        pub fn namespace(mut self, inp: crate::model::HttpNamespaceChange) -> Self {
            self.inner = self.inner.namespace(inp);
            self
        }
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::HttpNamespaceChange>,
        ) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateInstanceCustomHealthStatus<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_instance_custom_health_status_input::Builder,
    }
    impl<C, M, R> UpdateInstanceCustomHealthStatus<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateInstanceCustomHealthStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdateInstanceCustomHealthStatusError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateInstanceCustomHealthStatusInputOperationOutputAlias,
                crate::output::UpdateInstanceCustomHealthStatusOutput,
                crate::error::UpdateInstanceCustomHealthStatusError,
                crate::input::UpdateInstanceCustomHealthStatusInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that includes the configuration for the custom health check that you want to change the
        /// status for.</p>
        pub fn service_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(inp);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The ID of the instance that you want to change the health status for.</p>
        pub fn instance_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(inp);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The new status of the instance, <code>HEALTHY</code> or <code>UNHEALTHY</code>.</p>
        pub fn status(mut self, inp: crate::model::CustomHealthStatus) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CustomHealthStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePrivateDnsNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_private_dns_namespace_input::Builder,
    }
    impl<C, M, R> UpdatePrivateDnsNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePrivateDnsNamespaceOutput,
            smithy_http::result::SdkError<crate::error::UpdatePrivateDnsNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdatePrivateDnsNamespaceInputOperationOutputAlias,
                crate::output::UpdatePrivateDnsNamespaceOutput,
                crate::error::UpdatePrivateDnsNamespaceError,
                crate::input::UpdatePrivateDnsNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the namespace that you want to
        /// update.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A unique string that identifies the
        /// request and that allows failed <code>UpdatePrivateDnsNamespace</code> requests to be retried without the risk of
        /// running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
        /// date/timestamp).</p>
        pub fn updater_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.updater_request_id(inp);
            self
        }
        pub fn set_updater_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_updater_request_id(input);
            self
        }
        /// <p>Updated properties for the private DNS
        /// namespace.</p>
        pub fn namespace(mut self, inp: crate::model::PrivateDnsNamespaceChange) -> Self {
            self.inner = self.inner.namespace(inp);
            self
        }
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::PrivateDnsNamespaceChange>,
        ) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePublicDnsNamespace<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_public_dns_namespace_input::Builder,
    }
    impl<C, M, R> UpdatePublicDnsNamespace<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePublicDnsNamespaceOutput,
            smithy_http::result::SdkError<crate::error::UpdatePublicDnsNamespaceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdatePublicDnsNamespaceInputOperationOutputAlias,
                crate::output::UpdatePublicDnsNamespaceOutput,
                crate::error::UpdatePublicDnsNamespaceError,
                crate::input::UpdatePublicDnsNamespaceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the namespace being
        /// updated.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A unique string that identifies the
        /// request and that allows failed <code>UpdatePublicDnsNamespace</code> requests to be retried without the risk of
        /// running the operation twice. <code>UpdaterRequestId</code> can be any unique string (for example, a
        /// date/timestamp).</p>
        pub fn updater_request_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.updater_request_id(inp);
            self
        }
        pub fn set_updater_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_updater_request_id(input);
            self
        }
        /// <p>Updated properties for the public DNS
        /// namespace.</p>
        pub fn namespace(mut self, inp: crate::model::PublicDnsNamespaceChange) -> Self {
            self.inner = self.inner.namespace(inp);
            self
        }
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::PublicDnsNamespaceChange>,
        ) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateService<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_service_input::Builder,
    }
    impl<C, M, R> UpdateService<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServiceOutput,
            smithy_http::result::SdkError<crate::error::UpdateServiceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateServiceInputOperationOutputAlias,
                crate::output::UpdateServiceOutput,
                crate::error::UpdateServiceError,
                crate::input::UpdateServiceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the service that you want to update.</p>
        pub fn id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(inp);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A complex type that contains the new settings for the service.</p>
        pub fn service(mut self, inp: crate::model::ServiceChange) -> Self {
            self.inner = self.inner.service(inp);
            self
        }
        pub fn set_service(
            mut self,
            input: std::option::Option<crate::model::ServiceChange>,
        ) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
