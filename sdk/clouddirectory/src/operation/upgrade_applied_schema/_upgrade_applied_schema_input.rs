// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct UpgradeAppliedSchemaInput {
    /// <p>The revision of the published schema to upgrade the directory to.</p>
    pub published_schema_arn: ::std::option::Option<::std::string::String>,
    /// <p>The ARN for the directory to which the upgraded schema will be applied.</p>
    pub directory_arn: ::std::option::Option<::std::string::String>,
    /// <p>Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.</p>
    pub dry_run: ::std::option::Option<bool>,
}
impl UpgradeAppliedSchemaInput {
    /// <p>The revision of the published schema to upgrade the directory to.</p>
    pub fn published_schema_arn(&self) -> ::std::option::Option<&str> {
        self.published_schema_arn.as_deref()
    }
    /// <p>The ARN for the directory to which the upgraded schema will be applied.</p>
    pub fn directory_arn(&self) -> ::std::option::Option<&str> {
        self.directory_arn.as_deref()
    }
    /// <p>Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.</p>
    pub fn dry_run(&self) -> ::std::option::Option<bool> {
        self.dry_run
    }
}
impl UpgradeAppliedSchemaInput {
    /// Creates a new builder-style object to manufacture [`UpgradeAppliedSchemaInput`](crate::operation::upgrade_applied_schema::UpgradeAppliedSchemaInput).
    pub fn builder() -> crate::operation::upgrade_applied_schema::builders::UpgradeAppliedSchemaInputBuilder {
        crate::operation::upgrade_applied_schema::builders::UpgradeAppliedSchemaInputBuilder::default()
    }
}

/// A builder for [`UpgradeAppliedSchemaInput`](crate::operation::upgrade_applied_schema::UpgradeAppliedSchemaInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct UpgradeAppliedSchemaInputBuilder {
    pub(crate) published_schema_arn: ::std::option::Option<::std::string::String>,
    pub(crate) directory_arn: ::std::option::Option<::std::string::String>,
    pub(crate) dry_run: ::std::option::Option<bool>,
}
impl UpgradeAppliedSchemaInputBuilder {
    /// <p>The revision of the published schema to upgrade the directory to.</p>
    /// This field is required.
    pub fn published_schema_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.published_schema_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The revision of the published schema to upgrade the directory to.</p>
    pub fn set_published_schema_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.published_schema_arn = input;
        self
    }
    /// <p>The revision of the published schema to upgrade the directory to.</p>
    pub fn get_published_schema_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.published_schema_arn
    }
    /// <p>The ARN for the directory to which the upgraded schema will be applied.</p>
    /// This field is required.
    pub fn directory_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.directory_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN for the directory to which the upgraded schema will be applied.</p>
    pub fn set_directory_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.directory_arn = input;
        self
    }
    /// <p>The ARN for the directory to which the upgraded schema will be applied.</p>
    pub fn get_directory_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.directory_arn
    }
    /// <p>Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.</p>
    pub fn dry_run(mut self, input: bool) -> Self {
        self.dry_run = ::std::option::Option::Some(input);
        self
    }
    /// <p>Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.</p>
    pub fn set_dry_run(mut self, input: ::std::option::Option<bool>) -> Self {
        self.dry_run = input;
        self
    }
    /// <p>Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.</p>
    pub fn get_dry_run(&self) -> &::std::option::Option<bool> {
        &self.dry_run
    }
    /// Consumes the builder and constructs a [`UpgradeAppliedSchemaInput`](crate::operation::upgrade_applied_schema::UpgradeAppliedSchemaInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::upgrade_applied_schema::UpgradeAppliedSchemaInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::upgrade_applied_schema::UpgradeAppliedSchemaInput {
            published_schema_arn: self.published_schema_arn,
            directory_arn: self.directory_arn,
            dry_run: self.dry_run,
        })
    }
}
