// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds a new <a>Facet</a> to an object. An object can have more than one facet applied on it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddFacetToObject {
    _private: (),
}
impl AddFacetToObject {
    /// Creates a new builder-style object to manufacture [`AddFacetToObjectInput`](crate::input::AddFacetToObjectInput)
    pub fn builder() -> crate::input::add_facet_to_object_input::Builder {
        crate::input::add_facet_to_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddFacetToObject {
    type Output = std::result::Result<
        crate::output::AddFacetToObjectOutput,
        crate::error::AddFacetToObjectError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_facet_to_object_error(response)
        } else {
            crate::operation_deser::parse_add_facet_to_object_response(response)
        }
    }
}

/// <p>Copies the input published schema, at the specified version, into the <a>Directory</a> with the same
/// name and version as that of the published schema.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ApplySchema {
    _private: (),
}
impl ApplySchema {
    /// Creates a new builder-style object to manufacture [`ApplySchemaInput`](crate::input::ApplySchemaInput)
    pub fn builder() -> crate::input::apply_schema_input::Builder {
        crate::input::apply_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ApplySchema {
    type Output =
        std::result::Result<crate::output::ApplySchemaOutput, crate::error::ApplySchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_apply_schema_error(response)
        } else {
            crate::operation_deser::parse_apply_schema_response(response)
        }
    }
}

/// <p>Attaches an existing object to another object. An object can be accessed in two
/// ways:</p>
/// <ol>
/// <li>
/// <p>Using the path</p>
/// </li>
/// <li>
/// <p>Using <code>ObjectIdentifier</code>
/// </p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachObject {
    _private: (),
}
impl AttachObject {
    /// Creates a new builder-style object to manufacture [`AttachObjectInput`](crate::input::AttachObjectInput)
    pub fn builder() -> crate::input::attach_object_input::Builder {
        crate::input::attach_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachObject {
    type Output =
        std::result::Result<crate::output::AttachObjectOutput, crate::error::AttachObjectError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_object_error(response)
        } else {
            crate::operation_deser::parse_attach_object_response(response)
        }
    }
}

/// <p>Attaches a policy object to a regular object. An object can have a limited number of attached
/// policies.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachPolicy {
    _private: (),
}
impl AttachPolicy {
    /// Creates a new builder-style object to manufacture [`AttachPolicyInput`](crate::input::AttachPolicyInput)
    pub fn builder() -> crate::input::attach_policy_input::Builder {
        crate::input::attach_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachPolicy {
    type Output =
        std::result::Result<crate::output::AttachPolicyOutput, crate::error::AttachPolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_policy_error(response)
        } else {
            crate::operation_deser::parse_attach_policy_response(response)
        }
    }
}

/// <p>Attaches the specified object to the specified index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachToIndex {
    _private: (),
}
impl AttachToIndex {
    /// Creates a new builder-style object to manufacture [`AttachToIndexInput`](crate::input::AttachToIndexInput)
    pub fn builder() -> crate::input::attach_to_index_input::Builder {
        crate::input::attach_to_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachToIndex {
    type Output =
        std::result::Result<crate::output::AttachToIndexOutput, crate::error::AttachToIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_to_index_error(response)
        } else {
            crate::operation_deser::parse_attach_to_index_response(response)
        }
    }
}

/// <p>Attaches a typed link to a specified source and target object. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachTypedLink {
    _private: (),
}
impl AttachTypedLink {
    /// Creates a new builder-style object to manufacture [`AttachTypedLinkInput`](crate::input::AttachTypedLinkInput)
    pub fn builder() -> crate::input::attach_typed_link_input::Builder {
        crate::input::attach_typed_link_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachTypedLink {
    type Output = std::result::Result<
        crate::output::AttachTypedLinkOutput,
        crate::error::AttachTypedLinkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_typed_link_error(response)
        } else {
            crate::operation_deser::parse_attach_typed_link_response(response)
        }
    }
}

/// <p>Performs all the read operations in a batch. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchRead {
    _private: (),
}
impl BatchRead {
    /// Creates a new builder-style object to manufacture [`BatchReadInput`](crate::input::BatchReadInput)
    pub fn builder() -> crate::input::batch_read_input::Builder {
        crate::input::batch_read_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchRead {
    type Output = std::result::Result<crate::output::BatchReadOutput, crate::error::BatchReadError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_read_error(response)
        } else {
            crate::operation_deser::parse_batch_read_response(response)
        }
    }
}

/// <p>Performs all the write operations in a batch. Either all the operations succeed or
/// none.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchWrite {
    _private: (),
}
impl BatchWrite {
    /// Creates a new builder-style object to manufacture [`BatchWriteInput`](crate::input::BatchWriteInput)
    pub fn builder() -> crate::input::batch_write_input::Builder {
        crate::input::batch_write_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchWrite {
    type Output =
        std::result::Result<crate::output::BatchWriteOutput, crate::error::BatchWriteError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_write_error(response)
        } else {
            crate::operation_deser::parse_batch_write_response(response)
        }
    }
}

/// <p>Creates a <a>Directory</a> by copying the published schema into the
/// directory. A directory cannot be created without a schema.</p>
/// <p>You can also quickly create a directory using a managed schema, called the
/// <code>QuickStartSchema</code>. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_managed.html">Managed Schema</a> in the <i>Amazon Cloud Directory Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDirectory {
    _private: (),
}
impl CreateDirectory {
    /// Creates a new builder-style object to manufacture [`CreateDirectoryInput`](crate::input::CreateDirectoryInput)
    pub fn builder() -> crate::input::create_directory_input::Builder {
        crate::input::create_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDirectory {
    type Output = std::result::Result<
        crate::output::CreateDirectoryOutput,
        crate::error::CreateDirectoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_directory_error(response)
        } else {
            crate::operation_deser::parse_create_directory_response(response)
        }
    }
}

/// <p>Creates a new <a>Facet</a> in a schema. Facet creation is allowed only
/// in development or applied schemas.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFacet {
    _private: (),
}
impl CreateFacet {
    /// Creates a new builder-style object to manufacture [`CreateFacetInput`](crate::input::CreateFacetInput)
    pub fn builder() -> crate::input::create_facet_input::Builder {
        crate::input::create_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFacet {
    type Output =
        std::result::Result<crate::output::CreateFacetOutput, crate::error::CreateFacetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_facet_error(response)
        } else {
            crate::operation_deser::parse_create_facet_response(response)
        }
    }
}

/// <p>Creates an index object. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.html">Indexing and search</a> for more information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIndex {
    _private: (),
}
impl CreateIndex {
    /// Creates a new builder-style object to manufacture [`CreateIndexInput`](crate::input::CreateIndexInput)
    pub fn builder() -> crate::input::create_index_input::Builder {
        crate::input::create_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIndex {
    type Output =
        std::result::Result<crate::output::CreateIndexOutput, crate::error::CreateIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_index_error(response)
        } else {
            crate::operation_deser::parse_create_index_response(response)
        }
    }
}

/// <p>Creates an object in a <a>Directory</a>. Additionally attaches the object to
/// a parent, if a parent reference and <code>LinkName</code> is specified. An object is simply a
/// collection of <a>Facet</a> attributes. You can also use this API call to create a
/// policy object, if the facet from which you create the object is a policy facet. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateObject {
    _private: (),
}
impl CreateObject {
    /// Creates a new builder-style object to manufacture [`CreateObjectInput`](crate::input::CreateObjectInput)
    pub fn builder() -> crate::input::create_object_input::Builder {
        crate::input::create_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateObject {
    type Output =
        std::result::Result<crate::output::CreateObjectOutput, crate::error::CreateObjectError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_object_error(response)
        } else {
            crate::operation_deser::parse_create_object_response(response)
        }
    }
}

/// <p>Creates a new schema in a development state. A schema can exist in three
/// phases:</p>
/// <ul>
/// <li>
/// <p>
/// <i>Development:</i> This is a mutable phase of the schema. All new
/// schemas are in the development phase. Once the schema is finalized, it can be
/// published.</p>
/// </li>
/// <li>
/// <p>
/// <i>Published:</i> Published schemas are immutable and have a version
/// associated with them.</p>
/// </li>
/// <li>
/// <p>
/// <i>Applied:</i> Applied schemas are mutable in a way that allows you
/// to add new schema facets. You can also add new, nonrequired attributes to existing schema
/// facets. You can apply only published schemas to directories. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSchema {
    _private: (),
}
impl CreateSchema {
    /// Creates a new builder-style object to manufacture [`CreateSchemaInput`](crate::input::CreateSchemaInput)
    pub fn builder() -> crate::input::create_schema_input::Builder {
        crate::input::create_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSchema {
    type Output =
        std::result::Result<crate::output::CreateSchemaOutput, crate::error::CreateSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_schema_error(response)
        } else {
            crate::operation_deser::parse_create_schema_response(response)
        }
    }
}

/// <p>Creates a <a>TypedLinkFacet</a>. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTypedLinkFacet {
    _private: (),
}
impl CreateTypedLinkFacet {
    /// Creates a new builder-style object to manufacture [`CreateTypedLinkFacetInput`](crate::input::CreateTypedLinkFacetInput)
    pub fn builder() -> crate::input::create_typed_link_facet_input::Builder {
        crate::input::create_typed_link_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTypedLinkFacet {
    type Output = std::result::Result<
        crate::output::CreateTypedLinkFacetOutput,
        crate::error::CreateTypedLinkFacetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_typed_link_facet_error(response)
        } else {
            crate::operation_deser::parse_create_typed_link_facet_response(response)
        }
    }
}

/// <p>Deletes a directory. Only disabled directories can be deleted. A deleted directory cannot be undone. Exercise extreme
/// caution
/// when deleting directories.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDirectory {
    _private: (),
}
impl DeleteDirectory {
    /// Creates a new builder-style object to manufacture [`DeleteDirectoryInput`](crate::input::DeleteDirectoryInput)
    pub fn builder() -> crate::input::delete_directory_input::Builder {
        crate::input::delete_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDirectory {
    type Output = std::result::Result<
        crate::output::DeleteDirectoryOutput,
        crate::error::DeleteDirectoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_directory_error(response)
        } else {
            crate::operation_deser::parse_delete_directory_response(response)
        }
    }
}

/// <p>Deletes a given <a>Facet</a>. All attributes and <a>Rule</a>s
/// that are associated with the facet will be deleted. Only development schema facets are allowed
/// deletion.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFacet {
    _private: (),
}
impl DeleteFacet {
    /// Creates a new builder-style object to manufacture [`DeleteFacetInput`](crate::input::DeleteFacetInput)
    pub fn builder() -> crate::input::delete_facet_input::Builder {
        crate::input::delete_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFacet {
    type Output =
        std::result::Result<crate::output::DeleteFacetOutput, crate::error::DeleteFacetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_facet_error(response)
        } else {
            crate::operation_deser::parse_delete_facet_response(response)
        }
    }
}

/// <p>Deletes an object and its associated attributes. Only objects with no children and no
/// parents can be deleted. The maximum number of attributes that can be deleted during an object deletion is 30. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html">Amazon Cloud Directory Limits</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteObject {
    _private: (),
}
impl DeleteObject {
    /// Creates a new builder-style object to manufacture [`DeleteObjectInput`](crate::input::DeleteObjectInput)
    pub fn builder() -> crate::input::delete_object_input::Builder {
        crate::input::delete_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteObject {
    type Output =
        std::result::Result<crate::output::DeleteObjectOutput, crate::error::DeleteObjectError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_object_error(response)
        } else {
            crate::operation_deser::parse_delete_object_response(response)
        }
    }
}

/// <p>Deletes a given schema. Schemas in a development and published state can only be deleted. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSchema {
    _private: (),
}
impl DeleteSchema {
    /// Creates a new builder-style object to manufacture [`DeleteSchemaInput`](crate::input::DeleteSchemaInput)
    pub fn builder() -> crate::input::delete_schema_input::Builder {
        crate::input::delete_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSchema {
    type Output =
        std::result::Result<crate::output::DeleteSchemaOutput, crate::error::DeleteSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_schema_error(response)
        } else {
            crate::operation_deser::parse_delete_schema_response(response)
        }
    }
}

/// <p>Deletes a <a>TypedLinkFacet</a>. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTypedLinkFacet {
    _private: (),
}
impl DeleteTypedLinkFacet {
    /// Creates a new builder-style object to manufacture [`DeleteTypedLinkFacetInput`](crate::input::DeleteTypedLinkFacetInput)
    pub fn builder() -> crate::input::delete_typed_link_facet_input::Builder {
        crate::input::delete_typed_link_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTypedLinkFacet {
    type Output = std::result::Result<
        crate::output::DeleteTypedLinkFacetOutput,
        crate::error::DeleteTypedLinkFacetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_typed_link_facet_error(response)
        } else {
            crate::operation_deser::parse_delete_typed_link_facet_response(response)
        }
    }
}

/// <p>Detaches the specified object from the specified index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachFromIndex {
    _private: (),
}
impl DetachFromIndex {
    /// Creates a new builder-style object to manufacture [`DetachFromIndexInput`](crate::input::DetachFromIndexInput)
    pub fn builder() -> crate::input::detach_from_index_input::Builder {
        crate::input::detach_from_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachFromIndex {
    type Output = std::result::Result<
        crate::output::DetachFromIndexOutput,
        crate::error::DetachFromIndexError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_from_index_error(response)
        } else {
            crate::operation_deser::parse_detach_from_index_response(response)
        }
    }
}

/// <p>Detaches a given object from the parent object. The object that is to be detached from the
/// parent is specified by the link name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachObject {
    _private: (),
}
impl DetachObject {
    /// Creates a new builder-style object to manufacture [`DetachObjectInput`](crate::input::DetachObjectInput)
    pub fn builder() -> crate::input::detach_object_input::Builder {
        crate::input::detach_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachObject {
    type Output =
        std::result::Result<crate::output::DetachObjectOutput, crate::error::DetachObjectError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_object_error(response)
        } else {
            crate::operation_deser::parse_detach_object_response(response)
        }
    }
}

/// <p>Detaches a policy from an object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachPolicy {
    _private: (),
}
impl DetachPolicy {
    /// Creates a new builder-style object to manufacture [`DetachPolicyInput`](crate::input::DetachPolicyInput)
    pub fn builder() -> crate::input::detach_policy_input::Builder {
        crate::input::detach_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachPolicy {
    type Output =
        std::result::Result<crate::output::DetachPolicyOutput, crate::error::DetachPolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_policy_error(response)
        } else {
            crate::operation_deser::parse_detach_policy_response(response)
        }
    }
}

/// <p>Detaches a typed link from a specified source and target object. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachTypedLink {
    _private: (),
}
impl DetachTypedLink {
    /// Creates a new builder-style object to manufacture [`DetachTypedLinkInput`](crate::input::DetachTypedLinkInput)
    pub fn builder() -> crate::input::detach_typed_link_input::Builder {
        crate::input::detach_typed_link_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachTypedLink {
    type Output = std::result::Result<
        crate::output::DetachTypedLinkOutput,
        crate::error::DetachTypedLinkError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_typed_link_error(response)
        } else {
            crate::operation_deser::parse_detach_typed_link_response(response)
        }
    }
}

/// <p>Disables the specified directory. Disabled directories cannot be read or written to.
/// Only enabled directories can be disabled. Disabled directories may be reenabled.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableDirectory {
    _private: (),
}
impl DisableDirectory {
    /// Creates a new builder-style object to manufacture [`DisableDirectoryInput`](crate::input::DisableDirectoryInput)
    pub fn builder() -> crate::input::disable_directory_input::Builder {
        crate::input::disable_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableDirectory {
    type Output = std::result::Result<
        crate::output::DisableDirectoryOutput,
        crate::error::DisableDirectoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_directory_error(response)
        } else {
            crate::operation_deser::parse_disable_directory_response(response)
        }
    }
}

/// <p>Enables the specified directory. Only disabled directories can be enabled. Once
/// enabled, the directory can then be read and written to.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableDirectory {
    _private: (),
}
impl EnableDirectory {
    /// Creates a new builder-style object to manufacture [`EnableDirectoryInput`](crate::input::EnableDirectoryInput)
    pub fn builder() -> crate::input::enable_directory_input::Builder {
        crate::input::enable_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableDirectory {
    type Output = std::result::Result<
        crate::output::EnableDirectoryOutput,
        crate::error::EnableDirectoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_directory_error(response)
        } else {
            crate::operation_deser::parse_enable_directory_response(response)
        }
    }
}

/// <p>Returns current applied schema version ARN, including the minor version in use.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAppliedSchemaVersion {
    _private: (),
}
impl GetAppliedSchemaVersion {
    /// Creates a new builder-style object to manufacture [`GetAppliedSchemaVersionInput`](crate::input::GetAppliedSchemaVersionInput)
    pub fn builder() -> crate::input::get_applied_schema_version_input::Builder {
        crate::input::get_applied_schema_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAppliedSchemaVersion {
    type Output = std::result::Result<
        crate::output::GetAppliedSchemaVersionOutput,
        crate::error::GetAppliedSchemaVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_applied_schema_version_error(response)
        } else {
            crate::operation_deser::parse_get_applied_schema_version_response(response)
        }
    }
}

/// <p>Retrieves metadata about a directory.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDirectory {
    _private: (),
}
impl GetDirectory {
    /// Creates a new builder-style object to manufacture [`GetDirectoryInput`](crate::input::GetDirectoryInput)
    pub fn builder() -> crate::input::get_directory_input::Builder {
        crate::input::get_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDirectory {
    type Output =
        std::result::Result<crate::output::GetDirectoryOutput, crate::error::GetDirectoryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_directory_error(response)
        } else {
            crate::operation_deser::parse_get_directory_response(response)
        }
    }
}

/// <p>Gets details of the <a>Facet</a>, such as facet name, attributes, <a>Rule</a>s, or <code>ObjectType</code>. You can call this on all kinds of schema
/// facets -- published, development, or applied.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFacet {
    _private: (),
}
impl GetFacet {
    /// Creates a new builder-style object to manufacture [`GetFacetInput`](crate::input::GetFacetInput)
    pub fn builder() -> crate::input::get_facet_input::Builder {
        crate::input::get_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFacet {
    type Output = std::result::Result<crate::output::GetFacetOutput, crate::error::GetFacetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_facet_error(response)
        } else {
            crate::operation_deser::parse_get_facet_response(response)
        }
    }
}

/// <p>Retrieves attributes that are associated with a typed link.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLinkAttributes {
    _private: (),
}
impl GetLinkAttributes {
    /// Creates a new builder-style object to manufacture [`GetLinkAttributesInput`](crate::input::GetLinkAttributesInput)
    pub fn builder() -> crate::input::get_link_attributes_input::Builder {
        crate::input::get_link_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLinkAttributes {
    type Output = std::result::Result<
        crate::output::GetLinkAttributesOutput,
        crate::error::GetLinkAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_link_attributes_error(response)
        } else {
            crate::operation_deser::parse_get_link_attributes_response(response)
        }
    }
}

/// <p>Retrieves attributes within a facet that are associated with an object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetObjectAttributes {
    _private: (),
}
impl GetObjectAttributes {
    /// Creates a new builder-style object to manufacture [`GetObjectAttributesInput`](crate::input::GetObjectAttributesInput)
    pub fn builder() -> crate::input::get_object_attributes_input::Builder {
        crate::input::get_object_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetObjectAttributes {
    type Output = std::result::Result<
        crate::output::GetObjectAttributesOutput,
        crate::error::GetObjectAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_object_attributes_error(response)
        } else {
            crate::operation_deser::parse_get_object_attributes_response(response)
        }
    }
}

/// <p>Retrieves metadata about an object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetObjectInformation {
    _private: (),
}
impl GetObjectInformation {
    /// Creates a new builder-style object to manufacture [`GetObjectInformationInput`](crate::input::GetObjectInformationInput)
    pub fn builder() -> crate::input::get_object_information_input::Builder {
        crate::input::get_object_information_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetObjectInformation {
    type Output = std::result::Result<
        crate::output::GetObjectInformationOutput,
        crate::error::GetObjectInformationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_object_information_error(response)
        } else {
            crate::operation_deser::parse_get_object_information_response(response)
        }
    }
}

/// <p>Retrieves a JSON representation of the schema. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_jsonformat.html#schemas_json">JSON Schema Format</a> for more information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSchemaAsJson {
    _private: (),
}
impl GetSchemaAsJson {
    /// Creates a new builder-style object to manufacture [`GetSchemaAsJsonInput`](crate::input::GetSchemaAsJsonInput)
    pub fn builder() -> crate::input::get_schema_as_json_input::Builder {
        crate::input::get_schema_as_json_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSchemaAsJson {
    type Output = std::result::Result<
        crate::output::GetSchemaAsJsonOutput,
        crate::error::GetSchemaAsJsonError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_schema_as_json_error(response)
        } else {
            crate::operation_deser::parse_get_schema_as_json_response(response)
        }
    }
}

/// <p>Returns the identity attribute order for a specific <a>TypedLinkFacet</a>. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTypedLinkFacetInformation {
    _private: (),
}
impl GetTypedLinkFacetInformation {
    /// Creates a new builder-style object to manufacture [`GetTypedLinkFacetInformationInput`](crate::input::GetTypedLinkFacetInformationInput)
    pub fn builder() -> crate::input::get_typed_link_facet_information_input::Builder {
        crate::input::get_typed_link_facet_information_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTypedLinkFacetInformation {
    type Output = std::result::Result<
        crate::output::GetTypedLinkFacetInformationOutput,
        crate::error::GetTypedLinkFacetInformationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_typed_link_facet_information_error(response)
        } else {
            crate::operation_deser::parse_get_typed_link_facet_information_response(response)
        }
    }
}

/// <p>Lists schema major versions applied to a directory. If <code>SchemaArn</code> is provided, lists the minor version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAppliedSchemaArns {
    _private: (),
}
impl ListAppliedSchemaArns {
    /// Creates a new builder-style object to manufacture [`ListAppliedSchemaArnsInput`](crate::input::ListAppliedSchemaArnsInput)
    pub fn builder() -> crate::input::list_applied_schema_arns_input::Builder {
        crate::input::list_applied_schema_arns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAppliedSchemaArns {
    type Output = std::result::Result<
        crate::output::ListAppliedSchemaArnsOutput,
        crate::error::ListAppliedSchemaArnsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_applied_schema_arns_error(response)
        } else {
            crate::operation_deser::parse_list_applied_schema_arns_response(response)
        }
    }
}

/// <p>Lists indices attached to the specified object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAttachedIndices {
    _private: (),
}
impl ListAttachedIndices {
    /// Creates a new builder-style object to manufacture [`ListAttachedIndicesInput`](crate::input::ListAttachedIndicesInput)
    pub fn builder() -> crate::input::list_attached_indices_input::Builder {
        crate::input::list_attached_indices_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAttachedIndices {
    type Output = std::result::Result<
        crate::output::ListAttachedIndicesOutput,
        crate::error::ListAttachedIndicesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_attached_indices_error(response)
        } else {
            crate::operation_deser::parse_list_attached_indices_response(response)
        }
    }
}

/// <p>Retrieves each Amazon Resource Name (ARN) of schemas in the development
/// state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDevelopmentSchemaArns {
    _private: (),
}
impl ListDevelopmentSchemaArns {
    /// Creates a new builder-style object to manufacture [`ListDevelopmentSchemaArnsInput`](crate::input::ListDevelopmentSchemaArnsInput)
    pub fn builder() -> crate::input::list_development_schema_arns_input::Builder {
        crate::input::list_development_schema_arns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDevelopmentSchemaArns {
    type Output = std::result::Result<
        crate::output::ListDevelopmentSchemaArnsOutput,
        crate::error::ListDevelopmentSchemaArnsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_development_schema_arns_error(response)
        } else {
            crate::operation_deser::parse_list_development_schema_arns_response(response)
        }
    }
}

/// <p>Lists directories created within an account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDirectories {
    _private: (),
}
impl ListDirectories {
    /// Creates a new builder-style object to manufacture [`ListDirectoriesInput`](crate::input::ListDirectoriesInput)
    pub fn builder() -> crate::input::list_directories_input::Builder {
        crate::input::list_directories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDirectories {
    type Output = std::result::Result<
        crate::output::ListDirectoriesOutput,
        crate::error::ListDirectoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_directories_error(response)
        } else {
            crate::operation_deser::parse_list_directories_response(response)
        }
    }
}

/// <p>Retrieves attributes attached to the facet.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFacetAttributes {
    _private: (),
}
impl ListFacetAttributes {
    /// Creates a new builder-style object to manufacture [`ListFacetAttributesInput`](crate::input::ListFacetAttributesInput)
    pub fn builder() -> crate::input::list_facet_attributes_input::Builder {
        crate::input::list_facet_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFacetAttributes {
    type Output = std::result::Result<
        crate::output::ListFacetAttributesOutput,
        crate::error::ListFacetAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_facet_attributes_error(response)
        } else {
            crate::operation_deser::parse_list_facet_attributes_response(response)
        }
    }
}

/// <p>Retrieves the names of facets that exist in a schema.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFacetNames {
    _private: (),
}
impl ListFacetNames {
    /// Creates a new builder-style object to manufacture [`ListFacetNamesInput`](crate::input::ListFacetNamesInput)
    pub fn builder() -> crate::input::list_facet_names_input::Builder {
        crate::input::list_facet_names_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFacetNames {
    type Output =
        std::result::Result<crate::output::ListFacetNamesOutput, crate::error::ListFacetNamesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_facet_names_error(response)
        } else {
            crate::operation_deser::parse_list_facet_names_response(response)
        }
    }
}

/// <p>Returns a paginated list of all the incoming <a>TypedLinkSpecifier</a>
/// information for an object. It also supports filtering by typed link facet and identity
/// attributes. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIncomingTypedLinks {
    _private: (),
}
impl ListIncomingTypedLinks {
    /// Creates a new builder-style object to manufacture [`ListIncomingTypedLinksInput`](crate::input::ListIncomingTypedLinksInput)
    pub fn builder() -> crate::input::list_incoming_typed_links_input::Builder {
        crate::input::list_incoming_typed_links_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIncomingTypedLinks {
    type Output = std::result::Result<
        crate::output::ListIncomingTypedLinksOutput,
        crate::error::ListIncomingTypedLinksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_incoming_typed_links_error(response)
        } else {
            crate::operation_deser::parse_list_incoming_typed_links_response(response)
        }
    }
}

/// <p>Lists objects attached to the specified index.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIndex {
    _private: (),
}
impl ListIndex {
    /// Creates a new builder-style object to manufacture [`ListIndexInput`](crate::input::ListIndexInput)
    pub fn builder() -> crate::input::list_index_input::Builder {
        crate::input::list_index_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIndex {
    type Output = std::result::Result<crate::output::ListIndexOutput, crate::error::ListIndexError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_index_error(response)
        } else {
            crate::operation_deser::parse_list_index_response(response)
        }
    }
}

/// <p>Lists the major version families of each managed schema. If a major version ARN is provided as SchemaArn, the minor version revisions in that family are listed instead.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListManagedSchemaArns {
    _private: (),
}
impl ListManagedSchemaArns {
    /// Creates a new builder-style object to manufacture [`ListManagedSchemaArnsInput`](crate::input::ListManagedSchemaArnsInput)
    pub fn builder() -> crate::input::list_managed_schema_arns_input::Builder {
        crate::input::list_managed_schema_arns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListManagedSchemaArns {
    type Output = std::result::Result<
        crate::output::ListManagedSchemaArnsOutput,
        crate::error::ListManagedSchemaArnsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_managed_schema_arns_error(response)
        } else {
            crate::operation_deser::parse_list_managed_schema_arns_response(response)
        }
    }
}

/// <p>Lists all attributes that are associated with an object.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListObjectAttributes {
    _private: (),
}
impl ListObjectAttributes {
    /// Creates a new builder-style object to manufacture [`ListObjectAttributesInput`](crate::input::ListObjectAttributesInput)
    pub fn builder() -> crate::input::list_object_attributes_input::Builder {
        crate::input::list_object_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListObjectAttributes {
    type Output = std::result::Result<
        crate::output::ListObjectAttributesOutput,
        crate::error::ListObjectAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_object_attributes_error(response)
        } else {
            crate::operation_deser::parse_list_object_attributes_response(response)
        }
    }
}

/// <p>Returns a paginated list of child objects that are associated with a given
/// object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListObjectChildren {
    _private: (),
}
impl ListObjectChildren {
    /// Creates a new builder-style object to manufacture [`ListObjectChildrenInput`](crate::input::ListObjectChildrenInput)
    pub fn builder() -> crate::input::list_object_children_input::Builder {
        crate::input::list_object_children_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListObjectChildren {
    type Output = std::result::Result<
        crate::output::ListObjectChildrenOutput,
        crate::error::ListObjectChildrenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_object_children_error(response)
        } else {
            crate::operation_deser::parse_list_object_children_response(response)
        }
    }
}

/// <p>Retrieves all available parent paths for any object type such as node, leaf node,
/// policy node, and index node objects. For more information about objects, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html">Directory Structure</a>.</p>
/// <p>Use this API to evaluate all parents for an object. The call returns all objects from
/// the root of the directory up to the requested object. The API returns the number of paths
/// based on user-defined <code>MaxResults</code>, in case there are multiple paths to the parent.
/// The order of the paths and nodes returned is consistent among multiple API calls unless the
/// objects are deleted or moved. Paths not leading to the directory root are ignored from the
/// target object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListObjectParentPaths {
    _private: (),
}
impl ListObjectParentPaths {
    /// Creates a new builder-style object to manufacture [`ListObjectParentPathsInput`](crate::input::ListObjectParentPathsInput)
    pub fn builder() -> crate::input::list_object_parent_paths_input::Builder {
        crate::input::list_object_parent_paths_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListObjectParentPaths {
    type Output = std::result::Result<
        crate::output::ListObjectParentPathsOutput,
        crate::error::ListObjectParentPathsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_object_parent_paths_error(response)
        } else {
            crate::operation_deser::parse_list_object_parent_paths_response(response)
        }
    }
}

/// <p>Lists parent objects that are associated with a given object in pagination
/// fashion.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListObjectParents {
    _private: (),
}
impl ListObjectParents {
    /// Creates a new builder-style object to manufacture [`ListObjectParentsInput`](crate::input::ListObjectParentsInput)
    pub fn builder() -> crate::input::list_object_parents_input::Builder {
        crate::input::list_object_parents_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListObjectParents {
    type Output = std::result::Result<
        crate::output::ListObjectParentsOutput,
        crate::error::ListObjectParentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_object_parents_error(response)
        } else {
            crate::operation_deser::parse_list_object_parents_response(response)
        }
    }
}

/// <p>Returns policies attached to an object in pagination fashion.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListObjectPolicies {
    _private: (),
}
impl ListObjectPolicies {
    /// Creates a new builder-style object to manufacture [`ListObjectPoliciesInput`](crate::input::ListObjectPoliciesInput)
    pub fn builder() -> crate::input::list_object_policies_input::Builder {
        crate::input::list_object_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListObjectPolicies {
    type Output = std::result::Result<
        crate::output::ListObjectPoliciesOutput,
        crate::error::ListObjectPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_object_policies_error(response)
        } else {
            crate::operation_deser::parse_list_object_policies_response(response)
        }
    }
}

/// <p>Returns a paginated list of all the outgoing <a>TypedLinkSpecifier</a>
/// information for an object. It also supports filtering by typed link facet and identity
/// attributes. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListOutgoingTypedLinks {
    _private: (),
}
impl ListOutgoingTypedLinks {
    /// Creates a new builder-style object to manufacture [`ListOutgoingTypedLinksInput`](crate::input::ListOutgoingTypedLinksInput)
    pub fn builder() -> crate::input::list_outgoing_typed_links_input::Builder {
        crate::input::list_outgoing_typed_links_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListOutgoingTypedLinks {
    type Output = std::result::Result<
        crate::output::ListOutgoingTypedLinksOutput,
        crate::error::ListOutgoingTypedLinksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_outgoing_typed_links_error(response)
        } else {
            crate::operation_deser::parse_list_outgoing_typed_links_response(response)
        }
    }
}

/// <p>Returns all of the <code>ObjectIdentifiers</code> to which a given policy is attached.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPolicyAttachments {
    _private: (),
}
impl ListPolicyAttachments {
    /// Creates a new builder-style object to manufacture [`ListPolicyAttachmentsInput`](crate::input::ListPolicyAttachmentsInput)
    pub fn builder() -> crate::input::list_policy_attachments_input::Builder {
        crate::input::list_policy_attachments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPolicyAttachments {
    type Output = std::result::Result<
        crate::output::ListPolicyAttachmentsOutput,
        crate::error::ListPolicyAttachmentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_policy_attachments_error(response)
        } else {
            crate::operation_deser::parse_list_policy_attachments_response(response)
        }
    }
}

/// <p>Lists the major version families of each published schema. If a major version ARN is provided as <code>SchemaArn</code>, the minor version revisions in that family are listed instead.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPublishedSchemaArns {
    _private: (),
}
impl ListPublishedSchemaArns {
    /// Creates a new builder-style object to manufacture [`ListPublishedSchemaArnsInput`](crate::input::ListPublishedSchemaArnsInput)
    pub fn builder() -> crate::input::list_published_schema_arns_input::Builder {
        crate::input::list_published_schema_arns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPublishedSchemaArns {
    type Output = std::result::Result<
        crate::output::ListPublishedSchemaArnsOutput,
        crate::error::ListPublishedSchemaArnsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_published_schema_arns_error(response)
        } else {
            crate::operation_deser::parse_list_published_schema_arns_response(response)
        }
    }
}

/// <p>Returns tags for a resource. Tagging is currently supported only for directories with a
/// limit of 50 tags per directory. All 50 tags are returned for a given directory with this API
/// call.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Returns a paginated list of all attribute definitions for a particular <a>TypedLinkFacet</a>. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTypedLinkFacetAttributes {
    _private: (),
}
impl ListTypedLinkFacetAttributes {
    /// Creates a new builder-style object to manufacture [`ListTypedLinkFacetAttributesInput`](crate::input::ListTypedLinkFacetAttributesInput)
    pub fn builder() -> crate::input::list_typed_link_facet_attributes_input::Builder {
        crate::input::list_typed_link_facet_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTypedLinkFacetAttributes {
    type Output = std::result::Result<
        crate::output::ListTypedLinkFacetAttributesOutput,
        crate::error::ListTypedLinkFacetAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_typed_link_facet_attributes_error(response)
        } else {
            crate::operation_deser::parse_list_typed_link_facet_attributes_response(response)
        }
    }
}

/// <p>Returns a paginated list of <code>TypedLink</code> facet names for a particular schema.
/// For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTypedLinkFacetNames {
    _private: (),
}
impl ListTypedLinkFacetNames {
    /// Creates a new builder-style object to manufacture [`ListTypedLinkFacetNamesInput`](crate::input::ListTypedLinkFacetNamesInput)
    pub fn builder() -> crate::input::list_typed_link_facet_names_input::Builder {
        crate::input::list_typed_link_facet_names_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTypedLinkFacetNames {
    type Output = std::result::Result<
        crate::output::ListTypedLinkFacetNamesOutput,
        crate::error::ListTypedLinkFacetNamesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_typed_link_facet_names_error(response)
        } else {
            crate::operation_deser::parse_list_typed_link_facet_names_response(response)
        }
    }
}

/// <p>Lists all policies from the root of the <a>Directory</a> to the object
/// specified. If there are no policies present, an empty list is returned. If policies are
/// present, and if some objects don't have the policies attached, it returns the <code>ObjectIdentifier</code>
/// for such objects. If policies are present, it returns <code>ObjectIdentifier</code>, <code>policyId</code>, and
/// <code>policyType</code>. Paths that don't lead to the root from the target object are ignored. For more
/// information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies">Policies</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct LookupPolicy {
    _private: (),
}
impl LookupPolicy {
    /// Creates a new builder-style object to manufacture [`LookupPolicyInput`](crate::input::LookupPolicyInput)
    pub fn builder() -> crate::input::lookup_policy_input::Builder {
        crate::input::lookup_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for LookupPolicy {
    type Output =
        std::result::Result<crate::output::LookupPolicyOutput, crate::error::LookupPolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_lookup_policy_error(response)
        } else {
            crate::operation_deser::parse_lookup_policy_response(response)
        }
    }
}

/// <p>Publishes a development schema with a major version and a recommended minor version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PublishSchema {
    _private: (),
}
impl PublishSchema {
    /// Creates a new builder-style object to manufacture [`PublishSchemaInput`](crate::input::PublishSchemaInput)
    pub fn builder() -> crate::input::publish_schema_input::Builder {
        crate::input::publish_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PublishSchema {
    type Output =
        std::result::Result<crate::output::PublishSchemaOutput, crate::error::PublishSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_publish_schema_error(response)
        } else {
            crate::operation_deser::parse_publish_schema_response(response)
        }
    }
}

/// <p>Allows a schema to be updated using JSON upload. Only available for development schemas. See <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_jsonformat.html#schemas_json">JSON Schema Format</a> for more information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSchemaFromJson {
    _private: (),
}
impl PutSchemaFromJson {
    /// Creates a new builder-style object to manufacture [`PutSchemaFromJsonInput`](crate::input::PutSchemaFromJsonInput)
    pub fn builder() -> crate::input::put_schema_from_json_input::Builder {
        crate::input::put_schema_from_json_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSchemaFromJson {
    type Output = std::result::Result<
        crate::output::PutSchemaFromJsonOutput,
        crate::error::PutSchemaFromJsonError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_schema_from_json_error(response)
        } else {
            crate::operation_deser::parse_put_schema_from_json_response(response)
        }
    }
}

/// <p>Removes the specified facet from the specified object.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveFacetFromObject {
    _private: (),
}
impl RemoveFacetFromObject {
    /// Creates a new builder-style object to manufacture [`RemoveFacetFromObjectInput`](crate::input::RemoveFacetFromObjectInput)
    pub fn builder() -> crate::input::remove_facet_from_object_input::Builder {
        crate::input::remove_facet_from_object_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveFacetFromObject {
    type Output = std::result::Result<
        crate::output::RemoveFacetFromObjectOutput,
        crate::error::RemoveFacetFromObjectError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_facet_from_object_error(response)
        } else {
            crate::operation_deser::parse_remove_facet_from_object_response(response)
        }
    }
}

/// <p>An API operation for adding tags to a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>An API operation for removing tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Does the following:</p>
/// <ol>
/// <li>
/// <p>Adds new <code>Attributes</code>, <code>Rules</code>, or <code>ObjectTypes</code>.</p>
/// </li>
/// <li>
/// <p>Updates existing <code>Attributes</code>, <code>Rules</code>, or <code>ObjectTypes</code>.</p>
/// </li>
/// <li>
/// <p>Deletes existing <code>Attributes</code>, <code>Rules</code>, or <code>ObjectTypes</code>.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFacet {
    _private: (),
}
impl UpdateFacet {
    /// Creates a new builder-style object to manufacture [`UpdateFacetInput`](crate::input::UpdateFacetInput)
    pub fn builder() -> crate::input::update_facet_input::Builder {
        crate::input::update_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFacet {
    type Output =
        std::result::Result<crate::output::UpdateFacetOutput, crate::error::UpdateFacetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_facet_error(response)
        } else {
            crate::operation_deser::parse_update_facet_response(response)
        }
    }
}

/// <p>Updates a given typed link’s attributes. Attributes to be updated must not contribute to the typed link’s identity, as defined by its <code>IdentityAttributeOrder</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateLinkAttributes {
    _private: (),
}
impl UpdateLinkAttributes {
    /// Creates a new builder-style object to manufacture [`UpdateLinkAttributesInput`](crate::input::UpdateLinkAttributesInput)
    pub fn builder() -> crate::input::update_link_attributes_input::Builder {
        crate::input::update_link_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateLinkAttributes {
    type Output = std::result::Result<
        crate::output::UpdateLinkAttributesOutput,
        crate::error::UpdateLinkAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_link_attributes_error(response)
        } else {
            crate::operation_deser::parse_update_link_attributes_response(response)
        }
    }
}

/// <p>Updates a given object's attributes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateObjectAttributes {
    _private: (),
}
impl UpdateObjectAttributes {
    /// Creates a new builder-style object to manufacture [`UpdateObjectAttributesInput`](crate::input::UpdateObjectAttributesInput)
    pub fn builder() -> crate::input::update_object_attributes_input::Builder {
        crate::input::update_object_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateObjectAttributes {
    type Output = std::result::Result<
        crate::output::UpdateObjectAttributesOutput,
        crate::error::UpdateObjectAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_object_attributes_error(response)
        } else {
            crate::operation_deser::parse_update_object_attributes_response(response)
        }
    }
}

/// <p>Updates the schema name with a new name. Only development schema names can be
/// updated.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSchema {
    _private: (),
}
impl UpdateSchema {
    /// Creates a new builder-style object to manufacture [`UpdateSchemaInput`](crate::input::UpdateSchemaInput)
    pub fn builder() -> crate::input::update_schema_input::Builder {
        crate::input::update_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSchema {
    type Output =
        std::result::Result<crate::output::UpdateSchemaOutput, crate::error::UpdateSchemaError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_schema_error(response)
        } else {
            crate::operation_deser::parse_update_schema_response(response)
        }
    }
}

/// <p>Updates a <a>TypedLinkFacet</a>. For more information, see <a href="https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink">Typed Links</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTypedLinkFacet {
    _private: (),
}
impl UpdateTypedLinkFacet {
    /// Creates a new builder-style object to manufacture [`UpdateTypedLinkFacetInput`](crate::input::UpdateTypedLinkFacetInput)
    pub fn builder() -> crate::input::update_typed_link_facet_input::Builder {
        crate::input::update_typed_link_facet_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTypedLinkFacet {
    type Output = std::result::Result<
        crate::output::UpdateTypedLinkFacetOutput,
        crate::error::UpdateTypedLinkFacetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_typed_link_facet_error(response)
        } else {
            crate::operation_deser::parse_update_typed_link_facet_response(response)
        }
    }
}

/// <p>Upgrades a single directory in-place using the <code>PublishedSchemaArn</code> with schema updates found in <code>MinorVersion</code>. Backwards-compatible minor version upgrades are instantaneously available for readers on all objects in the directory. Note: This is a synchronous API call and upgrades only one schema on a given directory per call. To upgrade multiple directories from one schema, you would need to call this API on each directory.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpgradeAppliedSchema {
    _private: (),
}
impl UpgradeAppliedSchema {
    /// Creates a new builder-style object to manufacture [`UpgradeAppliedSchemaInput`](crate::input::UpgradeAppliedSchemaInput)
    pub fn builder() -> crate::input::upgrade_applied_schema_input::Builder {
        crate::input::upgrade_applied_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpgradeAppliedSchema {
    type Output = std::result::Result<
        crate::output::UpgradeAppliedSchemaOutput,
        crate::error::UpgradeAppliedSchemaError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_upgrade_applied_schema_error(response)
        } else {
            crate::operation_deser::parse_upgrade_applied_schema_response(response)
        }
    }
}

/// <p>Upgrades a published schema under a new minor version revision using the current contents of <code>DevelopmentSchemaArn</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpgradePublishedSchema {
    _private: (),
}
impl UpgradePublishedSchema {
    /// Creates a new builder-style object to manufacture [`UpgradePublishedSchemaInput`](crate::input::UpgradePublishedSchemaInput)
    pub fn builder() -> crate::input::upgrade_published_schema_input::Builder {
        crate::input::upgrade_published_schema_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpgradePublishedSchema {
    type Output = std::result::Result<
        crate::output::UpgradePublishedSchemaOutput,
        crate::error::UpgradePublishedSchemaError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_upgrade_published_schema_error(response)
        } else {
            crate::operation_deser::parse_upgrade_published_schema_response(response)
        }
    }
}
