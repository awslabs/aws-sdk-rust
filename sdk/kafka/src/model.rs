// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `StorageMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let storagemode = unimplemented!();
/// match storagemode {
///     StorageMode::Local => { /* ... */ },
///     StorageMode::Tiered => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `storagemode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StorageMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StorageMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StorageMode::NewFeature` is defined.
/// Specifically, when `storagemode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StorageMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Controls storage mode for various supported storage tiers.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StorageMode {
    #[allow(missing_docs)] // documentation missing in model
    Local,
    #[allow(missing_docs)] // documentation missing in model
    Tiered,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StorageMode {
    fn from(s: &str) -> Self {
        match s {
            "LOCAL" => StorageMode::Local,
            "TIERED" => StorageMode::Tiered,
            other => StorageMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StorageMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StorageMode::from(s))
    }
}
impl StorageMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StorageMode::Local => "LOCAL",
            StorageMode::Tiered => "TIERED",
            StorageMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LOCAL", "TIERED"]
    }
}
impl AsRef<str> for StorageMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedThroughput {
    /// <p>Provisioned throughput is enabled or not.</p>
    #[doc(hidden)]
    pub enabled: bool,
    /// <p>Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.</p>
    #[doc(hidden)]
    pub volume_throughput: i32,
}
impl ProvisionedThroughput {
    /// <p>Provisioned throughput is enabled or not.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    /// <p>Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.</p>
    pub fn volume_throughput(&self) -> i32 {
        self.volume_throughput
    }
}
/// See [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
pub mod provisioned_throughput {

    /// A builder for [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) volume_throughput: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Provisioned throughput is enabled or not.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Provisioned throughput is enabled or not.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.</p>
        pub fn volume_throughput(mut self, input: i32) -> Self {
            self.volume_throughput = Some(input);
            self
        }
        /// <p>Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.</p>
        pub fn set_volume_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
        pub fn build(self) -> crate::model::ProvisionedThroughput {
            crate::model::ProvisionedThroughput {
                enabled: self.enabled.unwrap_or_default(),
                volume_throughput: self.volume_throughput.unwrap_or_default(),
            }
        }
    }
}
impl ProvisionedThroughput {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
    pub fn builder() -> crate::model::provisioned_throughput::Builder {
        crate::model::provisioned_throughput::Builder::default()
    }
}

/// <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionInfo {
    /// <p>The data-volume encryption details.</p>
    #[doc(hidden)]
    pub encryption_at_rest: std::option::Option<crate::model::EncryptionAtRest>,
    /// <p>The details for encryption in transit.</p>
    #[doc(hidden)]
    pub encryption_in_transit: std::option::Option<crate::model::EncryptionInTransit>,
}
impl EncryptionInfo {
    /// <p>The data-volume encryption details.</p>
    pub fn encryption_at_rest(&self) -> std::option::Option<&crate::model::EncryptionAtRest> {
        self.encryption_at_rest.as_ref()
    }
    /// <p>The details for encryption in transit.</p>
    pub fn encryption_in_transit(&self) -> std::option::Option<&crate::model::EncryptionInTransit> {
        self.encryption_in_transit.as_ref()
    }
}
/// See [`EncryptionInfo`](crate::model::EncryptionInfo).
pub mod encryption_info {

    /// A builder for [`EncryptionInfo`](crate::model::EncryptionInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_at_rest: std::option::Option<crate::model::EncryptionAtRest>,
        pub(crate) encryption_in_transit: std::option::Option<crate::model::EncryptionInTransit>,
    }
    impl Builder {
        /// <p>The data-volume encryption details.</p>
        pub fn encryption_at_rest(mut self, input: crate::model::EncryptionAtRest) -> Self {
            self.encryption_at_rest = Some(input);
            self
        }
        /// <p>The data-volume encryption details.</p>
        pub fn set_encryption_at_rest(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRest>,
        ) -> Self {
            self.encryption_at_rest = input;
            self
        }
        /// <p>The details for encryption in transit.</p>
        pub fn encryption_in_transit(mut self, input: crate::model::EncryptionInTransit) -> Self {
            self.encryption_in_transit = Some(input);
            self
        }
        /// <p>The details for encryption in transit.</p>
        pub fn set_encryption_in_transit(
            mut self,
            input: std::option::Option<crate::model::EncryptionInTransit>,
        ) -> Self {
            self.encryption_in_transit = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionInfo`](crate::model::EncryptionInfo).
        pub fn build(self) -> crate::model::EncryptionInfo {
            crate::model::EncryptionInfo {
                encryption_at_rest: self.encryption_at_rest,
                encryption_in_transit: self.encryption_in_transit,
            }
        }
    }
}
impl EncryptionInfo {
    /// Creates a new builder-style object to manufacture [`EncryptionInfo`](crate::model::EncryptionInfo).
    pub fn builder() -> crate::model::encryption_info::Builder {
        crate::model::encryption_info::Builder::default()
    }
}

/// <p>The settings for encrypting data in transit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionInTransit {
    /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
    /// <p> TLS means that client-broker communication is enabled with TLS only.</p>
    /// <p> TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
    /// <p> PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
    /// <p>The default value is TLS_PLAINTEXT.</p>
    #[doc(hidden)]
    pub client_broker: std::option::Option<crate::model::ClientBroker>,
    /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
    /// <p>The default value is true.</p>
    #[doc(hidden)]
    pub in_cluster: bool,
}
impl EncryptionInTransit {
    /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
    /// <p> TLS means that client-broker communication is enabled with TLS only.</p>
    /// <p> TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
    /// <p> PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
    /// <p>The default value is TLS_PLAINTEXT.</p>
    pub fn client_broker(&self) -> std::option::Option<&crate::model::ClientBroker> {
        self.client_broker.as_ref()
    }
    /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
    /// <p>The default value is true.</p>
    pub fn in_cluster(&self) -> bool {
        self.in_cluster
    }
}
/// See [`EncryptionInTransit`](crate::model::EncryptionInTransit).
pub mod encryption_in_transit {

    /// A builder for [`EncryptionInTransit`](crate::model::EncryptionInTransit).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_broker: std::option::Option<crate::model::ClientBroker>,
        pub(crate) in_cluster: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
        /// <p> TLS means that client-broker communication is enabled with TLS only.</p>
        /// <p> TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
        /// <p> PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
        /// <p>The default value is TLS_PLAINTEXT.</p>
        pub fn client_broker(mut self, input: crate::model::ClientBroker) -> Self {
            self.client_broker = Some(input);
            self
        }
        /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
        /// <p> TLS means that client-broker communication is enabled with TLS only.</p>
        /// <p> TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
        /// <p> PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
        /// <p>The default value is TLS_PLAINTEXT.</p>
        pub fn set_client_broker(
            mut self,
            input: std::option::Option<crate::model::ClientBroker>,
        ) -> Self {
            self.client_broker = input;
            self
        }
        /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
        /// <p>The default value is true.</p>
        pub fn in_cluster(mut self, input: bool) -> Self {
            self.in_cluster = Some(input);
            self
        }
        /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
        /// <p>The default value is true.</p>
        pub fn set_in_cluster(mut self, input: std::option::Option<bool>) -> Self {
            self.in_cluster = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionInTransit`](crate::model::EncryptionInTransit).
        pub fn build(self) -> crate::model::EncryptionInTransit {
            crate::model::EncryptionInTransit {
                client_broker: self.client_broker,
                in_cluster: self.in_cluster.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionInTransit {
    /// Creates a new builder-style object to manufacture [`EncryptionInTransit`](crate::model::EncryptionInTransit).
    pub fn builder() -> crate::model::encryption_in_transit::Builder {
        crate::model::encryption_in_transit::Builder::default()
    }
}

/// When writing a match expression against `ClientBroker`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let clientbroker = unimplemented!();
/// match clientbroker {
///     ClientBroker::Plaintext => { /* ... */ },
///     ClientBroker::Tls => { /* ... */ },
///     ClientBroker::TlsPlaintext => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clientbroker` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClientBroker::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClientBroker::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClientBroker::NewFeature` is defined.
/// Specifically, when `clientbroker` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClientBroker::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Client-broker encryption in transit setting.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientBroker {
    #[allow(missing_docs)] // documentation missing in model
    Plaintext,
    #[allow(missing_docs)] // documentation missing in model
    Tls,
    #[allow(missing_docs)] // documentation missing in model
    TlsPlaintext,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ClientBroker {
    fn from(s: &str) -> Self {
        match s {
            "PLAINTEXT" => ClientBroker::Plaintext,
            "TLS" => ClientBroker::Tls,
            "TLS_PLAINTEXT" => ClientBroker::TlsPlaintext,
            other => ClientBroker::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ClientBroker {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientBroker::from(s))
    }
}
impl ClientBroker {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClientBroker::Plaintext => "PLAINTEXT",
            ClientBroker::Tls => "TLS",
            ClientBroker::TlsPlaintext => "TLS_PLAINTEXT",
            ClientBroker::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PLAINTEXT", "TLS", "TLS_PLAINTEXT"]
    }
}
impl AsRef<str> for ClientBroker {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data-volume encryption details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionAtRest {
    /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
    #[doc(hidden)]
    pub data_volume_kms_key_id: std::option::Option<std::string::String>,
}
impl EncryptionAtRest {
    /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
    pub fn data_volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.data_volume_kms_key_id.as_deref()
    }
}
/// See [`EncryptionAtRest`](crate::model::EncryptionAtRest).
pub mod encryption_at_rest {

    /// A builder for [`EncryptionAtRest`](crate::model::EncryptionAtRest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
        pub fn data_volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
        pub fn set_data_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRest`](crate::model::EncryptionAtRest).
        pub fn build(self) -> crate::model::EncryptionAtRest {
            crate::model::EncryptionAtRest {
                data_volume_kms_key_id: self.data_volume_kms_key_id,
            }
        }
    }
}
impl EncryptionAtRest {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRest`](crate::model::EncryptionAtRest).
    pub fn builder() -> crate::model::encryption_at_rest::Builder {
        crate::model::encryption_at_rest::Builder::default()
    }
}

/// <p>Includes all client authentication information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClientAuthentication {
    /// <p>Details for ClientAuthentication using SASL.</p>
    #[doc(hidden)]
    pub sasl: std::option::Option<crate::model::Sasl>,
    /// <p>Details for ClientAuthentication using TLS.</p>
    #[doc(hidden)]
    pub tls: std::option::Option<crate::model::Tls>,
    /// <p>Contains information about unauthenticated traffic to the cluster.</p>
    #[doc(hidden)]
    pub unauthenticated: std::option::Option<crate::model::Unauthenticated>,
}
impl ClientAuthentication {
    /// <p>Details for ClientAuthentication using SASL.</p>
    pub fn sasl(&self) -> std::option::Option<&crate::model::Sasl> {
        self.sasl.as_ref()
    }
    /// <p>Details for ClientAuthentication using TLS.</p>
    pub fn tls(&self) -> std::option::Option<&crate::model::Tls> {
        self.tls.as_ref()
    }
    /// <p>Contains information about unauthenticated traffic to the cluster.</p>
    pub fn unauthenticated(&self) -> std::option::Option<&crate::model::Unauthenticated> {
        self.unauthenticated.as_ref()
    }
}
/// See [`ClientAuthentication`](crate::model::ClientAuthentication).
pub mod client_authentication {

    /// A builder for [`ClientAuthentication`](crate::model::ClientAuthentication).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sasl: std::option::Option<crate::model::Sasl>,
        pub(crate) tls: std::option::Option<crate::model::Tls>,
        pub(crate) unauthenticated: std::option::Option<crate::model::Unauthenticated>,
    }
    impl Builder {
        /// <p>Details for ClientAuthentication using SASL.</p>
        pub fn sasl(mut self, input: crate::model::Sasl) -> Self {
            self.sasl = Some(input);
            self
        }
        /// <p>Details for ClientAuthentication using SASL.</p>
        pub fn set_sasl(mut self, input: std::option::Option<crate::model::Sasl>) -> Self {
            self.sasl = input;
            self
        }
        /// <p>Details for ClientAuthentication using TLS.</p>
        pub fn tls(mut self, input: crate::model::Tls) -> Self {
            self.tls = Some(input);
            self
        }
        /// <p>Details for ClientAuthentication using TLS.</p>
        pub fn set_tls(mut self, input: std::option::Option<crate::model::Tls>) -> Self {
            self.tls = input;
            self
        }
        /// <p>Contains information about unauthenticated traffic to the cluster.</p>
        pub fn unauthenticated(mut self, input: crate::model::Unauthenticated) -> Self {
            self.unauthenticated = Some(input);
            self
        }
        /// <p>Contains information about unauthenticated traffic to the cluster.</p>
        pub fn set_unauthenticated(
            mut self,
            input: std::option::Option<crate::model::Unauthenticated>,
        ) -> Self {
            self.unauthenticated = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientAuthentication`](crate::model::ClientAuthentication).
        pub fn build(self) -> crate::model::ClientAuthentication {
            crate::model::ClientAuthentication {
                sasl: self.sasl,
                tls: self.tls,
                unauthenticated: self.unauthenticated,
            }
        }
    }
}
impl ClientAuthentication {
    /// Creates a new builder-style object to manufacture [`ClientAuthentication`](crate::model::ClientAuthentication).
    pub fn builder() -> crate::model::client_authentication::Builder {
        crate::model::client_authentication::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Unauthenticated {
    /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
    #[doc(hidden)]
    pub enabled: bool,
}
impl Unauthenticated {
    /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
/// See [`Unauthenticated`](crate::model::Unauthenticated).
pub mod unauthenticated {

    /// A builder for [`Unauthenticated`](crate::model::Unauthenticated).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Unauthenticated`](crate::model::Unauthenticated).
        pub fn build(self) -> crate::model::Unauthenticated {
            crate::model::Unauthenticated {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Unauthenticated {
    /// Creates a new builder-style object to manufacture [`Unauthenticated`](crate::model::Unauthenticated).
    pub fn builder() -> crate::model::unauthenticated::Builder {
        crate::model::unauthenticated::Builder::default()
    }
}

/// <p>Details for client authentication using TLS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tls {
    /// <p>List of ACM Certificate Authority ARNs.</p>
    #[doc(hidden)]
    pub certificate_authority_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
    #[doc(hidden)]
    pub enabled: bool,
}
impl Tls {
    /// <p>List of ACM Certificate Authority ARNs.</p>
    pub fn certificate_authority_arn_list(&self) -> std::option::Option<&[std::string::String]> {
        self.certificate_authority_arn_list.as_deref()
    }
    /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
/// See [`Tls`](crate::model::Tls).
pub mod tls {

    /// A builder for [`Tls`](crate::model::Tls).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_authority_arn_list:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `certificate_authority_arn_list`.
        ///
        /// To override the contents of this collection use [`set_certificate_authority_arn_list`](Self::set_certificate_authority_arn_list).
        ///
        /// <p>List of ACM Certificate Authority ARNs.</p>
        pub fn certificate_authority_arn_list(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.certificate_authority_arn_list.unwrap_or_default();
            v.push(input.into());
            self.certificate_authority_arn_list = Some(v);
            self
        }
        /// <p>List of ACM Certificate Authority ARNs.</p>
        pub fn set_certificate_authority_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.certificate_authority_arn_list = input;
            self
        }
        /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Tls`](crate::model::Tls).
        pub fn build(self) -> crate::model::Tls {
            crate::model::Tls {
                certificate_authority_arn_list: self.certificate_authority_arn_list,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Tls {
    /// Creates a new builder-style object to manufacture [`Tls`](crate::model::Tls).
    pub fn builder() -> crate::model::tls::Builder {
        crate::model::tls::Builder::default()
    }
}

/// <p>Details for client authentication using SASL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Sasl {
    /// <p>Details for SASL/SCRAM client authentication.</p>
    #[doc(hidden)]
    pub scram: std::option::Option<crate::model::Scram>,
    /// <p>Indicates whether IAM access control is enabled.</p>
    #[doc(hidden)]
    pub iam: std::option::Option<crate::model::Iam>,
}
impl Sasl {
    /// <p>Details for SASL/SCRAM client authentication.</p>
    pub fn scram(&self) -> std::option::Option<&crate::model::Scram> {
        self.scram.as_ref()
    }
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub fn iam(&self) -> std::option::Option<&crate::model::Iam> {
        self.iam.as_ref()
    }
}
/// See [`Sasl`](crate::model::Sasl).
pub mod sasl {

    /// A builder for [`Sasl`](crate::model::Sasl).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scram: std::option::Option<crate::model::Scram>,
        pub(crate) iam: std::option::Option<crate::model::Iam>,
    }
    impl Builder {
        /// <p>Details for SASL/SCRAM client authentication.</p>
        pub fn scram(mut self, input: crate::model::Scram) -> Self {
            self.scram = Some(input);
            self
        }
        /// <p>Details for SASL/SCRAM client authentication.</p>
        pub fn set_scram(mut self, input: std::option::Option<crate::model::Scram>) -> Self {
            self.scram = input;
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn iam(mut self, input: crate::model::Iam) -> Self {
            self.iam = Some(input);
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn set_iam(mut self, input: std::option::Option<crate::model::Iam>) -> Self {
            self.iam = input;
            self
        }
        /// Consumes the builder and constructs a [`Sasl`](crate::model::Sasl).
        pub fn build(self) -> crate::model::Sasl {
            crate::model::Sasl {
                scram: self.scram,
                iam: self.iam,
            }
        }
    }
}
impl Sasl {
    /// Creates a new builder-style object to manufacture [`Sasl`](crate::model::Sasl).
    pub fn builder() -> crate::model::sasl::Builder {
        crate::model::sasl::Builder::default()
    }
}

/// <p>Details for IAM access control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Iam {
    /// <p>Indicates whether IAM access control is enabled.</p>
    #[doc(hidden)]
    pub enabled: bool,
}
impl Iam {
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
/// See [`Iam`](crate::model::Iam).
pub mod iam {

    /// A builder for [`Iam`](crate::model::Iam).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Iam`](crate::model::Iam).
        pub fn build(self) -> crate::model::Iam {
            crate::model::Iam {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Iam {
    /// Creates a new builder-style object to manufacture [`Iam`](crate::model::Iam).
    pub fn builder() -> crate::model::iam::Builder {
        crate::model::iam::Builder::default()
    }
}

/// <p>Details for SASL/SCRAM client authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Scram {
    /// <p>SASL/SCRAM authentication is enabled or not.</p>
    #[doc(hidden)]
    pub enabled: bool,
}
impl Scram {
    /// <p>SASL/SCRAM authentication is enabled or not.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
/// See [`Scram`](crate::model::Scram).
pub mod scram {

    /// A builder for [`Scram`](crate::model::Scram).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>SASL/SCRAM authentication is enabled or not.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>SASL/SCRAM authentication is enabled or not.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Scram`](crate::model::Scram).
        pub fn build(self) -> crate::model::Scram {
            crate::model::Scram {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Scram {
    /// Creates a new builder-style object to manufacture [`Scram`](crate::model::Scram).
    pub fn builder() -> crate::model::scram::Builder {
        crate::model::scram::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoggingInfo {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub broker_logs: std::option::Option<crate::model::BrokerLogs>,
}
impl LoggingInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub fn broker_logs(&self) -> std::option::Option<&crate::model::BrokerLogs> {
        self.broker_logs.as_ref()
    }
}
/// See [`LoggingInfo`](crate::model::LoggingInfo).
pub mod logging_info {

    /// A builder for [`LoggingInfo`](crate::model::LoggingInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_logs: std::option::Option<crate::model::BrokerLogs>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn broker_logs(mut self, input: crate::model::BrokerLogs) -> Self {
            self.broker_logs = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_broker_logs(
            mut self,
            input: std::option::Option<crate::model::BrokerLogs>,
        ) -> Self {
            self.broker_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingInfo`](crate::model::LoggingInfo).
        pub fn build(self) -> crate::model::LoggingInfo {
            crate::model::LoggingInfo {
                broker_logs: self.broker_logs,
            }
        }
    }
}
impl LoggingInfo {
    /// Creates a new builder-style object to manufacture [`LoggingInfo`](crate::model::LoggingInfo).
    pub fn builder() -> crate::model::logging_info::Builder {
        crate::model::logging_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BrokerLogs {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub cloud_watch_logs: std::option::Option<crate::model::CloudWatchLogs>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub firehose: std::option::Option<crate::model::Firehose>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub s3: std::option::Option<crate::model::S3>,
}
impl BrokerLogs {
    #[allow(missing_docs)] // documentation missing in model
    pub fn cloud_watch_logs(&self) -> std::option::Option<&crate::model::CloudWatchLogs> {
        self.cloud_watch_logs.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn firehose(&self) -> std::option::Option<&crate::model::Firehose> {
        self.firehose.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn s3(&self) -> std::option::Option<&crate::model::S3> {
        self.s3.as_ref()
    }
}
/// See [`BrokerLogs`](crate::model::BrokerLogs).
pub mod broker_logs {

    /// A builder for [`BrokerLogs`](crate::model::BrokerLogs).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs: std::option::Option<crate::model::CloudWatchLogs>,
        pub(crate) firehose: std::option::Option<crate::model::Firehose>,
        pub(crate) s3: std::option::Option<crate::model::S3>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn cloud_watch_logs(mut self, input: crate::model::CloudWatchLogs) -> Self {
            self.cloud_watch_logs = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_cloud_watch_logs(
            mut self,
            input: std::option::Option<crate::model::CloudWatchLogs>,
        ) -> Self {
            self.cloud_watch_logs = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn firehose(mut self, input: crate::model::Firehose) -> Self {
            self.firehose = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_firehose(mut self, input: std::option::Option<crate::model::Firehose>) -> Self {
            self.firehose = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn s3(mut self, input: crate::model::S3) -> Self {
            self.s3 = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_s3(mut self, input: std::option::Option<crate::model::S3>) -> Self {
            self.s3 = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerLogs`](crate::model::BrokerLogs).
        pub fn build(self) -> crate::model::BrokerLogs {
            crate::model::BrokerLogs {
                cloud_watch_logs: self.cloud_watch_logs,
                firehose: self.firehose,
                s3: self.s3,
            }
        }
    }
}
impl BrokerLogs {
    /// Creates a new builder-style object to manufacture [`BrokerLogs`](crate::model::BrokerLogs).
    pub fn builder() -> crate::model::broker_logs::Builder {
        crate::model::broker_logs::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3 {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub enabled: bool,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub prefix: std::option::Option<std::string::String>,
}
impl S3 {
    #[allow(missing_docs)] // documentation missing in model
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
/// See [`S3`](crate::model::S3).
pub mod s3 {

    /// A builder for [`S3`](crate::model::S3).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`S3`](crate::model::S3).
        pub fn build(self) -> crate::model::S3 {
            crate::model::S3 {
                bucket: self.bucket,
                enabled: self.enabled.unwrap_or_default(),
                prefix: self.prefix,
            }
        }
    }
}
impl S3 {
    /// Creates a new builder-style object to manufacture [`S3`](crate::model::S3).
    pub fn builder() -> crate::model::s3::Builder {
        crate::model::s3::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Firehose {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub delivery_stream: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub enabled: bool,
}
impl Firehose {
    #[allow(missing_docs)] // documentation missing in model
    pub fn delivery_stream(&self) -> std::option::Option<&str> {
        self.delivery_stream.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
/// See [`Firehose`](crate::model::Firehose).
pub mod firehose {

    /// A builder for [`Firehose`](crate::model::Firehose).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_stream: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn delivery_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_stream = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_delivery_stream(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_stream = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Firehose`](crate::model::Firehose).
        pub fn build(self) -> crate::model::Firehose {
            crate::model::Firehose {
                delivery_stream: self.delivery_stream,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Firehose {
    /// Creates a new builder-style object to manufacture [`Firehose`](crate::model::Firehose).
    pub fn builder() -> crate::model::firehose::Builder {
        crate::model::firehose::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudWatchLogs {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub enabled: bool,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub log_group: std::option::Option<std::string::String>,
}
impl CloudWatchLogs {
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn log_group(&self) -> std::option::Option<&str> {
        self.log_group.as_deref()
    }
}
/// See [`CloudWatchLogs`](crate::model::CloudWatchLogs).
pub mod cloud_watch_logs {

    /// A builder for [`CloudWatchLogs`](crate::model::CloudWatchLogs).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) log_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_log_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_group = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLogs`](crate::model::CloudWatchLogs).
        pub fn build(self) -> crate::model::CloudWatchLogs {
            crate::model::CloudWatchLogs {
                enabled: self.enabled.unwrap_or_default(),
                log_group: self.log_group,
            }
        }
    }
}
impl CloudWatchLogs {
    /// Creates a new builder-style object to manufacture [`CloudWatchLogs`](crate::model::CloudWatchLogs).
    pub fn builder() -> crate::model::cloud_watch_logs::Builder {
        crate::model::cloud_watch_logs::Builder::default()
    }
}

/// <p>JMX and Node monitoring for the MSK cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OpenMonitoringInfo {
    /// <p>Prometheus settings.</p>
    #[doc(hidden)]
    pub prometheus: std::option::Option<crate::model::PrometheusInfo>,
}
impl OpenMonitoringInfo {
    /// <p>Prometheus settings.</p>
    pub fn prometheus(&self) -> std::option::Option<&crate::model::PrometheusInfo> {
        self.prometheus.as_ref()
    }
}
/// See [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo).
pub mod open_monitoring_info {

    /// A builder for [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prometheus: std::option::Option<crate::model::PrometheusInfo>,
    }
    impl Builder {
        /// <p>Prometheus settings.</p>
        pub fn prometheus(mut self, input: crate::model::PrometheusInfo) -> Self {
            self.prometheus = Some(input);
            self
        }
        /// <p>Prometheus settings.</p>
        pub fn set_prometheus(
            mut self,
            input: std::option::Option<crate::model::PrometheusInfo>,
        ) -> Self {
            self.prometheus = input;
            self
        }
        /// Consumes the builder and constructs a [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo).
        pub fn build(self) -> crate::model::OpenMonitoringInfo {
            crate::model::OpenMonitoringInfo {
                prometheus: self.prometheus,
            }
        }
    }
}
impl OpenMonitoringInfo {
    /// Creates a new builder-style object to manufacture [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo).
    pub fn builder() -> crate::model::open_monitoring_info::Builder {
        crate::model::open_monitoring_info::Builder::default()
    }
}

/// <p>Prometheus settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PrometheusInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    #[doc(hidden)]
    pub jmx_exporter: std::option::Option<crate::model::JmxExporterInfo>,
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    #[doc(hidden)]
    pub node_exporter: std::option::Option<crate::model::NodeExporterInfo>,
}
impl PrometheusInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn jmx_exporter(&self) -> std::option::Option<&crate::model::JmxExporterInfo> {
        self.jmx_exporter.as_ref()
    }
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn node_exporter(&self) -> std::option::Option<&crate::model::NodeExporterInfo> {
        self.node_exporter.as_ref()
    }
}
/// See [`PrometheusInfo`](crate::model::PrometheusInfo).
pub mod prometheus_info {

    /// A builder for [`PrometheusInfo`](crate::model::PrometheusInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jmx_exporter: std::option::Option<crate::model::JmxExporterInfo>,
        pub(crate) node_exporter: std::option::Option<crate::model::NodeExporterInfo>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn jmx_exporter(mut self, input: crate::model::JmxExporterInfo) -> Self {
            self.jmx_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_jmx_exporter(
            mut self,
            input: std::option::Option<crate::model::JmxExporterInfo>,
        ) -> Self {
            self.jmx_exporter = input;
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn node_exporter(mut self, input: crate::model::NodeExporterInfo) -> Self {
            self.node_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_node_exporter(
            mut self,
            input: std::option::Option<crate::model::NodeExporterInfo>,
        ) -> Self {
            self.node_exporter = input;
            self
        }
        /// Consumes the builder and constructs a [`PrometheusInfo`](crate::model::PrometheusInfo).
        pub fn build(self) -> crate::model::PrometheusInfo {
            crate::model::PrometheusInfo {
                jmx_exporter: self.jmx_exporter,
                node_exporter: self.node_exporter,
            }
        }
    }
}
impl PrometheusInfo {
    /// Creates a new builder-style object to manufacture [`PrometheusInfo`](crate::model::PrometheusInfo).
    pub fn builder() -> crate::model::prometheus_info::Builder {
        crate::model::prometheus_info::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    #[doc(hidden)]
    pub enabled_in_broker: bool,
}
impl NodeExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
/// See [`NodeExporterInfo`](crate::model::NodeExporterInfo).
pub mod node_exporter_info {

    /// A builder for [`NodeExporterInfo`](crate::model::NodeExporterInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeExporterInfo`](crate::model::NodeExporterInfo).
        pub fn build(self) -> crate::model::NodeExporterInfo {
            crate::model::NodeExporterInfo {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl NodeExporterInfo {
    /// Creates a new builder-style object to manufacture [`NodeExporterInfo`](crate::model::NodeExporterInfo).
    pub fn builder() -> crate::model::node_exporter_info::Builder {
        crate::model::node_exporter_info::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JmxExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    #[doc(hidden)]
    pub enabled_in_broker: bool,
}
impl JmxExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
/// See [`JmxExporterInfo`](crate::model::JmxExporterInfo).
pub mod jmx_exporter_info {

    /// A builder for [`JmxExporterInfo`](crate::model::JmxExporterInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`JmxExporterInfo`](crate::model::JmxExporterInfo).
        pub fn build(self) -> crate::model::JmxExporterInfo {
            crate::model::JmxExporterInfo {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl JmxExporterInfo {
    /// Creates a new builder-style object to manufacture [`JmxExporterInfo`](crate::model::JmxExporterInfo).
    pub fn builder() -> crate::model::jmx_exporter_info::Builder {
        crate::model::jmx_exporter_info::Builder::default()
    }
}

/// When writing a match expression against `EnhancedMonitoring`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let enhancedmonitoring = unimplemented!();
/// match enhancedmonitoring {
///     EnhancedMonitoring::Default => { /* ... */ },
///     EnhancedMonitoring::PerBroker => { /* ... */ },
///     EnhancedMonitoring::PerTopicPerBroker => { /* ... */ },
///     EnhancedMonitoring::PerTopicPerPartition => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `enhancedmonitoring` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EnhancedMonitoring::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EnhancedMonitoring::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EnhancedMonitoring::NewFeature` is defined.
/// Specifically, when `enhancedmonitoring` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EnhancedMonitoring::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EnhancedMonitoring {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    #[allow(missing_docs)] // documentation missing in model
    PerBroker,
    #[allow(missing_docs)] // documentation missing in model
    PerTopicPerBroker,
    #[allow(missing_docs)] // documentation missing in model
    PerTopicPerPartition,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EnhancedMonitoring {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => EnhancedMonitoring::Default,
            "PER_BROKER" => EnhancedMonitoring::PerBroker,
            "PER_TOPIC_PER_BROKER" => EnhancedMonitoring::PerTopicPerBroker,
            "PER_TOPIC_PER_PARTITION" => EnhancedMonitoring::PerTopicPerPartition,
            other => {
                EnhancedMonitoring::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for EnhancedMonitoring {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EnhancedMonitoring::from(s))
    }
}
impl EnhancedMonitoring {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnhancedMonitoring::Default => "DEFAULT",
            EnhancedMonitoring::PerBroker => "PER_BROKER",
            EnhancedMonitoring::PerTopicPerBroker => "PER_TOPIC_PER_BROKER",
            EnhancedMonitoring::PerTopicPerPartition => "PER_TOPIC_PER_PARTITION",
            EnhancedMonitoring::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEFAULT",
            "PER_BROKER",
            "PER_TOPIC_PER_BROKER",
            "PER_TOPIC_PER_PARTITION",
        ]
    }
}
impl AsRef<str> for EnhancedMonitoring {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the broker access configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectivityInfo {
    /// <p>Public access control for brokers.</p>
    #[doc(hidden)]
    pub public_access: std::option::Option<crate::model::PublicAccess>,
}
impl ConnectivityInfo {
    /// <p>Public access control for brokers.</p>
    pub fn public_access(&self) -> std::option::Option<&crate::model::PublicAccess> {
        self.public_access.as_ref()
    }
}
/// See [`ConnectivityInfo`](crate::model::ConnectivityInfo).
pub mod connectivity_info {

    /// A builder for [`ConnectivityInfo`](crate::model::ConnectivityInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) public_access: std::option::Option<crate::model::PublicAccess>,
    }
    impl Builder {
        /// <p>Public access control for brokers.</p>
        pub fn public_access(mut self, input: crate::model::PublicAccess) -> Self {
            self.public_access = Some(input);
            self
        }
        /// <p>Public access control for brokers.</p>
        pub fn set_public_access(
            mut self,
            input: std::option::Option<crate::model::PublicAccess>,
        ) -> Self {
            self.public_access = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectivityInfo`](crate::model::ConnectivityInfo).
        pub fn build(self) -> crate::model::ConnectivityInfo {
            crate::model::ConnectivityInfo {
                public_access: self.public_access,
            }
        }
    }
}
impl ConnectivityInfo {
    /// Creates a new builder-style object to manufacture [`ConnectivityInfo`](crate::model::ConnectivityInfo).
    pub fn builder() -> crate::model::connectivity_info::Builder {
        crate::model::connectivity_info::Builder::default()
    }
}

/// Public access control for brokers.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PublicAccess {
    /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl PublicAccess {
    /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`PublicAccess`](crate::model::PublicAccess).
pub mod public_access {

    /// A builder for [`PublicAccess`](crate::model::PublicAccess).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicAccess`](crate::model::PublicAccess).
        pub fn build(self) -> crate::model::PublicAccess {
            crate::model::PublicAccess {
                r#type: self.r#type,
            }
        }
    }
}
impl PublicAccess {
    /// Creates a new builder-style object to manufacture [`PublicAccess`](crate::model::PublicAccess).
    pub fn builder() -> crate::model::public_access::Builder {
        crate::model::public_access::Builder::default()
    }
}

/// <p>Describes a configuration revision.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationRevision {
    /// <p>The time when the configuration revision was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the configuration revision.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The revision number.</p>
    #[doc(hidden)]
    pub revision: i64,
}
impl ConfigurationRevision {
    /// <p>The time when the configuration revision was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The description of the configuration revision.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The revision number.</p>
    pub fn revision(&self) -> i64 {
        self.revision
    }
}
/// See [`ConfigurationRevision`](crate::model::ConfigurationRevision).
pub mod configuration_revision {

    /// A builder for [`ConfigurationRevision`](crate::model::ConfigurationRevision).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) revision: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The time when the configuration revision was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the configuration revision was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The description of the configuration revision.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the configuration revision.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The revision number.</p>
        pub fn revision(mut self, input: i64) -> Self {
            self.revision = Some(input);
            self
        }
        /// <p>The revision number.</p>
        pub fn set_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.revision = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationRevision`](crate::model::ConfigurationRevision).
        pub fn build(self) -> crate::model::ConfigurationRevision {
            crate::model::ConfigurationRevision {
                creation_time: self.creation_time,
                description: self.description,
                revision: self.revision.unwrap_or_default(),
            }
        }
    }
}
impl ConfigurationRevision {
    /// Creates a new builder-style object to manufacture [`ConfigurationRevision`](crate::model::ConfigurationRevision).
    pub fn builder() -> crate::model::configuration_revision::Builder {
        crate::model::configuration_revision::Builder::default()
    }
}

/// <p>Specifies the configuration to use for the brokers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationInfo {
    /// <p>ARN of the configuration to use.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The revision of the configuration to use.</p>
    #[doc(hidden)]
    pub revision: i64,
}
impl ConfigurationInfo {
    /// <p>ARN of the configuration to use.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The revision of the configuration to use.</p>
    pub fn revision(&self) -> i64 {
        self.revision
    }
}
/// See [`ConfigurationInfo`](crate::model::ConfigurationInfo).
pub mod configuration_info {

    /// A builder for [`ConfigurationInfo`](crate::model::ConfigurationInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) revision: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>ARN of the configuration to use.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>ARN of the configuration to use.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The revision of the configuration to use.</p>
        pub fn revision(mut self, input: i64) -> Self {
            self.revision = Some(input);
            self
        }
        /// <p>The revision of the configuration to use.</p>
        pub fn set_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.revision = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationInfo`](crate::model::ConfigurationInfo).
        pub fn build(self) -> crate::model::ConfigurationInfo {
            crate::model::ConfigurationInfo {
                arn: self.arn,
                revision: self.revision.unwrap_or_default(),
            }
        }
    }
}
impl ConfigurationInfo {
    /// Creates a new builder-style object to manufacture [`ConfigurationInfo`](crate::model::ConfigurationInfo).
    pub fn builder() -> crate::model::configuration_info::Builder {
        crate::model::configuration_info::Builder::default()
    }
}

/// <p>Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BrokerEbsVolumeInfo {
    /// <p>The ID of the broker to update.</p>
    #[doc(hidden)]
    pub kafka_broker_node_id: std::option::Option<std::string::String>,
    /// <p>EBS volume provisioned throughput information.</p>
    #[doc(hidden)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    /// <p>Size of the EBS volume to update.</p>
    #[doc(hidden)]
    pub volume_size_gb: i32,
}
impl BrokerEbsVolumeInfo {
    /// <p>The ID of the broker to update.</p>
    pub fn kafka_broker_node_id(&self) -> std::option::Option<&str> {
        self.kafka_broker_node_id.as_deref()
    }
    /// <p>EBS volume provisioned throughput information.</p>
    pub fn provisioned_throughput(
        &self,
    ) -> std::option::Option<&crate::model::ProvisionedThroughput> {
        self.provisioned_throughput.as_ref()
    }
    /// <p>Size of the EBS volume to update.</p>
    pub fn volume_size_gb(&self) -> i32 {
        self.volume_size_gb
    }
}
/// See [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo).
pub mod broker_ebs_volume_info {

    /// A builder for [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kafka_broker_node_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
        pub(crate) volume_size_gb: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the broker to update.</p>
        pub fn kafka_broker_node_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_broker_node_id = Some(input.into());
            self
        }
        /// <p>The ID of the broker to update.</p>
        pub fn set_kafka_broker_node_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_broker_node_id = input;
            self
        }
        /// <p>EBS volume provisioned throughput information.</p>
        pub fn provisioned_throughput(
            mut self,
            input: crate::model::ProvisionedThroughput,
        ) -> Self {
            self.provisioned_throughput = Some(input);
            self
        }
        /// <p>EBS volume provisioned throughput information.</p>
        pub fn set_provisioned_throughput(
            mut self,
            input: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = input;
            self
        }
        /// <p>Size of the EBS volume to update.</p>
        pub fn volume_size_gb(mut self, input: i32) -> Self {
            self.volume_size_gb = Some(input);
            self
        }
        /// <p>Size of the EBS volume to update.</p>
        pub fn set_volume_size_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_gb = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo).
        pub fn build(self) -> crate::model::BrokerEbsVolumeInfo {
            crate::model::BrokerEbsVolumeInfo {
                kafka_broker_node_id: self.kafka_broker_node_id,
                provisioned_throughput: self.provisioned_throughput,
                volume_size_gb: self.volume_size_gb.unwrap_or_default(),
            }
        }
    }
}
impl BrokerEbsVolumeInfo {
    /// Creates a new builder-style object to manufacture [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo).
    pub fn builder() -> crate::model::broker_ebs_volume_info::Builder {
        crate::model::broker_ebs_volume_info::Builder::default()
    }
}

/// <p>The node information object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeInfo {
    /// <p>The start time.</p>
    #[doc(hidden)]
    pub added_to_cluster_time: std::option::Option<std::string::String>,
    /// <p>The broker node info.</p>
    #[doc(hidden)]
    pub broker_node_info: std::option::Option<crate::model::BrokerNodeInfo>,
    /// <p>The instance type.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the node.</p>
    #[doc(hidden)]
    pub node_arn: std::option::Option<std::string::String>,
    /// <p>The node type.</p>
    #[doc(hidden)]
    pub node_type: std::option::Option<crate::model::NodeType>,
    /// <p>The ZookeeperNodeInfo.</p>
    #[doc(hidden)]
    pub zookeeper_node_info: std::option::Option<crate::model::ZookeeperNodeInfo>,
}
impl NodeInfo {
    /// <p>The start time.</p>
    pub fn added_to_cluster_time(&self) -> std::option::Option<&str> {
        self.added_to_cluster_time.as_deref()
    }
    /// <p>The broker node info.</p>
    pub fn broker_node_info(&self) -> std::option::Option<&crate::model::BrokerNodeInfo> {
        self.broker_node_info.as_ref()
    }
    /// <p>The instance type.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the node.</p>
    pub fn node_arn(&self) -> std::option::Option<&str> {
        self.node_arn.as_deref()
    }
    /// <p>The node type.</p>
    pub fn node_type(&self) -> std::option::Option<&crate::model::NodeType> {
        self.node_type.as_ref()
    }
    /// <p>The ZookeeperNodeInfo.</p>
    pub fn zookeeper_node_info(&self) -> std::option::Option<&crate::model::ZookeeperNodeInfo> {
        self.zookeeper_node_info.as_ref()
    }
}
/// See [`NodeInfo`](crate::model::NodeInfo).
pub mod node_info {

    /// A builder for [`NodeInfo`](crate::model::NodeInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) added_to_cluster_time: std::option::Option<std::string::String>,
        pub(crate) broker_node_info: std::option::Option<crate::model::BrokerNodeInfo>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) node_arn: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<crate::model::NodeType>,
        pub(crate) zookeeper_node_info: std::option::Option<crate::model::ZookeeperNodeInfo>,
    }
    impl Builder {
        /// <p>The start time.</p>
        pub fn added_to_cluster_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.added_to_cluster_time = Some(input.into());
            self
        }
        /// <p>The start time.</p>
        pub fn set_added_to_cluster_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.added_to_cluster_time = input;
            self
        }
        /// <p>The broker node info.</p>
        pub fn broker_node_info(mut self, input: crate::model::BrokerNodeInfo) -> Self {
            self.broker_node_info = Some(input);
            self
        }
        /// <p>The broker node info.</p>
        pub fn set_broker_node_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeInfo>,
        ) -> Self {
            self.broker_node_info = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the node.</p>
        pub fn node_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the node.</p>
        pub fn set_node_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_arn = input;
            self
        }
        /// <p>The node type.</p>
        pub fn node_type(mut self, input: crate::model::NodeType) -> Self {
            self.node_type = Some(input);
            self
        }
        /// <p>The node type.</p>
        pub fn set_node_type(mut self, input: std::option::Option<crate::model::NodeType>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The ZookeeperNodeInfo.</p>
        pub fn zookeeper_node_info(mut self, input: crate::model::ZookeeperNodeInfo) -> Self {
            self.zookeeper_node_info = Some(input);
            self
        }
        /// <p>The ZookeeperNodeInfo.</p>
        pub fn set_zookeeper_node_info(
            mut self,
            input: std::option::Option<crate::model::ZookeeperNodeInfo>,
        ) -> Self {
            self.zookeeper_node_info = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeInfo`](crate::model::NodeInfo).
        pub fn build(self) -> crate::model::NodeInfo {
            crate::model::NodeInfo {
                added_to_cluster_time: self.added_to_cluster_time,
                broker_node_info: self.broker_node_info,
                instance_type: self.instance_type,
                node_arn: self.node_arn,
                node_type: self.node_type,
                zookeeper_node_info: self.zookeeper_node_info,
            }
        }
    }
}
impl NodeInfo {
    /// Creates a new builder-style object to manufacture [`NodeInfo`](crate::model::NodeInfo).
    pub fn builder() -> crate::model::node_info::Builder {
        crate::model::node_info::Builder::default()
    }
}

/// <p>Zookeeper node information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ZookeeperNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    #[doc(hidden)]
    pub attached_eni_id: std::option::Option<std::string::String>,
    /// <p>The virtual private cloud (VPC) IP address of the client.</p>
    #[doc(hidden)]
    pub client_vpc_ip_address: std::option::Option<std::string::String>,
    /// <p>Endpoints for accessing the ZooKeeper.</p>
    #[doc(hidden)]
    pub endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The role-specific ID for Zookeeper.</p>
    #[doc(hidden)]
    pub zookeeper_id: f64,
    /// <p>The version of Zookeeper.</p>
    #[doc(hidden)]
    pub zookeeper_version: std::option::Option<std::string::String>,
}
impl ZookeeperNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    pub fn attached_eni_id(&self) -> std::option::Option<&str> {
        self.attached_eni_id.as_deref()
    }
    /// <p>The virtual private cloud (VPC) IP address of the client.</p>
    pub fn client_vpc_ip_address(&self) -> std::option::Option<&str> {
        self.client_vpc_ip_address.as_deref()
    }
    /// <p>Endpoints for accessing the ZooKeeper.</p>
    pub fn endpoints(&self) -> std::option::Option<&[std::string::String]> {
        self.endpoints.as_deref()
    }
    /// <p>The role-specific ID for Zookeeper.</p>
    pub fn zookeeper_id(&self) -> f64 {
        self.zookeeper_id
    }
    /// <p>The version of Zookeeper.</p>
    pub fn zookeeper_version(&self) -> std::option::Option<&str> {
        self.zookeeper_version.as_deref()
    }
}
/// See [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo).
pub mod zookeeper_node_info {

    /// A builder for [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attached_eni_id: std::option::Option<std::string::String>,
        pub(crate) client_vpc_ip_address: std::option::Option<std::string::String>,
        pub(crate) endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) zookeeper_id: std::option::Option<f64>,
        pub(crate) zookeeper_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn attached_eni_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attached_eni_id = Some(input.into());
            self
        }
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn set_attached_eni_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attached_eni_id = input;
            self
        }
        /// <p>The virtual private cloud (VPC) IP address of the client.</p>
        pub fn client_vpc_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpc_ip_address = Some(input.into());
            self
        }
        /// <p>The virtual private cloud (VPC) IP address of the client.</p>
        pub fn set_client_vpc_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpc_ip_address = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>Endpoints for accessing the ZooKeeper.</p>
        pub fn endpoints(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input.into());
            self.endpoints = Some(v);
            self
        }
        /// <p>Endpoints for accessing the ZooKeeper.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// <p>The role-specific ID for Zookeeper.</p>
        pub fn zookeeper_id(mut self, input: f64) -> Self {
            self.zookeeper_id = Some(input);
            self
        }
        /// <p>The role-specific ID for Zookeeper.</p>
        pub fn set_zookeeper_id(mut self, input: std::option::Option<f64>) -> Self {
            self.zookeeper_id = input;
            self
        }
        /// <p>The version of Zookeeper.</p>
        pub fn zookeeper_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.zookeeper_version = Some(input.into());
            self
        }
        /// <p>The version of Zookeeper.</p>
        pub fn set_zookeeper_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo).
        pub fn build(self) -> crate::model::ZookeeperNodeInfo {
            crate::model::ZookeeperNodeInfo {
                attached_eni_id: self.attached_eni_id,
                client_vpc_ip_address: self.client_vpc_ip_address,
                endpoints: self.endpoints,
                zookeeper_id: self.zookeeper_id.unwrap_or_default(),
                zookeeper_version: self.zookeeper_version,
            }
        }
    }
}
impl ZookeeperNodeInfo {
    /// Creates a new builder-style object to manufacture [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo).
    pub fn builder() -> crate::model::zookeeper_node_info::Builder {
        crate::model::zookeeper_node_info::Builder::default()
    }
}

/// When writing a match expression against `NodeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let nodetype = unimplemented!();
/// match nodetype {
///     NodeType::Broker => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `nodetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NodeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NodeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NodeType::NewFeature` is defined.
/// Specifically, when `nodetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NodeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The broker or Zookeeper node.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NodeType {
    #[allow(missing_docs)] // documentation missing in model
    Broker,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NodeType {
    fn from(s: &str) -> Self {
        match s {
            "BROKER" => NodeType::Broker,
            other => NodeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NodeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NodeType::from(s))
    }
}
impl NodeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NodeType::Broker => "BROKER",
            NodeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BROKER"]
    }
}
impl AsRef<str> for NodeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>BrokerNodeInfo</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BrokerNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    #[doc(hidden)]
    pub attached_eni_id: std::option::Option<std::string::String>,
    /// <p>The ID of the broker.</p>
    #[doc(hidden)]
    pub broker_id: f64,
    /// <p>The client subnet to which this broker node belongs.</p>
    #[doc(hidden)]
    pub client_subnet: std::option::Option<std::string::String>,
    /// <p>The virtual private cloud (VPC) of the client.</p>
    #[doc(hidden)]
    pub client_vpc_ip_address: std::option::Option<std::string::String>,
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    #[doc(hidden)]
    pub current_broker_software_info: std::option::Option<crate::model::BrokerSoftwareInfo>,
    /// <p>Endpoints for accessing the broker.</p>
    #[doc(hidden)]
    pub endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BrokerNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    pub fn attached_eni_id(&self) -> std::option::Option<&str> {
        self.attached_eni_id.as_deref()
    }
    /// <p>The ID of the broker.</p>
    pub fn broker_id(&self) -> f64 {
        self.broker_id
    }
    /// <p>The client subnet to which this broker node belongs.</p>
    pub fn client_subnet(&self) -> std::option::Option<&str> {
        self.client_subnet.as_deref()
    }
    /// <p>The virtual private cloud (VPC) of the client.</p>
    pub fn client_vpc_ip_address(&self) -> std::option::Option<&str> {
        self.client_vpc_ip_address.as_deref()
    }
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    pub fn current_broker_software_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerSoftwareInfo> {
        self.current_broker_software_info.as_ref()
    }
    /// <p>Endpoints for accessing the broker.</p>
    pub fn endpoints(&self) -> std::option::Option<&[std::string::String]> {
        self.endpoints.as_deref()
    }
}
/// See [`BrokerNodeInfo`](crate::model::BrokerNodeInfo).
pub mod broker_node_info {

    /// A builder for [`BrokerNodeInfo`](crate::model::BrokerNodeInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attached_eni_id: std::option::Option<std::string::String>,
        pub(crate) broker_id: std::option::Option<f64>,
        pub(crate) client_subnet: std::option::Option<std::string::String>,
        pub(crate) client_vpc_ip_address: std::option::Option<std::string::String>,
        pub(crate) current_broker_software_info:
            std::option::Option<crate::model::BrokerSoftwareInfo>,
        pub(crate) endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn attached_eni_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attached_eni_id = Some(input.into());
            self
        }
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn set_attached_eni_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attached_eni_id = input;
            self
        }
        /// <p>The ID of the broker.</p>
        pub fn broker_id(mut self, input: f64) -> Self {
            self.broker_id = Some(input);
            self
        }
        /// <p>The ID of the broker.</p>
        pub fn set_broker_id(mut self, input: std::option::Option<f64>) -> Self {
            self.broker_id = input;
            self
        }
        /// <p>The client subnet to which this broker node belongs.</p>
        pub fn client_subnet(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_subnet = Some(input.into());
            self
        }
        /// <p>The client subnet to which this broker node belongs.</p>
        pub fn set_client_subnet(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_subnet = input;
            self
        }
        /// <p>The virtual private cloud (VPC) of the client.</p>
        pub fn client_vpc_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpc_ip_address = Some(input.into());
            self
        }
        /// <p>The virtual private cloud (VPC) of the client.</p>
        pub fn set_client_vpc_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpc_ip_address = input;
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn current_broker_software_info(
            mut self,
            input: crate::model::BrokerSoftwareInfo,
        ) -> Self {
            self.current_broker_software_info = Some(input);
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn set_current_broker_software_info(
            mut self,
            input: std::option::Option<crate::model::BrokerSoftwareInfo>,
        ) -> Self {
            self.current_broker_software_info = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>Endpoints for accessing the broker.</p>
        pub fn endpoints(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input.into());
            self.endpoints = Some(v);
            self
        }
        /// <p>Endpoints for accessing the broker.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerNodeInfo`](crate::model::BrokerNodeInfo).
        pub fn build(self) -> crate::model::BrokerNodeInfo {
            crate::model::BrokerNodeInfo {
                attached_eni_id: self.attached_eni_id,
                broker_id: self.broker_id.unwrap_or_default(),
                client_subnet: self.client_subnet,
                client_vpc_ip_address: self.client_vpc_ip_address,
                current_broker_software_info: self.current_broker_software_info,
                endpoints: self.endpoints,
            }
        }
    }
}
impl BrokerNodeInfo {
    /// Creates a new builder-style object to manufacture [`BrokerNodeInfo`](crate::model::BrokerNodeInfo).
    pub fn builder() -> crate::model::broker_node_info::Builder {
        crate::model::broker_node_info::Builder::default()
    }
}

/// <p>Information about the current software installed on the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BrokerSoftwareInfo {
    /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
    #[doc(hidden)]
    pub configuration_arn: std::option::Option<std::string::String>,
    /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
    #[doc(hidden)]
    pub configuration_revision: i64,
    /// <p>The version of Apache Kafka.</p>
    #[doc(hidden)]
    pub kafka_version: std::option::Option<std::string::String>,
}
impl BrokerSoftwareInfo {
    /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
    pub fn configuration_arn(&self) -> std::option::Option<&str> {
        self.configuration_arn.as_deref()
    }
    /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
    pub fn configuration_revision(&self) -> i64 {
        self.configuration_revision
    }
    /// <p>The version of Apache Kafka.</p>
    pub fn kafka_version(&self) -> std::option::Option<&str> {
        self.kafka_version.as_deref()
    }
}
/// See [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo).
pub mod broker_software_info {

    /// A builder for [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_arn: std::option::Option<std::string::String>,
        pub(crate) configuration_revision: std::option::Option<i64>,
        pub(crate) kafka_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
        pub fn configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
        pub fn set_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_arn = input;
            self
        }
        /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
        pub fn configuration_revision(mut self, input: i64) -> Self {
            self.configuration_revision = Some(input);
            self
        }
        /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
        pub fn set_configuration_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.configuration_revision = input;
            self
        }
        /// <p>The version of Apache Kafka.</p>
        pub fn kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_version = Some(input.into());
            self
        }
        /// <p>The version of Apache Kafka.</p>
        pub fn set_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_version = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo).
        pub fn build(self) -> crate::model::BrokerSoftwareInfo {
            crate::model::BrokerSoftwareInfo {
                configuration_arn: self.configuration_arn,
                configuration_revision: self.configuration_revision.unwrap_or_default(),
                kafka_version: self.kafka_version,
            }
        }
    }
}
impl BrokerSoftwareInfo {
    /// Creates a new builder-style object to manufacture [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo).
    pub fn builder() -> crate::model::broker_software_info::Builder {
        crate::model::broker_software_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KafkaVersion {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::KafkaVersionStatus>,
}
impl KafkaVersion {
    #[allow(missing_docs)] // documentation missing in model
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> std::option::Option<&crate::model::KafkaVersionStatus> {
        self.status.as_ref()
    }
}
/// See [`KafkaVersion`](crate::model::KafkaVersion).
pub mod kafka_version {

    /// A builder for [`KafkaVersion`](crate::model::KafkaVersion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::KafkaVersionStatus>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: crate::model::KafkaVersionStatus) -> Self {
            self.status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::KafkaVersionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`KafkaVersion`](crate::model::KafkaVersion).
        pub fn build(self) -> crate::model::KafkaVersion {
            crate::model::KafkaVersion {
                version: self.version,
                status: self.status,
            }
        }
    }
}
impl KafkaVersion {
    /// Creates a new builder-style object to manufacture [`KafkaVersion`](crate::model::KafkaVersion).
    pub fn builder() -> crate::model::kafka_version::Builder {
        crate::model::kafka_version::Builder::default()
    }
}

/// When writing a match expression against `KafkaVersionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let kafkaversionstatus = unimplemented!();
/// match kafkaversionstatus {
///     KafkaVersionStatus::Active => { /* ... */ },
///     KafkaVersionStatus::Deprecated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `kafkaversionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `KafkaVersionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `KafkaVersionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `KafkaVersionStatus::NewFeature` is defined.
/// Specifically, when `kafkaversionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `KafkaVersionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum KafkaVersionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deprecated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for KafkaVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => KafkaVersionStatus::Active,
            "DEPRECATED" => KafkaVersionStatus::Deprecated,
            other => {
                KafkaVersionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for KafkaVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(KafkaVersionStatus::from(s))
    }
}
impl KafkaVersionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            KafkaVersionStatus::Active => "ACTIVE",
            KafkaVersionStatus::Deprecated => "DEPRECATED",
            KafkaVersionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DEPRECATED"]
    }
}
impl AsRef<str> for KafkaVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents an MSK Configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Configuration {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time when the configuration was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the configuration.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
    #[doc(hidden)]
    pub kafka_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Latest revision of the configuration.</p>
    #[doc(hidden)]
    pub latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
    /// <p>The name of the configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ConfigurationState>,
}
impl Configuration {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time when the configuration was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The description of the configuration.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
    pub fn kafka_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.kafka_versions.as_deref()
    }
    /// <p>Latest revision of the configuration.</p>
    pub fn latest_revision(&self) -> std::option::Option<&crate::model::ConfigurationRevision> {
        self.latest_revision.as_ref()
    }
    /// <p>The name of the configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    pub fn state(&self) -> std::option::Option<&crate::model::ConfigurationState> {
        self.state.as_ref()
    }
}
/// See [`Configuration`](crate::model::Configuration).
pub mod configuration {

    /// A builder for [`Configuration`](crate::model::Configuration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) kafka_versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ConfigurationState>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time when the configuration was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the configuration was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The description of the configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the configuration.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `kafka_versions`.
        ///
        /// To override the contents of this collection use [`set_kafka_versions`](Self::set_kafka_versions).
        ///
        /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
        pub fn kafka_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.kafka_versions.unwrap_or_default();
            v.push(input.into());
            self.kafka_versions = Some(v);
            self
        }
        /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
        pub fn set_kafka_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.kafka_versions = input;
            self
        }
        /// <p>Latest revision of the configuration.</p>
        pub fn latest_revision(mut self, input: crate::model::ConfigurationRevision) -> Self {
            self.latest_revision = Some(input);
            self
        }
        /// <p>Latest revision of the configuration.</p>
        pub fn set_latest_revision(
            mut self,
            input: std::option::Option<crate::model::ConfigurationRevision>,
        ) -> Self {
            self.latest_revision = input;
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
        pub fn state(mut self, input: crate::model::ConfigurationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ConfigurationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`Configuration`](crate::model::Configuration).
        pub fn build(self) -> crate::model::Configuration {
            crate::model::Configuration {
                arn: self.arn,
                creation_time: self.creation_time,
                description: self.description,
                kafka_versions: self.kafka_versions,
                latest_revision: self.latest_revision,
                name: self.name,
                state: self.state,
            }
        }
    }
}
impl Configuration {
    /// Creates a new builder-style object to manufacture [`Configuration`](crate::model::Configuration).
    pub fn builder() -> crate::model::configuration::Builder {
        crate::model::configuration::Builder::default()
    }
}

/// When writing a match expression against `ConfigurationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let configurationstate = unimplemented!();
/// match configurationstate {
///     ConfigurationState::Active => { /* ... */ },
///     ConfigurationState::DeleteFailed => { /* ... */ },
///     ConfigurationState::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `configurationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConfigurationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConfigurationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConfigurationState::NewFeature` is defined.
/// Specifically, when `configurationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConfigurationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The state of a configuration.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigurationState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConfigurationState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ConfigurationState::Active,
            "DELETE_FAILED" => ConfigurationState::DeleteFailed,
            "DELETING" => ConfigurationState::Deleting,
            other => {
                ConfigurationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConfigurationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigurationState::from(s))
    }
}
impl ConfigurationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigurationState::Active => "ACTIVE",
            ConfigurationState::DeleteFailed => "DELETE_FAILED",
            ConfigurationState::Deleting => "DELETING",
            ConfigurationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DELETE_FAILED", "DELETING"]
    }
}
impl AsRef<str> for ConfigurationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information about a cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Cluster {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.</p>
    #[doc(hidden)]
    pub active_operation_arn: std::option::Option<std::string::String>,
    /// <p>Cluster Type.</p>
    #[doc(hidden)]
    pub cluster_type: std::option::Option<crate::model::ClusterType>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    #[doc(hidden)]
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The name of the cluster.</p>
    #[doc(hidden)]
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The time when the cluster was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current version of the MSK cluster.</p>
    #[doc(hidden)]
    pub current_version: std::option::Option<std::string::String>,
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ClusterState>,
    /// <p>State Info for the Amazon MSK cluster.</p>
    #[doc(hidden)]
    pub state_info: std::option::Option<crate::model::StateInfo>,
    /// <p>Tags attached to the cluster.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Information about the provisioned cluster.</p>
    #[doc(hidden)]
    pub provisioned: std::option::Option<crate::model::Provisioned>,
    /// <p>Information about the serverless cluster.</p>
    #[doc(hidden)]
    pub serverless: std::option::Option<crate::model::Serverless>,
}
impl Cluster {
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.</p>
    pub fn active_operation_arn(&self) -> std::option::Option<&str> {
        self.active_operation_arn.as_deref()
    }
    /// <p>Cluster Type.</p>
    pub fn cluster_type(&self) -> std::option::Option<&crate::model::ClusterType> {
        self.cluster_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The name of the cluster.</p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The time when the cluster was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The current version of the MSK cluster.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ClusterState> {
        self.state.as_ref()
    }
    /// <p>State Info for the Amazon MSK cluster.</p>
    pub fn state_info(&self) -> std::option::Option<&crate::model::StateInfo> {
        self.state_info.as_ref()
    }
    /// <p>Tags attached to the cluster.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>Information about the provisioned cluster.</p>
    pub fn provisioned(&self) -> std::option::Option<&crate::model::Provisioned> {
        self.provisioned.as_ref()
    }
    /// <p>Information about the serverless cluster.</p>
    pub fn serverless(&self) -> std::option::Option<&crate::model::Serverless> {
        self.serverless.as_ref()
    }
}
/// See [`Cluster`](crate::model::Cluster).
pub mod cluster {

    /// A builder for [`Cluster`](crate::model::Cluster).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_operation_arn: std::option::Option<std::string::String>,
        pub(crate) cluster_type: std::option::Option<crate::model::ClusterType>,
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) cluster_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ClusterState>,
        pub(crate) state_info: std::option::Option<crate::model::StateInfo>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) provisioned: std::option::Option<crate::model::Provisioned>,
        pub(crate) serverless: std::option::Option<crate::model::Serverless>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.</p>
        pub fn active_operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_operation_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.</p>
        pub fn set_active_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_operation_arn = input;
            self
        }
        /// <p>Cluster Type.</p>
        pub fn cluster_type(mut self, input: crate::model::ClusterType) -> Self {
            self.cluster_type = Some(input);
            self
        }
        /// <p>Cluster Type.</p>
        pub fn set_cluster_type(
            mut self,
            input: std::option::Option<crate::model::ClusterType>,
        ) -> Self {
            self.cluster_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_name = input;
            self
        }
        /// <p>The time when the cluster was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the cluster was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
        pub fn state(mut self, input: crate::model::ClusterState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::ClusterState>) -> Self {
            self.state = input;
            self
        }
        /// <p>State Info for the Amazon MSK cluster.</p>
        pub fn state_info(mut self, input: crate::model::StateInfo) -> Self {
            self.state_info = Some(input);
            self
        }
        /// <p>State Info for the Amazon MSK cluster.</p>
        pub fn set_state_info(
            mut self,
            input: std::option::Option<crate::model::StateInfo>,
        ) -> Self {
            self.state_info = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags attached to the cluster.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Tags attached to the cluster.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Information about the provisioned cluster.</p>
        pub fn provisioned(mut self, input: crate::model::Provisioned) -> Self {
            self.provisioned = Some(input);
            self
        }
        /// <p>Information about the provisioned cluster.</p>
        pub fn set_provisioned(
            mut self,
            input: std::option::Option<crate::model::Provisioned>,
        ) -> Self {
            self.provisioned = input;
            self
        }
        /// <p>Information about the serverless cluster.</p>
        pub fn serverless(mut self, input: crate::model::Serverless) -> Self {
            self.serverless = Some(input);
            self
        }
        /// <p>Information about the serverless cluster.</p>
        pub fn set_serverless(
            mut self,
            input: std::option::Option<crate::model::Serverless>,
        ) -> Self {
            self.serverless = input;
            self
        }
        /// Consumes the builder and constructs a [`Cluster`](crate::model::Cluster).
        pub fn build(self) -> crate::model::Cluster {
            crate::model::Cluster {
                active_operation_arn: self.active_operation_arn,
                cluster_type: self.cluster_type,
                cluster_arn: self.cluster_arn,
                cluster_name: self.cluster_name,
                creation_time: self.creation_time,
                current_version: self.current_version,
                state: self.state,
                state_info: self.state_info,
                tags: self.tags,
                provisioned: self.provisioned,
                serverless: self.serverless,
            }
        }
    }
}
impl Cluster {
    /// Creates a new builder-style object to manufacture [`Cluster`](crate::model::Cluster).
    pub fn builder() -> crate::model::cluster::Builder {
        crate::model::cluster::Builder::default()
    }
}

/// <p>Serverless cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Serverless {
    /// <p>The configuration of the Amazon VPCs for the cluster.</p>
    #[doc(hidden)]
    pub vpc_configs: std::option::Option<std::vec::Vec<crate::model::VpcConfig>>,
    /// <p>Includes all client authentication information.</p>
    #[doc(hidden)]
    pub client_authentication: std::option::Option<crate::model::ServerlessClientAuthentication>,
}
impl Serverless {
    /// <p>The configuration of the Amazon VPCs for the cluster.</p>
    pub fn vpc_configs(&self) -> std::option::Option<&[crate::model::VpcConfig]> {
        self.vpc_configs.as_deref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ServerlessClientAuthentication> {
        self.client_authentication.as_ref()
    }
}
/// See [`Serverless`](crate::model::Serverless).
pub mod serverless {

    /// A builder for [`Serverless`](crate::model::Serverless).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_configs: std::option::Option<std::vec::Vec<crate::model::VpcConfig>>,
        pub(crate) client_authentication:
            std::option::Option<crate::model::ServerlessClientAuthentication>,
    }
    impl Builder {
        /// Appends an item to `vpc_configs`.
        ///
        /// To override the contents of this collection use [`set_vpc_configs`](Self::set_vpc_configs).
        ///
        /// <p>The configuration of the Amazon VPCs for the cluster.</p>
        pub fn vpc_configs(mut self, input: crate::model::VpcConfig) -> Self {
            let mut v = self.vpc_configs.unwrap_or_default();
            v.push(input);
            self.vpc_configs = Some(v);
            self
        }
        /// <p>The configuration of the Amazon VPCs for the cluster.</p>
        pub fn set_vpc_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcConfig>>,
        ) -> Self {
            self.vpc_configs = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(
            mut self,
            input: crate::model::ServerlessClientAuthentication,
        ) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ServerlessClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// Consumes the builder and constructs a [`Serverless`](crate::model::Serverless).
        pub fn build(self) -> crate::model::Serverless {
            crate::model::Serverless {
                vpc_configs: self.vpc_configs,
                client_authentication: self.client_authentication,
            }
        }
    }
}
impl Serverless {
    /// Creates a new builder-style object to manufacture [`Serverless`](crate::model::Serverless).
    pub fn builder() -> crate::model::serverless::Builder {
        crate::model::serverless::Builder::default()
    }
}

/// <p>Includes all client authentication information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerlessClientAuthentication {
    /// <p>Details for ClientAuthentication using SASL.</p>
    #[doc(hidden)]
    pub sasl: std::option::Option<crate::model::ServerlessSasl>,
}
impl ServerlessClientAuthentication {
    /// <p>Details for ClientAuthentication using SASL.</p>
    pub fn sasl(&self) -> std::option::Option<&crate::model::ServerlessSasl> {
        self.sasl.as_ref()
    }
}
/// See [`ServerlessClientAuthentication`](crate::model::ServerlessClientAuthentication).
pub mod serverless_client_authentication {

    /// A builder for [`ServerlessClientAuthentication`](crate::model::ServerlessClientAuthentication).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sasl: std::option::Option<crate::model::ServerlessSasl>,
    }
    impl Builder {
        /// <p>Details for ClientAuthentication using SASL.</p>
        pub fn sasl(mut self, input: crate::model::ServerlessSasl) -> Self {
            self.sasl = Some(input);
            self
        }
        /// <p>Details for ClientAuthentication using SASL.</p>
        pub fn set_sasl(
            mut self,
            input: std::option::Option<crate::model::ServerlessSasl>,
        ) -> Self {
            self.sasl = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerlessClientAuthentication`](crate::model::ServerlessClientAuthentication).
        pub fn build(self) -> crate::model::ServerlessClientAuthentication {
            crate::model::ServerlessClientAuthentication { sasl: self.sasl }
        }
    }
}
impl ServerlessClientAuthentication {
    /// Creates a new builder-style object to manufacture [`ServerlessClientAuthentication`](crate::model::ServerlessClientAuthentication).
    pub fn builder() -> crate::model::serverless_client_authentication::Builder {
        crate::model::serverless_client_authentication::Builder::default()
    }
}

/// <p>Details for client authentication using SASL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerlessSasl {
    /// <p>Indicates whether IAM access control is enabled.</p>
    #[doc(hidden)]
    pub iam: std::option::Option<crate::model::Iam>,
}
impl ServerlessSasl {
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub fn iam(&self) -> std::option::Option<&crate::model::Iam> {
        self.iam.as_ref()
    }
}
/// See [`ServerlessSasl`](crate::model::ServerlessSasl).
pub mod serverless_sasl {

    /// A builder for [`ServerlessSasl`](crate::model::ServerlessSasl).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) iam: std::option::Option<crate::model::Iam>,
    }
    impl Builder {
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn iam(mut self, input: crate::model::Iam) -> Self {
            self.iam = Some(input);
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn set_iam(mut self, input: std::option::Option<crate::model::Iam>) -> Self {
            self.iam = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerlessSasl`](crate::model::ServerlessSasl).
        pub fn build(self) -> crate::model::ServerlessSasl {
            crate::model::ServerlessSasl { iam: self.iam }
        }
    }
}
impl ServerlessSasl {
    /// Creates a new builder-style object to manufacture [`ServerlessSasl`](crate::model::ServerlessSasl).
    pub fn builder() -> crate::model::serverless_sasl::Builder {
        crate::model::serverless_sasl::Builder::default()
    }
}

/// <p>The configuration of the Amazon VPCs for the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcConfig {
    /// <p>The IDs of the subnets associated with the cluster.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IDs of the security groups associated with the cluster.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl VpcConfig {
    /// <p>The IDs of the subnets associated with the cluster.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The IDs of the security groups associated with the cluster.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
/// See [`VpcConfig`](crate::model::VpcConfig).
pub mod vpc_config {

    /// A builder for [`VpcConfig`](crate::model::VpcConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The IDs of the subnets associated with the cluster.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The IDs of the subnets associated with the cluster.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The IDs of the security groups associated with the cluster.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The IDs of the security groups associated with the cluster.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcConfig`](crate::model::VpcConfig).
        pub fn build(self) -> crate::model::VpcConfig {
            crate::model::VpcConfig {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl VpcConfig {
    /// Creates a new builder-style object to manufacture [`VpcConfig`](crate::model::VpcConfig).
    pub fn builder() -> crate::model::vpc_config::Builder {
        crate::model::vpc_config::Builder::default()
    }
}

/// <p>Provisioned cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Provisioned {
    /// <p>Information about the brokers.</p>
    #[doc(hidden)]
    pub broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
    /// <p>Information about the Apache Kafka version deployed on the brokers.</p>
    #[doc(hidden)]
    pub current_broker_software_info: std::option::Option<crate::model::BrokerSoftwareInfo>,
    /// <p>Includes all client authentication information.</p>
    #[doc(hidden)]
    pub client_authentication: std::option::Option<crate::model::ClientAuthentication>,
    /// <p>Includes all encryption-related information.</p>
    #[doc(hidden)]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,
    /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
    #[doc(hidden)]
    pub enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
    /// <p>The settings for open monitoring.</p>
    #[doc(hidden)]
    pub open_monitoring: std::option::Option<crate::model::OpenMonitoringInfo>,
    /// <p>Log delivery information for the cluster.</p>
    #[doc(hidden)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The number of broker nodes in the cluster.</p>
    #[doc(hidden)]
    pub number_of_broker_nodes: i32,
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    #[doc(hidden)]
    pub zookeeper_connect_string: std::option::Option<std::string::String>,
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.</p>
    #[doc(hidden)]
    pub zookeeper_connect_string_tls: std::option::Option<std::string::String>,
    /// <p>This controls storage mode for supported storage tiers.</p>
    #[doc(hidden)]
    pub storage_mode: std::option::Option<crate::model::StorageMode>,
}
impl Provisioned {
    /// <p>Information about the brokers.</p>
    pub fn broker_node_group_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerNodeGroupInfo> {
        self.broker_node_group_info.as_ref()
    }
    /// <p>Information about the Apache Kafka version deployed on the brokers.</p>
    pub fn current_broker_software_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerSoftwareInfo> {
        self.current_broker_software_info.as_ref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ClientAuthentication> {
        self.client_authentication.as_ref()
    }
    /// <p>Includes all encryption-related information.</p>
    pub fn encryption_info(&self) -> std::option::Option<&crate::model::EncryptionInfo> {
        self.encryption_info.as_ref()
    }
    /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
    pub fn enhanced_monitoring(&self) -> std::option::Option<&crate::model::EnhancedMonitoring> {
        self.enhanced_monitoring.as_ref()
    }
    /// <p>The settings for open monitoring.</p>
    pub fn open_monitoring(&self) -> std::option::Option<&crate::model::OpenMonitoringInfo> {
        self.open_monitoring.as_ref()
    }
    /// <p>Log delivery information for the cluster.</p>
    pub fn logging_info(&self) -> std::option::Option<&crate::model::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>The number of broker nodes in the cluster.</p>
    pub fn number_of_broker_nodes(&self) -> i32 {
        self.number_of_broker_nodes
    }
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    pub fn zookeeper_connect_string(&self) -> std::option::Option<&str> {
        self.zookeeper_connect_string.as_deref()
    }
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.</p>
    pub fn zookeeper_connect_string_tls(&self) -> std::option::Option<&str> {
        self.zookeeper_connect_string_tls.as_deref()
    }
    /// <p>This controls storage mode for supported storage tiers.</p>
    pub fn storage_mode(&self) -> std::option::Option<&crate::model::StorageMode> {
        self.storage_mode.as_ref()
    }
}
/// See [`Provisioned`](crate::model::Provisioned).
pub mod provisioned {

    /// A builder for [`Provisioned`](crate::model::Provisioned).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        pub(crate) current_broker_software_info:
            std::option::Option<crate::model::BrokerSoftwareInfo>,
        pub(crate) client_authentication: std::option::Option<crate::model::ClientAuthentication>,
        pub(crate) encryption_info: std::option::Option<crate::model::EncryptionInfo>,
        pub(crate) enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
        pub(crate) open_monitoring: std::option::Option<crate::model::OpenMonitoringInfo>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) number_of_broker_nodes: std::option::Option<i32>,
        pub(crate) zookeeper_connect_string: std::option::Option<std::string::String>,
        pub(crate) zookeeper_connect_string_tls: std::option::Option<std::string::String>,
        pub(crate) storage_mode: std::option::Option<crate::model::StorageMode>,
    }
    impl Builder {
        /// <p>Information about the brokers.</p>
        pub fn broker_node_group_info(mut self, input: crate::model::BrokerNodeGroupInfo) -> Self {
            self.broker_node_group_info = Some(input);
            self
        }
        /// <p>Information about the brokers.</p>
        pub fn set_broker_node_group_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        ) -> Self {
            self.broker_node_group_info = input;
            self
        }
        /// <p>Information about the Apache Kafka version deployed on the brokers.</p>
        pub fn current_broker_software_info(
            mut self,
            input: crate::model::BrokerSoftwareInfo,
        ) -> Self {
            self.current_broker_software_info = Some(input);
            self
        }
        /// <p>Information about the Apache Kafka version deployed on the brokers.</p>
        pub fn set_current_broker_software_info(
            mut self,
            input: std::option::Option<crate::model::BrokerSoftwareInfo>,
        ) -> Self {
            self.current_broker_software_info = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.encryption_info = Some(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.encryption_info = input;
            self
        }
        /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.enhanced_monitoring = Some(input);
            self
        }
        /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.enhanced_monitoring = input;
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoringInfo) -> Self {
            self.open_monitoring = Some(input);
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoringInfo>,
        ) -> Self {
            self.open_monitoring = input;
            self
        }
        /// <p>Log delivery information for the cluster.</p>
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        /// <p>Log delivery information for the cluster.</p>
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.number_of_broker_nodes = Some(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_broker_nodes = input;
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
        pub fn zookeeper_connect_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.zookeeper_connect_string = Some(input.into());
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
        pub fn set_zookeeper_connect_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string = input;
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.</p>
        pub fn zookeeper_connect_string_tls(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string_tls = Some(input.into());
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.</p>
        pub fn set_zookeeper_connect_string_tls(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string_tls = input;
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn storage_mode(mut self, input: crate::model::StorageMode) -> Self {
            self.storage_mode = Some(input);
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn set_storage_mode(
            mut self,
            input: std::option::Option<crate::model::StorageMode>,
        ) -> Self {
            self.storage_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`Provisioned`](crate::model::Provisioned).
        pub fn build(self) -> crate::model::Provisioned {
            crate::model::Provisioned {
                broker_node_group_info: self.broker_node_group_info,
                current_broker_software_info: self.current_broker_software_info,
                client_authentication: self.client_authentication,
                encryption_info: self.encryption_info,
                enhanced_monitoring: self.enhanced_monitoring,
                open_monitoring: self.open_monitoring,
                logging_info: self.logging_info,
                number_of_broker_nodes: self.number_of_broker_nodes.unwrap_or_default(),
                zookeeper_connect_string: self.zookeeper_connect_string,
                zookeeper_connect_string_tls: self.zookeeper_connect_string_tls,
                storage_mode: self.storage_mode,
            }
        }
    }
}
impl Provisioned {
    /// Creates a new builder-style object to manufacture [`Provisioned`](crate::model::Provisioned).
    pub fn builder() -> crate::model::provisioned::Builder {
        crate::model::provisioned::Builder::default()
    }
}

/// <p>Describes the setup to be used for Apache Kafka broker nodes in the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BrokerNodeGroupInfo {
    /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
    /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
    #[doc(hidden)]
    pub broker_az_distribution: std::option::Option<crate::model::BrokerAzDistribution>,
    /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.</p>
    #[doc(hidden)]
    pub client_subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
    #[doc(hidden)]
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
    #[doc(hidden)]
    pub storage_info: std::option::Option<crate::model::StorageInfo>,
    /// <p>Information about the broker access configuration.</p>
    #[doc(hidden)]
    pub connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
}
impl BrokerNodeGroupInfo {
    /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
    /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
    pub fn broker_az_distribution(
        &self,
    ) -> std::option::Option<&crate::model::BrokerAzDistribution> {
        self.broker_az_distribution.as_ref()
    }
    /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.</p>
    pub fn client_subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.client_subnets.as_deref()
    }
    /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
    pub fn storage_info(&self) -> std::option::Option<&crate::model::StorageInfo> {
        self.storage_info.as_ref()
    }
    /// <p>Information about the broker access configuration.</p>
    pub fn connectivity_info(&self) -> std::option::Option<&crate::model::ConnectivityInfo> {
        self.connectivity_info.as_ref()
    }
}
/// See [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo).
pub mod broker_node_group_info {

    /// A builder for [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_az_distribution: std::option::Option<crate::model::BrokerAzDistribution>,
        pub(crate) client_subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) storage_info: std::option::Option<crate::model::StorageInfo>,
        pub(crate) connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
    }
    impl Builder {
        /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
        /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
        pub fn broker_az_distribution(mut self, input: crate::model::BrokerAzDistribution) -> Self {
            self.broker_az_distribution = Some(input);
            self
        }
        /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
        /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
        pub fn set_broker_az_distribution(
            mut self,
            input: std::option::Option<crate::model::BrokerAzDistribution>,
        ) -> Self {
            self.broker_az_distribution = input;
            self
        }
        /// Appends an item to `client_subnets`.
        ///
        /// To override the contents of this collection use [`set_client_subnets`](Self::set_client_subnets).
        ///
        /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.</p>
        pub fn client_subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.client_subnets.unwrap_or_default();
            v.push(input.into());
            self.client_subnets = Some(v);
            self
        }
        /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.</p>
        pub fn set_client_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.client_subnets = input;
            self
        }
        /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
        pub fn storage_info(mut self, input: crate::model::StorageInfo) -> Self {
            self.storage_info = Some(input);
            self
        }
        /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
        pub fn set_storage_info(
            mut self,
            input: std::option::Option<crate::model::StorageInfo>,
        ) -> Self {
            self.storage_info = input;
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn connectivity_info(mut self, input: crate::model::ConnectivityInfo) -> Self {
            self.connectivity_info = Some(input);
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn set_connectivity_info(
            mut self,
            input: std::option::Option<crate::model::ConnectivityInfo>,
        ) -> Self {
            self.connectivity_info = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo).
        pub fn build(self) -> crate::model::BrokerNodeGroupInfo {
            crate::model::BrokerNodeGroupInfo {
                broker_az_distribution: self.broker_az_distribution,
                client_subnets: self.client_subnets,
                instance_type: self.instance_type,
                security_groups: self.security_groups,
                storage_info: self.storage_info,
                connectivity_info: self.connectivity_info,
            }
        }
    }
}
impl BrokerNodeGroupInfo {
    /// Creates a new builder-style object to manufacture [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo).
    pub fn builder() -> crate::model::broker_node_group_info::Builder {
        crate::model::broker_node_group_info::Builder::default()
    }
}

/// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageInfo {
    /// <p>EBS volume information.</p>
    #[doc(hidden)]
    pub ebs_storage_info: std::option::Option<crate::model::EbsStorageInfo>,
}
impl StorageInfo {
    /// <p>EBS volume information.</p>
    pub fn ebs_storage_info(&self) -> std::option::Option<&crate::model::EbsStorageInfo> {
        self.ebs_storage_info.as_ref()
    }
}
/// See [`StorageInfo`](crate::model::StorageInfo).
pub mod storage_info {

    /// A builder for [`StorageInfo`](crate::model::StorageInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ebs_storage_info: std::option::Option<crate::model::EbsStorageInfo>,
    }
    impl Builder {
        /// <p>EBS volume information.</p>
        pub fn ebs_storage_info(mut self, input: crate::model::EbsStorageInfo) -> Self {
            self.ebs_storage_info = Some(input);
            self
        }
        /// <p>EBS volume information.</p>
        pub fn set_ebs_storage_info(
            mut self,
            input: std::option::Option<crate::model::EbsStorageInfo>,
        ) -> Self {
            self.ebs_storage_info = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageInfo`](crate::model::StorageInfo).
        pub fn build(self) -> crate::model::StorageInfo {
            crate::model::StorageInfo {
                ebs_storage_info: self.ebs_storage_info,
            }
        }
    }
}
impl StorageInfo {
    /// Creates a new builder-style object to manufacture [`StorageInfo`](crate::model::StorageInfo).
    pub fn builder() -> crate::model::storage_info::Builder {
        crate::model::storage_info::Builder::default()
    }
}

/// <p>Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EbsStorageInfo {
    /// <p>EBS volume provisioned throughput information.</p>
    #[doc(hidden)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
    #[doc(hidden)]
    pub volume_size: i32,
}
impl EbsStorageInfo {
    /// <p>EBS volume provisioned throughput information.</p>
    pub fn provisioned_throughput(
        &self,
    ) -> std::option::Option<&crate::model::ProvisionedThroughput> {
        self.provisioned_throughput.as_ref()
    }
    /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
    pub fn volume_size(&self) -> i32 {
        self.volume_size
    }
}
/// See [`EbsStorageInfo`](crate::model::EbsStorageInfo).
pub mod ebs_storage_info {

    /// A builder for [`EbsStorageInfo`](crate::model::EbsStorageInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
        pub(crate) volume_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>EBS volume provisioned throughput information.</p>
        pub fn provisioned_throughput(
            mut self,
            input: crate::model::ProvisionedThroughput,
        ) -> Self {
            self.provisioned_throughput = Some(input);
            self
        }
        /// <p>EBS volume provisioned throughput information.</p>
        pub fn set_provisioned_throughput(
            mut self,
            input: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = input;
            self
        }
        /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsStorageInfo`](crate::model::EbsStorageInfo).
        pub fn build(self) -> crate::model::EbsStorageInfo {
            crate::model::EbsStorageInfo {
                provisioned_throughput: self.provisioned_throughput,
                volume_size: self.volume_size.unwrap_or_default(),
            }
        }
    }
}
impl EbsStorageInfo {
    /// Creates a new builder-style object to manufacture [`EbsStorageInfo`](crate::model::EbsStorageInfo).
    pub fn builder() -> crate::model::ebs_storage_info::Builder {
        crate::model::ebs_storage_info::Builder::default()
    }
}

/// When writing a match expression against `BrokerAzDistribution`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let brokerazdistribution = unimplemented!();
/// match brokerazdistribution {
///     BrokerAzDistribution::Default => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `brokerazdistribution` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BrokerAzDistribution::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BrokerAzDistribution::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BrokerAzDistribution::NewFeature` is defined.
/// Specifically, when `brokerazdistribution` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BrokerAzDistribution::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
/// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BrokerAzDistribution {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BrokerAzDistribution {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => BrokerAzDistribution::Default,
            other => {
                BrokerAzDistribution::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for BrokerAzDistribution {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BrokerAzDistribution::from(s))
    }
}
impl BrokerAzDistribution {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BrokerAzDistribution::Default => "DEFAULT",
            BrokerAzDistribution::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEFAULT"]
    }
}
impl AsRef<str> for BrokerAzDistribution {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StateInfo {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl StateInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`StateInfo`](crate::model::StateInfo).
pub mod state_info {

    /// A builder for [`StateInfo`](crate::model::StateInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StateInfo`](crate::model::StateInfo).
        pub fn build(self) -> crate::model::StateInfo {
            crate::model::StateInfo {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl StateInfo {
    /// Creates a new builder-style object to manufacture [`StateInfo`](crate::model::StateInfo).
    pub fn builder() -> crate::model::state_info::Builder {
        crate::model::state_info::Builder::default()
    }
}

/// When writing a match expression against `ClusterState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let clusterstate = unimplemented!();
/// match clusterstate {
///     ClusterState::Active => { /* ... */ },
///     ClusterState::Creating => { /* ... */ },
///     ClusterState::Deleting => { /* ... */ },
///     ClusterState::Failed => { /* ... */ },
///     ClusterState::Healing => { /* ... */ },
///     ClusterState::Maintenance => { /* ... */ },
///     ClusterState::RebootingBroker => { /* ... */ },
///     ClusterState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clusterstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClusterState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClusterState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClusterState::NewFeature` is defined.
/// Specifically, when `clusterstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClusterState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The state of the Apache Kafka cluster.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClusterState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Healing,
    #[allow(missing_docs)] // documentation missing in model
    Maintenance,
    #[allow(missing_docs)] // documentation missing in model
    RebootingBroker,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ClusterState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ClusterState::Active,
            "CREATING" => ClusterState::Creating,
            "DELETING" => ClusterState::Deleting,
            "FAILED" => ClusterState::Failed,
            "HEALING" => ClusterState::Healing,
            "MAINTENANCE" => ClusterState::Maintenance,
            "REBOOTING_BROKER" => ClusterState::RebootingBroker,
            "UPDATING" => ClusterState::Updating,
            other => ClusterState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ClusterState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClusterState::from(s))
    }
}
impl ClusterState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClusterState::Active => "ACTIVE",
            ClusterState::Creating => "CREATING",
            ClusterState::Deleting => "DELETING",
            ClusterState::Failed => "FAILED",
            ClusterState::Healing => "HEALING",
            ClusterState::Maintenance => "MAINTENANCE",
            ClusterState::RebootingBroker => "REBOOTING_BROKER",
            ClusterState::Updating => "UPDATING",
            ClusterState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATING",
            "DELETING",
            "FAILED",
            "HEALING",
            "MAINTENANCE",
            "REBOOTING_BROKER",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for ClusterState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ClusterType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let clustertype = unimplemented!();
/// match clustertype {
///     ClusterType::Provisioned => { /* ... */ },
///     ClusterType::Serverless => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clustertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClusterType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClusterType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClusterType::NewFeature` is defined.
/// Specifically, when `clustertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClusterType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The type of cluster.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClusterType {
    #[allow(missing_docs)] // documentation missing in model
    Provisioned,
    #[allow(missing_docs)] // documentation missing in model
    Serverless,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ClusterType {
    fn from(s: &str) -> Self {
        match s {
            "PROVISIONED" => ClusterType::Provisioned,
            "SERVERLESS" => ClusterType::Serverless,
            other => ClusterType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ClusterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClusterType::from(s))
    }
}
impl ClusterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClusterType::Provisioned => "PROVISIONED",
            ClusterType::Serverless => "SERVERLESS",
            ClusterType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PROVISIONED", "SERVERLESS"]
    }
}
impl AsRef<str> for ClusterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information about a cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterInfo {
    /// <p>Arn of active cluster operation.</p>
    #[doc(hidden)]
    pub active_operation_arn: std::option::Option<std::string::String>,
    /// <p>Information about the broker nodes.</p>
    #[doc(hidden)]
    pub broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
    /// <p>Includes all client authentication information.</p>
    #[doc(hidden)]
    pub client_authentication: std::option::Option<crate::model::ClientAuthentication>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    #[doc(hidden)]
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The name of the cluster.</p>
    #[doc(hidden)]
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The time when the cluster was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    #[doc(hidden)]
    pub current_broker_software_info: std::option::Option<crate::model::BrokerSoftwareInfo>,
    /// <p>The current version of the MSK cluster.</p>
    #[doc(hidden)]
    pub current_version: std::option::Option<std::string::String>,
    /// <p>Includes all encryption-related information.</p>
    #[doc(hidden)]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,
    /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
    #[doc(hidden)]
    pub enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
    /// <p>Settings for open monitoring using Prometheus.</p>
    #[doc(hidden)]
    pub open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The number of broker nodes in the cluster.</p>
    #[doc(hidden)]
    pub number_of_broker_nodes: i32,
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ClusterState>,
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub state_info: std::option::Option<crate::model::StateInfo>,
    /// <p>Tags attached to the cluster.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    #[doc(hidden)]
    pub zookeeper_connect_string: std::option::Option<std::string::String>,
    /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
    #[doc(hidden)]
    pub zookeeper_connect_string_tls: std::option::Option<std::string::String>,
    /// <p>This controls storage mode for supported storage tiers.</p>
    #[doc(hidden)]
    pub storage_mode: std::option::Option<crate::model::StorageMode>,
}
impl ClusterInfo {
    /// <p>Arn of active cluster operation.</p>
    pub fn active_operation_arn(&self) -> std::option::Option<&str> {
        self.active_operation_arn.as_deref()
    }
    /// <p>Information about the broker nodes.</p>
    pub fn broker_node_group_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerNodeGroupInfo> {
        self.broker_node_group_info.as_ref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ClientAuthentication> {
        self.client_authentication.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The name of the cluster.</p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The time when the cluster was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    pub fn current_broker_software_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerSoftwareInfo> {
        self.current_broker_software_info.as_ref()
    }
    /// <p>The current version of the MSK cluster.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>Includes all encryption-related information.</p>
    pub fn encryption_info(&self) -> std::option::Option<&crate::model::EncryptionInfo> {
        self.encryption_info.as_ref()
    }
    /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
    pub fn enhanced_monitoring(&self) -> std::option::Option<&crate::model::EnhancedMonitoring> {
        self.enhanced_monitoring.as_ref()
    }
    /// <p>Settings for open monitoring using Prometheus.</p>
    pub fn open_monitoring(&self) -> std::option::Option<&crate::model::OpenMonitoring> {
        self.open_monitoring.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn logging_info(&self) -> std::option::Option<&crate::model::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>The number of broker nodes in the cluster.</p>
    pub fn number_of_broker_nodes(&self) -> i32 {
        self.number_of_broker_nodes
    }
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ClusterState> {
        self.state.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn state_info(&self) -> std::option::Option<&crate::model::StateInfo> {
        self.state_info.as_ref()
    }
    /// <p>Tags attached to the cluster.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    pub fn zookeeper_connect_string(&self) -> std::option::Option<&str> {
        self.zookeeper_connect_string.as_deref()
    }
    /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
    pub fn zookeeper_connect_string_tls(&self) -> std::option::Option<&str> {
        self.zookeeper_connect_string_tls.as_deref()
    }
    /// <p>This controls storage mode for supported storage tiers.</p>
    pub fn storage_mode(&self) -> std::option::Option<&crate::model::StorageMode> {
        self.storage_mode.as_ref()
    }
}
/// See [`ClusterInfo`](crate::model::ClusterInfo).
pub mod cluster_info {

    /// A builder for [`ClusterInfo`](crate::model::ClusterInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_operation_arn: std::option::Option<std::string::String>,
        pub(crate) broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        pub(crate) client_authentication: std::option::Option<crate::model::ClientAuthentication>,
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) cluster_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) current_broker_software_info:
            std::option::Option<crate::model::BrokerSoftwareInfo>,
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) encryption_info: std::option::Option<crate::model::EncryptionInfo>,
        pub(crate) enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
        pub(crate) open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) number_of_broker_nodes: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::ClusterState>,
        pub(crate) state_info: std::option::Option<crate::model::StateInfo>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) zookeeper_connect_string: std::option::Option<std::string::String>,
        pub(crate) zookeeper_connect_string_tls: std::option::Option<std::string::String>,
        pub(crate) storage_mode: std::option::Option<crate::model::StorageMode>,
    }
    impl Builder {
        /// <p>Arn of active cluster operation.</p>
        pub fn active_operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_operation_arn = Some(input.into());
            self
        }
        /// <p>Arn of active cluster operation.</p>
        pub fn set_active_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_operation_arn = input;
            self
        }
        /// <p>Information about the broker nodes.</p>
        pub fn broker_node_group_info(mut self, input: crate::model::BrokerNodeGroupInfo) -> Self {
            self.broker_node_group_info = Some(input);
            self
        }
        /// <p>Information about the broker nodes.</p>
        pub fn set_broker_node_group_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        ) -> Self {
            self.broker_node_group_info = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_name = input;
            self
        }
        /// <p>The time when the cluster was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the cluster was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn current_broker_software_info(
            mut self,
            input: crate::model::BrokerSoftwareInfo,
        ) -> Self {
            self.current_broker_software_info = Some(input);
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn set_current_broker_software_info(
            mut self,
            input: std::option::Option<crate::model::BrokerSoftwareInfo>,
        ) -> Self {
            self.current_broker_software_info = input;
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.encryption_info = Some(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.encryption_info = input;
            self
        }
        /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.enhanced_monitoring = Some(input);
            self
        }
        /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.enhanced_monitoring = input;
            self
        }
        /// <p>Settings for open monitoring using Prometheus.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoring) -> Self {
            self.open_monitoring = Some(input);
            self
        }
        /// <p>Settings for open monitoring using Prometheus.</p>
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoring>,
        ) -> Self {
            self.open_monitoring = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.number_of_broker_nodes = Some(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_broker_nodes = input;
            self
        }
        /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
        pub fn state(mut self, input: crate::model::ClusterState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::ClusterState>) -> Self {
            self.state = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn state_info(mut self, input: crate::model::StateInfo) -> Self {
            self.state_info = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_state_info(
            mut self,
            input: std::option::Option<crate::model::StateInfo>,
        ) -> Self {
            self.state_info = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags attached to the cluster.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Tags attached to the cluster.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
        pub fn zookeeper_connect_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.zookeeper_connect_string = Some(input.into());
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
        pub fn set_zookeeper_connect_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string = input;
            self
        }
        /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
        pub fn zookeeper_connect_string_tls(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string_tls = Some(input.into());
            self
        }
        /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
        pub fn set_zookeeper_connect_string_tls(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string_tls = input;
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn storage_mode(mut self, input: crate::model::StorageMode) -> Self {
            self.storage_mode = Some(input);
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn set_storage_mode(
            mut self,
            input: std::option::Option<crate::model::StorageMode>,
        ) -> Self {
            self.storage_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterInfo`](crate::model::ClusterInfo).
        pub fn build(self) -> crate::model::ClusterInfo {
            crate::model::ClusterInfo {
                active_operation_arn: self.active_operation_arn,
                broker_node_group_info: self.broker_node_group_info,
                client_authentication: self.client_authentication,
                cluster_arn: self.cluster_arn,
                cluster_name: self.cluster_name,
                creation_time: self.creation_time,
                current_broker_software_info: self.current_broker_software_info,
                current_version: self.current_version,
                encryption_info: self.encryption_info,
                enhanced_monitoring: self.enhanced_monitoring,
                open_monitoring: self.open_monitoring,
                logging_info: self.logging_info,
                number_of_broker_nodes: self.number_of_broker_nodes.unwrap_or_default(),
                state: self.state,
                state_info: self.state_info,
                tags: self.tags,
                zookeeper_connect_string: self.zookeeper_connect_string,
                zookeeper_connect_string_tls: self.zookeeper_connect_string_tls,
                storage_mode: self.storage_mode,
            }
        }
    }
}
impl ClusterInfo {
    /// Creates a new builder-style object to manufacture [`ClusterInfo`](crate::model::ClusterInfo).
    pub fn builder() -> crate::model::cluster_info::Builder {
        crate::model::cluster_info::Builder::default()
    }
}

/// <p>JMX and Node monitoring for the MSK cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OpenMonitoring {
    /// <p>Prometheus settings.</p>
    #[doc(hidden)]
    pub prometheus: std::option::Option<crate::model::Prometheus>,
}
impl OpenMonitoring {
    /// <p>Prometheus settings.</p>
    pub fn prometheus(&self) -> std::option::Option<&crate::model::Prometheus> {
        self.prometheus.as_ref()
    }
}
/// See [`OpenMonitoring`](crate::model::OpenMonitoring).
pub mod open_monitoring {

    /// A builder for [`OpenMonitoring`](crate::model::OpenMonitoring).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prometheus: std::option::Option<crate::model::Prometheus>,
    }
    impl Builder {
        /// <p>Prometheus settings.</p>
        pub fn prometheus(mut self, input: crate::model::Prometheus) -> Self {
            self.prometheus = Some(input);
            self
        }
        /// <p>Prometheus settings.</p>
        pub fn set_prometheus(
            mut self,
            input: std::option::Option<crate::model::Prometheus>,
        ) -> Self {
            self.prometheus = input;
            self
        }
        /// Consumes the builder and constructs a [`OpenMonitoring`](crate::model::OpenMonitoring).
        pub fn build(self) -> crate::model::OpenMonitoring {
            crate::model::OpenMonitoring {
                prometheus: self.prometheus,
            }
        }
    }
}
impl OpenMonitoring {
    /// Creates a new builder-style object to manufacture [`OpenMonitoring`](crate::model::OpenMonitoring).
    pub fn builder() -> crate::model::open_monitoring::Builder {
        crate::model::open_monitoring::Builder::default()
    }
}

/// <p>Prometheus settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Prometheus {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    #[doc(hidden)]
    pub jmx_exporter: std::option::Option<crate::model::JmxExporter>,
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    #[doc(hidden)]
    pub node_exporter: std::option::Option<crate::model::NodeExporter>,
}
impl Prometheus {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn jmx_exporter(&self) -> std::option::Option<&crate::model::JmxExporter> {
        self.jmx_exporter.as_ref()
    }
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn node_exporter(&self) -> std::option::Option<&crate::model::NodeExporter> {
        self.node_exporter.as_ref()
    }
}
/// See [`Prometheus`](crate::model::Prometheus).
pub mod prometheus {

    /// A builder for [`Prometheus`](crate::model::Prometheus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jmx_exporter: std::option::Option<crate::model::JmxExporter>,
        pub(crate) node_exporter: std::option::Option<crate::model::NodeExporter>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn jmx_exporter(mut self, input: crate::model::JmxExporter) -> Self {
            self.jmx_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_jmx_exporter(
            mut self,
            input: std::option::Option<crate::model::JmxExporter>,
        ) -> Self {
            self.jmx_exporter = input;
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn node_exporter(mut self, input: crate::model::NodeExporter) -> Self {
            self.node_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_node_exporter(
            mut self,
            input: std::option::Option<crate::model::NodeExporter>,
        ) -> Self {
            self.node_exporter = input;
            self
        }
        /// Consumes the builder and constructs a [`Prometheus`](crate::model::Prometheus).
        pub fn build(self) -> crate::model::Prometheus {
            crate::model::Prometheus {
                jmx_exporter: self.jmx_exporter,
                node_exporter: self.node_exporter,
            }
        }
    }
}
impl Prometheus {
    /// Creates a new builder-style object to manufacture [`Prometheus`](crate::model::Prometheus).
    pub fn builder() -> crate::model::prometheus::Builder {
        crate::model::prometheus::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeExporter {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    #[doc(hidden)]
    pub enabled_in_broker: bool,
}
impl NodeExporter {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
/// See [`NodeExporter`](crate::model::NodeExporter).
pub mod node_exporter {

    /// A builder for [`NodeExporter`](crate::model::NodeExporter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeExporter`](crate::model::NodeExporter).
        pub fn build(self) -> crate::model::NodeExporter {
            crate::model::NodeExporter {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl NodeExporter {
    /// Creates a new builder-style object to manufacture [`NodeExporter`](crate::model::NodeExporter).
    pub fn builder() -> crate::model::node_exporter::Builder {
        crate::model::node_exporter::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JmxExporter {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    #[doc(hidden)]
    pub enabled_in_broker: bool,
}
impl JmxExporter {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
/// See [`JmxExporter`](crate::model::JmxExporter).
pub mod jmx_exporter {

    /// A builder for [`JmxExporter`](crate::model::JmxExporter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`JmxExporter`](crate::model::JmxExporter).
        pub fn build(self) -> crate::model::JmxExporter {
            crate::model::JmxExporter {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl JmxExporter {
    /// Creates a new builder-style object to manufacture [`JmxExporter`](crate::model::JmxExporter).
    pub fn builder() -> crate::model::jmx_exporter::Builder {
        crate::model::jmx_exporter::Builder::default()
    }
}

/// <p>Returns information about a cluster operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterOperationInfo {
    /// <p>The ID of the API request that triggered this operation.</p>
    #[doc(hidden)]
    pub client_request_id: std::option::Option<std::string::String>,
    /// <p>ARN of the cluster.</p>
    #[doc(hidden)]
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The time that the operation was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the operation finished.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Describes the error if the operation fails.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::ErrorInfo>,
    /// <p>ARN of the cluster operation.</p>
    #[doc(hidden)]
    pub operation_arn: std::option::Option<std::string::String>,
    /// <p>State of the cluster operation.</p>
    #[doc(hidden)]
    pub operation_state: std::option::Option<std::string::String>,
    /// <p>Steps completed during the operation.</p>
    #[doc(hidden)]
    pub operation_steps: std::option::Option<std::vec::Vec<crate::model::ClusterOperationStep>>,
    /// <p>Type of the cluster operation.</p>
    #[doc(hidden)]
    pub operation_type: std::option::Option<std::string::String>,
    /// <p>Information about cluster attributes before a cluster is updated.</p>
    #[doc(hidden)]
    pub source_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
    /// <p>Information about cluster attributes after a cluster is updated.</p>
    #[doc(hidden)]
    pub target_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
}
impl ClusterOperationInfo {
    /// <p>The ID of the API request that triggered this operation.</p>
    pub fn client_request_id(&self) -> std::option::Option<&str> {
        self.client_request_id.as_deref()
    }
    /// <p>ARN of the cluster.</p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The time that the operation was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time at which the operation finished.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>Describes the error if the operation fails.</p>
    pub fn error_info(&self) -> std::option::Option<&crate::model::ErrorInfo> {
        self.error_info.as_ref()
    }
    /// <p>ARN of the cluster operation.</p>
    pub fn operation_arn(&self) -> std::option::Option<&str> {
        self.operation_arn.as_deref()
    }
    /// <p>State of the cluster operation.</p>
    pub fn operation_state(&self) -> std::option::Option<&str> {
        self.operation_state.as_deref()
    }
    /// <p>Steps completed during the operation.</p>
    pub fn operation_steps(&self) -> std::option::Option<&[crate::model::ClusterOperationStep]> {
        self.operation_steps.as_deref()
    }
    /// <p>Type of the cluster operation.</p>
    pub fn operation_type(&self) -> std::option::Option<&str> {
        self.operation_type.as_deref()
    }
    /// <p>Information about cluster attributes before a cluster is updated.</p>
    pub fn source_cluster_info(&self) -> std::option::Option<&crate::model::MutableClusterInfo> {
        self.source_cluster_info.as_ref()
    }
    /// <p>Information about cluster attributes after a cluster is updated.</p>
    pub fn target_cluster_info(&self) -> std::option::Option<&crate::model::MutableClusterInfo> {
        self.target_cluster_info.as_ref()
    }
}
/// See [`ClusterOperationInfo`](crate::model::ClusterOperationInfo).
pub mod cluster_operation_info {

    /// A builder for [`ClusterOperationInfo`](crate::model::ClusterOperationInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_request_id: std::option::Option<std::string::String>,
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) error_info: std::option::Option<crate::model::ErrorInfo>,
        pub(crate) operation_arn: std::option::Option<std::string::String>,
        pub(crate) operation_state: std::option::Option<std::string::String>,
        pub(crate) operation_steps:
            std::option::Option<std::vec::Vec<crate::model::ClusterOperationStep>>,
        pub(crate) operation_type: std::option::Option<std::string::String>,
        pub(crate) source_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
        pub(crate) target_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
    }
    impl Builder {
        /// <p>The ID of the API request that triggered this operation.</p>
        pub fn client_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_id = Some(input.into());
            self
        }
        /// <p>The ID of the API request that triggered this operation.</p>
        pub fn set_client_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_id = input;
            self
        }
        /// <p>ARN of the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>ARN of the cluster.</p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The time that the operation was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the operation was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the operation finished.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time at which the operation finished.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Describes the error if the operation fails.</p>
        pub fn error_info(mut self, input: crate::model::ErrorInfo) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>Describes the error if the operation fails.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::ErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// <p>ARN of the cluster operation.</p>
        pub fn operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_arn = Some(input.into());
            self
        }
        /// <p>ARN of the cluster operation.</p>
        pub fn set_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_arn = input;
            self
        }
        /// <p>State of the cluster operation.</p>
        pub fn operation_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_state = Some(input.into());
            self
        }
        /// <p>State of the cluster operation.</p>
        pub fn set_operation_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_state = input;
            self
        }
        /// Appends an item to `operation_steps`.
        ///
        /// To override the contents of this collection use [`set_operation_steps`](Self::set_operation_steps).
        ///
        /// <p>Steps completed during the operation.</p>
        pub fn operation_steps(mut self, input: crate::model::ClusterOperationStep) -> Self {
            let mut v = self.operation_steps.unwrap_or_default();
            v.push(input);
            self.operation_steps = Some(v);
            self
        }
        /// <p>Steps completed during the operation.</p>
        pub fn set_operation_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterOperationStep>>,
        ) -> Self {
            self.operation_steps = input;
            self
        }
        /// <p>Type of the cluster operation.</p>
        pub fn operation_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_type = Some(input.into());
            self
        }
        /// <p>Type of the cluster operation.</p>
        pub fn set_operation_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_type = input;
            self
        }
        /// <p>Information about cluster attributes before a cluster is updated.</p>
        pub fn source_cluster_info(mut self, input: crate::model::MutableClusterInfo) -> Self {
            self.source_cluster_info = Some(input);
            self
        }
        /// <p>Information about cluster attributes before a cluster is updated.</p>
        pub fn set_source_cluster_info(
            mut self,
            input: std::option::Option<crate::model::MutableClusterInfo>,
        ) -> Self {
            self.source_cluster_info = input;
            self
        }
        /// <p>Information about cluster attributes after a cluster is updated.</p>
        pub fn target_cluster_info(mut self, input: crate::model::MutableClusterInfo) -> Self {
            self.target_cluster_info = Some(input);
            self
        }
        /// <p>Information about cluster attributes after a cluster is updated.</p>
        pub fn set_target_cluster_info(
            mut self,
            input: std::option::Option<crate::model::MutableClusterInfo>,
        ) -> Self {
            self.target_cluster_info = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOperationInfo`](crate::model::ClusterOperationInfo).
        pub fn build(self) -> crate::model::ClusterOperationInfo {
            crate::model::ClusterOperationInfo {
                client_request_id: self.client_request_id,
                cluster_arn: self.cluster_arn,
                creation_time: self.creation_time,
                end_time: self.end_time,
                error_info: self.error_info,
                operation_arn: self.operation_arn,
                operation_state: self.operation_state,
                operation_steps: self.operation_steps,
                operation_type: self.operation_type,
                source_cluster_info: self.source_cluster_info,
                target_cluster_info: self.target_cluster_info,
            }
        }
    }
}
impl ClusterOperationInfo {
    /// Creates a new builder-style object to manufacture [`ClusterOperationInfo`](crate::model::ClusterOperationInfo).
    pub fn builder() -> crate::model::cluster_operation_info::Builder {
        crate::model::cluster_operation_info::Builder::default()
    }
}

/// <p>Information about cluster attributes that can be updated via update APIs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MutableClusterInfo {
    /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
    #[doc(hidden)]
    pub broker_ebs_volume_info:
        std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
    /// <p>Information about the changes in the configuration of the brokers.</p>
    #[doc(hidden)]
    pub configuration_info: std::option::Option<crate::model::ConfigurationInfo>,
    /// <p>The number of broker nodes in the cluster.</p>
    #[doc(hidden)]
    pub number_of_broker_nodes: i32,
    /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
    #[doc(hidden)]
    pub enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
    /// <p>The settings for open monitoring.</p>
    #[doc(hidden)]
    pub open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
    /// <p>The Apache Kafka version.</p>
    #[doc(hidden)]
    pub kafka_version: std::option::Option<std::string::String>,
    /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
    #[doc(hidden)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>Information about the Amazon MSK broker type.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>Includes all client authentication information.</p>
    #[doc(hidden)]
    pub client_authentication: std::option::Option<crate::model::ClientAuthentication>,
    /// <p>Includes all encryption-related information.</p>
    #[doc(hidden)]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,
    /// <p>Information about the broker access configuration.</p>
    #[doc(hidden)]
    pub connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
    /// <p>This controls storage mode for supported storage tiers.</p>
    #[doc(hidden)]
    pub storage_mode: std::option::Option<crate::model::StorageMode>,
}
impl MutableClusterInfo {
    /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
    pub fn broker_ebs_volume_info(
        &self,
    ) -> std::option::Option<&[crate::model::BrokerEbsVolumeInfo]> {
        self.broker_ebs_volume_info.as_deref()
    }
    /// <p>Information about the changes in the configuration of the brokers.</p>
    pub fn configuration_info(&self) -> std::option::Option<&crate::model::ConfigurationInfo> {
        self.configuration_info.as_ref()
    }
    /// <p>The number of broker nodes in the cluster.</p>
    pub fn number_of_broker_nodes(&self) -> i32 {
        self.number_of_broker_nodes
    }
    /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
    pub fn enhanced_monitoring(&self) -> std::option::Option<&crate::model::EnhancedMonitoring> {
        self.enhanced_monitoring.as_ref()
    }
    /// <p>The settings for open monitoring.</p>
    pub fn open_monitoring(&self) -> std::option::Option<&crate::model::OpenMonitoring> {
        self.open_monitoring.as_ref()
    }
    /// <p>The Apache Kafka version.</p>
    pub fn kafka_version(&self) -> std::option::Option<&str> {
        self.kafka_version.as_deref()
    }
    /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
    pub fn logging_info(&self) -> std::option::Option<&crate::model::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>Information about the Amazon MSK broker type.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ClientAuthentication> {
        self.client_authentication.as_ref()
    }
    /// <p>Includes all encryption-related information.</p>
    pub fn encryption_info(&self) -> std::option::Option<&crate::model::EncryptionInfo> {
        self.encryption_info.as_ref()
    }
    /// <p>Information about the broker access configuration.</p>
    pub fn connectivity_info(&self) -> std::option::Option<&crate::model::ConnectivityInfo> {
        self.connectivity_info.as_ref()
    }
    /// <p>This controls storage mode for supported storage tiers.</p>
    pub fn storage_mode(&self) -> std::option::Option<&crate::model::StorageMode> {
        self.storage_mode.as_ref()
    }
}
/// See [`MutableClusterInfo`](crate::model::MutableClusterInfo).
pub mod mutable_cluster_info {

    /// A builder for [`MutableClusterInfo`](crate::model::MutableClusterInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_ebs_volume_info:
            std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
        pub(crate) configuration_info: std::option::Option<crate::model::ConfigurationInfo>,
        pub(crate) number_of_broker_nodes: std::option::Option<i32>,
        pub(crate) enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
        pub(crate) open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
        pub(crate) kafka_version: std::option::Option<std::string::String>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) client_authentication: std::option::Option<crate::model::ClientAuthentication>,
        pub(crate) encryption_info: std::option::Option<crate::model::EncryptionInfo>,
        pub(crate) connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
        pub(crate) storage_mode: std::option::Option<crate::model::StorageMode>,
    }
    impl Builder {
        /// Appends an item to `broker_ebs_volume_info`.
        ///
        /// To override the contents of this collection use [`set_broker_ebs_volume_info`](Self::set_broker_ebs_volume_info).
        ///
        /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
        pub fn broker_ebs_volume_info(mut self, input: crate::model::BrokerEbsVolumeInfo) -> Self {
            let mut v = self.broker_ebs_volume_info.unwrap_or_default();
            v.push(input);
            self.broker_ebs_volume_info = Some(v);
            self
        }
        /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
        pub fn set_broker_ebs_volume_info(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
        ) -> Self {
            self.broker_ebs_volume_info = input;
            self
        }
        /// <p>Information about the changes in the configuration of the brokers.</p>
        pub fn configuration_info(mut self, input: crate::model::ConfigurationInfo) -> Self {
            self.configuration_info = Some(input);
            self
        }
        /// <p>Information about the changes in the configuration of the brokers.</p>
        pub fn set_configuration_info(
            mut self,
            input: std::option::Option<crate::model::ConfigurationInfo>,
        ) -> Self {
            self.configuration_info = input;
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.number_of_broker_nodes = Some(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_broker_nodes = input;
            self
        }
        /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.enhanced_monitoring = Some(input);
            self
        }
        /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.enhanced_monitoring = input;
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoring) -> Self {
            self.open_monitoring = Some(input);
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoring>,
        ) -> Self {
            self.open_monitoring = input;
            self
        }
        /// <p>The Apache Kafka version.</p>
        pub fn kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_version = Some(input.into());
            self
        }
        /// <p>The Apache Kafka version.</p>
        pub fn set_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_version = input;
            self
        }
        /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>Information about the Amazon MSK broker type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>Information about the Amazon MSK broker type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.encryption_info = Some(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.encryption_info = input;
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn connectivity_info(mut self, input: crate::model::ConnectivityInfo) -> Self {
            self.connectivity_info = Some(input);
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn set_connectivity_info(
            mut self,
            input: std::option::Option<crate::model::ConnectivityInfo>,
        ) -> Self {
            self.connectivity_info = input;
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn storage_mode(mut self, input: crate::model::StorageMode) -> Self {
            self.storage_mode = Some(input);
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn set_storage_mode(
            mut self,
            input: std::option::Option<crate::model::StorageMode>,
        ) -> Self {
            self.storage_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`MutableClusterInfo`](crate::model::MutableClusterInfo).
        pub fn build(self) -> crate::model::MutableClusterInfo {
            crate::model::MutableClusterInfo {
                broker_ebs_volume_info: self.broker_ebs_volume_info,
                configuration_info: self.configuration_info,
                number_of_broker_nodes: self.number_of_broker_nodes.unwrap_or_default(),
                enhanced_monitoring: self.enhanced_monitoring,
                open_monitoring: self.open_monitoring,
                kafka_version: self.kafka_version,
                logging_info: self.logging_info,
                instance_type: self.instance_type,
                client_authentication: self.client_authentication,
                encryption_info: self.encryption_info,
                connectivity_info: self.connectivity_info,
                storage_mode: self.storage_mode,
            }
        }
    }
}
impl MutableClusterInfo {
    /// Creates a new builder-style object to manufacture [`MutableClusterInfo`](crate::model::MutableClusterInfo).
    pub fn builder() -> crate::model::mutable_cluster_info::Builder {
        crate::model::mutable_cluster_info::Builder::default()
    }
}

/// <p>Step taken during a cluster operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterOperationStep {
    /// <p>Information about the step and its status.</p>
    #[doc(hidden)]
    pub step_info: std::option::Option<crate::model::ClusterOperationStepInfo>,
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub step_name: std::option::Option<std::string::String>,
}
impl ClusterOperationStep {
    /// <p>Information about the step and its status.</p>
    pub fn step_info(&self) -> std::option::Option<&crate::model::ClusterOperationStepInfo> {
        self.step_info.as_ref()
    }
    /// <p>The name of the step.</p>
    pub fn step_name(&self) -> std::option::Option<&str> {
        self.step_name.as_deref()
    }
}
/// See [`ClusterOperationStep`](crate::model::ClusterOperationStep).
pub mod cluster_operation_step {

    /// A builder for [`ClusterOperationStep`](crate::model::ClusterOperationStep).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_info: std::option::Option<crate::model::ClusterOperationStepInfo>,
        pub(crate) step_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the step and its status.</p>
        pub fn step_info(mut self, input: crate::model::ClusterOperationStepInfo) -> Self {
            self.step_info = Some(input);
            self
        }
        /// <p>Information about the step and its status.</p>
        pub fn set_step_info(
            mut self,
            input: std::option::Option<crate::model::ClusterOperationStepInfo>,
        ) -> Self {
            self.step_info = input;
            self
        }
        /// <p>The name of the step.</p>
        pub fn step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_name = Some(input.into());
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_step_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOperationStep`](crate::model::ClusterOperationStep).
        pub fn build(self) -> crate::model::ClusterOperationStep {
            crate::model::ClusterOperationStep {
                step_info: self.step_info,
                step_name: self.step_name,
            }
        }
    }
}
impl ClusterOperationStep {
    /// Creates a new builder-style object to manufacture [`ClusterOperationStep`](crate::model::ClusterOperationStep).
    pub fn builder() -> crate::model::cluster_operation_step::Builder {
        crate::model::cluster_operation_step::Builder::default()
    }
}

/// <p>State information about the operation step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterOperationStepInfo {
    /// <p>The steps current status.</p>
    #[doc(hidden)]
    pub step_status: std::option::Option<std::string::String>,
}
impl ClusterOperationStepInfo {
    /// <p>The steps current status.</p>
    pub fn step_status(&self) -> std::option::Option<&str> {
        self.step_status.as_deref()
    }
}
/// See [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo).
pub mod cluster_operation_step_info {

    /// A builder for [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The steps current status.</p>
        pub fn step_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_status = Some(input.into());
            self
        }
        /// <p>The steps current status.</p>
        pub fn set_step_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo).
        pub fn build(self) -> crate::model::ClusterOperationStepInfo {
            crate::model::ClusterOperationStepInfo {
                step_status: self.step_status,
            }
        }
    }
}
impl ClusterOperationStepInfo {
    /// Creates a new builder-style object to manufacture [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo).
    pub fn builder() -> crate::model::cluster_operation_step_info::Builder {
        crate::model::cluster_operation_step_info::Builder::default()
    }
}

/// <p>Returns information about an error state of the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ErrorInfo {
    /// <p>A number describing the error programmatically.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>An optional field to provide more details about the error.</p>
    #[doc(hidden)]
    pub error_string: std::option::Option<std::string::String>,
}
impl ErrorInfo {
    /// <p>A number describing the error programmatically.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>An optional field to provide more details about the error.</p>
    pub fn error_string(&self) -> std::option::Option<&str> {
        self.error_string.as_deref()
    }
}
/// See [`ErrorInfo`](crate::model::ErrorInfo).
pub mod error_info {

    /// A builder for [`ErrorInfo`](crate::model::ErrorInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A number describing the error programmatically.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>A number describing the error programmatically.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An optional field to provide more details about the error.</p>
        pub fn error_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_string = Some(input.into());
            self
        }
        /// <p>An optional field to provide more details about the error.</p>
        pub fn set_error_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_string = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorInfo`](crate::model::ErrorInfo).
        pub fn build(self) -> crate::model::ErrorInfo {
            crate::model::ErrorInfo {
                error_code: self.error_code,
                error_string: self.error_string,
            }
        }
    }
}
impl ErrorInfo {
    /// Creates a new builder-style object to manufacture [`ErrorInfo`](crate::model::ErrorInfo).
    pub fn builder() -> crate::model::error_info::Builder {
        crate::model::error_info::Builder::default()
    }
}

/// <p>Contains source Apache Kafka versions and compatible target Apache Kafka versions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CompatibleKafkaVersion {
    /// <p>An Apache Kafka version.</p>
    #[doc(hidden)]
    pub source_version: std::option::Option<std::string::String>,
    /// <p>A list of Apache Kafka versions.</p>
    #[doc(hidden)]
    pub target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CompatibleKafkaVersion {
    /// <p>An Apache Kafka version.</p>
    pub fn source_version(&self) -> std::option::Option<&str> {
        self.source_version.as_deref()
    }
    /// <p>A list of Apache Kafka versions.</p>
    pub fn target_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.target_versions.as_deref()
    }
}
/// See [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion).
pub mod compatible_kafka_version {

    /// A builder for [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_version: std::option::Option<std::string::String>,
        pub(crate) target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>An Apache Kafka version.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_version = Some(input.into());
            self
        }
        /// <p>An Apache Kafka version.</p>
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_version = input;
            self
        }
        /// Appends an item to `target_versions`.
        ///
        /// To override the contents of this collection use [`set_target_versions`](Self::set_target_versions).
        ///
        /// <p>A list of Apache Kafka versions.</p>
        pub fn target_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_versions.unwrap_or_default();
            v.push(input.into());
            self.target_versions = Some(v);
            self
        }
        /// <p>A list of Apache Kafka versions.</p>
        pub fn set_target_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_versions = input;
            self
        }
        /// Consumes the builder and constructs a [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion).
        pub fn build(self) -> crate::model::CompatibleKafkaVersion {
            crate::model::CompatibleKafkaVersion {
                source_version: self.source_version,
                target_versions: self.target_versions,
            }
        }
    }
}
impl CompatibleKafkaVersion {
    /// Creates a new builder-style object to manufacture [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion).
    pub fn builder() -> crate::model::compatible_kafka_version::Builder {
        crate::model::compatible_kafka_version::Builder::default()
    }
}

/// <p>Serverless cluster request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServerlessRequest {
    /// <p>The configuration of the Amazon VPCs for the cluster.</p>
    #[doc(hidden)]
    pub vpc_configs: std::option::Option<std::vec::Vec<crate::model::VpcConfig>>,
    /// <p>Includes all client authentication information.</p>
    #[doc(hidden)]
    pub client_authentication: std::option::Option<crate::model::ServerlessClientAuthentication>,
}
impl ServerlessRequest {
    /// <p>The configuration of the Amazon VPCs for the cluster.</p>
    pub fn vpc_configs(&self) -> std::option::Option<&[crate::model::VpcConfig]> {
        self.vpc_configs.as_deref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ServerlessClientAuthentication> {
        self.client_authentication.as_ref()
    }
}
/// See [`ServerlessRequest`](crate::model::ServerlessRequest).
pub mod serverless_request {

    /// A builder for [`ServerlessRequest`](crate::model::ServerlessRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_configs: std::option::Option<std::vec::Vec<crate::model::VpcConfig>>,
        pub(crate) client_authentication:
            std::option::Option<crate::model::ServerlessClientAuthentication>,
    }
    impl Builder {
        /// Appends an item to `vpc_configs`.
        ///
        /// To override the contents of this collection use [`set_vpc_configs`](Self::set_vpc_configs).
        ///
        /// <p>The configuration of the Amazon VPCs for the cluster.</p>
        pub fn vpc_configs(mut self, input: crate::model::VpcConfig) -> Self {
            let mut v = self.vpc_configs.unwrap_or_default();
            v.push(input);
            self.vpc_configs = Some(v);
            self
        }
        /// <p>The configuration of the Amazon VPCs for the cluster.</p>
        pub fn set_vpc_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcConfig>>,
        ) -> Self {
            self.vpc_configs = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(
            mut self,
            input: crate::model::ServerlessClientAuthentication,
        ) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ServerlessClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerlessRequest`](crate::model::ServerlessRequest).
        pub fn build(self) -> crate::model::ServerlessRequest {
            crate::model::ServerlessRequest {
                vpc_configs: self.vpc_configs,
                client_authentication: self.client_authentication,
            }
        }
    }
}
impl ServerlessRequest {
    /// Creates a new builder-style object to manufacture [`ServerlessRequest`](crate::model::ServerlessRequest).
    pub fn builder() -> crate::model::serverless_request::Builder {
        crate::model::serverless_request::Builder::default()
    }
}

/// <p>Provisioned cluster request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedRequest {
    /// <p>Information about the brokers.</p>
    #[doc(hidden)]
    pub broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
    /// <p>Includes all client authentication information.</p>
    #[doc(hidden)]
    pub client_authentication: std::option::Option<crate::model::ClientAuthentication>,
    /// <p>Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.</p>
    #[doc(hidden)]
    pub configuration_info: std::option::Option<crate::model::ConfigurationInfo>,
    /// <p>Includes all encryption-related information.</p>
    #[doc(hidden)]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,
    /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
    #[doc(hidden)]
    pub enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
    /// <p>The settings for open monitoring.</p>
    #[doc(hidden)]
    pub open_monitoring: std::option::Option<crate::model::OpenMonitoringInfo>,
    /// <p>The Apache Kafka version that you want for the cluster.</p>
    #[doc(hidden)]
    pub kafka_version: std::option::Option<std::string::String>,
    /// <p>Log delivery information for the cluster.</p>
    #[doc(hidden)]
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The number of broker nodes in the cluster.</p>
    #[doc(hidden)]
    pub number_of_broker_nodes: i32,
    /// <p>This controls storage mode for supported storage tiers.</p>
    #[doc(hidden)]
    pub storage_mode: std::option::Option<crate::model::StorageMode>,
}
impl ProvisionedRequest {
    /// <p>Information about the brokers.</p>
    pub fn broker_node_group_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerNodeGroupInfo> {
        self.broker_node_group_info.as_ref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ClientAuthentication> {
        self.client_authentication.as_ref()
    }
    /// <p>Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.</p>
    pub fn configuration_info(&self) -> std::option::Option<&crate::model::ConfigurationInfo> {
        self.configuration_info.as_ref()
    }
    /// <p>Includes all encryption-related information.</p>
    pub fn encryption_info(&self) -> std::option::Option<&crate::model::EncryptionInfo> {
        self.encryption_info.as_ref()
    }
    /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
    pub fn enhanced_monitoring(&self) -> std::option::Option<&crate::model::EnhancedMonitoring> {
        self.enhanced_monitoring.as_ref()
    }
    /// <p>The settings for open monitoring.</p>
    pub fn open_monitoring(&self) -> std::option::Option<&crate::model::OpenMonitoringInfo> {
        self.open_monitoring.as_ref()
    }
    /// <p>The Apache Kafka version that you want for the cluster.</p>
    pub fn kafka_version(&self) -> std::option::Option<&str> {
        self.kafka_version.as_deref()
    }
    /// <p>Log delivery information for the cluster.</p>
    pub fn logging_info(&self) -> std::option::Option<&crate::model::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>The number of broker nodes in the cluster.</p>
    pub fn number_of_broker_nodes(&self) -> i32 {
        self.number_of_broker_nodes
    }
    /// <p>This controls storage mode for supported storage tiers.</p>
    pub fn storage_mode(&self) -> std::option::Option<&crate::model::StorageMode> {
        self.storage_mode.as_ref()
    }
}
/// See [`ProvisionedRequest`](crate::model::ProvisionedRequest).
pub mod provisioned_request {

    /// A builder for [`ProvisionedRequest`](crate::model::ProvisionedRequest).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        pub(crate) client_authentication: std::option::Option<crate::model::ClientAuthentication>,
        pub(crate) configuration_info: std::option::Option<crate::model::ConfigurationInfo>,
        pub(crate) encryption_info: std::option::Option<crate::model::EncryptionInfo>,
        pub(crate) enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
        pub(crate) open_monitoring: std::option::Option<crate::model::OpenMonitoringInfo>,
        pub(crate) kafka_version: std::option::Option<std::string::String>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) number_of_broker_nodes: std::option::Option<i32>,
        pub(crate) storage_mode: std::option::Option<crate::model::StorageMode>,
    }
    impl Builder {
        /// <p>Information about the brokers.</p>
        pub fn broker_node_group_info(mut self, input: crate::model::BrokerNodeGroupInfo) -> Self {
            self.broker_node_group_info = Some(input);
            self
        }
        /// <p>Information about the brokers.</p>
        pub fn set_broker_node_group_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        ) -> Self {
            self.broker_node_group_info = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// <p>Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.</p>
        pub fn configuration_info(mut self, input: crate::model::ConfigurationInfo) -> Self {
            self.configuration_info = Some(input);
            self
        }
        /// <p>Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.</p>
        pub fn set_configuration_info(
            mut self,
            input: std::option::Option<crate::model::ConfigurationInfo>,
        ) -> Self {
            self.configuration_info = input;
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.encryption_info = Some(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.encryption_info = input;
            self
        }
        /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.enhanced_monitoring = Some(input);
            self
        }
        /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.enhanced_monitoring = input;
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoringInfo) -> Self {
            self.open_monitoring = Some(input);
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoringInfo>,
        ) -> Self {
            self.open_monitoring = input;
            self
        }
        /// <p>The Apache Kafka version that you want for the cluster.</p>
        pub fn kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_version = Some(input.into());
            self
        }
        /// <p>The Apache Kafka version that you want for the cluster.</p>
        pub fn set_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_version = input;
            self
        }
        /// <p>Log delivery information for the cluster.</p>
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        /// <p>Log delivery information for the cluster.</p>
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.number_of_broker_nodes = Some(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_broker_nodes = input;
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn storage_mode(mut self, input: crate::model::StorageMode) -> Self {
            self.storage_mode = Some(input);
            self
        }
        /// <p>This controls storage mode for supported storage tiers.</p>
        pub fn set_storage_mode(
            mut self,
            input: std::option::Option<crate::model::StorageMode>,
        ) -> Self {
            self.storage_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedRequest`](crate::model::ProvisionedRequest).
        pub fn build(self) -> crate::model::ProvisionedRequest {
            crate::model::ProvisionedRequest {
                broker_node_group_info: self.broker_node_group_info,
                client_authentication: self.client_authentication,
                configuration_info: self.configuration_info,
                encryption_info: self.encryption_info,
                enhanced_monitoring: self.enhanced_monitoring,
                open_monitoring: self.open_monitoring,
                kafka_version: self.kafka_version,
                logging_info: self.logging_info,
                number_of_broker_nodes: self.number_of_broker_nodes.unwrap_or_default(),
                storage_mode: self.storage_mode,
            }
        }
    }
}
impl ProvisionedRequest {
    /// Creates a new builder-style object to manufacture [`ProvisionedRequest`](crate::model::ProvisionedRequest).
    pub fn builder() -> crate::model::provisioned_request::Builder {
        crate::model::provisioned_request::Builder::default()
    }
}

/// <p>Error info for scram secret associate/disassociate failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnprocessedScramSecret {
    /// <p>Error code for associate/disassociate failure.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>Error message for associate/disassociate failure.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>AWS Secrets Manager secret ARN.</p>
    #[doc(hidden)]
    pub secret_arn: std::option::Option<std::string::String>,
}
impl UnprocessedScramSecret {
    /// <p>Error code for associate/disassociate failure.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>Error message for associate/disassociate failure.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>AWS Secrets Manager secret ARN.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
/// See [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret).
pub mod unprocessed_scram_secret {

    /// A builder for [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error code for associate/disassociate failure.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>Error code for associate/disassociate failure.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Error message for associate/disassociate failure.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Error message for associate/disassociate failure.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>AWS Secrets Manager secret ARN.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>AWS Secrets Manager secret ARN.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret).
        pub fn build(self) -> crate::model::UnprocessedScramSecret {
            crate::model::UnprocessedScramSecret {
                error_code: self.error_code,
                error_message: self.error_message,
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl UnprocessedScramSecret {
    /// Creates a new builder-style object to manufacture [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret).
    pub fn builder() -> crate::model::unprocessed_scram_secret::Builder {
        crate::model::unprocessed_scram_secret::Builder::default()
    }
}
