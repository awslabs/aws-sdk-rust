// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionInfo {
    /// <p>The data-volume encryption details.</p>
    pub encryption_at_rest: std::option::Option<crate::model::EncryptionAtRest>,
    /// <p>The details for encryption in transit.</p>
    pub encryption_in_transit: std::option::Option<crate::model::EncryptionInTransit>,
}
impl EncryptionInfo {
    /// <p>The data-volume encryption details.</p>
    pub fn encryption_at_rest(&self) -> std::option::Option<&crate::model::EncryptionAtRest> {
        self.encryption_at_rest.as_ref()
    }
    /// <p>The details for encryption in transit.</p>
    pub fn encryption_in_transit(&self) -> std::option::Option<&crate::model::EncryptionInTransit> {
        self.encryption_in_transit.as_ref()
    }
}
impl std::fmt::Debug for EncryptionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionInfo");
        formatter.field("encryption_at_rest", &self.encryption_at_rest);
        formatter.field("encryption_in_transit", &self.encryption_in_transit);
        formatter.finish()
    }
}
/// See [`EncryptionInfo`](crate::model::EncryptionInfo)
pub mod encryption_info {
    /// A builder for [`EncryptionInfo`](crate::model::EncryptionInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_at_rest: std::option::Option<crate::model::EncryptionAtRest>,
        pub(crate) encryption_in_transit: std::option::Option<crate::model::EncryptionInTransit>,
    }
    impl Builder {
        /// <p>The data-volume encryption details.</p>
        pub fn encryption_at_rest(mut self, input: crate::model::EncryptionAtRest) -> Self {
            self.encryption_at_rest = Some(input);
            self
        }
        /// <p>The data-volume encryption details.</p>
        pub fn set_encryption_at_rest(
            mut self,
            input: std::option::Option<crate::model::EncryptionAtRest>,
        ) -> Self {
            self.encryption_at_rest = input;
            self
        }
        /// <p>The details for encryption in transit.</p>
        pub fn encryption_in_transit(mut self, input: crate::model::EncryptionInTransit) -> Self {
            self.encryption_in_transit = Some(input);
            self
        }
        /// <p>The details for encryption in transit.</p>
        pub fn set_encryption_in_transit(
            mut self,
            input: std::option::Option<crate::model::EncryptionInTransit>,
        ) -> Self {
            self.encryption_in_transit = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionInfo`](crate::model::EncryptionInfo)
        pub fn build(self) -> crate::model::EncryptionInfo {
            crate::model::EncryptionInfo {
                encryption_at_rest: self.encryption_at_rest,
                encryption_in_transit: self.encryption_in_transit,
            }
        }
    }
}
impl EncryptionInfo {
    /// Creates a new builder-style object to manufacture [`EncryptionInfo`](crate::model::EncryptionInfo)
    pub fn builder() -> crate::model::encryption_info::Builder {
        crate::model::encryption_info::Builder::default()
    }
}

/// <p>The settings for encrypting data in transit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionInTransit {
    /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
    /// <p>
    /// TLS means that client-broker communication is enabled with TLS only.</p>
    /// <p>
    /// TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
    /// <p>
    /// PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
    /// <p>The default value is TLS_PLAINTEXT.</p>
    pub client_broker: std::option::Option<crate::model::ClientBroker>,
    /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
    /// <p>The default value is true.</p>
    pub in_cluster: bool,
}
impl EncryptionInTransit {
    /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
    /// <p>
    /// TLS means that client-broker communication is enabled with TLS only.</p>
    /// <p>
    /// TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
    /// <p>
    /// PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
    /// <p>The default value is TLS_PLAINTEXT.</p>
    pub fn client_broker(&self) -> std::option::Option<&crate::model::ClientBroker> {
        self.client_broker.as_ref()
    }
    /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
    /// <p>The default value is true.</p>
    pub fn in_cluster(&self) -> bool {
        self.in_cluster
    }
}
impl std::fmt::Debug for EncryptionInTransit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionInTransit");
        formatter.field("client_broker", &self.client_broker);
        formatter.field("in_cluster", &self.in_cluster);
        formatter.finish()
    }
}
/// See [`EncryptionInTransit`](crate::model::EncryptionInTransit)
pub mod encryption_in_transit {
    /// A builder for [`EncryptionInTransit`](crate::model::EncryptionInTransit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_broker: std::option::Option<crate::model::ClientBroker>,
        pub(crate) in_cluster: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
        /// <p>
        /// TLS means that client-broker communication is enabled with TLS only.</p>
        /// <p>
        /// TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
        /// <p>
        /// PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
        /// <p>The default value is TLS_PLAINTEXT.</p>
        pub fn client_broker(mut self, input: crate::model::ClientBroker) -> Self {
            self.client_broker = Some(input);
            self
        }
        /// <p>Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.</p>
        /// <p>
        /// TLS means that client-broker communication is enabled with TLS only.</p>
        /// <p>
        /// TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.</p>
        /// <p>
        /// PLAINTEXT means that client-broker communication is enabled in plaintext only.</p>
        /// <p>The default value is TLS_PLAINTEXT.</p>
        pub fn set_client_broker(
            mut self,
            input: std::option::Option<crate::model::ClientBroker>,
        ) -> Self {
            self.client_broker = input;
            self
        }
        /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
        /// <p>The default value is true.</p>
        pub fn in_cluster(mut self, input: bool) -> Self {
            self.in_cluster = Some(input);
            self
        }
        /// <p>When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.</p>
        /// <p>The default value is true.</p>
        pub fn set_in_cluster(mut self, input: std::option::Option<bool>) -> Self {
            self.in_cluster = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionInTransit`](crate::model::EncryptionInTransit)
        pub fn build(self) -> crate::model::EncryptionInTransit {
            crate::model::EncryptionInTransit {
                client_broker: self.client_broker,
                in_cluster: self.in_cluster.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionInTransit {
    /// Creates a new builder-style object to manufacture [`EncryptionInTransit`](crate::model::EncryptionInTransit)
    pub fn builder() -> crate::model::encryption_in_transit::Builder {
        crate::model::encryption_in_transit::Builder::default()
    }
}

/// <p>Client-broker encryption in transit setting.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientBroker {
    #[allow(missing_docs)] // documentation missing in model
    Plaintext,
    #[allow(missing_docs)] // documentation missing in model
    Tls,
    #[allow(missing_docs)] // documentation missing in model
    TlsPlaintext,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClientBroker {
    fn from(s: &str) -> Self {
        match s {
            "PLAINTEXT" => ClientBroker::Plaintext,
            "TLS" => ClientBroker::Tls,
            "TLS_PLAINTEXT" => ClientBroker::TlsPlaintext,
            other => ClientBroker::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClientBroker {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientBroker::from(s))
    }
}
impl ClientBroker {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClientBroker::Plaintext => "PLAINTEXT",
            ClientBroker::Tls => "TLS",
            ClientBroker::TlsPlaintext => "TLS_PLAINTEXT",
            ClientBroker::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PLAINTEXT", "TLS", "TLS_PLAINTEXT"]
    }
}
impl AsRef<str> for ClientBroker {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data-volume encryption details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionAtRest {
    /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
    pub data_volume_kms_key_id: std::option::Option<std::string::String>,
}
impl EncryptionAtRest {
    /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
    pub fn data_volume_kms_key_id(&self) -> std::option::Option<&str> {
        self.data_volume_kms_key_id.as_deref()
    }
}
impl std::fmt::Debug for EncryptionAtRest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionAtRest");
        formatter.field("data_volume_kms_key_id", &self.data_volume_kms_key_id);
        formatter.finish()
    }
}
/// See [`EncryptionAtRest`](crate::model::EncryptionAtRest)
pub mod encryption_at_rest {
    /// A builder for [`EncryptionAtRest`](crate::model::EncryptionAtRest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_volume_kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
        pub fn data_volume_kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_volume_kms_key_id = Some(input.into());
            self
        }
        /// <p>The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.</p>
        pub fn set_data_volume_kms_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_volume_kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionAtRest`](crate::model::EncryptionAtRest)
        pub fn build(self) -> crate::model::EncryptionAtRest {
            crate::model::EncryptionAtRest {
                data_volume_kms_key_id: self.data_volume_kms_key_id,
            }
        }
    }
}
impl EncryptionAtRest {
    /// Creates a new builder-style object to manufacture [`EncryptionAtRest`](crate::model::EncryptionAtRest)
    pub fn builder() -> crate::model::encryption_at_rest::Builder {
        crate::model::encryption_at_rest::Builder::default()
    }
}

/// <p>Includes all client authentication information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientAuthentication {
    /// <p>Details for ClientAuthentication using SASL.</p>
    pub sasl: std::option::Option<crate::model::Sasl>,
    /// <p>Details for ClientAuthentication using TLS.</p>
    pub tls: std::option::Option<crate::model::Tls>,
    /// <p>Contains information about unauthenticated traffic to the cluster.</p>
    pub unauthenticated: std::option::Option<crate::model::Unauthenticated>,
}
impl ClientAuthentication {
    /// <p>Details for ClientAuthentication using SASL.</p>
    pub fn sasl(&self) -> std::option::Option<&crate::model::Sasl> {
        self.sasl.as_ref()
    }
    /// <p>Details for ClientAuthentication using TLS.</p>
    pub fn tls(&self) -> std::option::Option<&crate::model::Tls> {
        self.tls.as_ref()
    }
    /// <p>Contains information about unauthenticated traffic to the cluster.</p>
    pub fn unauthenticated(&self) -> std::option::Option<&crate::model::Unauthenticated> {
        self.unauthenticated.as_ref()
    }
}
impl std::fmt::Debug for ClientAuthentication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientAuthentication");
        formatter.field("sasl", &self.sasl);
        formatter.field("tls", &self.tls);
        formatter.field("unauthenticated", &self.unauthenticated);
        formatter.finish()
    }
}
/// See [`ClientAuthentication`](crate::model::ClientAuthentication)
pub mod client_authentication {
    /// A builder for [`ClientAuthentication`](crate::model::ClientAuthentication)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sasl: std::option::Option<crate::model::Sasl>,
        pub(crate) tls: std::option::Option<crate::model::Tls>,
        pub(crate) unauthenticated: std::option::Option<crate::model::Unauthenticated>,
    }
    impl Builder {
        /// <p>Details for ClientAuthentication using SASL.</p>
        pub fn sasl(mut self, input: crate::model::Sasl) -> Self {
            self.sasl = Some(input);
            self
        }
        /// <p>Details for ClientAuthentication using SASL.</p>
        pub fn set_sasl(mut self, input: std::option::Option<crate::model::Sasl>) -> Self {
            self.sasl = input;
            self
        }
        /// <p>Details for ClientAuthentication using TLS.</p>
        pub fn tls(mut self, input: crate::model::Tls) -> Self {
            self.tls = Some(input);
            self
        }
        /// <p>Details for ClientAuthentication using TLS.</p>
        pub fn set_tls(mut self, input: std::option::Option<crate::model::Tls>) -> Self {
            self.tls = input;
            self
        }
        /// <p>Contains information about unauthenticated traffic to the cluster.</p>
        pub fn unauthenticated(mut self, input: crate::model::Unauthenticated) -> Self {
            self.unauthenticated = Some(input);
            self
        }
        /// <p>Contains information about unauthenticated traffic to the cluster.</p>
        pub fn set_unauthenticated(
            mut self,
            input: std::option::Option<crate::model::Unauthenticated>,
        ) -> Self {
            self.unauthenticated = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientAuthentication`](crate::model::ClientAuthentication)
        pub fn build(self) -> crate::model::ClientAuthentication {
            crate::model::ClientAuthentication {
                sasl: self.sasl,
                tls: self.tls,
                unauthenticated: self.unauthenticated,
            }
        }
    }
}
impl ClientAuthentication {
    /// Creates a new builder-style object to manufacture [`ClientAuthentication`](crate::model::ClientAuthentication)
    pub fn builder() -> crate::model::client_authentication::Builder {
        crate::model::client_authentication::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Unauthenticated {
    /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
    pub enabled: bool,
}
impl Unauthenticated {
    /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for Unauthenticated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Unauthenticated");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`Unauthenticated`](crate::model::Unauthenticated)
pub mod unauthenticated {
    /// A builder for [`Unauthenticated`](crate::model::Unauthenticated)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Unauthenticated`](crate::model::Unauthenticated)
        pub fn build(self) -> crate::model::Unauthenticated {
            crate::model::Unauthenticated {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Unauthenticated {
    /// Creates a new builder-style object to manufacture [`Unauthenticated`](crate::model::Unauthenticated)
    pub fn builder() -> crate::model::unauthenticated::Builder {
        crate::model::unauthenticated::Builder::default()
    }
}

/// <p>Details for client authentication using TLS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tls {
    /// <p>List of ACM Certificate Authority ARNs.</p>
    pub certificate_authority_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
    pub enabled: bool,
}
impl Tls {
    /// <p>List of ACM Certificate Authority ARNs.</p>
    pub fn certificate_authority_arn_list(&self) -> std::option::Option<&[std::string::String]> {
        self.certificate_authority_arn_list.as_deref()
    }
    /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for Tls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tls");
        formatter.field(
            "certificate_authority_arn_list",
            &self.certificate_authority_arn_list,
        );
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`Tls`](crate::model::Tls)
pub mod tls {
    /// A builder for [`Tls`](crate::model::Tls)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) certificate_authority_arn_list:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// Appends an item to `certificate_authority_arn_list`.
        ///
        /// To override the contents of this collection use [`set_certificate_authority_arn_list`](Self::set_certificate_authority_arn_list).
        ///
        /// <p>List of ACM Certificate Authority ARNs.</p>
        pub fn certificate_authority_arn_list(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.certificate_authority_arn_list.unwrap_or_default();
            v.push(input.into());
            self.certificate_authority_arn_list = Some(v);
            self
        }
        /// <p>List of ACM Certificate Authority ARNs.</p>
        pub fn set_certificate_authority_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.certificate_authority_arn_list = input;
            self
        }
        /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether you want to turn on or turn off TLS authentication.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Tls`](crate::model::Tls)
        pub fn build(self) -> crate::model::Tls {
            crate::model::Tls {
                certificate_authority_arn_list: self.certificate_authority_arn_list,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Tls {
    /// Creates a new builder-style object to manufacture [`Tls`](crate::model::Tls)
    pub fn builder() -> crate::model::tls::Builder {
        crate::model::tls::Builder::default()
    }
}

/// <p>Details for client authentication using SASL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Sasl {
    /// <p>Details for SASL/SCRAM client authentication.</p>
    pub scram: std::option::Option<crate::model::Scram>,
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub iam: std::option::Option<crate::model::Iam>,
}
impl Sasl {
    /// <p>Details for SASL/SCRAM client authentication.</p>
    pub fn scram(&self) -> std::option::Option<&crate::model::Scram> {
        self.scram.as_ref()
    }
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub fn iam(&self) -> std::option::Option<&crate::model::Iam> {
        self.iam.as_ref()
    }
}
impl std::fmt::Debug for Sasl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Sasl");
        formatter.field("scram", &self.scram);
        formatter.field("iam", &self.iam);
        formatter.finish()
    }
}
/// See [`Sasl`](crate::model::Sasl)
pub mod sasl {
    /// A builder for [`Sasl`](crate::model::Sasl)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scram: std::option::Option<crate::model::Scram>,
        pub(crate) iam: std::option::Option<crate::model::Iam>,
    }
    impl Builder {
        /// <p>Details for SASL/SCRAM client authentication.</p>
        pub fn scram(mut self, input: crate::model::Scram) -> Self {
            self.scram = Some(input);
            self
        }
        /// <p>Details for SASL/SCRAM client authentication.</p>
        pub fn set_scram(mut self, input: std::option::Option<crate::model::Scram>) -> Self {
            self.scram = input;
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn iam(mut self, input: crate::model::Iam) -> Self {
            self.iam = Some(input);
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn set_iam(mut self, input: std::option::Option<crate::model::Iam>) -> Self {
            self.iam = input;
            self
        }
        /// Consumes the builder and constructs a [`Sasl`](crate::model::Sasl)
        pub fn build(self) -> crate::model::Sasl {
            crate::model::Sasl {
                scram: self.scram,
                iam: self.iam,
            }
        }
    }
}
impl Sasl {
    /// Creates a new builder-style object to manufacture [`Sasl`](crate::model::Sasl)
    pub fn builder() -> crate::model::sasl::Builder {
        crate::model::sasl::Builder::default()
    }
}

/// <p>Details for IAM access control.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Iam {
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub enabled: bool,
}
impl Iam {
    /// <p>Indicates whether IAM access control is enabled.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for Iam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Iam");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`Iam`](crate::model::Iam)
pub mod iam {
    /// A builder for [`Iam`](crate::model::Iam)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Indicates whether IAM access control is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Iam`](crate::model::Iam)
        pub fn build(self) -> crate::model::Iam {
            crate::model::Iam {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Iam {
    /// Creates a new builder-style object to manufacture [`Iam`](crate::model::Iam)
    pub fn builder() -> crate::model::iam::Builder {
        crate::model::iam::Builder::default()
    }
}

/// <p>Details for SASL/SCRAM client authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Scram {
    /// <p>SASL/SCRAM authentication is enabled or not.</p>
    pub enabled: bool,
}
impl Scram {
    /// <p>SASL/SCRAM authentication is enabled or not.</p>
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for Scram {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Scram");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`Scram`](crate::model::Scram)
pub mod scram {
    /// A builder for [`Scram`](crate::model::Scram)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>SASL/SCRAM authentication is enabled or not.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>SASL/SCRAM authentication is enabled or not.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Scram`](crate::model::Scram)
        pub fn build(self) -> crate::model::Scram {
            crate::model::Scram {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Scram {
    /// Creates a new builder-style object to manufacture [`Scram`](crate::model::Scram)
    pub fn builder() -> crate::model::scram::Builder {
        crate::model::scram::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoggingInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub broker_logs: std::option::Option<crate::model::BrokerLogs>,
}
impl LoggingInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub fn broker_logs(&self) -> std::option::Option<&crate::model::BrokerLogs> {
        self.broker_logs.as_ref()
    }
}
impl std::fmt::Debug for LoggingInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoggingInfo");
        formatter.field("broker_logs", &self.broker_logs);
        formatter.finish()
    }
}
/// See [`LoggingInfo`](crate::model::LoggingInfo)
pub mod logging_info {
    /// A builder for [`LoggingInfo`](crate::model::LoggingInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_logs: std::option::Option<crate::model::BrokerLogs>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn broker_logs(mut self, input: crate::model::BrokerLogs) -> Self {
            self.broker_logs = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_broker_logs(
            mut self,
            input: std::option::Option<crate::model::BrokerLogs>,
        ) -> Self {
            self.broker_logs = input;
            self
        }
        /// Consumes the builder and constructs a [`LoggingInfo`](crate::model::LoggingInfo)
        pub fn build(self) -> crate::model::LoggingInfo {
            crate::model::LoggingInfo {
                broker_logs: self.broker_logs,
            }
        }
    }
}
impl LoggingInfo {
    /// Creates a new builder-style object to manufacture [`LoggingInfo`](crate::model::LoggingInfo)
    pub fn builder() -> crate::model::logging_info::Builder {
        crate::model::logging_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BrokerLogs {
    #[allow(missing_docs)] // documentation missing in model
    pub cloud_watch_logs: std::option::Option<crate::model::CloudWatchLogs>,
    #[allow(missing_docs)] // documentation missing in model
    pub firehose: std::option::Option<crate::model::Firehose>,
    #[allow(missing_docs)] // documentation missing in model
    pub s3: std::option::Option<crate::model::S3>,
}
impl BrokerLogs {
    #[allow(missing_docs)] // documentation missing in model
    pub fn cloud_watch_logs(&self) -> std::option::Option<&crate::model::CloudWatchLogs> {
        self.cloud_watch_logs.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn firehose(&self) -> std::option::Option<&crate::model::Firehose> {
        self.firehose.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn s3(&self) -> std::option::Option<&crate::model::S3> {
        self.s3.as_ref()
    }
}
impl std::fmt::Debug for BrokerLogs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BrokerLogs");
        formatter.field("cloud_watch_logs", &self.cloud_watch_logs);
        formatter.field("firehose", &self.firehose);
        formatter.field("s3", &self.s3);
        formatter.finish()
    }
}
/// See [`BrokerLogs`](crate::model::BrokerLogs)
pub mod broker_logs {
    /// A builder for [`BrokerLogs`](crate::model::BrokerLogs)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_logs: std::option::Option<crate::model::CloudWatchLogs>,
        pub(crate) firehose: std::option::Option<crate::model::Firehose>,
        pub(crate) s3: std::option::Option<crate::model::S3>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn cloud_watch_logs(mut self, input: crate::model::CloudWatchLogs) -> Self {
            self.cloud_watch_logs = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_cloud_watch_logs(
            mut self,
            input: std::option::Option<crate::model::CloudWatchLogs>,
        ) -> Self {
            self.cloud_watch_logs = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn firehose(mut self, input: crate::model::Firehose) -> Self {
            self.firehose = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_firehose(mut self, input: std::option::Option<crate::model::Firehose>) -> Self {
            self.firehose = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn s3(mut self, input: crate::model::S3) -> Self {
            self.s3 = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_s3(mut self, input: std::option::Option<crate::model::S3>) -> Self {
            self.s3 = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerLogs`](crate::model::BrokerLogs)
        pub fn build(self) -> crate::model::BrokerLogs {
            crate::model::BrokerLogs {
                cloud_watch_logs: self.cloud_watch_logs,
                firehose: self.firehose,
                s3: self.s3,
            }
        }
    }
}
impl BrokerLogs {
    /// Creates a new builder-style object to manufacture [`BrokerLogs`](crate::model::BrokerLogs)
    pub fn builder() -> crate::model::broker_logs::Builder {
        crate::model::broker_logs::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3 {
    #[allow(missing_docs)] // documentation missing in model
    pub bucket: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub enabled: bool,
    #[allow(missing_docs)] // documentation missing in model
    pub prefix: std::option::Option<std::string::String>,
}
impl S3 {
    #[allow(missing_docs)] // documentation missing in model
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn prefix(&self) -> std::option::Option<&str> {
        self.prefix.as_deref()
    }
}
impl std::fmt::Debug for S3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3");
        formatter.field("bucket", &self.bucket);
        formatter.field("enabled", &self.enabled);
        formatter.field("prefix", &self.prefix);
        formatter.finish()
    }
}
/// See [`S3`](crate::model::S3)
pub mod s3 {
    /// A builder for [`S3`](crate::model::S3)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`S3`](crate::model::S3)
        pub fn build(self) -> crate::model::S3 {
            crate::model::S3 {
                bucket: self.bucket,
                enabled: self.enabled.unwrap_or_default(),
                prefix: self.prefix,
            }
        }
    }
}
impl S3 {
    /// Creates a new builder-style object to manufacture [`S3`](crate::model::S3)
    pub fn builder() -> crate::model::s3::Builder {
        crate::model::s3::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Firehose {
    #[allow(missing_docs)] // documentation missing in model
    pub delivery_stream: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub enabled: bool,
}
impl Firehose {
    #[allow(missing_docs)] // documentation missing in model
    pub fn delivery_stream(&self) -> std::option::Option<&str> {
        self.delivery_stream.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> bool {
        self.enabled
    }
}
impl std::fmt::Debug for Firehose {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Firehose");
        formatter.field("delivery_stream", &self.delivery_stream);
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`Firehose`](crate::model::Firehose)
pub mod firehose {
    /// A builder for [`Firehose`](crate::model::Firehose)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_stream: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn delivery_stream(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_stream = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_delivery_stream(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivery_stream = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`Firehose`](crate::model::Firehose)
        pub fn build(self) -> crate::model::Firehose {
            crate::model::Firehose {
                delivery_stream: self.delivery_stream,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl Firehose {
    /// Creates a new builder-style object to manufacture [`Firehose`](crate::model::Firehose)
    pub fn builder() -> crate::model::firehose::Builder {
        crate::model::firehose::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CloudWatchLogs {
    #[allow(missing_docs)] // documentation missing in model
    pub enabled: bool,
    #[allow(missing_docs)] // documentation missing in model
    pub log_group: std::option::Option<std::string::String>,
}
impl CloudWatchLogs {
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> bool {
        self.enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn log_group(&self) -> std::option::Option<&str> {
        self.log_group.as_deref()
    }
}
impl std::fmt::Debug for CloudWatchLogs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CloudWatchLogs");
        formatter.field("enabled", &self.enabled);
        formatter.field("log_group", &self.log_group);
        formatter.finish()
    }
}
/// See [`CloudWatchLogs`](crate::model::CloudWatchLogs)
pub mod cloud_watch_logs {
    /// A builder for [`CloudWatchLogs`](crate::model::CloudWatchLogs)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) log_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_log_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_group = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLogs`](crate::model::CloudWatchLogs)
        pub fn build(self) -> crate::model::CloudWatchLogs {
            crate::model::CloudWatchLogs {
                enabled: self.enabled.unwrap_or_default(),
                log_group: self.log_group,
            }
        }
    }
}
impl CloudWatchLogs {
    /// Creates a new builder-style object to manufacture [`CloudWatchLogs`](crate::model::CloudWatchLogs)
    pub fn builder() -> crate::model::cloud_watch_logs::Builder {
        crate::model::cloud_watch_logs::Builder::default()
    }
}

/// <p>JMX and Node monitoring for the MSK cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OpenMonitoringInfo {
    /// <p>Prometheus settings.</p>
    pub prometheus: std::option::Option<crate::model::PrometheusInfo>,
}
impl OpenMonitoringInfo {
    /// <p>Prometheus settings.</p>
    pub fn prometheus(&self) -> std::option::Option<&crate::model::PrometheusInfo> {
        self.prometheus.as_ref()
    }
}
impl std::fmt::Debug for OpenMonitoringInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpenMonitoringInfo");
        formatter.field("prometheus", &self.prometheus);
        formatter.finish()
    }
}
/// See [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo)
pub mod open_monitoring_info {
    /// A builder for [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prometheus: std::option::Option<crate::model::PrometheusInfo>,
    }
    impl Builder {
        /// <p>Prometheus settings.</p>
        pub fn prometheus(mut self, input: crate::model::PrometheusInfo) -> Self {
            self.prometheus = Some(input);
            self
        }
        /// <p>Prometheus settings.</p>
        pub fn set_prometheus(
            mut self,
            input: std::option::Option<crate::model::PrometheusInfo>,
        ) -> Self {
            self.prometheus = input;
            self
        }
        /// Consumes the builder and constructs a [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo)
        pub fn build(self) -> crate::model::OpenMonitoringInfo {
            crate::model::OpenMonitoringInfo {
                prometheus: self.prometheus,
            }
        }
    }
}
impl OpenMonitoringInfo {
    /// Creates a new builder-style object to manufacture [`OpenMonitoringInfo`](crate::model::OpenMonitoringInfo)
    pub fn builder() -> crate::model::open_monitoring_info::Builder {
        crate::model::open_monitoring_info::Builder::default()
    }
}

/// <p>Prometheus settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrometheusInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub jmx_exporter: std::option::Option<crate::model::JmxExporterInfo>,
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub node_exporter: std::option::Option<crate::model::NodeExporterInfo>,
}
impl PrometheusInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn jmx_exporter(&self) -> std::option::Option<&crate::model::JmxExporterInfo> {
        self.jmx_exporter.as_ref()
    }
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn node_exporter(&self) -> std::option::Option<&crate::model::NodeExporterInfo> {
        self.node_exporter.as_ref()
    }
}
impl std::fmt::Debug for PrometheusInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PrometheusInfo");
        formatter.field("jmx_exporter", &self.jmx_exporter);
        formatter.field("node_exporter", &self.node_exporter);
        formatter.finish()
    }
}
/// See [`PrometheusInfo`](crate::model::PrometheusInfo)
pub mod prometheus_info {
    /// A builder for [`PrometheusInfo`](crate::model::PrometheusInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jmx_exporter: std::option::Option<crate::model::JmxExporterInfo>,
        pub(crate) node_exporter: std::option::Option<crate::model::NodeExporterInfo>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn jmx_exporter(mut self, input: crate::model::JmxExporterInfo) -> Self {
            self.jmx_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_jmx_exporter(
            mut self,
            input: std::option::Option<crate::model::JmxExporterInfo>,
        ) -> Self {
            self.jmx_exporter = input;
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn node_exporter(mut self, input: crate::model::NodeExporterInfo) -> Self {
            self.node_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_node_exporter(
            mut self,
            input: std::option::Option<crate::model::NodeExporterInfo>,
        ) -> Self {
            self.node_exporter = input;
            self
        }
        /// Consumes the builder and constructs a [`PrometheusInfo`](crate::model::PrometheusInfo)
        pub fn build(self) -> crate::model::PrometheusInfo {
            crate::model::PrometheusInfo {
                jmx_exporter: self.jmx_exporter,
                node_exporter: self.node_exporter,
            }
        }
    }
}
impl PrometheusInfo {
    /// Creates a new builder-style object to manufacture [`PrometheusInfo`](crate::model::PrometheusInfo)
    pub fn builder() -> crate::model::prometheus_info::Builder {
        crate::model::prometheus_info::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub enabled_in_broker: bool,
}
impl NodeExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
impl std::fmt::Debug for NodeExporterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeExporterInfo");
        formatter.field("enabled_in_broker", &self.enabled_in_broker);
        formatter.finish()
    }
}
/// See [`NodeExporterInfo`](crate::model::NodeExporterInfo)
pub mod node_exporter_info {
    /// A builder for [`NodeExporterInfo`](crate::model::NodeExporterInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeExporterInfo`](crate::model::NodeExporterInfo)
        pub fn build(self) -> crate::model::NodeExporterInfo {
            crate::model::NodeExporterInfo {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl NodeExporterInfo {
    /// Creates a new builder-style object to manufacture [`NodeExporterInfo`](crate::model::NodeExporterInfo)
    pub fn builder() -> crate::model::node_exporter_info::Builder {
        crate::model::node_exporter_info::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JmxExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub enabled_in_broker: bool,
}
impl JmxExporterInfo {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
impl std::fmt::Debug for JmxExporterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JmxExporterInfo");
        formatter.field("enabled_in_broker", &self.enabled_in_broker);
        formatter.finish()
    }
}
/// See [`JmxExporterInfo`](crate::model::JmxExporterInfo)
pub mod jmx_exporter_info {
    /// A builder for [`JmxExporterInfo`](crate::model::JmxExporterInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`JmxExporterInfo`](crate::model::JmxExporterInfo)
        pub fn build(self) -> crate::model::JmxExporterInfo {
            crate::model::JmxExporterInfo {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl JmxExporterInfo {
    /// Creates a new builder-style object to manufacture [`JmxExporterInfo`](crate::model::JmxExporterInfo)
    pub fn builder() -> crate::model::jmx_exporter_info::Builder {
        crate::model::jmx_exporter_info::Builder::default()
    }
}

/// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EnhancedMonitoring {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    #[allow(missing_docs)] // documentation missing in model
    PerBroker,
    #[allow(missing_docs)] // documentation missing in model
    PerTopicPerBroker,
    #[allow(missing_docs)] // documentation missing in model
    PerTopicPerPartition,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EnhancedMonitoring {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => EnhancedMonitoring::Default,
            "PER_BROKER" => EnhancedMonitoring::PerBroker,
            "PER_TOPIC_PER_BROKER" => EnhancedMonitoring::PerTopicPerBroker,
            "PER_TOPIC_PER_PARTITION" => EnhancedMonitoring::PerTopicPerPartition,
            other => EnhancedMonitoring::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EnhancedMonitoring {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EnhancedMonitoring::from(s))
    }
}
impl EnhancedMonitoring {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EnhancedMonitoring::Default => "DEFAULT",
            EnhancedMonitoring::PerBroker => "PER_BROKER",
            EnhancedMonitoring::PerTopicPerBroker => "PER_TOPIC_PER_BROKER",
            EnhancedMonitoring::PerTopicPerPartition => "PER_TOPIC_PER_PARTITION",
            EnhancedMonitoring::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DEFAULT",
            "PER_BROKER",
            "PER_TOPIC_PER_BROKER",
            "PER_TOPIC_PER_PARTITION",
        ]
    }
}
impl AsRef<str> for EnhancedMonitoring {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the broker access configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConnectivityInfo {
    /// <p>Public access control for brokers.</p>
    pub public_access: std::option::Option<crate::model::PublicAccess>,
}
impl ConnectivityInfo {
    /// <p>Public access control for brokers.</p>
    pub fn public_access(&self) -> std::option::Option<&crate::model::PublicAccess> {
        self.public_access.as_ref()
    }
}
impl std::fmt::Debug for ConnectivityInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConnectivityInfo");
        formatter.field("public_access", &self.public_access);
        formatter.finish()
    }
}
/// See [`ConnectivityInfo`](crate::model::ConnectivityInfo)
pub mod connectivity_info {
    /// A builder for [`ConnectivityInfo`](crate::model::ConnectivityInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) public_access: std::option::Option<crate::model::PublicAccess>,
    }
    impl Builder {
        /// <p>Public access control for brokers.</p>
        pub fn public_access(mut self, input: crate::model::PublicAccess) -> Self {
            self.public_access = Some(input);
            self
        }
        /// <p>Public access control for brokers.</p>
        pub fn set_public_access(
            mut self,
            input: std::option::Option<crate::model::PublicAccess>,
        ) -> Self {
            self.public_access = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectivityInfo`](crate::model::ConnectivityInfo)
        pub fn build(self) -> crate::model::ConnectivityInfo {
            crate::model::ConnectivityInfo {
                public_access: self.public_access,
            }
        }
    }
}
impl ConnectivityInfo {
    /// Creates a new builder-style object to manufacture [`ConnectivityInfo`](crate::model::ConnectivityInfo)
    pub fn builder() -> crate::model::connectivity_info::Builder {
        crate::model::connectivity_info::Builder::default()
    }
}

/// Public access control for brokers.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicAccess {
    /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl PublicAccess {
    /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for PublicAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicAccess");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`PublicAccess`](crate::model::PublicAccess)
pub mod public_access {
    /// A builder for [`PublicAccess`](crate::model::PublicAccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicAccess`](crate::model::PublicAccess)
        pub fn build(self) -> crate::model::PublicAccess {
            crate::model::PublicAccess {
                r#type: self.r#type,
            }
        }
    }
}
impl PublicAccess {
    /// Creates a new builder-style object to manufacture [`PublicAccess`](crate::model::PublicAccess)
    pub fn builder() -> crate::model::public_access::Builder {
        crate::model::public_access::Builder::default()
    }
}

/// <p>Describes a configuration revision.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigurationRevision {
    /// <p>The time when the configuration revision was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the configuration revision.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The revision number.</p>
    pub revision: i64,
}
impl ConfigurationRevision {
    /// <p>The time when the configuration revision was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The description of the configuration revision.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The revision number.</p>
    pub fn revision(&self) -> i64 {
        self.revision
    }
}
impl std::fmt::Debug for ConfigurationRevision {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigurationRevision");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("revision", &self.revision);
        formatter.finish()
    }
}
/// See [`ConfigurationRevision`](crate::model::ConfigurationRevision)
pub mod configuration_revision {
    /// A builder for [`ConfigurationRevision`](crate::model::ConfigurationRevision)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) revision: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The time when the configuration revision was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the configuration revision was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The description of the configuration revision.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the configuration revision.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The revision number.</p>
        pub fn revision(mut self, input: i64) -> Self {
            self.revision = Some(input);
            self
        }
        /// <p>The revision number.</p>
        pub fn set_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.revision = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationRevision`](crate::model::ConfigurationRevision)
        pub fn build(self) -> crate::model::ConfigurationRevision {
            crate::model::ConfigurationRevision {
                creation_time: self.creation_time,
                description: self.description,
                revision: self.revision.unwrap_or_default(),
            }
        }
    }
}
impl ConfigurationRevision {
    /// Creates a new builder-style object to manufacture [`ConfigurationRevision`](crate::model::ConfigurationRevision)
    pub fn builder() -> crate::model::configuration_revision::Builder {
        crate::model::configuration_revision::Builder::default()
    }
}

/// <p>Specifies the configuration to use for the brokers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigurationInfo {
    /// <p>ARN of the configuration to use.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The revision of the configuration to use.</p>
    pub revision: i64,
}
impl ConfigurationInfo {
    /// <p>ARN of the configuration to use.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The revision of the configuration to use.</p>
    pub fn revision(&self) -> i64 {
        self.revision
    }
}
impl std::fmt::Debug for ConfigurationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigurationInfo");
        formatter.field("arn", &self.arn);
        formatter.field("revision", &self.revision);
        formatter.finish()
    }
}
/// See [`ConfigurationInfo`](crate::model::ConfigurationInfo)
pub mod configuration_info {
    /// A builder for [`ConfigurationInfo`](crate::model::ConfigurationInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) revision: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>ARN of the configuration to use.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>ARN of the configuration to use.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The revision of the configuration to use.</p>
        pub fn revision(mut self, input: i64) -> Self {
            self.revision = Some(input);
            self
        }
        /// <p>The revision of the configuration to use.</p>
        pub fn set_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.revision = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationInfo`](crate::model::ConfigurationInfo)
        pub fn build(self) -> crate::model::ConfigurationInfo {
            crate::model::ConfigurationInfo {
                arn: self.arn,
                revision: self.revision.unwrap_or_default(),
            }
        }
    }
}
impl ConfigurationInfo {
    /// Creates a new builder-style object to manufacture [`ConfigurationInfo`](crate::model::ConfigurationInfo)
    pub fn builder() -> crate::model::configuration_info::Builder {
        crate::model::configuration_info::Builder::default()
    }
}

/// <p>Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BrokerEbsVolumeInfo {
    /// <p>The ID of the broker to update.</p>
    pub kafka_broker_node_id: std::option::Option<std::string::String>,
    /// <p>Size of the EBS volume to update.</p>
    pub volume_size_gb: i32,
}
impl BrokerEbsVolumeInfo {
    /// <p>The ID of the broker to update.</p>
    pub fn kafka_broker_node_id(&self) -> std::option::Option<&str> {
        self.kafka_broker_node_id.as_deref()
    }
    /// <p>Size of the EBS volume to update.</p>
    pub fn volume_size_gb(&self) -> i32 {
        self.volume_size_gb
    }
}
impl std::fmt::Debug for BrokerEbsVolumeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BrokerEbsVolumeInfo");
        formatter.field("kafka_broker_node_id", &self.kafka_broker_node_id);
        formatter.field("volume_size_gb", &self.volume_size_gb);
        formatter.finish()
    }
}
/// See [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo)
pub mod broker_ebs_volume_info {
    /// A builder for [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kafka_broker_node_id: std::option::Option<std::string::String>,
        pub(crate) volume_size_gb: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the broker to update.</p>
        pub fn kafka_broker_node_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_broker_node_id = Some(input.into());
            self
        }
        /// <p>The ID of the broker to update.</p>
        pub fn set_kafka_broker_node_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_broker_node_id = input;
            self
        }
        /// <p>Size of the EBS volume to update.</p>
        pub fn volume_size_gb(mut self, input: i32) -> Self {
            self.volume_size_gb = Some(input);
            self
        }
        /// <p>Size of the EBS volume to update.</p>
        pub fn set_volume_size_gb(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size_gb = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo)
        pub fn build(self) -> crate::model::BrokerEbsVolumeInfo {
            crate::model::BrokerEbsVolumeInfo {
                kafka_broker_node_id: self.kafka_broker_node_id,
                volume_size_gb: self.volume_size_gb.unwrap_or_default(),
            }
        }
    }
}
impl BrokerEbsVolumeInfo {
    /// Creates a new builder-style object to manufacture [`BrokerEbsVolumeInfo`](crate::model::BrokerEbsVolumeInfo)
    pub fn builder() -> crate::model::broker_ebs_volume_info::Builder {
        crate::model::broker_ebs_volume_info::Builder::default()
    }
}

/// <p>The node information object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeInfo {
    /// <p>The start time.</p>
    pub added_to_cluster_time: std::option::Option<std::string::String>,
    /// <p>The broker node info.</p>
    pub broker_node_info: std::option::Option<crate::model::BrokerNodeInfo>,
    /// <p>The instance type.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the node.</p>
    pub node_arn: std::option::Option<std::string::String>,
    /// <p>The node type.</p>
    pub node_type: std::option::Option<crate::model::NodeType>,
    /// <p>The ZookeeperNodeInfo.</p>
    pub zookeeper_node_info: std::option::Option<crate::model::ZookeeperNodeInfo>,
}
impl NodeInfo {
    /// <p>The start time.</p>
    pub fn added_to_cluster_time(&self) -> std::option::Option<&str> {
        self.added_to_cluster_time.as_deref()
    }
    /// <p>The broker node info.</p>
    pub fn broker_node_info(&self) -> std::option::Option<&crate::model::BrokerNodeInfo> {
        self.broker_node_info.as_ref()
    }
    /// <p>The instance type.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the node.</p>
    pub fn node_arn(&self) -> std::option::Option<&str> {
        self.node_arn.as_deref()
    }
    /// <p>The node type.</p>
    pub fn node_type(&self) -> std::option::Option<&crate::model::NodeType> {
        self.node_type.as_ref()
    }
    /// <p>The ZookeeperNodeInfo.</p>
    pub fn zookeeper_node_info(&self) -> std::option::Option<&crate::model::ZookeeperNodeInfo> {
        self.zookeeper_node_info.as_ref()
    }
}
impl std::fmt::Debug for NodeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeInfo");
        formatter.field("added_to_cluster_time", &self.added_to_cluster_time);
        formatter.field("broker_node_info", &self.broker_node_info);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("node_arn", &self.node_arn);
        formatter.field("node_type", &self.node_type);
        formatter.field("zookeeper_node_info", &self.zookeeper_node_info);
        formatter.finish()
    }
}
/// See [`NodeInfo`](crate::model::NodeInfo)
pub mod node_info {
    /// A builder for [`NodeInfo`](crate::model::NodeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) added_to_cluster_time: std::option::Option<std::string::String>,
        pub(crate) broker_node_info: std::option::Option<crate::model::BrokerNodeInfo>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) node_arn: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<crate::model::NodeType>,
        pub(crate) zookeeper_node_info: std::option::Option<crate::model::ZookeeperNodeInfo>,
    }
    impl Builder {
        /// <p>The start time.</p>
        pub fn added_to_cluster_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.added_to_cluster_time = Some(input.into());
            self
        }
        /// <p>The start time.</p>
        pub fn set_added_to_cluster_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.added_to_cluster_time = input;
            self
        }
        /// <p>The broker node info.</p>
        pub fn broker_node_info(mut self, input: crate::model::BrokerNodeInfo) -> Self {
            self.broker_node_info = Some(input);
            self
        }
        /// <p>The broker node info.</p>
        pub fn set_broker_node_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeInfo>,
        ) -> Self {
            self.broker_node_info = input;
            self
        }
        /// <p>The instance type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The instance type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the node.</p>
        pub fn node_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the node.</p>
        pub fn set_node_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_arn = input;
            self
        }
        /// <p>The node type.</p>
        pub fn node_type(mut self, input: crate::model::NodeType) -> Self {
            self.node_type = Some(input);
            self
        }
        /// <p>The node type.</p>
        pub fn set_node_type(mut self, input: std::option::Option<crate::model::NodeType>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The ZookeeperNodeInfo.</p>
        pub fn zookeeper_node_info(mut self, input: crate::model::ZookeeperNodeInfo) -> Self {
            self.zookeeper_node_info = Some(input);
            self
        }
        /// <p>The ZookeeperNodeInfo.</p>
        pub fn set_zookeeper_node_info(
            mut self,
            input: std::option::Option<crate::model::ZookeeperNodeInfo>,
        ) -> Self {
            self.zookeeper_node_info = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeInfo`](crate::model::NodeInfo)
        pub fn build(self) -> crate::model::NodeInfo {
            crate::model::NodeInfo {
                added_to_cluster_time: self.added_to_cluster_time,
                broker_node_info: self.broker_node_info,
                instance_type: self.instance_type,
                node_arn: self.node_arn,
                node_type: self.node_type,
                zookeeper_node_info: self.zookeeper_node_info,
            }
        }
    }
}
impl NodeInfo {
    /// Creates a new builder-style object to manufacture [`NodeInfo`](crate::model::NodeInfo)
    pub fn builder() -> crate::model::node_info::Builder {
        crate::model::node_info::Builder::default()
    }
}

/// <p>Zookeeper node information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ZookeeperNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    pub attached_eni_id: std::option::Option<std::string::String>,
    /// <p>The virtual private cloud (VPC) IP address of the client.</p>
    pub client_vpc_ip_address: std::option::Option<std::string::String>,
    /// <p>Endpoints for accessing the ZooKeeper.</p>
    pub endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The role-specific ID for Zookeeper.</p>
    pub zookeeper_id: f64,
    /// <p>The version of Zookeeper.</p>
    pub zookeeper_version: std::option::Option<std::string::String>,
}
impl ZookeeperNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    pub fn attached_eni_id(&self) -> std::option::Option<&str> {
        self.attached_eni_id.as_deref()
    }
    /// <p>The virtual private cloud (VPC) IP address of the client.</p>
    pub fn client_vpc_ip_address(&self) -> std::option::Option<&str> {
        self.client_vpc_ip_address.as_deref()
    }
    /// <p>Endpoints for accessing the ZooKeeper.</p>
    pub fn endpoints(&self) -> std::option::Option<&[std::string::String]> {
        self.endpoints.as_deref()
    }
    /// <p>The role-specific ID for Zookeeper.</p>
    pub fn zookeeper_id(&self) -> f64 {
        self.zookeeper_id
    }
    /// <p>The version of Zookeeper.</p>
    pub fn zookeeper_version(&self) -> std::option::Option<&str> {
        self.zookeeper_version.as_deref()
    }
}
impl std::fmt::Debug for ZookeeperNodeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ZookeeperNodeInfo");
        formatter.field("attached_eni_id", &self.attached_eni_id);
        formatter.field("client_vpc_ip_address", &self.client_vpc_ip_address);
        formatter.field("endpoints", &self.endpoints);
        formatter.field("zookeeper_id", &self.zookeeper_id);
        formatter.field("zookeeper_version", &self.zookeeper_version);
        formatter.finish()
    }
}
/// See [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo)
pub mod zookeeper_node_info {
    /// A builder for [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attached_eni_id: std::option::Option<std::string::String>,
        pub(crate) client_vpc_ip_address: std::option::Option<std::string::String>,
        pub(crate) endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) zookeeper_id: std::option::Option<f64>,
        pub(crate) zookeeper_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn attached_eni_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attached_eni_id = Some(input.into());
            self
        }
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn set_attached_eni_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attached_eni_id = input;
            self
        }
        /// <p>The virtual private cloud (VPC) IP address of the client.</p>
        pub fn client_vpc_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpc_ip_address = Some(input.into());
            self
        }
        /// <p>The virtual private cloud (VPC) IP address of the client.</p>
        pub fn set_client_vpc_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpc_ip_address = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>Endpoints for accessing the ZooKeeper.</p>
        pub fn endpoints(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input.into());
            self.endpoints = Some(v);
            self
        }
        /// <p>Endpoints for accessing the ZooKeeper.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// <p>The role-specific ID for Zookeeper.</p>
        pub fn zookeeper_id(mut self, input: f64) -> Self {
            self.zookeeper_id = Some(input);
            self
        }
        /// <p>The role-specific ID for Zookeeper.</p>
        pub fn set_zookeeper_id(mut self, input: std::option::Option<f64>) -> Self {
            self.zookeeper_id = input;
            self
        }
        /// <p>The version of Zookeeper.</p>
        pub fn zookeeper_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.zookeeper_version = Some(input.into());
            self
        }
        /// <p>The version of Zookeeper.</p>
        pub fn set_zookeeper_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo)
        pub fn build(self) -> crate::model::ZookeeperNodeInfo {
            crate::model::ZookeeperNodeInfo {
                attached_eni_id: self.attached_eni_id,
                client_vpc_ip_address: self.client_vpc_ip_address,
                endpoints: self.endpoints,
                zookeeper_id: self.zookeeper_id.unwrap_or_default(),
                zookeeper_version: self.zookeeper_version,
            }
        }
    }
}
impl ZookeeperNodeInfo {
    /// Creates a new builder-style object to manufacture [`ZookeeperNodeInfo`](crate::model::ZookeeperNodeInfo)
    pub fn builder() -> crate::model::zookeeper_node_info::Builder {
        crate::model::zookeeper_node_info::Builder::default()
    }
}

/// <p>The broker or Zookeeper node.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NodeType {
    #[allow(missing_docs)] // documentation missing in model
    Broker,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NodeType {
    fn from(s: &str) -> Self {
        match s {
            "BROKER" => NodeType::Broker,
            other => NodeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NodeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NodeType::from(s))
    }
}
impl NodeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NodeType::Broker => "BROKER",
            NodeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["BROKER"]
    }
}
impl AsRef<str> for NodeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>BrokerNodeInfo</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BrokerNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    pub attached_eni_id: std::option::Option<std::string::String>,
    /// <p>The ID of the broker.</p>
    pub broker_id: f64,
    /// <p>The client subnet to which this broker node belongs.</p>
    pub client_subnet: std::option::Option<std::string::String>,
    /// <p>The virtual private cloud (VPC) of the client.</p>
    pub client_vpc_ip_address: std::option::Option<std::string::String>,
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    pub current_broker_software_info: std::option::Option<crate::model::BrokerSoftwareInfo>,
    /// <p>Endpoints for accessing the broker.</p>
    pub endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl BrokerNodeInfo {
    /// <p>The attached elastic network interface of the broker.</p>
    pub fn attached_eni_id(&self) -> std::option::Option<&str> {
        self.attached_eni_id.as_deref()
    }
    /// <p>The ID of the broker.</p>
    pub fn broker_id(&self) -> f64 {
        self.broker_id
    }
    /// <p>The client subnet to which this broker node belongs.</p>
    pub fn client_subnet(&self) -> std::option::Option<&str> {
        self.client_subnet.as_deref()
    }
    /// <p>The virtual private cloud (VPC) of the client.</p>
    pub fn client_vpc_ip_address(&self) -> std::option::Option<&str> {
        self.client_vpc_ip_address.as_deref()
    }
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    pub fn current_broker_software_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerSoftwareInfo> {
        self.current_broker_software_info.as_ref()
    }
    /// <p>Endpoints for accessing the broker.</p>
    pub fn endpoints(&self) -> std::option::Option<&[std::string::String]> {
        self.endpoints.as_deref()
    }
}
impl std::fmt::Debug for BrokerNodeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BrokerNodeInfo");
        formatter.field("attached_eni_id", &self.attached_eni_id);
        formatter.field("broker_id", &self.broker_id);
        formatter.field("client_subnet", &self.client_subnet);
        formatter.field("client_vpc_ip_address", &self.client_vpc_ip_address);
        formatter.field(
            "current_broker_software_info",
            &self.current_broker_software_info,
        );
        formatter.field("endpoints", &self.endpoints);
        formatter.finish()
    }
}
/// See [`BrokerNodeInfo`](crate::model::BrokerNodeInfo)
pub mod broker_node_info {
    /// A builder for [`BrokerNodeInfo`](crate::model::BrokerNodeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attached_eni_id: std::option::Option<std::string::String>,
        pub(crate) broker_id: std::option::Option<f64>,
        pub(crate) client_subnet: std::option::Option<std::string::String>,
        pub(crate) client_vpc_ip_address: std::option::Option<std::string::String>,
        pub(crate) current_broker_software_info:
            std::option::Option<crate::model::BrokerSoftwareInfo>,
        pub(crate) endpoints: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn attached_eni_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attached_eni_id = Some(input.into());
            self
        }
        /// <p>The attached elastic network interface of the broker.</p>
        pub fn set_attached_eni_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attached_eni_id = input;
            self
        }
        /// <p>The ID of the broker.</p>
        pub fn broker_id(mut self, input: f64) -> Self {
            self.broker_id = Some(input);
            self
        }
        /// <p>The ID of the broker.</p>
        pub fn set_broker_id(mut self, input: std::option::Option<f64>) -> Self {
            self.broker_id = input;
            self
        }
        /// <p>The client subnet to which this broker node belongs.</p>
        pub fn client_subnet(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_subnet = Some(input.into());
            self
        }
        /// <p>The client subnet to which this broker node belongs.</p>
        pub fn set_client_subnet(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_subnet = input;
            self
        }
        /// <p>The virtual private cloud (VPC) of the client.</p>
        pub fn client_vpc_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_vpc_ip_address = Some(input.into());
            self
        }
        /// <p>The virtual private cloud (VPC) of the client.</p>
        pub fn set_client_vpc_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_vpc_ip_address = input;
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn current_broker_software_info(
            mut self,
            input: crate::model::BrokerSoftwareInfo,
        ) -> Self {
            self.current_broker_software_info = Some(input);
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn set_current_broker_software_info(
            mut self,
            input: std::option::Option<crate::model::BrokerSoftwareInfo>,
        ) -> Self {
            self.current_broker_software_info = input;
            self
        }
        /// Appends an item to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>Endpoints for accessing the broker.</p>
        pub fn endpoints(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.endpoints.unwrap_or_default();
            v.push(input.into());
            self.endpoints = Some(v);
            self
        }
        /// <p>Endpoints for accessing the broker.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerNodeInfo`](crate::model::BrokerNodeInfo)
        pub fn build(self) -> crate::model::BrokerNodeInfo {
            crate::model::BrokerNodeInfo {
                attached_eni_id: self.attached_eni_id,
                broker_id: self.broker_id.unwrap_or_default(),
                client_subnet: self.client_subnet,
                client_vpc_ip_address: self.client_vpc_ip_address,
                current_broker_software_info: self.current_broker_software_info,
                endpoints: self.endpoints,
            }
        }
    }
}
impl BrokerNodeInfo {
    /// Creates a new builder-style object to manufacture [`BrokerNodeInfo`](crate::model::BrokerNodeInfo)
    pub fn builder() -> crate::model::broker_node_info::Builder {
        crate::model::broker_node_info::Builder::default()
    }
}

/// <p>Information about the current software installed on the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BrokerSoftwareInfo {
    /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
    pub configuration_arn: std::option::Option<std::string::String>,
    /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
    pub configuration_revision: i64,
    /// <p>The version of Apache Kafka.</p>
    pub kafka_version: std::option::Option<std::string::String>,
}
impl BrokerSoftwareInfo {
    /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
    pub fn configuration_arn(&self) -> std::option::Option<&str> {
        self.configuration_arn.as_deref()
    }
    /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
    pub fn configuration_revision(&self) -> i64 {
        self.configuration_revision
    }
    /// <p>The version of Apache Kafka.</p>
    pub fn kafka_version(&self) -> std::option::Option<&str> {
        self.kafka_version.as_deref()
    }
}
impl std::fmt::Debug for BrokerSoftwareInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BrokerSoftwareInfo");
        formatter.field("configuration_arn", &self.configuration_arn);
        formatter.field("configuration_revision", &self.configuration_revision);
        formatter.field("kafka_version", &self.kafka_version);
        formatter.finish()
    }
}
/// See [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo)
pub mod broker_software_info {
    /// A builder for [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_arn: std::option::Option<std::string::String>,
        pub(crate) configuration_revision: std::option::Option<i64>,
        pub(crate) kafka_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
        pub fn configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.</p>
        pub fn set_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_arn = input;
            self
        }
        /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
        pub fn configuration_revision(mut self, input: i64) -> Self {
            self.configuration_revision = Some(input);
            self
        }
        /// <p>The revision of the configuration to use. This field isn't visible in this preview release.</p>
        pub fn set_configuration_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.configuration_revision = input;
            self
        }
        /// <p>The version of Apache Kafka.</p>
        pub fn kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_version = Some(input.into());
            self
        }
        /// <p>The version of Apache Kafka.</p>
        pub fn set_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_version = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo)
        pub fn build(self) -> crate::model::BrokerSoftwareInfo {
            crate::model::BrokerSoftwareInfo {
                configuration_arn: self.configuration_arn,
                configuration_revision: self.configuration_revision.unwrap_or_default(),
                kafka_version: self.kafka_version,
            }
        }
    }
}
impl BrokerSoftwareInfo {
    /// Creates a new builder-style object to manufacture [`BrokerSoftwareInfo`](crate::model::BrokerSoftwareInfo)
    pub fn builder() -> crate::model::broker_software_info::Builder {
        crate::model::broker_software_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KafkaVersion {
    #[allow(missing_docs)] // documentation missing in model
    pub version: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub status: std::option::Option<crate::model::KafkaVersionStatus>,
}
impl KafkaVersion {
    #[allow(missing_docs)] // documentation missing in model
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> std::option::Option<&crate::model::KafkaVersionStatus> {
        self.status.as_ref()
    }
}
impl std::fmt::Debug for KafkaVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KafkaVersion");
        formatter.field("version", &self.version);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`KafkaVersion`](crate::model::KafkaVersion)
pub mod kafka_version {
    /// A builder for [`KafkaVersion`](crate::model::KafkaVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::KafkaVersionStatus>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: crate::model::KafkaVersionStatus) -> Self {
            self.status = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::KafkaVersionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`KafkaVersion`](crate::model::KafkaVersion)
        pub fn build(self) -> crate::model::KafkaVersion {
            crate::model::KafkaVersion {
                version: self.version,
                status: self.status,
            }
        }
    }
}
impl KafkaVersion {
    /// Creates a new builder-style object to manufacture [`KafkaVersion`](crate::model::KafkaVersion)
    pub fn builder() -> crate::model::kafka_version::Builder {
        crate::model::kafka_version::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum KafkaVersionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deprecated,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for KafkaVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => KafkaVersionStatus::Active,
            "DEPRECATED" => KafkaVersionStatus::Deprecated,
            other => KafkaVersionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for KafkaVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(KafkaVersionStatus::from(s))
    }
}
impl KafkaVersionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            KafkaVersionStatus::Active => "ACTIVE",
            KafkaVersionStatus::Deprecated => "DEPRECATED",
            KafkaVersionStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "DEPRECATED"]
    }
}
impl AsRef<str> for KafkaVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents an MSK Configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Configuration {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time when the configuration was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the configuration.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
    pub kafka_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Latest revision of the configuration.</p>
    pub latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
    /// <p>The name of the configuration.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    pub state: std::option::Option<crate::model::ConfigurationState>,
}
impl Configuration {
    /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time when the configuration was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The description of the configuration.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
    pub fn kafka_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.kafka_versions.as_deref()
    }
    /// <p>Latest revision of the configuration.</p>
    pub fn latest_revision(&self) -> std::option::Option<&crate::model::ConfigurationRevision> {
        self.latest_revision.as_ref()
    }
    /// <p>The name of the configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
    pub fn state(&self) -> std::option::Option<&crate::model::ConfigurationState> {
        self.state.as_ref()
    }
}
impl std::fmt::Debug for Configuration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Configuration");
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("kafka_versions", &self.kafka_versions);
        formatter.field("latest_revision", &self.latest_revision);
        formatter.field("name", &self.name);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`Configuration`](crate::model::Configuration)
pub mod configuration {
    /// A builder for [`Configuration`](crate::model::Configuration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) kafka_versions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) latest_revision: std::option::Option<crate::model::ConfigurationRevision>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ConfigurationState>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time when the configuration was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the configuration was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The description of the configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the configuration.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `kafka_versions`.
        ///
        /// To override the contents of this collection use [`set_kafka_versions`](Self::set_kafka_versions).
        ///
        /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
        pub fn kafka_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.kafka_versions.unwrap_or_default();
            v.push(input.into());
            self.kafka_versions = Some(v);
            self
        }
        /// <p>An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.</p>
        pub fn set_kafka_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.kafka_versions = input;
            self
        }
        /// <p>Latest revision of the configuration.</p>
        pub fn latest_revision(mut self, input: crate::model::ConfigurationRevision) -> Self {
            self.latest_revision = Some(input);
            self
        }
        /// <p>Latest revision of the configuration.</p>
        pub fn set_latest_revision(
            mut self,
            input: std::option::Option<crate::model::ConfigurationRevision>,
        ) -> Self {
            self.latest_revision = input;
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
        pub fn state(mut self, input: crate::model::ConfigurationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED. </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ConfigurationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`Configuration`](crate::model::Configuration)
        pub fn build(self) -> crate::model::Configuration {
            crate::model::Configuration {
                arn: self.arn,
                creation_time: self.creation_time,
                description: self.description,
                kafka_versions: self.kafka_versions,
                latest_revision: self.latest_revision,
                name: self.name,
                state: self.state,
            }
        }
    }
}
impl Configuration {
    /// Creates a new builder-style object to manufacture [`Configuration`](crate::model::Configuration)
    pub fn builder() -> crate::model::configuration::Builder {
        crate::model::configuration::Builder::default()
    }
}

/// <p>The state of a configuration.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConfigurationState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConfigurationState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ConfigurationState::Active,
            "DELETE_FAILED" => ConfigurationState::DeleteFailed,
            "DELETING" => ConfigurationState::Deleting,
            other => ConfigurationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConfigurationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConfigurationState::from(s))
    }
}
impl ConfigurationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConfigurationState::Active => "ACTIVE",
            ConfigurationState::DeleteFailed => "DELETE_FAILED",
            ConfigurationState::Deleting => "DELETING",
            ConfigurationState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "DELETE_FAILED", "DELETING"]
    }
}
impl AsRef<str> for ConfigurationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information about a cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterInfo {
    /// <p>Arn of active cluster operation.</p>
    pub active_operation_arn: std::option::Option<std::string::String>,
    /// <p>Information about the broker nodes.</p>
    pub broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
    /// <p>Includes all client authentication information.</p>
    pub client_authentication: std::option::Option<crate::model::ClientAuthentication>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The name of the cluster.</p>
    pub cluster_name: std::option::Option<std::string::String>,
    /// <p>The time when the cluster was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    pub current_broker_software_info: std::option::Option<crate::model::BrokerSoftwareInfo>,
    /// <p>The current version of the MSK cluster.</p>
    pub current_version: std::option::Option<std::string::String>,
    /// <p>Includes all encryption-related information.</p>
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,
    /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
    pub enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
    /// <p>Settings for open monitoring using Prometheus.</p>
    pub open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
    #[allow(missing_docs)] // documentation missing in model
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>The number of broker nodes in the cluster.</p>
    pub number_of_broker_nodes: i32,
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    pub state: std::option::Option<crate::model::ClusterState>,
    #[allow(missing_docs)] // documentation missing in model
    pub state_info: std::option::Option<crate::model::StateInfo>,
    /// <p>Tags attached to the cluster.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    pub zookeeper_connect_string: std::option::Option<std::string::String>,
    /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
    pub zookeeper_connect_string_tls: std::option::Option<std::string::String>,
}
impl ClusterInfo {
    /// <p>Arn of active cluster operation.</p>
    pub fn active_operation_arn(&self) -> std::option::Option<&str> {
        self.active_operation_arn.as_deref()
    }
    /// <p>Information about the broker nodes.</p>
    pub fn broker_node_group_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerNodeGroupInfo> {
        self.broker_node_group_info.as_ref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ClientAuthentication> {
        self.client_authentication.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The name of the cluster.</p>
    pub fn cluster_name(&self) -> std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The time when the cluster was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
    pub fn current_broker_software_info(
        &self,
    ) -> std::option::Option<&crate::model::BrokerSoftwareInfo> {
        self.current_broker_software_info.as_ref()
    }
    /// <p>The current version of the MSK cluster.</p>
    pub fn current_version(&self) -> std::option::Option<&str> {
        self.current_version.as_deref()
    }
    /// <p>Includes all encryption-related information.</p>
    pub fn encryption_info(&self) -> std::option::Option<&crate::model::EncryptionInfo> {
        self.encryption_info.as_ref()
    }
    /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
    pub fn enhanced_monitoring(&self) -> std::option::Option<&crate::model::EnhancedMonitoring> {
        self.enhanced_monitoring.as_ref()
    }
    /// <p>Settings for open monitoring using Prometheus.</p>
    pub fn open_monitoring(&self) -> std::option::Option<&crate::model::OpenMonitoring> {
        self.open_monitoring.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn logging_info(&self) -> std::option::Option<&crate::model::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>The number of broker nodes in the cluster.</p>
    pub fn number_of_broker_nodes(&self) -> i32 {
        self.number_of_broker_nodes
    }
    /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ClusterState> {
        self.state.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn state_info(&self) -> std::option::Option<&crate::model::StateInfo> {
        self.state_info.as_ref()
    }
    /// <p>Tags attached to the cluster.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
    pub fn zookeeper_connect_string(&self) -> std::option::Option<&str> {
        self.zookeeper_connect_string.as_deref()
    }
    /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
    pub fn zookeeper_connect_string_tls(&self) -> std::option::Option<&str> {
        self.zookeeper_connect_string_tls.as_deref()
    }
}
impl std::fmt::Debug for ClusterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterInfo");
        formatter.field("active_operation_arn", &self.active_operation_arn);
        formatter.field("broker_node_group_info", &self.broker_node_group_info);
        formatter.field("client_authentication", &self.client_authentication);
        formatter.field("cluster_arn", &self.cluster_arn);
        formatter.field("cluster_name", &self.cluster_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field(
            "current_broker_software_info",
            &self.current_broker_software_info,
        );
        formatter.field("current_version", &self.current_version);
        formatter.field("encryption_info", &self.encryption_info);
        formatter.field("enhanced_monitoring", &self.enhanced_monitoring);
        formatter.field("open_monitoring", &self.open_monitoring);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("number_of_broker_nodes", &self.number_of_broker_nodes);
        formatter.field("state", &self.state);
        formatter.field("state_info", &self.state_info);
        formatter.field("tags", &self.tags);
        formatter.field("zookeeper_connect_string", &self.zookeeper_connect_string);
        formatter.field(
            "zookeeper_connect_string_tls",
            &self.zookeeper_connect_string_tls,
        );
        formatter.finish()
    }
}
/// See [`ClusterInfo`](crate::model::ClusterInfo)
pub mod cluster_info {
    /// A builder for [`ClusterInfo`](crate::model::ClusterInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_operation_arn: std::option::Option<std::string::String>,
        pub(crate) broker_node_group_info: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        pub(crate) client_authentication: std::option::Option<crate::model::ClientAuthentication>,
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) cluster_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) current_broker_software_info:
            std::option::Option<crate::model::BrokerSoftwareInfo>,
        pub(crate) current_version: std::option::Option<std::string::String>,
        pub(crate) encryption_info: std::option::Option<crate::model::EncryptionInfo>,
        pub(crate) enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
        pub(crate) open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) number_of_broker_nodes: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::ClusterState>,
        pub(crate) state_info: std::option::Option<crate::model::StateInfo>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) zookeeper_connect_string: std::option::Option<std::string::String>,
        pub(crate) zookeeper_connect_string_tls: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Arn of active cluster operation.</p>
        pub fn active_operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_operation_arn = Some(input.into());
            self
        }
        /// <p>Arn of active cluster operation.</p>
        pub fn set_active_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_operation_arn = input;
            self
        }
        /// <p>Information about the broker nodes.</p>
        pub fn broker_node_group_info(mut self, input: crate::model::BrokerNodeGroupInfo) -> Self {
            self.broker_node_group_info = Some(input);
            self
        }
        /// <p>Information about the broker nodes.</p>
        pub fn set_broker_node_group_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        ) -> Self {
            self.broker_node_group_info = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_name = input;
            self
        }
        /// <p>The time when the cluster was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the cluster was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn current_broker_software_info(
            mut self,
            input: crate::model::BrokerSoftwareInfo,
        ) -> Self {
            self.current_broker_software_info = Some(input);
            self
        }
        /// <p>Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.</p>
        pub fn set_current_broker_software_info(
            mut self,
            input: std::option::Option<crate::model::BrokerSoftwareInfo>,
        ) -> Self {
            self.current_broker_software_info = input;
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_version = Some(input.into());
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.encryption_info = Some(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.encryption_info = input;
            self
        }
        /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.enhanced_monitoring = Some(input);
            self
        }
        /// <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.enhanced_monitoring = input;
            self
        }
        /// <p>Settings for open monitoring using Prometheus.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoring) -> Self {
            self.open_monitoring = Some(input);
            self
        }
        /// <p>Settings for open monitoring using Prometheus.</p>
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoring>,
        ) -> Self {
            self.open_monitoring = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.number_of_broker_nodes = Some(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_broker_nodes = input;
            self
        }
        /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
        pub fn state(mut self, input: crate::model::ClusterState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::ClusterState>) -> Self {
            self.state = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn state_info(mut self, input: crate::model::StateInfo) -> Self {
            self.state_info = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_state_info(
            mut self,
            input: std::option::Option<crate::model::StateInfo>,
        ) -> Self {
            self.state_info = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Tags attached to the cluster.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>Tags attached to the cluster.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
        pub fn zookeeper_connect_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.zookeeper_connect_string = Some(input.into());
            self
        }
        /// <p>The connection string to use to connect to the Apache ZooKeeper cluster.</p>
        pub fn set_zookeeper_connect_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string = input;
            self
        }
        /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
        pub fn zookeeper_connect_string_tls(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string_tls = Some(input.into());
            self
        }
        /// <p>The connection string to use to connect to zookeeper cluster on Tls port.</p>
        pub fn set_zookeeper_connect_string_tls(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.zookeeper_connect_string_tls = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterInfo`](crate::model::ClusterInfo)
        pub fn build(self) -> crate::model::ClusterInfo {
            crate::model::ClusterInfo {
                active_operation_arn: self.active_operation_arn,
                broker_node_group_info: self.broker_node_group_info,
                client_authentication: self.client_authentication,
                cluster_arn: self.cluster_arn,
                cluster_name: self.cluster_name,
                creation_time: self.creation_time,
                current_broker_software_info: self.current_broker_software_info,
                current_version: self.current_version,
                encryption_info: self.encryption_info,
                enhanced_monitoring: self.enhanced_monitoring,
                open_monitoring: self.open_monitoring,
                logging_info: self.logging_info,
                number_of_broker_nodes: self.number_of_broker_nodes.unwrap_or_default(),
                state: self.state,
                state_info: self.state_info,
                tags: self.tags,
                zookeeper_connect_string: self.zookeeper_connect_string,
                zookeeper_connect_string_tls: self.zookeeper_connect_string_tls,
            }
        }
    }
}
impl ClusterInfo {
    /// Creates a new builder-style object to manufacture [`ClusterInfo`](crate::model::ClusterInfo)
    pub fn builder() -> crate::model::cluster_info::Builder {
        crate::model::cluster_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StateInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub code: std::option::Option<std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl StateInfo {
    #[allow(missing_docs)] // documentation missing in model
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Debug for StateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StateInfo");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`StateInfo`](crate::model::StateInfo)
pub mod state_info {
    /// A builder for [`StateInfo`](crate::model::StateInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StateInfo`](crate::model::StateInfo)
        pub fn build(self) -> crate::model::StateInfo {
            crate::model::StateInfo {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl StateInfo {
    /// Creates a new builder-style object to manufacture [`StateInfo`](crate::model::StateInfo)
    pub fn builder() -> crate::model::state_info::Builder {
        crate::model::state_info::Builder::default()
    }
}

/// <p>The state of the Apache Kafka cluster.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClusterState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Healing,
    #[allow(missing_docs)] // documentation missing in model
    Maintenance,
    #[allow(missing_docs)] // documentation missing in model
    RebootingBroker,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ClusterState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ClusterState::Active,
            "CREATING" => ClusterState::Creating,
            "DELETING" => ClusterState::Deleting,
            "FAILED" => ClusterState::Failed,
            "HEALING" => ClusterState::Healing,
            "MAINTENANCE" => ClusterState::Maintenance,
            "REBOOTING_BROKER" => ClusterState::RebootingBroker,
            "UPDATING" => ClusterState::Updating,
            other => ClusterState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ClusterState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClusterState::from(s))
    }
}
impl ClusterState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClusterState::Active => "ACTIVE",
            ClusterState::Creating => "CREATING",
            ClusterState::Deleting => "DELETING",
            ClusterState::Failed => "FAILED",
            ClusterState::Healing => "HEALING",
            ClusterState::Maintenance => "MAINTENANCE",
            ClusterState::RebootingBroker => "REBOOTING_BROKER",
            ClusterState::Updating => "UPDATING",
            ClusterState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CREATING",
            "DELETING",
            "FAILED",
            "HEALING",
            "MAINTENANCE",
            "REBOOTING_BROKER",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for ClusterState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>JMX and Node monitoring for the MSK cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OpenMonitoring {
    /// <p>Prometheus settings.</p>
    pub prometheus: std::option::Option<crate::model::Prometheus>,
}
impl OpenMonitoring {
    /// <p>Prometheus settings.</p>
    pub fn prometheus(&self) -> std::option::Option<&crate::model::Prometheus> {
        self.prometheus.as_ref()
    }
}
impl std::fmt::Debug for OpenMonitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OpenMonitoring");
        formatter.field("prometheus", &self.prometheus);
        formatter.finish()
    }
}
/// See [`OpenMonitoring`](crate::model::OpenMonitoring)
pub mod open_monitoring {
    /// A builder for [`OpenMonitoring`](crate::model::OpenMonitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) prometheus: std::option::Option<crate::model::Prometheus>,
    }
    impl Builder {
        /// <p>Prometheus settings.</p>
        pub fn prometheus(mut self, input: crate::model::Prometheus) -> Self {
            self.prometheus = Some(input);
            self
        }
        /// <p>Prometheus settings.</p>
        pub fn set_prometheus(
            mut self,
            input: std::option::Option<crate::model::Prometheus>,
        ) -> Self {
            self.prometheus = input;
            self
        }
        /// Consumes the builder and constructs a [`OpenMonitoring`](crate::model::OpenMonitoring)
        pub fn build(self) -> crate::model::OpenMonitoring {
            crate::model::OpenMonitoring {
                prometheus: self.prometheus,
            }
        }
    }
}
impl OpenMonitoring {
    /// Creates a new builder-style object to manufacture [`OpenMonitoring`](crate::model::OpenMonitoring)
    pub fn builder() -> crate::model::open_monitoring::Builder {
        crate::model::open_monitoring::Builder::default()
    }
}

/// <p>Prometheus settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Prometheus {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub jmx_exporter: std::option::Option<crate::model::JmxExporter>,
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub node_exporter: std::option::Option<crate::model::NodeExporter>,
}
impl Prometheus {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn jmx_exporter(&self) -> std::option::Option<&crate::model::JmxExporter> {
        self.jmx_exporter.as_ref()
    }
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn node_exporter(&self) -> std::option::Option<&crate::model::NodeExporter> {
        self.node_exporter.as_ref()
    }
}
impl std::fmt::Debug for Prometheus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Prometheus");
        formatter.field("jmx_exporter", &self.jmx_exporter);
        formatter.field("node_exporter", &self.node_exporter);
        formatter.finish()
    }
}
/// See [`Prometheus`](crate::model::Prometheus)
pub mod prometheus {
    /// A builder for [`Prometheus`](crate::model::Prometheus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) jmx_exporter: std::option::Option<crate::model::JmxExporter>,
        pub(crate) node_exporter: std::option::Option<crate::model::NodeExporter>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn jmx_exporter(mut self, input: crate::model::JmxExporter) -> Self {
            self.jmx_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_jmx_exporter(
            mut self,
            input: std::option::Option<crate::model::JmxExporter>,
        ) -> Self {
            self.jmx_exporter = input;
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn node_exporter(mut self, input: crate::model::NodeExporter) -> Self {
            self.node_exporter = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_node_exporter(
            mut self,
            input: std::option::Option<crate::model::NodeExporter>,
        ) -> Self {
            self.node_exporter = input;
            self
        }
        /// Consumes the builder and constructs a [`Prometheus`](crate::model::Prometheus)
        pub fn build(self) -> crate::model::Prometheus {
            crate::model::Prometheus {
                jmx_exporter: self.jmx_exporter,
                node_exporter: self.node_exporter,
            }
        }
    }
}
impl Prometheus {
    /// Creates a new builder-style object to manufacture [`Prometheus`](crate::model::Prometheus)
    pub fn builder() -> crate::model::prometheus::Builder {
        crate::model::prometheus::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeExporter {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub enabled_in_broker: bool,
}
impl NodeExporter {
    /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
impl std::fmt::Debug for NodeExporter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeExporter");
        formatter.field("enabled_in_broker", &self.enabled_in_broker);
        formatter.finish()
    }
}
/// See [`NodeExporter`](crate::model::NodeExporter)
pub mod node_exporter {
    /// A builder for [`NodeExporter`](crate::model::NodeExporter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeExporter`](crate::model::NodeExporter)
        pub fn build(self) -> crate::model::NodeExporter {
            crate::model::NodeExporter {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl NodeExporter {
    /// Creates a new builder-style object to manufacture [`NodeExporter`](crate::model::NodeExporter)
    pub fn builder() -> crate::model::node_exporter::Builder {
        crate::model::node_exporter::Builder::default()
    }
}

/// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JmxExporter {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub enabled_in_broker: bool,
}
impl JmxExporter {
    /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
    pub fn enabled_in_broker(&self) -> bool {
        self.enabled_in_broker
    }
}
impl std::fmt::Debug for JmxExporter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JmxExporter");
        formatter.field("enabled_in_broker", &self.enabled_in_broker);
        formatter.finish()
    }
}
/// See [`JmxExporter`](crate::model::JmxExporter)
pub mod jmx_exporter {
    /// A builder for [`JmxExporter`](crate::model::JmxExporter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled_in_broker: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn enabled_in_broker(mut self, input: bool) -> Self {
            self.enabled_in_broker = Some(input);
            self
        }
        /// <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
        pub fn set_enabled_in_broker(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled_in_broker = input;
            self
        }
        /// Consumes the builder and constructs a [`JmxExporter`](crate::model::JmxExporter)
        pub fn build(self) -> crate::model::JmxExporter {
            crate::model::JmxExporter {
                enabled_in_broker: self.enabled_in_broker.unwrap_or_default(),
            }
        }
    }
}
impl JmxExporter {
    /// Creates a new builder-style object to manufacture [`JmxExporter`](crate::model::JmxExporter)
    pub fn builder() -> crate::model::jmx_exporter::Builder {
        crate::model::jmx_exporter::Builder::default()
    }
}

/// <p>Describes the setup to be used for Apache Kafka broker nodes in the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BrokerNodeGroupInfo {
    /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
    /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
    pub broker_az_distribution: std::option::Option<crate::model::BrokerAzDistribution>,
    /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.</p>
    pub client_subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
    /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
    pub storage_info: std::option::Option<crate::model::StorageInfo>,
    /// <p>Information about the broker access configuration.</p>
    pub connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
}
impl BrokerNodeGroupInfo {
    /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
    /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
    pub fn broker_az_distribution(
        &self,
    ) -> std::option::Option<&crate::model::BrokerAzDistribution> {
        self.broker_az_distribution.as_ref()
    }
    /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.</p>
    pub fn client_subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.client_subnets.as_deref()
    }
    /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
    /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
    pub fn storage_info(&self) -> std::option::Option<&crate::model::StorageInfo> {
        self.storage_info.as_ref()
    }
    /// <p>Information about the broker access configuration.</p>
    pub fn connectivity_info(&self) -> std::option::Option<&crate::model::ConnectivityInfo> {
        self.connectivity_info.as_ref()
    }
}
impl std::fmt::Debug for BrokerNodeGroupInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BrokerNodeGroupInfo");
        formatter.field("broker_az_distribution", &self.broker_az_distribution);
        formatter.field("client_subnets", &self.client_subnets);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("storage_info", &self.storage_info);
        formatter.field("connectivity_info", &self.connectivity_info);
        formatter.finish()
    }
}
/// See [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo)
pub mod broker_node_group_info {
    /// A builder for [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_az_distribution: std::option::Option<crate::model::BrokerAzDistribution>,
        pub(crate) client_subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) storage_info: std::option::Option<crate::model::StorageInfo>,
        pub(crate) connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
    }
    impl Builder {
        /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
        /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
        pub fn broker_az_distribution(mut self, input: crate::model::BrokerAzDistribution) -> Self {
            self.broker_az_distribution = Some(input);
            self
        }
        /// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
        /// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
        pub fn set_broker_az_distribution(
            mut self,
            input: std::option::Option<crate::model::BrokerAzDistribution>,
        ) -> Self {
            self.broker_az_distribution = input;
            self
        }
        /// Appends an item to `client_subnets`.
        ///
        /// To override the contents of this collection use [`set_client_subnets`](Self::set_client_subnets).
        ///
        /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.</p>
        pub fn client_subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.client_subnets.unwrap_or_default();
            v.push(input.into());
            self.client_subnets = Some(v);
            self
        }
        /// <p>The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.</p>
        pub fn set_client_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.client_subnets = input;
            self
        }
        /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
        /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
        /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
        pub fn storage_info(mut self, input: crate::model::StorageInfo) -> Self {
            self.storage_info = Some(input);
            self
        }
        /// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
        pub fn set_storage_info(
            mut self,
            input: std::option::Option<crate::model::StorageInfo>,
        ) -> Self {
            self.storage_info = input;
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn connectivity_info(mut self, input: crate::model::ConnectivityInfo) -> Self {
            self.connectivity_info = Some(input);
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn set_connectivity_info(
            mut self,
            input: std::option::Option<crate::model::ConnectivityInfo>,
        ) -> Self {
            self.connectivity_info = input;
            self
        }
        /// Consumes the builder and constructs a [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo)
        pub fn build(self) -> crate::model::BrokerNodeGroupInfo {
            crate::model::BrokerNodeGroupInfo {
                broker_az_distribution: self.broker_az_distribution,
                client_subnets: self.client_subnets,
                instance_type: self.instance_type,
                security_groups: self.security_groups,
                storage_info: self.storage_info,
                connectivity_info: self.connectivity_info,
            }
        }
    }
}
impl BrokerNodeGroupInfo {
    /// Creates a new builder-style object to manufacture [`BrokerNodeGroupInfo`](crate::model::BrokerNodeGroupInfo)
    pub fn builder() -> crate::model::broker_node_group_info::Builder {
        crate::model::broker_node_group_info::Builder::default()
    }
}

/// <p>Contains information about storage volumes attached to MSK broker nodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StorageInfo {
    /// <p>EBS volume information.</p>
    pub ebs_storage_info: std::option::Option<crate::model::EbsStorageInfo>,
}
impl StorageInfo {
    /// <p>EBS volume information.</p>
    pub fn ebs_storage_info(&self) -> std::option::Option<&crate::model::EbsStorageInfo> {
        self.ebs_storage_info.as_ref()
    }
}
impl std::fmt::Debug for StorageInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StorageInfo");
        formatter.field("ebs_storage_info", &self.ebs_storage_info);
        formatter.finish()
    }
}
/// See [`StorageInfo`](crate::model::StorageInfo)
pub mod storage_info {
    /// A builder for [`StorageInfo`](crate::model::StorageInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ebs_storage_info: std::option::Option<crate::model::EbsStorageInfo>,
    }
    impl Builder {
        /// <p>EBS volume information.</p>
        pub fn ebs_storage_info(mut self, input: crate::model::EbsStorageInfo) -> Self {
            self.ebs_storage_info = Some(input);
            self
        }
        /// <p>EBS volume information.</p>
        pub fn set_ebs_storage_info(
            mut self,
            input: std::option::Option<crate::model::EbsStorageInfo>,
        ) -> Self {
            self.ebs_storage_info = input;
            self
        }
        /// Consumes the builder and constructs a [`StorageInfo`](crate::model::StorageInfo)
        pub fn build(self) -> crate::model::StorageInfo {
            crate::model::StorageInfo {
                ebs_storage_info: self.ebs_storage_info,
            }
        }
    }
}
impl StorageInfo {
    /// Creates a new builder-style object to manufacture [`StorageInfo`](crate::model::StorageInfo)
    pub fn builder() -> crate::model::storage_info::Builder {
        crate::model::storage_info::Builder::default()
    }
}

/// <p>Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsStorageInfo {
    /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
    pub volume_size: i32,
}
impl EbsStorageInfo {
    /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
    pub fn volume_size(&self) -> i32 {
        self.volume_size
    }
}
impl std::fmt::Debug for EbsStorageInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsStorageInfo");
        formatter.field("volume_size", &self.volume_size);
        formatter.finish()
    }
}
/// See [`EbsStorageInfo`](crate::model::EbsStorageInfo)
pub mod ebs_storage_info {
    /// A builder for [`EbsStorageInfo`](crate::model::EbsStorageInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        /// <p>The size in GiB of the EBS volume for the data drive on each broker node.</p>
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsStorageInfo`](crate::model::EbsStorageInfo)
        pub fn build(self) -> crate::model::EbsStorageInfo {
            crate::model::EbsStorageInfo {
                volume_size: self.volume_size.unwrap_or_default(),
            }
        }
    }
}
impl EbsStorageInfo {
    /// Creates a new builder-style object to manufacture [`EbsStorageInfo`](crate::model::EbsStorageInfo)
    pub fn builder() -> crate::model::ebs_storage_info::Builder {
        crate::model::ebs_storage_info::Builder::default()
    }
}

/// <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
/// <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BrokerAzDistribution {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BrokerAzDistribution {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => BrokerAzDistribution::Default,
            other => BrokerAzDistribution::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BrokerAzDistribution {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BrokerAzDistribution::from(s))
    }
}
impl BrokerAzDistribution {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BrokerAzDistribution::Default => "DEFAULT",
            BrokerAzDistribution::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DEFAULT"]
    }
}
impl AsRef<str> for BrokerAzDistribution {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information about a cluster operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterOperationInfo {
    /// <p>The ID of the API request that triggered this operation.</p>
    pub client_request_id: std::option::Option<std::string::String>,
    /// <p>ARN of the cluster.</p>
    pub cluster_arn: std::option::Option<std::string::String>,
    /// <p>The time that the operation was created.</p>
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the operation finished.</p>
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Describes the error if the operation fails.</p>
    pub error_info: std::option::Option<crate::model::ErrorInfo>,
    /// <p>ARN of the cluster operation.</p>
    pub operation_arn: std::option::Option<std::string::String>,
    /// <p>State of the cluster operation.</p>
    pub operation_state: std::option::Option<std::string::String>,
    /// <p>Steps completed during the operation.</p>
    pub operation_steps: std::option::Option<std::vec::Vec<crate::model::ClusterOperationStep>>,
    /// <p>Type of the cluster operation.</p>
    pub operation_type: std::option::Option<std::string::String>,
    /// <p>Information about cluster attributes before a cluster is updated.</p>
    pub source_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
    /// <p>Information about cluster attributes after a cluster is updated.</p>
    pub target_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
}
impl ClusterOperationInfo {
    /// <p>The ID of the API request that triggered this operation.</p>
    pub fn client_request_id(&self) -> std::option::Option<&str> {
        self.client_request_id.as_deref()
    }
    /// <p>ARN of the cluster.</p>
    pub fn cluster_arn(&self) -> std::option::Option<&str> {
        self.cluster_arn.as_deref()
    }
    /// <p>The time that the operation was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time at which the operation finished.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>Describes the error if the operation fails.</p>
    pub fn error_info(&self) -> std::option::Option<&crate::model::ErrorInfo> {
        self.error_info.as_ref()
    }
    /// <p>ARN of the cluster operation.</p>
    pub fn operation_arn(&self) -> std::option::Option<&str> {
        self.operation_arn.as_deref()
    }
    /// <p>State of the cluster operation.</p>
    pub fn operation_state(&self) -> std::option::Option<&str> {
        self.operation_state.as_deref()
    }
    /// <p>Steps completed during the operation.</p>
    pub fn operation_steps(&self) -> std::option::Option<&[crate::model::ClusterOperationStep]> {
        self.operation_steps.as_deref()
    }
    /// <p>Type of the cluster operation.</p>
    pub fn operation_type(&self) -> std::option::Option<&str> {
        self.operation_type.as_deref()
    }
    /// <p>Information about cluster attributes before a cluster is updated.</p>
    pub fn source_cluster_info(&self) -> std::option::Option<&crate::model::MutableClusterInfo> {
        self.source_cluster_info.as_ref()
    }
    /// <p>Information about cluster attributes after a cluster is updated.</p>
    pub fn target_cluster_info(&self) -> std::option::Option<&crate::model::MutableClusterInfo> {
        self.target_cluster_info.as_ref()
    }
}
impl std::fmt::Debug for ClusterOperationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterOperationInfo");
        formatter.field("client_request_id", &self.client_request_id);
        formatter.field("cluster_arn", &self.cluster_arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("error_info", &self.error_info);
        formatter.field("operation_arn", &self.operation_arn);
        formatter.field("operation_state", &self.operation_state);
        formatter.field("operation_steps", &self.operation_steps);
        formatter.field("operation_type", &self.operation_type);
        formatter.field("source_cluster_info", &self.source_cluster_info);
        formatter.field("target_cluster_info", &self.target_cluster_info);
        formatter.finish()
    }
}
/// See [`ClusterOperationInfo`](crate::model::ClusterOperationInfo)
pub mod cluster_operation_info {
    /// A builder for [`ClusterOperationInfo`](crate::model::ClusterOperationInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_request_id: std::option::Option<std::string::String>,
        pub(crate) cluster_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) error_info: std::option::Option<crate::model::ErrorInfo>,
        pub(crate) operation_arn: std::option::Option<std::string::String>,
        pub(crate) operation_state: std::option::Option<std::string::String>,
        pub(crate) operation_steps:
            std::option::Option<std::vec::Vec<crate::model::ClusterOperationStep>>,
        pub(crate) operation_type: std::option::Option<std::string::String>,
        pub(crate) source_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
        pub(crate) target_cluster_info: std::option::Option<crate::model::MutableClusterInfo>,
    }
    impl Builder {
        /// <p>The ID of the API request that triggered this operation.</p>
        pub fn client_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_id = Some(input.into());
            self
        }
        /// <p>The ID of the API request that triggered this operation.</p>
        pub fn set_client_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_id = input;
            self
        }
        /// <p>ARN of the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_arn = Some(input.into());
            self
        }
        /// <p>ARN of the cluster.</p>
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_arn = input;
            self
        }
        /// <p>The time that the operation was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time that the operation was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time at which the operation finished.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time at which the operation finished.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Describes the error if the operation fails.</p>
        pub fn error_info(mut self, input: crate::model::ErrorInfo) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>Describes the error if the operation fails.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::ErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// <p>ARN of the cluster operation.</p>
        pub fn operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_arn = Some(input.into());
            self
        }
        /// <p>ARN of the cluster operation.</p>
        pub fn set_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_arn = input;
            self
        }
        /// <p>State of the cluster operation.</p>
        pub fn operation_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_state = Some(input.into());
            self
        }
        /// <p>State of the cluster operation.</p>
        pub fn set_operation_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_state = input;
            self
        }
        /// Appends an item to `operation_steps`.
        ///
        /// To override the contents of this collection use [`set_operation_steps`](Self::set_operation_steps).
        ///
        /// <p>Steps completed during the operation.</p>
        pub fn operation_steps(
            mut self,
            input: impl Into<crate::model::ClusterOperationStep>,
        ) -> Self {
            let mut v = self.operation_steps.unwrap_or_default();
            v.push(input.into());
            self.operation_steps = Some(v);
            self
        }
        /// <p>Steps completed during the operation.</p>
        pub fn set_operation_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterOperationStep>>,
        ) -> Self {
            self.operation_steps = input;
            self
        }
        /// <p>Type of the cluster operation.</p>
        pub fn operation_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_type = Some(input.into());
            self
        }
        /// <p>Type of the cluster operation.</p>
        pub fn set_operation_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_type = input;
            self
        }
        /// <p>Information about cluster attributes before a cluster is updated.</p>
        pub fn source_cluster_info(mut self, input: crate::model::MutableClusterInfo) -> Self {
            self.source_cluster_info = Some(input);
            self
        }
        /// <p>Information about cluster attributes before a cluster is updated.</p>
        pub fn set_source_cluster_info(
            mut self,
            input: std::option::Option<crate::model::MutableClusterInfo>,
        ) -> Self {
            self.source_cluster_info = input;
            self
        }
        /// <p>Information about cluster attributes after a cluster is updated.</p>
        pub fn target_cluster_info(mut self, input: crate::model::MutableClusterInfo) -> Self {
            self.target_cluster_info = Some(input);
            self
        }
        /// <p>Information about cluster attributes after a cluster is updated.</p>
        pub fn set_target_cluster_info(
            mut self,
            input: std::option::Option<crate::model::MutableClusterInfo>,
        ) -> Self {
            self.target_cluster_info = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOperationInfo`](crate::model::ClusterOperationInfo)
        pub fn build(self) -> crate::model::ClusterOperationInfo {
            crate::model::ClusterOperationInfo {
                client_request_id: self.client_request_id,
                cluster_arn: self.cluster_arn,
                creation_time: self.creation_time,
                end_time: self.end_time,
                error_info: self.error_info,
                operation_arn: self.operation_arn,
                operation_state: self.operation_state,
                operation_steps: self.operation_steps,
                operation_type: self.operation_type,
                source_cluster_info: self.source_cluster_info,
                target_cluster_info: self.target_cluster_info,
            }
        }
    }
}
impl ClusterOperationInfo {
    /// Creates a new builder-style object to manufacture [`ClusterOperationInfo`](crate::model::ClusterOperationInfo)
    pub fn builder() -> crate::model::cluster_operation_info::Builder {
        crate::model::cluster_operation_info::Builder::default()
    }
}

/// <p>Information about cluster attributes that can be updated via update APIs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MutableClusterInfo {
    /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
    pub broker_ebs_volume_info:
        std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
    /// <p>Information about the changes in the configuration of the brokers.</p>
    pub configuration_info: std::option::Option<crate::model::ConfigurationInfo>,
    /// <p>The number of broker nodes in the cluster.</p>
    pub number_of_broker_nodes: i32,
    /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
    pub enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
    /// <p>The settings for open monitoring.</p>
    pub open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
    /// <p>The Apache Kafka version.</p>
    pub kafka_version: std::option::Option<std::string::String>,
    /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
    pub logging_info: std::option::Option<crate::model::LoggingInfo>,
    /// <p>Information about the Amazon MSK broker type.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>Includes all client authentication information.</p>
    pub client_authentication: std::option::Option<crate::model::ClientAuthentication>,
    /// <p>Includes all encryption-related information.</p>
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,
    /// <p>Information about the broker access configuration.</p>
    pub connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
}
impl MutableClusterInfo {
    /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
    pub fn broker_ebs_volume_info(
        &self,
    ) -> std::option::Option<&[crate::model::BrokerEbsVolumeInfo]> {
        self.broker_ebs_volume_info.as_deref()
    }
    /// <p>Information about the changes in the configuration of the brokers.</p>
    pub fn configuration_info(&self) -> std::option::Option<&crate::model::ConfigurationInfo> {
        self.configuration_info.as_ref()
    }
    /// <p>The number of broker nodes in the cluster.</p>
    pub fn number_of_broker_nodes(&self) -> i32 {
        self.number_of_broker_nodes
    }
    /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
    pub fn enhanced_monitoring(&self) -> std::option::Option<&crate::model::EnhancedMonitoring> {
        self.enhanced_monitoring.as_ref()
    }
    /// <p>The settings for open monitoring.</p>
    pub fn open_monitoring(&self) -> std::option::Option<&crate::model::OpenMonitoring> {
        self.open_monitoring.as_ref()
    }
    /// <p>The Apache Kafka version.</p>
    pub fn kafka_version(&self) -> std::option::Option<&str> {
        self.kafka_version.as_deref()
    }
    /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
    pub fn logging_info(&self) -> std::option::Option<&crate::model::LoggingInfo> {
        self.logging_info.as_ref()
    }
    /// <p>Information about the Amazon MSK broker type.</p>
    pub fn instance_type(&self) -> std::option::Option<&str> {
        self.instance_type.as_deref()
    }
    /// <p>Includes all client authentication information.</p>
    pub fn client_authentication(
        &self,
    ) -> std::option::Option<&crate::model::ClientAuthentication> {
        self.client_authentication.as_ref()
    }
    /// <p>Includes all encryption-related information.</p>
    pub fn encryption_info(&self) -> std::option::Option<&crate::model::EncryptionInfo> {
        self.encryption_info.as_ref()
    }
    /// <p>Information about the broker access configuration.</p>
    pub fn connectivity_info(&self) -> std::option::Option<&crate::model::ConnectivityInfo> {
        self.connectivity_info.as_ref()
    }
}
impl std::fmt::Debug for MutableClusterInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MutableClusterInfo");
        formatter.field("broker_ebs_volume_info", &self.broker_ebs_volume_info);
        formatter.field("configuration_info", &self.configuration_info);
        formatter.field("number_of_broker_nodes", &self.number_of_broker_nodes);
        formatter.field("enhanced_monitoring", &self.enhanced_monitoring);
        formatter.field("open_monitoring", &self.open_monitoring);
        formatter.field("kafka_version", &self.kafka_version);
        formatter.field("logging_info", &self.logging_info);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("client_authentication", &self.client_authentication);
        formatter.field("encryption_info", &self.encryption_info);
        formatter.field("connectivity_info", &self.connectivity_info);
        formatter.finish()
    }
}
/// See [`MutableClusterInfo`](crate::model::MutableClusterInfo)
pub mod mutable_cluster_info {
    /// A builder for [`MutableClusterInfo`](crate::model::MutableClusterInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) broker_ebs_volume_info:
            std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
        pub(crate) configuration_info: std::option::Option<crate::model::ConfigurationInfo>,
        pub(crate) number_of_broker_nodes: std::option::Option<i32>,
        pub(crate) enhanced_monitoring: std::option::Option<crate::model::EnhancedMonitoring>,
        pub(crate) open_monitoring: std::option::Option<crate::model::OpenMonitoring>,
        pub(crate) kafka_version: std::option::Option<std::string::String>,
        pub(crate) logging_info: std::option::Option<crate::model::LoggingInfo>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) client_authentication: std::option::Option<crate::model::ClientAuthentication>,
        pub(crate) encryption_info: std::option::Option<crate::model::EncryptionInfo>,
        pub(crate) connectivity_info: std::option::Option<crate::model::ConnectivityInfo>,
    }
    impl Builder {
        /// Appends an item to `broker_ebs_volume_info`.
        ///
        /// To override the contents of this collection use [`set_broker_ebs_volume_info`](Self::set_broker_ebs_volume_info).
        ///
        /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
        pub fn broker_ebs_volume_info(
            mut self,
            input: impl Into<crate::model::BrokerEbsVolumeInfo>,
        ) -> Self {
            let mut v = self.broker_ebs_volume_info.unwrap_or_default();
            v.push(input.into());
            self.broker_ebs_volume_info = Some(v);
            self
        }
        /// <p>Specifies the size of the EBS volume and the ID of the associated broker.</p>
        pub fn set_broker_ebs_volume_info(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
        ) -> Self {
            self.broker_ebs_volume_info = input;
            self
        }
        /// <p>Information about the changes in the configuration of the brokers.</p>
        pub fn configuration_info(mut self, input: crate::model::ConfigurationInfo) -> Self {
            self.configuration_info = Some(input);
            self
        }
        /// <p>Information about the changes in the configuration of the brokers.</p>
        pub fn set_configuration_info(
            mut self,
            input: std::option::Option<crate::model::ConfigurationInfo>,
        ) -> Self {
            self.configuration_info = input;
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.number_of_broker_nodes = Some(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_broker_nodes = input;
            self
        }
        /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.enhanced_monitoring = Some(input);
            self
        }
        /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.enhanced_monitoring = input;
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoring) -> Self {
            self.open_monitoring = Some(input);
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoring>,
        ) -> Self {
            self.open_monitoring = input;
            self
        }
        /// <p>The Apache Kafka version.</p>
        pub fn kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.kafka_version = Some(input.into());
            self
        }
        /// <p>The Apache Kafka version.</p>
        pub fn set_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kafka_version = input;
            self
        }
        /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.logging_info = Some(input);
            self
        }
        /// <p>You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.</p>
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.logging_info = input;
            self
        }
        /// <p>Information about the Amazon MSK broker type.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        /// <p>Information about the Amazon MSK broker type.</p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.client_authentication = Some(input);
            self
        }
        /// <p>Includes all client authentication information.</p>
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.client_authentication = input;
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.encryption_info = Some(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.encryption_info = input;
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn connectivity_info(mut self, input: crate::model::ConnectivityInfo) -> Self {
            self.connectivity_info = Some(input);
            self
        }
        /// <p>Information about the broker access configuration.</p>
        pub fn set_connectivity_info(
            mut self,
            input: std::option::Option<crate::model::ConnectivityInfo>,
        ) -> Self {
            self.connectivity_info = input;
            self
        }
        /// Consumes the builder and constructs a [`MutableClusterInfo`](crate::model::MutableClusterInfo)
        pub fn build(self) -> crate::model::MutableClusterInfo {
            crate::model::MutableClusterInfo {
                broker_ebs_volume_info: self.broker_ebs_volume_info,
                configuration_info: self.configuration_info,
                number_of_broker_nodes: self.number_of_broker_nodes.unwrap_or_default(),
                enhanced_monitoring: self.enhanced_monitoring,
                open_monitoring: self.open_monitoring,
                kafka_version: self.kafka_version,
                logging_info: self.logging_info,
                instance_type: self.instance_type,
                client_authentication: self.client_authentication,
                encryption_info: self.encryption_info,
                connectivity_info: self.connectivity_info,
            }
        }
    }
}
impl MutableClusterInfo {
    /// Creates a new builder-style object to manufacture [`MutableClusterInfo`](crate::model::MutableClusterInfo)
    pub fn builder() -> crate::model::mutable_cluster_info::Builder {
        crate::model::mutable_cluster_info::Builder::default()
    }
}

/// <p>Step taken during a cluster operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterOperationStep {
    /// <p>Information about the step and its status.</p>
    pub step_info: std::option::Option<crate::model::ClusterOperationStepInfo>,
    /// <p>The name of the step.</p>
    pub step_name: std::option::Option<std::string::String>,
}
impl ClusterOperationStep {
    /// <p>Information about the step and its status.</p>
    pub fn step_info(&self) -> std::option::Option<&crate::model::ClusterOperationStepInfo> {
        self.step_info.as_ref()
    }
    /// <p>The name of the step.</p>
    pub fn step_name(&self) -> std::option::Option<&str> {
        self.step_name.as_deref()
    }
}
impl std::fmt::Debug for ClusterOperationStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterOperationStep");
        formatter.field("step_info", &self.step_info);
        formatter.field("step_name", &self.step_name);
        formatter.finish()
    }
}
/// See [`ClusterOperationStep`](crate::model::ClusterOperationStep)
pub mod cluster_operation_step {
    /// A builder for [`ClusterOperationStep`](crate::model::ClusterOperationStep)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_info: std::option::Option<crate::model::ClusterOperationStepInfo>,
        pub(crate) step_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the step and its status.</p>
        pub fn step_info(mut self, input: crate::model::ClusterOperationStepInfo) -> Self {
            self.step_info = Some(input);
            self
        }
        /// <p>Information about the step and its status.</p>
        pub fn set_step_info(
            mut self,
            input: std::option::Option<crate::model::ClusterOperationStepInfo>,
        ) -> Self {
            self.step_info = input;
            self
        }
        /// <p>The name of the step.</p>
        pub fn step_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_name = Some(input.into());
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_step_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOperationStep`](crate::model::ClusterOperationStep)
        pub fn build(self) -> crate::model::ClusterOperationStep {
            crate::model::ClusterOperationStep {
                step_info: self.step_info,
                step_name: self.step_name,
            }
        }
    }
}
impl ClusterOperationStep {
    /// Creates a new builder-style object to manufacture [`ClusterOperationStep`](crate::model::ClusterOperationStep)
    pub fn builder() -> crate::model::cluster_operation_step::Builder {
        crate::model::cluster_operation_step::Builder::default()
    }
}

/// <p>State information about the operation step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterOperationStepInfo {
    /// <p>The steps current status.</p>
    pub step_status: std::option::Option<std::string::String>,
}
impl ClusterOperationStepInfo {
    /// <p>The steps current status.</p>
    pub fn step_status(&self) -> std::option::Option<&str> {
        self.step_status.as_deref()
    }
}
impl std::fmt::Debug for ClusterOperationStepInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterOperationStepInfo");
        formatter.field("step_status", &self.step_status);
        formatter.finish()
    }
}
/// See [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo)
pub mod cluster_operation_step_info {
    /// A builder for [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) step_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The steps current status.</p>
        pub fn step_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.step_status = Some(input.into());
            self
        }
        /// <p>The steps current status.</p>
        pub fn set_step_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.step_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo)
        pub fn build(self) -> crate::model::ClusterOperationStepInfo {
            crate::model::ClusterOperationStepInfo {
                step_status: self.step_status,
            }
        }
    }
}
impl ClusterOperationStepInfo {
    /// Creates a new builder-style object to manufacture [`ClusterOperationStepInfo`](crate::model::ClusterOperationStepInfo)
    pub fn builder() -> crate::model::cluster_operation_step_info::Builder {
        crate::model::cluster_operation_step_info::Builder::default()
    }
}

/// <p>Returns information about an error state of the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ErrorInfo {
    /// <p>A number describing the error programmatically.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>An optional field to provide more details about the error.</p>
    pub error_string: std::option::Option<std::string::String>,
}
impl ErrorInfo {
    /// <p>A number describing the error programmatically.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>An optional field to provide more details about the error.</p>
    pub fn error_string(&self) -> std::option::Option<&str> {
        self.error_string.as_deref()
    }
}
impl std::fmt::Debug for ErrorInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ErrorInfo");
        formatter.field("error_code", &self.error_code);
        formatter.field("error_string", &self.error_string);
        formatter.finish()
    }
}
/// See [`ErrorInfo`](crate::model::ErrorInfo)
pub mod error_info {
    /// A builder for [`ErrorInfo`](crate::model::ErrorInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A number describing the error programmatically.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>A number describing the error programmatically.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>An optional field to provide more details about the error.</p>
        pub fn error_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_string = Some(input.into());
            self
        }
        /// <p>An optional field to provide more details about the error.</p>
        pub fn set_error_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_string = input;
            self
        }
        /// Consumes the builder and constructs a [`ErrorInfo`](crate::model::ErrorInfo)
        pub fn build(self) -> crate::model::ErrorInfo {
            crate::model::ErrorInfo {
                error_code: self.error_code,
                error_string: self.error_string,
            }
        }
    }
}
impl ErrorInfo {
    /// Creates a new builder-style object to manufacture [`ErrorInfo`](crate::model::ErrorInfo)
    pub fn builder() -> crate::model::error_info::Builder {
        crate::model::error_info::Builder::default()
    }
}

/// <p>Contains source Apache Kafka versions and compatible target Apache Kafka versions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompatibleKafkaVersion {
    /// <p>An Apache Kafka version.</p>
    pub source_version: std::option::Option<std::string::String>,
    /// <p>A list of Apache Kafka versions.</p>
    pub target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CompatibleKafkaVersion {
    /// <p>An Apache Kafka version.</p>
    pub fn source_version(&self) -> std::option::Option<&str> {
        self.source_version.as_deref()
    }
    /// <p>A list of Apache Kafka versions.</p>
    pub fn target_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.target_versions.as_deref()
    }
}
impl std::fmt::Debug for CompatibleKafkaVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompatibleKafkaVersion");
        formatter.field("source_version", &self.source_version);
        formatter.field("target_versions", &self.target_versions);
        formatter.finish()
    }
}
/// See [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion)
pub mod compatible_kafka_version {
    /// A builder for [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_version: std::option::Option<std::string::String>,
        pub(crate) target_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>An Apache Kafka version.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_version = Some(input.into());
            self
        }
        /// <p>An Apache Kafka version.</p>
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_version = input;
            self
        }
        /// Appends an item to `target_versions`.
        ///
        /// To override the contents of this collection use [`set_target_versions`](Self::set_target_versions).
        ///
        /// <p>A list of Apache Kafka versions.</p>
        pub fn target_versions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_versions.unwrap_or_default();
            v.push(input.into());
            self.target_versions = Some(v);
            self
        }
        /// <p>A list of Apache Kafka versions.</p>
        pub fn set_target_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_versions = input;
            self
        }
        /// Consumes the builder and constructs a [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion)
        pub fn build(self) -> crate::model::CompatibleKafkaVersion {
            crate::model::CompatibleKafkaVersion {
                source_version: self.source_version,
                target_versions: self.target_versions,
            }
        }
    }
}
impl CompatibleKafkaVersion {
    /// Creates a new builder-style object to manufacture [`CompatibleKafkaVersion`](crate::model::CompatibleKafkaVersion)
    pub fn builder() -> crate::model::compatible_kafka_version::Builder {
        crate::model::compatible_kafka_version::Builder::default()
    }
}

/// <p>Error info for scram secret associate/disassociate failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnprocessedScramSecret {
    /// <p>Error code for associate/disassociate failure.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>Error message for associate/disassociate failure.</p>
    pub error_message: std::option::Option<std::string::String>,
    /// <p>AWS Secrets Manager secret ARN.</p>
    pub secret_arn: std::option::Option<std::string::String>,
}
impl UnprocessedScramSecret {
    /// <p>Error code for associate/disassociate failure.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>Error message for associate/disassociate failure.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>AWS Secrets Manager secret ARN.</p>
    pub fn secret_arn(&self) -> std::option::Option<&str> {
        self.secret_arn.as_deref()
    }
}
impl std::fmt::Debug for UnprocessedScramSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnprocessedScramSecret");
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.field("secret_arn", &self.secret_arn);
        formatter.finish()
    }
}
/// See [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret)
pub mod unprocessed_scram_secret {
    /// A builder for [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) secret_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error code for associate/disassociate failure.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>Error code for associate/disassociate failure.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>Error message for associate/disassociate failure.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Error message for associate/disassociate failure.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>AWS Secrets Manager secret ARN.</p>
        pub fn secret_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_arn = Some(input.into());
            self
        }
        /// <p>AWS Secrets Manager secret ARN.</p>
        pub fn set_secret_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret)
        pub fn build(self) -> crate::model::UnprocessedScramSecret {
            crate::model::UnprocessedScramSecret {
                error_code: self.error_code,
                error_message: self.error_message,
                secret_arn: self.secret_arn,
            }
        }
    }
}
impl UnprocessedScramSecret {
    /// Creates a new builder-style object to manufacture [`UnprocessedScramSecret`](crate::model::UnprocessedScramSecret)
    pub fn builder() -> crate::model::unprocessed_scram_secret::Builder {
        crate::model::unprocessed_scram_secret::Builder::default()
    }
}
