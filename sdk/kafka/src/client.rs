// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn batch_associate_scram_secret(&self) -> fluent_builders::BatchAssociateScramSecret<C> {
        fluent_builders::BatchAssociateScramSecret::new(self.handle.clone())
    }
    pub fn batch_disassociate_scram_secret(
        &self,
    ) -> fluent_builders::BatchDisassociateScramSecret<C> {
        fluent_builders::BatchDisassociateScramSecret::new(self.handle.clone())
    }
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_configuration(&self) -> fluent_builders::CreateConfiguration<C> {
        fluent_builders::CreateConfiguration::new(self.handle.clone())
    }
    pub fn delete_cluster(&self) -> fluent_builders::DeleteCluster<C> {
        fluent_builders::DeleteCluster::new(self.handle.clone())
    }
    pub fn delete_configuration(&self) -> fluent_builders::DeleteConfiguration<C> {
        fluent_builders::DeleteConfiguration::new(self.handle.clone())
    }
    pub fn describe_cluster(&self) -> fluent_builders::DescribeCluster<C> {
        fluent_builders::DescribeCluster::new(self.handle.clone())
    }
    pub fn describe_cluster_operation(&self) -> fluent_builders::DescribeClusterOperation<C> {
        fluent_builders::DescribeClusterOperation::new(self.handle.clone())
    }
    pub fn describe_configuration(&self) -> fluent_builders::DescribeConfiguration<C> {
        fluent_builders::DescribeConfiguration::new(self.handle.clone())
    }
    pub fn describe_configuration_revision(
        &self,
    ) -> fluent_builders::DescribeConfigurationRevision<C> {
        fluent_builders::DescribeConfigurationRevision::new(self.handle.clone())
    }
    pub fn get_bootstrap_brokers(&self) -> fluent_builders::GetBootstrapBrokers<C> {
        fluent_builders::GetBootstrapBrokers::new(self.handle.clone())
    }
    pub fn get_compatible_kafka_versions(&self) -> fluent_builders::GetCompatibleKafkaVersions<C> {
        fluent_builders::GetCompatibleKafkaVersions::new(self.handle.clone())
    }
    pub fn list_cluster_operations(&self) -> fluent_builders::ListClusterOperations<C> {
        fluent_builders::ListClusterOperations::new(self.handle.clone())
    }
    pub fn list_clusters(&self) -> fluent_builders::ListClusters<C> {
        fluent_builders::ListClusters::new(self.handle.clone())
    }
    pub fn list_configuration_revisions(&self) -> fluent_builders::ListConfigurationRevisions<C> {
        fluent_builders::ListConfigurationRevisions::new(self.handle.clone())
    }
    pub fn list_configurations(&self) -> fluent_builders::ListConfigurations<C> {
        fluent_builders::ListConfigurations::new(self.handle.clone())
    }
    pub fn list_kafka_versions(&self) -> fluent_builders::ListKafkaVersions<C> {
        fluent_builders::ListKafkaVersions::new(self.handle.clone())
    }
    pub fn list_nodes(&self) -> fluent_builders::ListNodes<C> {
        fluent_builders::ListNodes::new(self.handle.clone())
    }
    pub fn list_scram_secrets(&self) -> fluent_builders::ListScramSecrets<C> {
        fluent_builders::ListScramSecrets::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn reboot_broker(&self) -> fluent_builders::RebootBroker<C> {
        fluent_builders::RebootBroker::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_broker_count(&self) -> fluent_builders::UpdateBrokerCount<C> {
        fluent_builders::UpdateBrokerCount::new(self.handle.clone())
    }
    pub fn update_broker_storage(&self) -> fluent_builders::UpdateBrokerStorage<C> {
        fluent_builders::UpdateBrokerStorage::new(self.handle.clone())
    }
    pub fn update_broker_type(&self) -> fluent_builders::UpdateBrokerType<C> {
        fluent_builders::UpdateBrokerType::new(self.handle.clone())
    }
    pub fn update_cluster_configuration(&self) -> fluent_builders::UpdateClusterConfiguration<C> {
        fluent_builders::UpdateClusterConfiguration::new(self.handle.clone())
    }
    pub fn update_cluster_kafka_version(&self) -> fluent_builders::UpdateClusterKafkaVersion<C> {
        fluent_builders::UpdateClusterKafkaVersion::new(self.handle.clone())
    }
    pub fn update_configuration(&self) -> fluent_builders::UpdateConfiguration<C> {
        fluent_builders::UpdateConfiguration::new(self.handle.clone())
    }
    pub fn update_monitoring(&self) -> fluent_builders::UpdateMonitoring<C> {
        fluent_builders::UpdateMonitoring::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct BatchAssociateScramSecret<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_associate_scram_secret_input::Builder,
    }
    impl<C> BatchAssociateScramSecret<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchAssociateScramSecretOutput,
            smithy_http::result::SdkError<crate::error::BatchAssociateScramSecretError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>List of AWS Secrets Manager secret ARNs.</p>
        pub fn secret_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_arn_list(inp);
            self
        }
        pub fn set_secret_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_secret_arn_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDisassociateScramSecret<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_disassociate_scram_secret_input::Builder,
    }
    impl<C> BatchDisassociateScramSecret<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDisassociateScramSecretOutput,
            smithy_http::result::SdkError<crate::error::BatchDisassociateScramSecretError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>List of AWS Secrets Manager secret ARNs.</p>
        pub fn secret_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_arn_list(inp);
            self
        }
        pub fn set_secret_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_secret_arn_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C> CreateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Information about the broker nodes in the cluster.</p>
        pub fn broker_node_group_info(mut self, input: crate::model::BrokerNodeGroupInfo) -> Self {
            self.inner = self.inner.broker_node_group_info(input);
            self
        }
        pub fn set_broker_node_group_info(
            mut self,
            input: std::option::Option<crate::model::BrokerNodeGroupInfo>,
        ) -> Self {
            self.inner = self.inner.set_broker_node_group_info(input);
            self
        }
        /// <p>Includes all client authentication related information.</p>
        pub fn client_authentication(mut self, input: crate::model::ClientAuthentication) -> Self {
            self.inner = self.inner.client_authentication(input);
            self
        }
        pub fn set_client_authentication(
            mut self,
            input: std::option::Option<crate::model::ClientAuthentication>,
        ) -> Self {
            self.inner = self.inner.set_client_authentication(input);
            self
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>Represents the configuration that you want MSK to use for the brokers in a cluster.</p>
        pub fn configuration_info(mut self, input: crate::model::ConfigurationInfo) -> Self {
            self.inner = self.inner.configuration_info(input);
            self
        }
        pub fn set_configuration_info(
            mut self,
            input: std::option::Option<crate::model::ConfigurationInfo>,
        ) -> Self {
            self.inner = self.inner.set_configuration_info(input);
            self
        }
        /// <p>Includes all encryption-related information.</p>
        pub fn encryption_info(mut self, input: crate::model::EncryptionInfo) -> Self {
            self.inner = self.inner.encryption_info(input);
            self
        }
        pub fn set_encryption_info(
            mut self,
            input: std::option::Option<crate::model::EncryptionInfo>,
        ) -> Self {
            self.inner = self.inner.set_encryption_info(input);
            self
        }
        /// <p>Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.inner = self.inner.enhanced_monitoring(input);
            self
        }
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.inner = self.inner.set_enhanced_monitoring(input);
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoringInfo) -> Self {
            self.inner = self.inner.open_monitoring(input);
            self
        }
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoringInfo>,
        ) -> Self {
            self.inner = self.inner.set_open_monitoring(input);
            self
        }
        /// <p>The version of Apache Kafka.</p>
        pub fn kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kafka_version(input);
            self
        }
        pub fn set_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_kafka_version(input);
            self
        }
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.inner = self.inner.logging_info(input);
            self
        }
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.inner = self.inner.set_logging_info(input);
            self
        }
        /// <p>The number of broker nodes in the cluster.</p>
        pub fn number_of_broker_nodes(mut self, input: i32) -> Self {
            self.inner = self.inner.number_of_broker_nodes(input);
            self
        }
        pub fn set_number_of_broker_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_number_of_broker_nodes(input);
            self
        }
        /// <p>Create tags when creating the cluster.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_configuration_input::Builder,
    }
    impl<C> CreateConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The description of the configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The versions of Apache Kafka with which you can use this MSK configuration.</p>
        pub fn kafka_versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kafka_versions(inp);
            self
        }
        pub fn set_kafka_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_kafka_versions(input);
            self
        }
        /// <p>The name of the configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded.
        /// When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
        pub fn server_properties(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.server_properties(input);
            self
        }
        pub fn set_server_properties(
            mut self,
            input: std::option::Option<smithy_types::Blob>,
        ) -> Self {
            self.inner = self.inner.set_server_properties(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cluster_input::Builder,
    }
    impl<C> DeleteCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClusterOutput,
            smithy_http::result::SdkError<crate::error::DeleteClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The current version of the MSK cluster.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_configuration_input::Builder,
    }
    impl<C> DeleteConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cluster_input::Builder,
    }
    impl<C> DescribeCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClusterOutput,
            smithy_http::result::SdkError<crate::error::DescribeClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClusterOperation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cluster_operation_input::Builder,
    }
    impl<C> DescribeClusterOperation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClusterOperationOutput,
            smithy_http::result::SdkError<crate::error::DescribeClusterOperationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.</p>
        pub fn cluster_operation_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_operation_arn(input);
            self
        }
        pub fn set_cluster_operation_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cluster_operation_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_configuration_input::Builder,
    }
    impl<C> DescribeConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConfigurationRevision<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_configuration_revision_input::Builder,
    }
    impl<C> DescribeConfigurationRevision<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConfigurationRevisionOutput,
            smithy_http::result::SdkError<crate::error::DescribeConfigurationRevisionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>A string that uniquely identifies a revision of an MSK configuration.</p>
        pub fn revision(mut self, input: i64) -> Self {
            self.inner = self.inner.revision(input);
            self
        }
        pub fn set_revision(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBootstrapBrokers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bootstrap_brokers_input::Builder,
    }
    impl<C> GetBootstrapBrokers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBootstrapBrokersOutput,
            smithy_http::result::SdkError<crate::error::GetBootstrapBrokersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCompatibleKafkaVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_compatible_kafka_versions_input::Builder,
    }
    impl<C> GetCompatibleKafkaVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCompatibleKafkaVersionsOutput,
            smithy_http::result::SdkError<crate::error::GetCompatibleKafkaVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the cluster check.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusterOperations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_cluster_operations_input::Builder,
    }
    impl<C> ListClusterOperations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClusterOperationsOutput,
            smithy_http::result::SdkError<crate::error::ListClusterOperationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
        /// To get the next batch, provide this token in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_clusters_input::Builder,
    }
    impl<C> ListClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClustersOutput,
            smithy_http::result::SdkError<crate::error::ListClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.</p>
        pub fn cluster_name_filter(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name_filter(input);
            self
        }
        pub fn set_cluster_name_filter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cluster_name_filter(input);
            self
        }
        /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
        /// To get the next batch, provide this token in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConfigurationRevisions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_configuration_revisions_input::Builder,
    }
    impl<C> ListConfigurationRevisions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConfigurationRevisionsOutput,
            smithy_http::result::SdkError<crate::error::ListConfigurationRevisionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
        /// To get the next batch, provide this token in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_configurations_input::Builder,
    }
    impl<C> ListConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
        /// To get the next batch, provide this token in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListKafkaVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_kafka_versions_input::Builder,
    }
    impl<C> ListKafkaVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListKafkaVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListKafkaVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListNodes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_nodes_input::Builder,
    }
    impl<C> ListNodes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListNodesOutput,
            smithy_http::result::SdkError<crate::error::ListNodesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.
        /// To get the next batch, provide this token in your next request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListScramSecrets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_scram_secrets_input::Builder,
    }
    impl<C> ListScramSecrets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListScramSecretsOutput,
            smithy_http::result::SdkError<crate::error::ListScramSecretsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The arn of the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The maxResults of the query.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The nextToken of the query.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootBroker<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_broker_input::Builder,
    }
    impl<C> RebootBroker<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootBrokerOutput,
            smithy_http::result::SdkError<crate::error::RebootBrokerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.</p>
        pub fn broker_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.broker_ids(inp);
            self
        }
        pub fn set_broker_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_broker_ids(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The key-value pair for the resource tag.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Tag keys must be unique for a given cluster. In addition, the following restrictions apply:</p>
        /// <ul>
        /// <li>
        /// <p>Each tag key must be unique. If you add a tag with a key that's already in
        /// use, your new tag overwrites the existing key-value pair. </p>
        /// </li>
        /// <li>
        /// <p>You can't start a tag key with aws: because this prefix is reserved for use
        /// by  AWS.  AWS creates tags that begin with this prefix on your behalf, but
        /// you can't edit or delete them.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys must be between 1 and 128 Unicode characters in length.</p>
        /// </li>
        /// <li>
        /// <p>Tag keys must consist of the following characters: Unicode letters, digits,
        /// white space, and the following special characters: _ . / = + -
        /// @.</p>
        /// </li>
        /// </ul>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBrokerCount<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_broker_count_input::Builder,
    }
    impl<C> UpdateBrokerCount<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBrokerCountOutput,
            smithy_http::result::SdkError<crate::error::UpdateBrokerCountError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
        /// <p>The number of broker nodes that you want the cluster to have after this operation completes successfully.</p>
        pub fn target_number_of_broker_nodes(mut self, input: i32) -> Self {
            self.inner = self.inner.target_number_of_broker_nodes(input);
            self
        }
        pub fn set_target_number_of_broker_nodes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_target_number_of_broker_nodes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBrokerStorage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_broker_storage_input::Builder,
    }
    impl<C> UpdateBrokerStorage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBrokerStorageOutput,
            smithy_http::result::SdkError<crate::error::UpdateBrokerStorageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
        /// <p>Describes the target volume size and the ID of the broker to apply the update to.</p>
        pub fn target_broker_ebs_volume_info(
            mut self,
            inp: impl Into<crate::model::BrokerEbsVolumeInfo>,
        ) -> Self {
            self.inner = self.inner.target_broker_ebs_volume_info(inp);
            self
        }
        pub fn set_target_broker_ebs_volume_info(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BrokerEbsVolumeInfo>>,
        ) -> Self {
            self.inner = self.inner.set_target_broker_ebs_volume_info(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateBrokerType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_broker_type_input::Builder,
    }
    impl<C> UpdateBrokerType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateBrokerTypeOutput,
            smithy_http::result::SdkError<crate::error::UpdateBrokerTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
        /// <p>The Amazon MSK broker type that you want all of the brokers in this cluster to be.</p>
        pub fn target_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_instance_type(input);
            self
        }
        pub fn set_target_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_instance_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateClusterConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_configuration_input::Builder,
    }
    impl<C> UpdateClusterConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>Represents the configuration that you want MSK to use for the brokers in a cluster.</p>
        pub fn configuration_info(mut self, input: crate::model::ConfigurationInfo) -> Self {
            self.inner = self.inner.configuration_info(input);
            self
        }
        pub fn set_configuration_info(
            mut self,
            input: std::option::Option<crate::model::ConfigurationInfo>,
        ) -> Self {
            self.inner = self.inner.set_configuration_info(input);
            self
        }
        /// <p>The version of the cluster that needs to be updated.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateClusterKafkaVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_kafka_version_input::Builder,
    }
    impl<C> UpdateClusterKafkaVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterKafkaVersionOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterKafkaVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The custom configuration that should be applied on the new version of cluster.</p>
        pub fn configuration_info(mut self, input: crate::model::ConfigurationInfo) -> Self {
            self.inner = self.inner.configuration_info(input);
            self
        }
        pub fn set_configuration_info(
            mut self,
            input: std::option::Option<crate::model::ConfigurationInfo>,
        ) -> Self {
            self.inner = self.inner.set_configuration_info(input);
            self
        }
        /// <p>Current cluster version.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
        /// <p>Target Kafka version.</p>
        pub fn target_kafka_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_kafka_version(input);
            self
        }
        pub fn set_target_kafka_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_kafka_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_configuration_input::Builder,
    }
    impl<C> UpdateConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the configuration.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>The description of the configuration revision.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded.
        /// When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
        pub fn server_properties(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.server_properties(input);
            self
        }
        pub fn set_server_properties(
            mut self,
            input: std::option::Option<smithy_types::Blob>,
        ) -> Self {
            self.inner = self.inner.set_server_properties(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateMonitoring<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_monitoring_input::Builder,
    }
    impl<C> UpdateMonitoring<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateMonitoringOutput,
            smithy_http::result::SdkError<crate::error::UpdateMonitoringError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
        pub fn cluster_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_arn(input);
            self
        }
        pub fn set_cluster_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_arn(input);
            self
        }
        /// <p>The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.</p>
        pub fn current_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
        /// <p>Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.</p>
        pub fn enhanced_monitoring(mut self, input: crate::model::EnhancedMonitoring) -> Self {
            self.inner = self.inner.enhanced_monitoring(input);
            self
        }
        pub fn set_enhanced_monitoring(
            mut self,
            input: std::option::Option<crate::model::EnhancedMonitoring>,
        ) -> Self {
            self.inner = self.inner.set_enhanced_monitoring(input);
            self
        }
        /// <p>The settings for open monitoring.</p>
        pub fn open_monitoring(mut self, input: crate::model::OpenMonitoringInfo) -> Self {
            self.inner = self.inner.open_monitoring(input);
            self
        }
        pub fn set_open_monitoring(
            mut self,
            input: std::option::Option<crate::model::OpenMonitoringInfo>,
        ) -> Self {
            self.inner = self.inner.set_open_monitoring(input);
            self
        }
        pub fn logging_info(mut self, input: crate::model::LoggingInfo) -> Self {
            self.inner = self.inner.logging_info(input);
            self
        }
        pub fn set_logging_info(
            mut self,
            input: std::option::Option<crate::model::LoggingInfo>,
        ) -> Self {
            self.inner = self.inner.set_logging_info(input);
            self
        }
    }
}
