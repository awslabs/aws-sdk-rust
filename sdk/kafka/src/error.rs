// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `BatchAssociateScramSecret` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchAssociateScramSecretError {
    /// Kind of error that occurred.
    pub kind: BatchAssociateScramSecretErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchAssociateScramSecret` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchAssociateScramSecretErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchAssociateScramSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchAssociateScramSecretErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchAssociateScramSecretErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchAssociateScramSecretErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            BatchAssociateScramSecretErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchAssociateScramSecretErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchAssociateScramSecretErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            BatchAssociateScramSecretErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            BatchAssociateScramSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchAssociateScramSecretError {
    fn code(&self) -> Option<&str> {
        BatchAssociateScramSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchAssociateScramSecretError {
    /// Creates a new `BatchAssociateScramSecretError`.
    pub fn new(kind: BatchAssociateScramSecretErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchAssociateScramSecretError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchAssociateScramSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchAssociateScramSecretError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchAssociateScramSecretErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchAssociateScramSecretErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchAssociateScramSecretErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for BatchAssociateScramSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchAssociateScramSecretErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchAssociateScramSecretErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchAssociateScramSecretErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            BatchAssociateScramSecretErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchAssociateScramSecretErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            BatchAssociateScramSecretErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            BatchAssociateScramSecretErrorKind::UnauthorizedException(_inner) => Some(_inner),
            BatchAssociateScramSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `BatchDisassociateScramSecret` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDisassociateScramSecretError {
    /// Kind of error that occurred.
    pub kind: BatchDisassociateScramSecretErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchDisassociateScramSecret` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDisassociateScramSecretErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDisassociateScramSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDisassociateScramSecretErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            BatchDisassociateScramSecretErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            BatchDisassociateScramSecretErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            BatchDisassociateScramSecretErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            BatchDisassociateScramSecretErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchDisassociateScramSecretErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            BatchDisassociateScramSecretErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            BatchDisassociateScramSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchDisassociateScramSecretError {
    fn code(&self) -> Option<&str> {
        BatchDisassociateScramSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDisassociateScramSecretError {
    /// Creates a new `BatchDisassociateScramSecretError`.
    pub fn new(kind: BatchDisassociateScramSecretErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchDisassociateScramSecretError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDisassociateScramSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchDisassociateScramSecretError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDisassociateScramSecretErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDisassociateScramSecretErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDisassociateScramSecretErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for BatchDisassociateScramSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDisassociateScramSecretErrorKind::BadRequestException(_inner) => Some(_inner),
            BatchDisassociateScramSecretErrorKind::ForbiddenException(_inner) => Some(_inner),
            BatchDisassociateScramSecretErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            BatchDisassociateScramSecretErrorKind::NotFoundException(_inner) => Some(_inner),
            BatchDisassociateScramSecretErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchDisassociateScramSecretErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            BatchDisassociateScramSecretErrorKind::UnauthorizedException(_inner) => Some(_inner),
            BatchDisassociateScramSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateCluster` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateClusterError {
    /// Kind of error that occurred.
    pub kind: CreateClusterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCluster` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateClusterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterError {
    fn code(&self) -> Option<&str> {
        CreateClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterError {
    /// Creates a new `CreateClusterError`.
    pub fn new(kind: CreateClusterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateClusterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateClusterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateClusterErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateClusterErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateClusterErrorKind::ConflictException(_inner) => Some(_inner),
            CreateClusterErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateClusterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateClusterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateClusterErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateClusterErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateClusterV2` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateClusterV2Error {
    /// Kind of error that occurred.
    pub kind: CreateClusterV2ErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateClusterV2` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterV2ErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateClusterV2Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateClusterV2ErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateClusterV2ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterV2Error {
    fn code(&self) -> Option<&str> {
        CreateClusterV2Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterV2Error {
    /// Creates a new `CreateClusterV2Error`.
    pub fn new(kind: CreateClusterV2ErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateClusterV2Error::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateClusterV2ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateClusterV2Error::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateClusterV2ErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterV2ErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterV2ErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateClusterV2ErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterV2ErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterV2ErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterV2ErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateClusterV2ErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateClusterV2ErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateClusterV2Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateClusterV2ErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::ConflictException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateClusterV2ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfigurationError {
    /// Kind of error that occurred.
    pub kind: CreateConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfigurationErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfigurationError {
    /// Creates a new `CreateConfigurationError`.
    pub fn new(kind: CreateConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::ConflictException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCluster` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteClusterError {
    /// Kind of error that occurred.
    pub kind: DeleteClusterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCluster` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteClusterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterError {
    fn code(&self) -> Option<&str> {
        DeleteClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterError {
    /// Creates a new `DeleteClusterError`.
    pub fn new(kind: DeleteClusterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteClusterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteClusterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteClusterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClusterErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteClusterErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteClusterErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteClusterErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteClusterErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteClusterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteClusterErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationError {
    /// Kind of error that occurred.
    pub kind: DeleteConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationError {
    /// Creates a new `DeleteConfigurationError`.
    pub fn new(kind: DeleteConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteConfigurationErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCluster` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClusterError {
    /// Kind of error that occurred.
    pub kind: DescribeClusterErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCluster` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClusterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeClusterErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeClusterErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeClusterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeClusterErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterError {
    fn code(&self) -> Option<&str> {
        DescribeClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterError {
    /// Creates a new `DescribeClusterError`.
    pub fn new(kind: DescribeClusterErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeClusterError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClusterErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeClusterErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DescribeClusterErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DescribeClusterErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeClusterErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClusterErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeClusterErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeClusterErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeClusterErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeClusterErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeClusterOperation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClusterOperationError {
    /// Kind of error that occurred.
    pub kind: DescribeClusterOperationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeClusterOperation` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterOperationErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClusterOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClusterOperationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeClusterOperationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeClusterOperationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeClusterOperationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeClusterOperationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeClusterOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterOperationError {
    fn code(&self) -> Option<&str> {
        DescribeClusterOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterOperationError {
    /// Creates a new `DescribeClusterOperationError`.
    pub fn new(kind: DescribeClusterOperationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeClusterOperationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClusterOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeClusterOperationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClusterOperationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeClusterOperationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterOperationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterOperationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterOperationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterOperationErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterOperationErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterOperationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterOperationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterOperationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterOperationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeClusterOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClusterOperationErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeClusterOperationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeClusterOperationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeClusterOperationErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeClusterOperationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeClusterOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeClusterV2` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeClusterV2Error {
    /// Kind of error that occurred.
    pub kind: DescribeClusterV2ErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeClusterV2` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterV2ErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeClusterV2Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeClusterV2ErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeClusterV2ErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeClusterV2ErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeClusterV2ErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeClusterV2ErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeClusterV2ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterV2Error {
    fn code(&self) -> Option<&str> {
        DescribeClusterV2Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterV2Error {
    /// Creates a new `DescribeClusterV2Error`.
    pub fn new(kind: DescribeClusterV2ErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeClusterV2Error::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeClusterV2ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeClusterV2Error::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeClusterV2ErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeClusterV2ErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterV2ErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterV2ErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterV2ErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterV2ErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterV2ErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeClusterV2ErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DescribeClusterV2ErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterV2ErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeClusterV2ErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeClusterV2Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeClusterV2ErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeClusterV2ErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeClusterV2ErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeClusterV2ErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeClusterV2ErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeClusterV2ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationError {
    /// Kind of error that occurred.
    pub kind: DescribeConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationError {
    /// Creates a new `DescribeConfigurationError`.
    pub fn new(kind: DescribeConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeConfigurationRevision` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConfigurationRevisionError {
    /// Kind of error that occurred.
    pub kind: DescribeConfigurationRevisionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeConfigurationRevision` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConfigurationRevisionErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConfigurationRevisionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConfigurationRevisionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigurationRevisionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConfigurationRevisionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DescribeConfigurationRevisionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeConfigurationRevisionError {
    fn code(&self) -> Option<&str> {
        DescribeConfigurationRevisionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConfigurationRevisionError {
    /// Creates a new `DescribeConfigurationRevisionError`.
    pub fn new(
        kind: DescribeConfigurationRevisionErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeConfigurationRevisionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConfigurationRevisionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeConfigurationRevisionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConfigurationRevisionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeConfigurationRevisionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationRevisionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationRevisionErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationRevisionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationRevisionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeConfigurationRevisionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConfigurationRevisionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DescribeConfigurationRevisionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConfigurationRevisionErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DescribeConfigurationRevisionErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeConfigurationRevisionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DescribeConfigurationRevisionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetBootstrapBrokers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBootstrapBrokersError {
    /// Kind of error that occurred.
    pub kind: GetBootstrapBrokersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetBootstrapBrokers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBootstrapBrokersErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBootstrapBrokersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBootstrapBrokersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBootstrapBrokersErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetBootstrapBrokersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetBootstrapBrokersErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetBootstrapBrokersErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetBootstrapBrokersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBootstrapBrokersError {
    fn code(&self) -> Option<&str> {
        GetBootstrapBrokersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBootstrapBrokersError {
    /// Creates a new `GetBootstrapBrokersError`.
    pub fn new(kind: GetBootstrapBrokersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetBootstrapBrokersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBootstrapBrokersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetBootstrapBrokersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBootstrapBrokersErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetBootstrapBrokersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBootstrapBrokersErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBootstrapBrokersErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBootstrapBrokersErrorKind::ConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBootstrapBrokersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBootstrapBrokersErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBootstrapBrokersErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBootstrapBrokersErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBootstrapBrokersErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBootstrapBrokersErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetBootstrapBrokersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBootstrapBrokersErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBootstrapBrokersErrorKind::ConflictException(_inner) => Some(_inner),
            GetBootstrapBrokersErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetBootstrapBrokersErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetBootstrapBrokersErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetBootstrapBrokersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCompatibleKafkaVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCompatibleKafkaVersionsError {
    /// Kind of error that occurred.
    pub kind: GetCompatibleKafkaVersionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCompatibleKafkaVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCompatibleKafkaVersionsErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCompatibleKafkaVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCompatibleKafkaVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCompatibleKafkaVersionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCompatibleKafkaVersionsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetCompatibleKafkaVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCompatibleKafkaVersionsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetCompatibleKafkaVersionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCompatibleKafkaVersionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetCompatibleKafkaVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCompatibleKafkaVersionsError {
    fn code(&self) -> Option<&str> {
        GetCompatibleKafkaVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCompatibleKafkaVersionsError {
    /// Creates a new `GetCompatibleKafkaVersionsError`.
    pub fn new(kind: GetCompatibleKafkaVersionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCompatibleKafkaVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCompatibleKafkaVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCompatibleKafkaVersionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCompatibleKafkaVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCompatibleKafkaVersionsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCompatibleKafkaVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetCompatibleKafkaVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCompatibleKafkaVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCompatibleKafkaVersionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCompatibleKafkaVersionsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetCompatibleKafkaVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCompatibleKafkaVersionsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetCompatibleKafkaVersionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCompatibleKafkaVersionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetCompatibleKafkaVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListClusterOperations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClusterOperationsError {
    /// Kind of error that occurred.
    pub kind: ListClusterOperationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListClusterOperations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClusterOperationsErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClusterOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClusterOperationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListClusterOperationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListClusterOperationsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListClusterOperationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListClusterOperationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListClusterOperationsError {
    fn code(&self) -> Option<&str> {
        ListClusterOperationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClusterOperationsError {
    /// Creates a new `ListClusterOperationsError`.
    pub fn new(kind: ListClusterOperationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListClusterOperationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClusterOperationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListClusterOperationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClusterOperationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListClusterOperationsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClusterOperationsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListClusterOperationsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClusterOperationsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListClusterOperationsErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClusterOperationsErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListClusterOperationsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClusterOperationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListClusterOperationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClusterOperationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListClusterOperationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListClusterOperationsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListClusterOperationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListClusterOperationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListClusters` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClustersError {
    /// Kind of error that occurred.
    pub kind: ListClustersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListClusters` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClustersErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClustersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListClustersError {
    fn code(&self) -> Option<&str> {
        ListClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClustersError {
    /// Creates a new `ListClustersError`.
    pub fn new(kind: ListClustersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListClustersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListClustersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClustersErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListClustersErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListClustersErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListClustersErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClustersErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListClustersErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListClustersErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClustersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListClustersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListClustersErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListClustersErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListClustersV2` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListClustersV2Error {
    /// Kind of error that occurred.
    pub kind: ListClustersV2ErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListClustersV2` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListClustersV2ErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListClustersV2Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListClustersV2ErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListClustersV2ErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListClustersV2ErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListClustersV2ErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListClustersV2ErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListClustersV2Error {
    fn code(&self) -> Option<&str> {
        ListClustersV2Error::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListClustersV2Error {
    /// Creates a new `ListClustersV2Error`.
    pub fn new(kind: ListClustersV2ErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListClustersV2Error::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListClustersV2ErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListClustersV2Error::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListClustersV2ErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListClustersV2ErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListClustersV2ErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListClustersV2ErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListClustersV2ErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListClustersV2ErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClustersV2ErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListClustersV2ErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListClustersV2ErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListClustersV2Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListClustersV2ErrorKind::BadRequestException(_inner) => Some(_inner),
            ListClustersV2ErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListClustersV2ErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListClustersV2ErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListClustersV2ErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListConfigurationRevisions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfigurationRevisionsError {
    /// Kind of error that occurred.
    pub kind: ListConfigurationRevisionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListConfigurationRevisions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfigurationRevisionsErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConfigurationRevisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfigurationRevisionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            ListConfigurationRevisionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            ListConfigurationRevisionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListConfigurationRevisionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListConfigurationRevisionsError {
    fn code(&self) -> Option<&str> {
        ListConfigurationRevisionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfigurationRevisionsError {
    /// Creates a new `ListConfigurationRevisionsError`.
    pub fn new(kind: ListConfigurationRevisionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListConfigurationRevisionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConfigurationRevisionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListConfigurationRevisionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConfigurationRevisionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListConfigurationRevisionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationRevisionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationRevisionsErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationRevisionsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationRevisionsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationRevisionsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationRevisionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListConfigurationRevisionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfigurationRevisionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            ListConfigurationRevisionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            ListConfigurationRevisionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListConfigurationRevisionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfigurationsError {
    /// Kind of error that occurred.
    pub kind: ListConfigurationsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListConfigurations` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfigurationsErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfigurationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfigurationsError {
    /// Creates a new `ListConfigurationsError`.
    pub fn new(kind: ListConfigurationsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListConfigurationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListConfigurationsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListConfigurationsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationsErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListConfigurationsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfigurationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListKafkaVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListKafkaVersionsError {
    /// Kind of error that occurred.
    pub kind: ListKafkaVersionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListKafkaVersions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListKafkaVersionsErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListKafkaVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListKafkaVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListKafkaVersionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListKafkaVersionsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListKafkaVersionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListKafkaVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListKafkaVersionsError {
    fn code(&self) -> Option<&str> {
        ListKafkaVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListKafkaVersionsError {
    /// Creates a new `ListKafkaVersionsError`.
    pub fn new(kind: ListKafkaVersionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListKafkaVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListKafkaVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListKafkaVersionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListKafkaVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListKafkaVersionsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKafkaVersionsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListKafkaVersionsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKafkaVersionsErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListKafkaVersionsErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKafkaVersionsErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListKafkaVersionsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListKafkaVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListKafkaVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListKafkaVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListKafkaVersionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListKafkaVersionsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListKafkaVersionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListKafkaVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListNodes` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListNodesError {
    /// Kind of error that occurred.
    pub kind: ListNodesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListNodes` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListNodesErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListNodesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListNodesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListNodesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListNodesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListNodesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListNodesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListNodesError {
    fn code(&self) -> Option<&str> {
        ListNodesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListNodesError {
    /// Creates a new `ListNodesError`.
    pub fn new(kind: ListNodesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListNodesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListNodesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListNodesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListNodesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListNodesErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListNodesErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListNodesErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListNodesErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListNodesErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNodesErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListNodesErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListNodesErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for ListNodesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListNodesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListNodesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListNodesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListNodesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListNodesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListScramSecrets` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListScramSecretsError {
    /// Kind of error that occurred.
    pub kind: ListScramSecretsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListScramSecrets` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListScramSecretsErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListScramSecretsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListScramSecretsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListScramSecretsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListScramSecretsError {
    fn code(&self) -> Option<&str> {
        ListScramSecretsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListScramSecretsError {
    /// Creates a new `ListScramSecretsError`.
    pub fn new(kind: ListScramSecretsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListScramSecretsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListScramSecretsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListScramSecretsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListScramSecretsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScramSecretsErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListScramSecretsErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScramSecretsErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListScramSecretsErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScramSecretsErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScramSecretsErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `ListScramSecretsErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListScramSecretsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListScramSecretsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListScramSecretsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListScramSecretsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
    pub kind: ListTagsForResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RebootBroker` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootBrokerError {
    /// Kind of error that occurred.
    pub kind: RebootBrokerErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RebootBroker` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootBrokerErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootBrokerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootBrokerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RebootBrokerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RebootBrokerError {
    fn code(&self) -> Option<&str> {
        RebootBrokerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootBrokerError {
    /// Creates a new `RebootBrokerError`.
    pub fn new(kind: RebootBrokerErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RebootBrokerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootBrokerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RebootBrokerError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootBrokerErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootBrokerErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootBrokerErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebootBrokerErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `RebootBrokerErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, RebootBrokerErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for RebootBrokerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootBrokerErrorKind::BadRequestException(_inner) => Some(_inner),
            RebootBrokerErrorKind::ForbiddenException(_inner) => Some(_inner),
            RebootBrokerErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            RebootBrokerErrorKind::NotFoundException(_inner) => Some(_inner),
            RebootBrokerErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            RebootBrokerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RebootBrokerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RebootBrokerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
    pub kind: TagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
    pub kind: UntagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateBrokerCount` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBrokerCountError {
    /// Kind of error that occurred.
    pub kind: UpdateBrokerCountErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateBrokerCount` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBrokerCountErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBrokerCountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBrokerCountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBrokerCountErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateBrokerCountErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateBrokerCountErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateBrokerCountErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateBrokerCountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateBrokerCountError {
    fn code(&self) -> Option<&str> {
        UpdateBrokerCountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBrokerCountError {
    /// Creates a new `UpdateBrokerCountError`.
    pub fn new(kind: UpdateBrokerCountErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateBrokerCountError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBrokerCountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateBrokerCountError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBrokerCountErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateBrokerCountErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerCountErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerCountErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerCountErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerCountErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerCountErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerCountErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerCountErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerCountErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerCountErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateBrokerCountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBrokerCountErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBrokerCountErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateBrokerCountErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateBrokerCountErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateBrokerCountErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateBrokerCountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateBrokerStorage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBrokerStorageError {
    /// Kind of error that occurred.
    pub kind: UpdateBrokerStorageErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateBrokerStorage` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBrokerStorageErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBrokerStorageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBrokerStorageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBrokerStorageErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateBrokerStorageErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateBrokerStorageErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateBrokerStorageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateBrokerStorageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateBrokerStorageError {
    fn code(&self) -> Option<&str> {
        UpdateBrokerStorageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBrokerStorageError {
    /// Creates a new `UpdateBrokerStorageError`.
    pub fn new(kind: UpdateBrokerStorageErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateBrokerStorageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBrokerStorageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateBrokerStorageError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBrokerStorageErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateBrokerStorageErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerStorageErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerStorageErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerStorageErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerStorageErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerStorageErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerStorageErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerStorageErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerStorageErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerStorageErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateBrokerStorageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBrokerStorageErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBrokerStorageErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateBrokerStorageErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateBrokerStorageErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateBrokerStorageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateBrokerStorageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateBrokerType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBrokerTypeError {
    /// Kind of error that occurred.
    pub kind: UpdateBrokerTypeErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateBrokerType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBrokerTypeErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBrokerTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBrokerTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateBrokerTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateBrokerTypeError {
    fn code(&self) -> Option<&str> {
        UpdateBrokerTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBrokerTypeError {
    /// Creates a new `UpdateBrokerTypeError`.
    pub fn new(kind: UpdateBrokerTypeErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateBrokerTypeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBrokerTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateBrokerTypeError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBrokerTypeErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerTypeErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateBrokerTypeErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerTypeErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateBrokerTypeErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerTypeErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerTypeErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateBrokerTypeErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBrokerTypeErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateBrokerTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBrokerTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateBrokerTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateClusterConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterConfigurationError {
    /// Kind of error that occurred.
    pub kind: UpdateClusterConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateClusterConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterConfigurationErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateClusterConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateClusterConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateClusterConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateClusterConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateClusterConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateClusterConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateClusterConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateClusterConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterConfigurationError {
    /// Creates a new `UpdateClusterConfigurationError`.
    pub fn new(kind: UpdateClusterConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateClusterConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateClusterConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateClusterConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterConfigurationErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateClusterConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateClusterConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateClusterConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateClusterConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateClusterConfigurationErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateClusterConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateClusterConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateClusterKafkaVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClusterKafkaVersionError {
    /// Kind of error that occurred.
    pub kind: UpdateClusterKafkaVersionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateClusterKafkaVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClusterKafkaVersionErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClusterKafkaVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClusterKafkaVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateClusterKafkaVersionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateClusterKafkaVersionErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateClusterKafkaVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateClusterKafkaVersionErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateClusterKafkaVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateClusterKafkaVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateClusterKafkaVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateClusterKafkaVersionError {
    fn code(&self) -> Option<&str> {
        UpdateClusterKafkaVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClusterKafkaVersionError {
    /// Creates a new `UpdateClusterKafkaVersionError`.
    pub fn new(kind: UpdateClusterKafkaVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateClusterKafkaVersionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClusterKafkaVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateClusterKafkaVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClusterKafkaVersionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateClusterKafkaVersionErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClusterKafkaVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateClusterKafkaVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClusterKafkaVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateClusterKafkaVersionErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateClusterKafkaVersionErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateClusterKafkaVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateClusterKafkaVersionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateClusterKafkaVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateClusterKafkaVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateClusterKafkaVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfigurationError {
    /// Kind of error that occurred.
    pub kind: UpdateConfigurationErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfigurationErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfigurationError {
    /// Creates a new `UpdateConfigurationError`.
    pub fn new(kind: UpdateConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateConfigurationErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConfigurationErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConfigurationErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConfigurationErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConfigurationErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConfigurationErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateConnectivity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConnectivityError {
    /// Kind of error that occurred.
    pub kind: UpdateConnectivityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateConnectivity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConnectivityErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConnectivityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConnectivityErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateConnectivityErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateConnectivityErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateConnectivityErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateConnectivityErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateConnectivityErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateConnectivityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateConnectivityError {
    fn code(&self) -> Option<&str> {
        UpdateConnectivityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConnectivityError {
    /// Creates a new `UpdateConnectivityError`.
    pub fn new(kind: UpdateConnectivityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateConnectivityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConnectivityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateConnectivityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConnectivityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateConnectivityErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectivityErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConnectivityErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectivityErrorKind::ForbiddenException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConnectivityErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectivityErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConnectivityErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectivityErrorKind::NotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConnectivityErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectivityErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateConnectivityErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectivityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateConnectivityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConnectivityErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateConnectivityErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateConnectivityErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateConnectivityErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateConnectivityErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateConnectivityErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateConnectivityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateMonitoring` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMonitoringError {
    /// Kind of error that occurred.
    pub kind: UpdateMonitoringErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateMonitoring` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMonitoringErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMonitoringError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMonitoringErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMonitoringErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateMonitoringErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateMonitoringErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateMonitoringErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateMonitoringErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateMonitoringError {
    fn code(&self) -> Option<&str> {
        UpdateMonitoringError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMonitoringError {
    /// Creates a new `UpdateMonitoringError`.
    pub fn new(kind: UpdateMonitoringErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateMonitoringError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMonitoringErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateMonitoringError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMonitoringErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateMonitoringErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMonitoringErrorKind::BadRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMonitoringErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateMonitoringErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateMonitoringErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMonitoringErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMonitoringErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMonitoringErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateMonitoringErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMonitoringErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateMonitoringError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMonitoringErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMonitoringErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateMonitoringErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateMonitoringErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateMonitoringErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateMonitoringErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateSecurity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecurityError {
    /// Kind of error that occurred.
    pub kind: UpdateSecurityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateSecurity` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecurityErrorKind {
    /// <p>Returns information about an error.</p>
    BadRequestException(crate::error::BadRequestException),
    /// <p>Returns information about an error.</p>
    ForbiddenException(crate::error::ForbiddenException),
    /// <p>Returns information about an error.</p>
    InternalServerErrorException(crate::error::InternalServerErrorException),
    /// <p>Returns information about an error.</p>
    NotFoundException(crate::error::NotFoundException),
    /// <p>Returns information about an error.</p>
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// <p>Returns information about an error.</p>
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// <p>Returns information about an error.</p>
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecurityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecurityErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateSecurityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSecurityError {
    fn code(&self) -> Option<&str> {
        UpdateSecurityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSecurityError {
    /// Creates a new `UpdateSecurityError`.
    pub fn new(kind: UpdateSecurityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateSecurityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecurityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateSecurityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecurityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSecurityErrorKind::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::ForbiddenException`.
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSecurityErrorKind::ForbiddenException(_))
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::InternalServerErrorException`.
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityErrorKind::InternalServerErrorException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::NotFoundException`.
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSecurityErrorKind::NotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityErrorKind::ServiceUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityErrorKind::TooManyRequestsException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateSecurityErrorKind::UnauthorizedException`.
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecurityErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateSecurityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecurityErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateSecurityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl UnauthorizedException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl TooManyRequestsException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl ServiceUnavailableException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl NotFoundException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl InternalServerErrorException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl ForbiddenException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl BadRequestException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>Returns information about an error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    /// <p>The parameter that caused the error.</p>
    pub invalid_parameter: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// <p>The parameter that caused the error.</p>
    pub fn invalid_parameter(&self) -> std::option::Option<&str> {
        self.invalid_parameter.as_deref()
    }
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("invalid_parameter", &self.invalid_parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) invalid_parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter that caused the error.</p>
        pub fn invalid_parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_parameter = Some(input.into());
            self
        }
        /// <p>The parameter that caused the error.</p>
        pub fn set_invalid_parameter(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_parameter = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                invalid_parameter: self.invalid_parameter,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
