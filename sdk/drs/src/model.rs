// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Validate exception field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>Validate exception field name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Validate exception field message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>Validate exception field name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Validate exception field message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Validate exception field name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Validate exception field name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Validate exception field message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Validate exception field message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "cannotParse" => ValidationExceptionReason::CannotParse,
            "fieldValidationFailed" => ValidationExceptionReason::FieldValidationFailed,
            "other" => ValidationExceptionReason::Other,
            "unknownOperation" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotParse => "cannotParse",
            ValidationExceptionReason::FieldValidationFailed => "fieldValidationFailed",
            ValidationExceptionReason::Other => "other",
            ValidationExceptionReason::UnknownOperation => "unknownOperation",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "cannotParse",
            "fieldValidationFailed",
            "other",
            "unknownOperation",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule in the Point in Time (PIT) policy representing when to take snapshots and how long to retain them for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PitPolicyRule {
    /// <p>The ID of the rule.</p>
    #[doc(hidden)]
    pub rule_id: i64,
    /// <p>The units used to measure the interval and retentionDuration.</p>
    #[doc(hidden)]
    pub units: std::option::Option<crate::model::PitPolicyRuleUnits>,
    /// <p>How often, in the chosen units, a snapshot should be taken.</p>
    #[doc(hidden)]
    pub interval: i32,
    /// <p>The duration to retain a snapshot for, in the chosen units.</p>
    #[doc(hidden)]
    pub retention_duration: i32,
    /// <p>Whether this rule is enabled or not.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
}
impl PitPolicyRule {
    /// <p>The ID of the rule.</p>
    pub fn rule_id(&self) -> i64 {
        self.rule_id
    }
    /// <p>The units used to measure the interval and retentionDuration.</p>
    pub fn units(&self) -> std::option::Option<&crate::model::PitPolicyRuleUnits> {
        self.units.as_ref()
    }
    /// <p>How often, in the chosen units, a snapshot should be taken.</p>
    pub fn interval(&self) -> i32 {
        self.interval
    }
    /// <p>The duration to retain a snapshot for, in the chosen units.</p>
    pub fn retention_duration(&self) -> i32 {
        self.retention_duration
    }
    /// <p>Whether this rule is enabled or not.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
/// See [`PitPolicyRule`](crate::model::PitPolicyRule).
pub mod pit_policy_rule {

    /// A builder for [`PitPolicyRule`](crate::model::PitPolicyRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_id: std::option::Option<i64>,
        pub(crate) units: std::option::Option<crate::model::PitPolicyRuleUnits>,
        pub(crate) interval: std::option::Option<i32>,
        pub(crate) retention_duration: std::option::Option<i32>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the rule.</p>
        pub fn rule_id(mut self, input: i64) -> Self {
            self.rule_id = Some(input);
            self
        }
        /// <p>The ID of the rule.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<i64>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The units used to measure the interval and retentionDuration.</p>
        pub fn units(mut self, input: crate::model::PitPolicyRuleUnits) -> Self {
            self.units = Some(input);
            self
        }
        /// <p>The units used to measure the interval and retentionDuration.</p>
        pub fn set_units(
            mut self,
            input: std::option::Option<crate::model::PitPolicyRuleUnits>,
        ) -> Self {
            self.units = input;
            self
        }
        /// <p>How often, in the chosen units, a snapshot should be taken.</p>
        pub fn interval(mut self, input: i32) -> Self {
            self.interval = Some(input);
            self
        }
        /// <p>How often, in the chosen units, a snapshot should be taken.</p>
        pub fn set_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.interval = input;
            self
        }
        /// <p>The duration to retain a snapshot for, in the chosen units.</p>
        pub fn retention_duration(mut self, input: i32) -> Self {
            self.retention_duration = Some(input);
            self
        }
        /// <p>The duration to retain a snapshot for, in the chosen units.</p>
        pub fn set_retention_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_duration = input;
            self
        }
        /// <p>Whether this rule is enabled or not.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Whether this rule is enabled or not.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`PitPolicyRule`](crate::model::PitPolicyRule).
        pub fn build(self) -> crate::model::PitPolicyRule {
            crate::model::PitPolicyRule {
                rule_id: self.rule_id.unwrap_or_default(),
                units: self.units,
                interval: self.interval.unwrap_or_default(),
                retention_duration: self.retention_duration.unwrap_or_default(),
                enabled: self.enabled,
            }
        }
    }
}
impl PitPolicyRule {
    /// Creates a new builder-style object to manufacture [`PitPolicyRule`](crate::model::PitPolicyRule).
    pub fn builder() -> crate::model::pit_policy_rule::Builder {
        crate::model::pit_policy_rule::Builder::default()
    }
}

/// When writing a match expression against `PitPolicyRuleUnits`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let pitpolicyruleunits = unimplemented!();
/// match pitpolicyruleunits {
///     PitPolicyRuleUnits::Day => { /* ... */ },
///     PitPolicyRuleUnits::Hour => { /* ... */ },
///     PitPolicyRuleUnits::Minute => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `pitpolicyruleunits` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PitPolicyRuleUnits::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PitPolicyRuleUnits::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PitPolicyRuleUnits::NewFeature` is defined.
/// Specifically, when `pitpolicyruleunits` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PitPolicyRuleUnits::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PitPolicyRuleUnits {
    #[allow(missing_docs)] // documentation missing in model
    Day,
    #[allow(missing_docs)] // documentation missing in model
    Hour,
    #[allow(missing_docs)] // documentation missing in model
    Minute,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PitPolicyRuleUnits {
    fn from(s: &str) -> Self {
        match s {
            "DAY" => PitPolicyRuleUnits::Day,
            "HOUR" => PitPolicyRuleUnits::Hour,
            "MINUTE" => PitPolicyRuleUnits::Minute,
            other => {
                PitPolicyRuleUnits::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PitPolicyRuleUnits {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PitPolicyRuleUnits::from(s))
    }
}
impl PitPolicyRuleUnits {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PitPolicyRuleUnits::Day => "DAY",
            PitPolicyRuleUnits::Hour => "HOUR",
            PitPolicyRuleUnits::Minute => "MINUTE",
            PitPolicyRuleUnits::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DAY", "HOUR", "MINUTE"]
    }
}
impl AsRef<str> for PitPolicyRuleUnits {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReplicationConfigurationDataPlaneRouting`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicationconfigurationdataplanerouting = unimplemented!();
/// match replicationconfigurationdataplanerouting {
///     ReplicationConfigurationDataPlaneRouting::PrivateIp => { /* ... */ },
///     ReplicationConfigurationDataPlaneRouting::PublicIp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicationconfigurationdataplanerouting` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicationConfigurationDataPlaneRouting::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicationConfigurationDataPlaneRouting::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicationConfigurationDataPlaneRouting::NewFeature` is defined.
/// Specifically, when `replicationconfigurationdataplanerouting` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicationConfigurationDataPlaneRouting::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicationConfigurationDataPlaneRouting {
    #[allow(missing_docs)] // documentation missing in model
    PrivateIp,
    #[allow(missing_docs)] // documentation missing in model
    PublicIp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicationConfigurationDataPlaneRouting {
    fn from(s: &str) -> Self {
        match s {
            "PRIVATE_IP" => ReplicationConfigurationDataPlaneRouting::PrivateIp,
            "PUBLIC_IP" => ReplicationConfigurationDataPlaneRouting::PublicIp,
            other => ReplicationConfigurationDataPlaneRouting::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReplicationConfigurationDataPlaneRouting {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicationConfigurationDataPlaneRouting::from(s))
    }
}
impl ReplicationConfigurationDataPlaneRouting {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicationConfigurationDataPlaneRouting::PrivateIp => "PRIVATE_IP",
            ReplicationConfigurationDataPlaneRouting::PublicIp => "PUBLIC_IP",
            ReplicationConfigurationDataPlaneRouting::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRIVATE_IP", "PUBLIC_IP"]
    }
}
impl AsRef<str> for ReplicationConfigurationDataPlaneRouting {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReplicationConfigurationEbsEncryption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicationconfigurationebsencryption = unimplemented!();
/// match replicationconfigurationebsencryption {
///     ReplicationConfigurationEbsEncryption::Custom => { /* ... */ },
///     ReplicationConfigurationEbsEncryption::Default => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicationconfigurationebsencryption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicationConfigurationEbsEncryption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicationConfigurationEbsEncryption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicationConfigurationEbsEncryption::NewFeature` is defined.
/// Specifically, when `replicationconfigurationebsencryption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicationConfigurationEbsEncryption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicationConfigurationEbsEncryption {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Default,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicationConfigurationEbsEncryption {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => ReplicationConfigurationEbsEncryption::Custom,
            "DEFAULT" => ReplicationConfigurationEbsEncryption::Default,
            other => ReplicationConfigurationEbsEncryption::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReplicationConfigurationEbsEncryption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicationConfigurationEbsEncryption::from(s))
    }
}
impl ReplicationConfigurationEbsEncryption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicationConfigurationEbsEncryption::Custom => "CUSTOM",
            ReplicationConfigurationEbsEncryption::Default => "DEFAULT",
            ReplicationConfigurationEbsEncryption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CUSTOM", "DEFAULT"]
    }
}
impl AsRef<str> for ReplicationConfigurationEbsEncryption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of a disk of the Source Server to be replicated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReplicationConfigurationReplicatedDisk {
    /// <p>The name of the device.</p>
    #[doc(hidden)]
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Whether to boot from this disk or not.</p>
    #[doc(hidden)]
    pub is_boot_disk: std::option::Option<bool>,
    /// <p>The Staging Disk EBS volume type to be used during replication.</p>
    #[doc(hidden)]
    pub staging_disk_type:
        std::option::Option<crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType>,
    /// <p>The requested number of I/O operations per second (IOPS).</p>
    #[doc(hidden)]
    pub iops: i64,
    /// <p>The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.</p>
    #[doc(hidden)]
    pub throughput: i64,
    /// <p>When <code>stagingDiskType</code> is set to Auto, this field shows the current staging disk EBS volume type as it is constantly updated by the service. This is a read-only field.</p>
    #[doc(hidden)]
    pub optimized_staging_disk_type:
        std::option::Option<crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType>,
}
impl ReplicationConfigurationReplicatedDisk {
    /// <p>The name of the device.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>Whether to boot from this disk or not.</p>
    pub fn is_boot_disk(&self) -> std::option::Option<bool> {
        self.is_boot_disk
    }
    /// <p>The Staging Disk EBS volume type to be used during replication.</p>
    pub fn staging_disk_type(
        &self,
    ) -> std::option::Option<&crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType>
    {
        self.staging_disk_type.as_ref()
    }
    /// <p>The requested number of I/O operations per second (IOPS).</p>
    pub fn iops(&self) -> i64 {
        self.iops
    }
    /// <p>The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.</p>
    pub fn throughput(&self) -> i64 {
        self.throughput
    }
    /// <p>When <code>stagingDiskType</code> is set to Auto, this field shows the current staging disk EBS volume type as it is constantly updated by the service. This is a read-only field.</p>
    pub fn optimized_staging_disk_type(
        &self,
    ) -> std::option::Option<&crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType>
    {
        self.optimized_staging_disk_type.as_ref()
    }
}
/// See [`ReplicationConfigurationReplicatedDisk`](crate::model::ReplicationConfigurationReplicatedDisk).
pub mod replication_configuration_replicated_disk {

    /// A builder for [`ReplicationConfigurationReplicatedDisk`](crate::model::ReplicationConfigurationReplicatedDisk).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) is_boot_disk: std::option::Option<bool>,
        pub(crate) staging_disk_type: std::option::Option<
            crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType,
        >,
        pub(crate) iops: std::option::Option<i64>,
        pub(crate) throughput: std::option::Option<i64>,
        pub(crate) optimized_staging_disk_type: std::option::Option<
            crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType,
        >,
    }
    impl Builder {
        /// <p>The name of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The name of the device.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Whether to boot from this disk or not.</p>
        pub fn is_boot_disk(mut self, input: bool) -> Self {
            self.is_boot_disk = Some(input);
            self
        }
        /// <p>Whether to boot from this disk or not.</p>
        pub fn set_is_boot_disk(mut self, input: std::option::Option<bool>) -> Self {
            self.is_boot_disk = input;
            self
        }
        /// <p>The Staging Disk EBS volume type to be used during replication.</p>
        pub fn staging_disk_type(
            mut self,
            input: crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType,
        ) -> Self {
            self.staging_disk_type = Some(input);
            self
        }
        /// <p>The Staging Disk EBS volume type to be used during replication.</p>
        pub fn set_staging_disk_type(
            mut self,
            input: std::option::Option<
                crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType,
            >,
        ) -> Self {
            self.staging_disk_type = input;
            self
        }
        /// <p>The requested number of I/O operations per second (IOPS).</p>
        pub fn iops(mut self, input: i64) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>The requested number of I/O operations per second (IOPS).</p>
        pub fn set_iops(mut self, input: std::option::Option<i64>) -> Self {
            self.iops = input;
            self
        }
        /// <p>The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.</p>
        pub fn throughput(mut self, input: i64) -> Self {
            self.throughput = Some(input);
            self
        }
        /// <p>The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.</p>
        pub fn set_throughput(mut self, input: std::option::Option<i64>) -> Self {
            self.throughput = input;
            self
        }
        /// <p>When <code>stagingDiskType</code> is set to Auto, this field shows the current staging disk EBS volume type as it is constantly updated by the service. This is a read-only field.</p>
        pub fn optimized_staging_disk_type(
            mut self,
            input: crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType,
        ) -> Self {
            self.optimized_staging_disk_type = Some(input);
            self
        }
        /// <p>When <code>stagingDiskType</code> is set to Auto, this field shows the current staging disk EBS volume type as it is constantly updated by the service. This is a read-only field.</p>
        pub fn set_optimized_staging_disk_type(
            mut self,
            input: std::option::Option<
                crate::model::ReplicationConfigurationReplicatedDiskStagingDiskType,
            >,
        ) -> Self {
            self.optimized_staging_disk_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationConfigurationReplicatedDisk`](crate::model::ReplicationConfigurationReplicatedDisk).
        pub fn build(self) -> crate::model::ReplicationConfigurationReplicatedDisk {
            crate::model::ReplicationConfigurationReplicatedDisk {
                device_name: self.device_name,
                is_boot_disk: self.is_boot_disk,
                staging_disk_type: self.staging_disk_type,
                iops: self.iops.unwrap_or_default(),
                throughput: self.throughput.unwrap_or_default(),
                optimized_staging_disk_type: self.optimized_staging_disk_type,
            }
        }
    }
}
impl ReplicationConfigurationReplicatedDisk {
    /// Creates a new builder-style object to manufacture [`ReplicationConfigurationReplicatedDisk`](crate::model::ReplicationConfigurationReplicatedDisk).
    pub fn builder() -> crate::model::replication_configuration_replicated_disk::Builder {
        crate::model::replication_configuration_replicated_disk::Builder::default()
    }
}

/// When writing a match expression against `ReplicationConfigurationReplicatedDiskStagingDiskType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicationconfigurationreplicateddiskstagingdisktype = unimplemented!();
/// match replicationconfigurationreplicateddiskstagingdisktype {
///     ReplicationConfigurationReplicatedDiskStagingDiskType::Auto => { /* ... */ },
///     ReplicationConfigurationReplicatedDiskStagingDiskType::Gp2 => { /* ... */ },
///     ReplicationConfigurationReplicatedDiskStagingDiskType::Gp3 => { /* ... */ },
///     ReplicationConfigurationReplicatedDiskStagingDiskType::Io1 => { /* ... */ },
///     ReplicationConfigurationReplicatedDiskStagingDiskType::Sc1 => { /* ... */ },
///     ReplicationConfigurationReplicatedDiskStagingDiskType::St1 => { /* ... */ },
///     ReplicationConfigurationReplicatedDiskStagingDiskType::Standard => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicationconfigurationreplicateddiskstagingdisktype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicationConfigurationReplicatedDiskStagingDiskType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicationConfigurationReplicatedDiskStagingDiskType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicationConfigurationReplicatedDiskStagingDiskType::NewFeature` is defined.
/// Specifically, when `replicationconfigurationreplicateddiskstagingdisktype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicationConfigurationReplicatedDiskStagingDiskType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicationConfigurationReplicatedDiskStagingDiskType {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Gp2,
    #[allow(missing_docs)] // documentation missing in model
    Gp3,
    #[allow(missing_docs)] // documentation missing in model
    Io1,
    #[allow(missing_docs)] // documentation missing in model
    Sc1,
    #[allow(missing_docs)] // documentation missing in model
    St1,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicationConfigurationReplicatedDiskStagingDiskType {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => ReplicationConfigurationReplicatedDiskStagingDiskType::Auto,
            "GP2" => ReplicationConfigurationReplicatedDiskStagingDiskType::Gp2,
            "GP3" => ReplicationConfigurationReplicatedDiskStagingDiskType::Gp3,
            "IO1" => ReplicationConfigurationReplicatedDiskStagingDiskType::Io1,
            "SC1" => ReplicationConfigurationReplicatedDiskStagingDiskType::Sc1,
            "ST1" => ReplicationConfigurationReplicatedDiskStagingDiskType::St1,
            "STANDARD" => ReplicationConfigurationReplicatedDiskStagingDiskType::Standard,
            other => ReplicationConfigurationReplicatedDiskStagingDiskType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReplicationConfigurationReplicatedDiskStagingDiskType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicationConfigurationReplicatedDiskStagingDiskType::from(
            s,
        ))
    }
}
impl ReplicationConfigurationReplicatedDiskStagingDiskType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicationConfigurationReplicatedDiskStagingDiskType::Auto => "AUTO",
            ReplicationConfigurationReplicatedDiskStagingDiskType::Gp2 => "GP2",
            ReplicationConfigurationReplicatedDiskStagingDiskType::Gp3 => "GP3",
            ReplicationConfigurationReplicatedDiskStagingDiskType::Io1 => "IO1",
            ReplicationConfigurationReplicatedDiskStagingDiskType::Sc1 => "SC1",
            ReplicationConfigurationReplicatedDiskStagingDiskType::St1 => "ST1",
            ReplicationConfigurationReplicatedDiskStagingDiskType::Standard => "STANDARD",
            ReplicationConfigurationReplicatedDiskStagingDiskType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTO", "GP2", "GP3", "IO1", "SC1", "ST1", "STANDARD"]
    }
}
impl AsRef<str> for ReplicationConfigurationReplicatedDiskStagingDiskType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ReplicationConfigurationDefaultLargeStagingDiskType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicationconfigurationdefaultlargestagingdisktype = unimplemented!();
/// match replicationconfigurationdefaultlargestagingdisktype {
///     ReplicationConfigurationDefaultLargeStagingDiskType::Auto => { /* ... */ },
///     ReplicationConfigurationDefaultLargeStagingDiskType::Gp2 => { /* ... */ },
///     ReplicationConfigurationDefaultLargeStagingDiskType::Gp3 => { /* ... */ },
///     ReplicationConfigurationDefaultLargeStagingDiskType::St1 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicationconfigurationdefaultlargestagingdisktype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicationConfigurationDefaultLargeStagingDiskType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicationConfigurationDefaultLargeStagingDiskType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicationConfigurationDefaultLargeStagingDiskType::NewFeature` is defined.
/// Specifically, when `replicationconfigurationdefaultlargestagingdisktype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicationConfigurationDefaultLargeStagingDiskType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicationConfigurationDefaultLargeStagingDiskType {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Gp2,
    #[allow(missing_docs)] // documentation missing in model
    Gp3,
    #[allow(missing_docs)] // documentation missing in model
    St1,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicationConfigurationDefaultLargeStagingDiskType {
    fn from(s: &str) -> Self {
        match s {
            "AUTO" => ReplicationConfigurationDefaultLargeStagingDiskType::Auto,
            "GP2" => ReplicationConfigurationDefaultLargeStagingDiskType::Gp2,
            "GP3" => ReplicationConfigurationDefaultLargeStagingDiskType::Gp3,
            "ST1" => ReplicationConfigurationDefaultLargeStagingDiskType::St1,
            other => ReplicationConfigurationDefaultLargeStagingDiskType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for ReplicationConfigurationDefaultLargeStagingDiskType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicationConfigurationDefaultLargeStagingDiskType::from(s))
    }
}
impl ReplicationConfigurationDefaultLargeStagingDiskType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicationConfigurationDefaultLargeStagingDiskType::Auto => "AUTO",
            ReplicationConfigurationDefaultLargeStagingDiskType::Gp2 => "GP2",
            ReplicationConfigurationDefaultLargeStagingDiskType::Gp3 => "GP3",
            ReplicationConfigurationDefaultLargeStagingDiskType::St1 => "ST1",
            ReplicationConfigurationDefaultLargeStagingDiskType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTO", "GP2", "GP3", "ST1"]
    }
}
impl AsRef<str> for ReplicationConfigurationDefaultLargeStagingDiskType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration of a machine's license.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Licensing {
    /// <p>Whether to enable "Bring your own license" or not.</p>
    #[doc(hidden)]
    pub os_byol: std::option::Option<bool>,
}
impl Licensing {
    /// <p>Whether to enable "Bring your own license" or not.</p>
    pub fn os_byol(&self) -> std::option::Option<bool> {
        self.os_byol
    }
}
/// See [`Licensing`](crate::model::Licensing).
pub mod licensing {

    /// A builder for [`Licensing`](crate::model::Licensing).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) os_byol: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Whether to enable "Bring your own license" or not.</p>
        pub fn os_byol(mut self, input: bool) -> Self {
            self.os_byol = Some(input);
            self
        }
        /// <p>Whether to enable "Bring your own license" or not.</p>
        pub fn set_os_byol(mut self, input: std::option::Option<bool>) -> Self {
            self.os_byol = input;
            self
        }
        /// Consumes the builder and constructs a [`Licensing`](crate::model::Licensing).
        pub fn build(self) -> crate::model::Licensing {
            crate::model::Licensing {
                os_byol: self.os_byol,
            }
        }
    }
}
impl Licensing {
    /// Creates a new builder-style object to manufacture [`Licensing`](crate::model::Licensing).
    pub fn builder() -> crate::model::licensing::Builder {
        crate::model::licensing::Builder::default()
    }
}

/// When writing a match expression against `TargetInstanceTypeRightSizingMethod`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetinstancetyperightsizingmethod = unimplemented!();
/// match targetinstancetyperightsizingmethod {
///     TargetInstanceTypeRightSizingMethod::Basic => { /* ... */ },
///     TargetInstanceTypeRightSizingMethod::None => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetinstancetyperightsizingmethod` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetInstanceTypeRightSizingMethod::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetInstanceTypeRightSizingMethod::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetInstanceTypeRightSizingMethod::NewFeature` is defined.
/// Specifically, when `targetinstancetyperightsizingmethod` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetInstanceTypeRightSizingMethod::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetInstanceTypeRightSizingMethod {
    #[allow(missing_docs)] // documentation missing in model
    Basic,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetInstanceTypeRightSizingMethod {
    fn from(s: &str) -> Self {
        match s {
            "BASIC" => TargetInstanceTypeRightSizingMethod::Basic,
            "NONE" => TargetInstanceTypeRightSizingMethod::None,
            other => TargetInstanceTypeRightSizingMethod::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for TargetInstanceTypeRightSizingMethod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetInstanceTypeRightSizingMethod::from(s))
    }
}
impl TargetInstanceTypeRightSizingMethod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetInstanceTypeRightSizingMethod::Basic => "BASIC",
            TargetInstanceTypeRightSizingMethod::None => "NONE",
            TargetInstanceTypeRightSizingMethod::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BASIC", "NONE"]
    }
}
impl AsRef<str> for TargetInstanceTypeRightSizingMethod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchDisposition`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchdisposition = unimplemented!();
/// match launchdisposition {
///     LaunchDisposition::Started => { /* ... */ },
///     LaunchDisposition::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchdisposition` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchDisposition::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchDisposition::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchDisposition::NewFeature` is defined.
/// Specifically, when `launchdisposition` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchDisposition::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchDisposition {
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchDisposition {
    fn from(s: &str) -> Self {
        match s {
            "STARTED" => LaunchDisposition::Started,
            "STOPPED" => LaunchDisposition::Stopped,
            other => {
                LaunchDisposition::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LaunchDisposition {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchDisposition::from(s))
    }
}
impl LaunchDisposition {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchDisposition::Started => "STARTED",
            LaunchDisposition::Stopped => "STOPPED",
            LaunchDisposition::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["STARTED", "STOPPED"]
    }
}
impl AsRef<str> for LaunchDisposition {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceServer {
    /// <p>The ID of the Source Server.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the Source Server.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The tags associated with the Source Server.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The ID of the Recovery Instance associated with this Source Server.</p>
    #[doc(hidden)]
    pub recovery_instance_id: std::option::Option<std::string::String>,
    /// <p>The status of the last recovery launch of this Source Server.</p>
    #[doc(hidden)]
    pub last_launch_result: std::option::Option<crate::model::LastLaunchResult>,
    /// <p>The Data Replication Info of the Source Server.</p>
    #[doc(hidden)]
    pub data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
    /// <p>The lifecycle information of this Source Server.</p>
    #[doc(hidden)]
    pub life_cycle: std::option::Option<crate::model::LifeCycle>,
    /// <p>The source properties of the Source Server.</p>
    #[doc(hidden)]
    pub source_properties: std::option::Option<crate::model::SourceProperties>,
    /// <p>The staging area of the source server.</p>
    #[doc(hidden)]
    pub staging_area: std::option::Option<crate::model::StagingArea>,
    /// <p>Source cloud properties of the Source Server.</p>
    #[doc(hidden)]
    pub source_cloud_properties: std::option::Option<crate::model::SourceCloudProperties>,
    /// <p>Replication direction of the Source Server.</p>
    #[doc(hidden)]
    pub replication_direction: std::option::Option<crate::model::ReplicationDirection>,
    /// <p>For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.</p>
    #[doc(hidden)]
    pub reversed_direction_source_server_arn: std::option::Option<std::string::String>,
}
impl SourceServer {
    /// <p>The ID of the Source Server.</p>
    pub fn source_server_id(&self) -> std::option::Option<&str> {
        self.source_server_id.as_deref()
    }
    /// <p>The ARN of the Source Server.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The tags associated with the Source Server.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The ID of the Recovery Instance associated with this Source Server.</p>
    pub fn recovery_instance_id(&self) -> std::option::Option<&str> {
        self.recovery_instance_id.as_deref()
    }
    /// <p>The status of the last recovery launch of this Source Server.</p>
    pub fn last_launch_result(&self) -> std::option::Option<&crate::model::LastLaunchResult> {
        self.last_launch_result.as_ref()
    }
    /// <p>The Data Replication Info of the Source Server.</p>
    pub fn data_replication_info(&self) -> std::option::Option<&crate::model::DataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>The lifecycle information of this Source Server.</p>
    pub fn life_cycle(&self) -> std::option::Option<&crate::model::LifeCycle> {
        self.life_cycle.as_ref()
    }
    /// <p>The source properties of the Source Server.</p>
    pub fn source_properties(&self) -> std::option::Option<&crate::model::SourceProperties> {
        self.source_properties.as_ref()
    }
    /// <p>The staging area of the source server.</p>
    pub fn staging_area(&self) -> std::option::Option<&crate::model::StagingArea> {
        self.staging_area.as_ref()
    }
    /// <p>Source cloud properties of the Source Server.</p>
    pub fn source_cloud_properties(
        &self,
    ) -> std::option::Option<&crate::model::SourceCloudProperties> {
        self.source_cloud_properties.as_ref()
    }
    /// <p>Replication direction of the Source Server.</p>
    pub fn replication_direction(
        &self,
    ) -> std::option::Option<&crate::model::ReplicationDirection> {
        self.replication_direction.as_ref()
    }
    /// <p>For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.</p>
    pub fn reversed_direction_source_server_arn(&self) -> std::option::Option<&str> {
        self.reversed_direction_source_server_arn.as_deref()
    }
}
impl std::fmt::Debug for SourceServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceServer");
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("recovery_instance_id", &self.recovery_instance_id);
        formatter.field("last_launch_result", &self.last_launch_result);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field("life_cycle", &self.life_cycle);
        formatter.field("source_properties", &self.source_properties);
        formatter.field("staging_area", &self.staging_area);
        formatter.field("source_cloud_properties", &self.source_cloud_properties);
        formatter.field("replication_direction", &self.replication_direction);
        formatter.field(
            "reversed_direction_source_server_arn",
            &self.reversed_direction_source_server_arn,
        );
        formatter.finish()
    }
}
/// See [`SourceServer`](crate::model::SourceServer).
pub mod source_server {

    /// A builder for [`SourceServer`](crate::model::SourceServer).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) recovery_instance_id: std::option::Option<std::string::String>,
        pub(crate) last_launch_result: std::option::Option<crate::model::LastLaunchResult>,
        pub(crate) data_replication_info: std::option::Option<crate::model::DataReplicationInfo>,
        pub(crate) life_cycle: std::option::Option<crate::model::LifeCycle>,
        pub(crate) source_properties: std::option::Option<crate::model::SourceProperties>,
        pub(crate) staging_area: std::option::Option<crate::model::StagingArea>,
        pub(crate) source_cloud_properties:
            std::option::Option<crate::model::SourceCloudProperties>,
        pub(crate) replication_direction: std::option::Option<crate::model::ReplicationDirection>,
        pub(crate) reversed_direction_source_server_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Source Server.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>The ID of the Source Server.</p>
        pub fn set_source_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_server_id = input;
            self
        }
        /// <p>The ARN of the Source Server.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Source Server.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the Source Server.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags associated with the Source Server.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ID of the Recovery Instance associated with this Source Server.</p>
        pub fn recovery_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_instance_id = Some(input.into());
            self
        }
        /// <p>The ID of the Recovery Instance associated with this Source Server.</p>
        pub fn set_recovery_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_instance_id = input;
            self
        }
        /// <p>The status of the last recovery launch of this Source Server.</p>
        pub fn last_launch_result(mut self, input: crate::model::LastLaunchResult) -> Self {
            self.last_launch_result = Some(input);
            self
        }
        /// <p>The status of the last recovery launch of this Source Server.</p>
        pub fn set_last_launch_result(
            mut self,
            input: std::option::Option<crate::model::LastLaunchResult>,
        ) -> Self {
            self.last_launch_result = input;
            self
        }
        /// <p>The Data Replication Info of the Source Server.</p>
        pub fn data_replication_info(mut self, input: crate::model::DataReplicationInfo) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>The Data Replication Info of the Source Server.</p>
        pub fn set_data_replication_info(
            mut self,
            input: std::option::Option<crate::model::DataReplicationInfo>,
        ) -> Self {
            self.data_replication_info = input;
            self
        }
        /// <p>The lifecycle information of this Source Server.</p>
        pub fn life_cycle(mut self, input: crate::model::LifeCycle) -> Self {
            self.life_cycle = Some(input);
            self
        }
        /// <p>The lifecycle information of this Source Server.</p>
        pub fn set_life_cycle(
            mut self,
            input: std::option::Option<crate::model::LifeCycle>,
        ) -> Self {
            self.life_cycle = input;
            self
        }
        /// <p>The source properties of the Source Server.</p>
        pub fn source_properties(mut self, input: crate::model::SourceProperties) -> Self {
            self.source_properties = Some(input);
            self
        }
        /// <p>The source properties of the Source Server.</p>
        pub fn set_source_properties(
            mut self,
            input: std::option::Option<crate::model::SourceProperties>,
        ) -> Self {
            self.source_properties = input;
            self
        }
        /// <p>The staging area of the source server.</p>
        pub fn staging_area(mut self, input: crate::model::StagingArea) -> Self {
            self.staging_area = Some(input);
            self
        }
        /// <p>The staging area of the source server.</p>
        pub fn set_staging_area(
            mut self,
            input: std::option::Option<crate::model::StagingArea>,
        ) -> Self {
            self.staging_area = input;
            self
        }
        /// <p>Source cloud properties of the Source Server.</p>
        pub fn source_cloud_properties(
            mut self,
            input: crate::model::SourceCloudProperties,
        ) -> Self {
            self.source_cloud_properties = Some(input);
            self
        }
        /// <p>Source cloud properties of the Source Server.</p>
        pub fn set_source_cloud_properties(
            mut self,
            input: std::option::Option<crate::model::SourceCloudProperties>,
        ) -> Self {
            self.source_cloud_properties = input;
            self
        }
        /// <p>Replication direction of the Source Server.</p>
        pub fn replication_direction(mut self, input: crate::model::ReplicationDirection) -> Self {
            self.replication_direction = Some(input);
            self
        }
        /// <p>Replication direction of the Source Server.</p>
        pub fn set_replication_direction(
            mut self,
            input: std::option::Option<crate::model::ReplicationDirection>,
        ) -> Self {
            self.replication_direction = input;
            self
        }
        /// <p>For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.</p>
        pub fn reversed_direction_source_server_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reversed_direction_source_server_arn = Some(input.into());
            self
        }
        /// <p>For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.</p>
        pub fn set_reversed_direction_source_server_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reversed_direction_source_server_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceServer`](crate::model::SourceServer).
        pub fn build(self) -> crate::model::SourceServer {
            crate::model::SourceServer {
                source_server_id: self.source_server_id,
                arn: self.arn,
                tags: self.tags,
                recovery_instance_id: self.recovery_instance_id,
                last_launch_result: self.last_launch_result,
                data_replication_info: self.data_replication_info,
                life_cycle: self.life_cycle,
                source_properties: self.source_properties,
                staging_area: self.staging_area,
                source_cloud_properties: self.source_cloud_properties,
                replication_direction: self.replication_direction,
                reversed_direction_source_server_arn: self.reversed_direction_source_server_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("recovery_instance_id", &self.recovery_instance_id);
            formatter.field("last_launch_result", &self.last_launch_result);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field("life_cycle", &self.life_cycle);
            formatter.field("source_properties", &self.source_properties);
            formatter.field("staging_area", &self.staging_area);
            formatter.field("source_cloud_properties", &self.source_cloud_properties);
            formatter.field("replication_direction", &self.replication_direction);
            formatter.field(
                "reversed_direction_source_server_arn",
                &self.reversed_direction_source_server_arn,
            );
            formatter.finish()
        }
    }
}
impl SourceServer {
    /// Creates a new builder-style object to manufacture [`SourceServer`](crate::model::SourceServer).
    pub fn builder() -> crate::model::source_server::Builder {
        crate::model::source_server::Builder::default()
    }
}

/// When writing a match expression against `ReplicationDirection`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replicationdirection = unimplemented!();
/// match replicationdirection {
///     ReplicationDirection::Failback => { /* ... */ },
///     ReplicationDirection::Failover => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replicationdirection` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReplicationDirection::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReplicationDirection::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReplicationDirection::NewFeature` is defined.
/// Specifically, when `replicationdirection` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReplicationDirection::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Replication direction designates if this is a failover replication, or a failback replication. When a DRS agent is installed on an instance, the replication direction is failover. In cases where a recovery launch was made in the recovery location and a new recovery instance was created, and then a failback replication was initiated from that recovery instance back to the origin location, then the replication direction will be failback.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicationDirection {
    #[allow(missing_docs)] // documentation missing in model
    Failback,
    #[allow(missing_docs)] // documentation missing in model
    Failover,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReplicationDirection {
    fn from(s: &str) -> Self {
        match s {
            "FAILBACK" => ReplicationDirection::Failback,
            "FAILOVER" => ReplicationDirection::Failover,
            other => {
                ReplicationDirection::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ReplicationDirection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReplicationDirection::from(s))
    }
}
impl ReplicationDirection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReplicationDirection::Failback => "FAILBACK",
            ReplicationDirection::Failover => "FAILOVER",
            ReplicationDirection::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILBACK", "FAILOVER"]
    }
}
impl AsRef<str> for ReplicationDirection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Properties of the cloud environment where this Source Server originated from.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceCloudProperties {
    /// <p>AWS Account ID for an EC2-originated Source Server.</p>
    #[doc(hidden)]
    pub origin_account_id: std::option::Option<std::string::String>,
    /// <p>AWS Region for an EC2-originated Source Server.</p>
    #[doc(hidden)]
    pub origin_region: std::option::Option<std::string::String>,
    /// <p>AWS Availability Zone for an EC2-originated Source Server.</p>
    #[doc(hidden)]
    pub origin_availability_zone: std::option::Option<std::string::String>,
}
impl SourceCloudProperties {
    /// <p>AWS Account ID for an EC2-originated Source Server.</p>
    pub fn origin_account_id(&self) -> std::option::Option<&str> {
        self.origin_account_id.as_deref()
    }
    /// <p>AWS Region for an EC2-originated Source Server.</p>
    pub fn origin_region(&self) -> std::option::Option<&str> {
        self.origin_region.as_deref()
    }
    /// <p>AWS Availability Zone for an EC2-originated Source Server.</p>
    pub fn origin_availability_zone(&self) -> std::option::Option<&str> {
        self.origin_availability_zone.as_deref()
    }
}
/// See [`SourceCloudProperties`](crate::model::SourceCloudProperties).
pub mod source_cloud_properties {

    /// A builder for [`SourceCloudProperties`](crate::model::SourceCloudProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) origin_account_id: std::option::Option<std::string::String>,
        pub(crate) origin_region: std::option::Option<std::string::String>,
        pub(crate) origin_availability_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>AWS Account ID for an EC2-originated Source Server.</p>
        pub fn origin_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin_account_id = Some(input.into());
            self
        }
        /// <p>AWS Account ID for an EC2-originated Source Server.</p>
        pub fn set_origin_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origin_account_id = input;
            self
        }
        /// <p>AWS Region for an EC2-originated Source Server.</p>
        pub fn origin_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin_region = Some(input.into());
            self
        }
        /// <p>AWS Region for an EC2-originated Source Server.</p>
        pub fn set_origin_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origin_region = input;
            self
        }
        /// <p>AWS Availability Zone for an EC2-originated Source Server.</p>
        pub fn origin_availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.origin_availability_zone = Some(input.into());
            self
        }
        /// <p>AWS Availability Zone for an EC2-originated Source Server.</p>
        pub fn set_origin_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origin_availability_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceCloudProperties`](crate::model::SourceCloudProperties).
        pub fn build(self) -> crate::model::SourceCloudProperties {
            crate::model::SourceCloudProperties {
                origin_account_id: self.origin_account_id,
                origin_region: self.origin_region,
                origin_availability_zone: self.origin_availability_zone,
            }
        }
    }
}
impl SourceCloudProperties {
    /// Creates a new builder-style object to manufacture [`SourceCloudProperties`](crate::model::SourceCloudProperties).
    pub fn builder() -> crate::model::source_cloud_properties::Builder {
        crate::model::source_cloud_properties::Builder::default()
    }
}

/// <p>Staging information related to source server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StagingArea {
    /// <p>Status of Source server extension. Possible values: (a) NOT_EXTENDED - This is a source server that is replicating in the current account. (b) EXTENDED - Source server is extended from a staging source server. In this case, the value of stagingSourceServerArn is pointing to the Arn of the source server in the staging account. (c) EXTENSION_ERROR - Some issue occurred when accessing staging source server. In this case, errorMessage field will contain an error message that explains what happened.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ExtensionStatus>,
    /// <p>Account ID of the account to which source server belongs. If this source server is extended - shows Account ID of staging source server.</p>
    #[doc(hidden)]
    pub staging_account_id: std::option::Option<std::string::String>,
    /// <p>Arn of the staging source server if this source server is extended</p>
    #[doc(hidden)]
    pub staging_source_server_arn: std::option::Option<std::string::String>,
    /// <p>Shows an error message that occurred when DRS tried to access the staging source server. In this case StagingArea$status will have value EXTENSION_ERROR</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl StagingArea {
    /// <p>Status of Source server extension. Possible values: (a) NOT_EXTENDED - This is a source server that is replicating in the current account. (b) EXTENDED - Source server is extended from a staging source server. In this case, the value of stagingSourceServerArn is pointing to the Arn of the source server in the staging account. (c) EXTENSION_ERROR - Some issue occurred when accessing staging source server. In this case, errorMessage field will contain an error message that explains what happened.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ExtensionStatus> {
        self.status.as_ref()
    }
    /// <p>Account ID of the account to which source server belongs. If this source server is extended - shows Account ID of staging source server.</p>
    pub fn staging_account_id(&self) -> std::option::Option<&str> {
        self.staging_account_id.as_deref()
    }
    /// <p>Arn of the staging source server if this source server is extended</p>
    pub fn staging_source_server_arn(&self) -> std::option::Option<&str> {
        self.staging_source_server_arn.as_deref()
    }
    /// <p>Shows an error message that occurred when DRS tried to access the staging source server. In this case StagingArea$status will have value EXTENSION_ERROR</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`StagingArea`](crate::model::StagingArea).
pub mod staging_area {

    /// A builder for [`StagingArea`](crate::model::StagingArea).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ExtensionStatus>,
        pub(crate) staging_account_id: std::option::Option<std::string::String>,
        pub(crate) staging_source_server_arn: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Status of Source server extension. Possible values: (a) NOT_EXTENDED - This is a source server that is replicating in the current account. (b) EXTENDED - Source server is extended from a staging source server. In this case, the value of stagingSourceServerArn is pointing to the Arn of the source server in the staging account. (c) EXTENSION_ERROR - Some issue occurred when accessing staging source server. In this case, errorMessage field will contain an error message that explains what happened.</p>
        pub fn status(mut self, input: crate::model::ExtensionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of Source server extension. Possible values: (a) NOT_EXTENDED - This is a source server that is replicating in the current account. (b) EXTENDED - Source server is extended from a staging source server. In this case, the value of stagingSourceServerArn is pointing to the Arn of the source server in the staging account. (c) EXTENSION_ERROR - Some issue occurred when accessing staging source server. In this case, errorMessage field will contain an error message that explains what happened.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ExtensionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Account ID of the account to which source server belongs. If this source server is extended - shows Account ID of staging source server.</p>
        pub fn staging_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_account_id = Some(input.into());
            self
        }
        /// <p>Account ID of the account to which source server belongs. If this source server is extended - shows Account ID of staging source server.</p>
        pub fn set_staging_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.staging_account_id = input;
            self
        }
        /// <p>Arn of the staging source server if this source server is extended</p>
        pub fn staging_source_server_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_source_server_arn = Some(input.into());
            self
        }
        /// <p>Arn of the staging source server if this source server is extended</p>
        pub fn set_staging_source_server_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.staging_source_server_arn = input;
            self
        }
        /// <p>Shows an error message that occurred when DRS tried to access the staging source server. In this case StagingArea$status will have value EXTENSION_ERROR</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>Shows an error message that occurred when DRS tried to access the staging source server. In this case StagingArea$status will have value EXTENSION_ERROR</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`StagingArea`](crate::model::StagingArea).
        pub fn build(self) -> crate::model::StagingArea {
            crate::model::StagingArea {
                status: self.status,
                staging_account_id: self.staging_account_id,
                staging_source_server_arn: self.staging_source_server_arn,
                error_message: self.error_message,
            }
        }
    }
}
impl StagingArea {
    /// Creates a new builder-style object to manufacture [`StagingArea`](crate::model::StagingArea).
    pub fn builder() -> crate::model::staging_area::Builder {
        crate::model::staging_area::Builder::default()
    }
}

/// When writing a match expression against `ExtensionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let extensionstatus = unimplemented!();
/// match extensionstatus {
///     ExtensionStatus::Extended => { /* ... */ },
///     ExtensionStatus::ExtensionError => { /* ... */ },
///     ExtensionStatus::NotExtended => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `extensionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExtensionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExtensionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExtensionStatus::NewFeature` is defined.
/// Specifically, when `extensionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExtensionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExtensionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Extended,
    #[allow(missing_docs)] // documentation missing in model
    ExtensionError,
    #[allow(missing_docs)] // documentation missing in model
    NotExtended,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExtensionStatus {
    fn from(s: &str) -> Self {
        match s {
            "EXTENDED" => ExtensionStatus::Extended,
            "EXTENSION_ERROR" => ExtensionStatus::ExtensionError,
            "NOT_EXTENDED" => ExtensionStatus::NotExtended,
            other => ExtensionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExtensionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExtensionStatus::from(s))
    }
}
impl ExtensionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExtensionStatus::Extended => "EXTENDED",
            ExtensionStatus::ExtensionError => "EXTENSION_ERROR",
            ExtensionStatus::NotExtended => "NOT_EXTENDED",
            ExtensionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXTENDED", "EXTENSION_ERROR", "NOT_EXTENDED"]
    }
}
impl AsRef<str> for ExtensionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Properties of the Source Server machine.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceProperties {
    /// <p>The date and time the Source Properties were last updated on.</p>
    #[doc(hidden)]
    pub last_updated_date_time: std::option::Option<std::string::String>,
    /// <p>The recommended EC2 instance type that will be used when recovering the Source Server.</p>
    #[doc(hidden)]
    pub recommended_instance_type: std::option::Option<std::string::String>,
    /// <p>Hints used to uniquely identify a machine.</p>
    #[doc(hidden)]
    pub identification_hints: std::option::Option<crate::model::IdentificationHints>,
    /// <p>An array of network interfaces.</p>
    #[doc(hidden)]
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    /// <p>An array of disks.</p>
    #[doc(hidden)]
    pub disks: std::option::Option<std::vec::Vec<crate::model::Disk>>,
    /// <p>An array of CPUs.</p>
    #[doc(hidden)]
    pub cpus: std::option::Option<std::vec::Vec<crate::model::Cpu>>,
    /// <p>The amount of RAM in bytes.</p>
    #[doc(hidden)]
    pub ram_bytes: i64,
    /// <p>Operating system.</p>
    #[doc(hidden)]
    pub os: std::option::Option<crate::model::Os>,
}
impl SourceProperties {
    /// <p>The date and time the Source Properties were last updated on.</p>
    pub fn last_updated_date_time(&self) -> std::option::Option<&str> {
        self.last_updated_date_time.as_deref()
    }
    /// <p>The recommended EC2 instance type that will be used when recovering the Source Server.</p>
    pub fn recommended_instance_type(&self) -> std::option::Option<&str> {
        self.recommended_instance_type.as_deref()
    }
    /// <p>Hints used to uniquely identify a machine.</p>
    pub fn identification_hints(&self) -> std::option::Option<&crate::model::IdentificationHints> {
        self.identification_hints.as_ref()
    }
    /// <p>An array of network interfaces.</p>
    pub fn network_interfaces(&self) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces.as_deref()
    }
    /// <p>An array of disks.</p>
    pub fn disks(&self) -> std::option::Option<&[crate::model::Disk]> {
        self.disks.as_deref()
    }
    /// <p>An array of CPUs.</p>
    pub fn cpus(&self) -> std::option::Option<&[crate::model::Cpu]> {
        self.cpus.as_deref()
    }
    /// <p>The amount of RAM in bytes.</p>
    pub fn ram_bytes(&self) -> i64 {
        self.ram_bytes
    }
    /// <p>Operating system.</p>
    pub fn os(&self) -> std::option::Option<&crate::model::Os> {
        self.os.as_ref()
    }
}
/// See [`SourceProperties`](crate::model::SourceProperties).
pub mod source_properties {

    /// A builder for [`SourceProperties`](crate::model::SourceProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_updated_date_time: std::option::Option<std::string::String>,
        pub(crate) recommended_instance_type: std::option::Option<std::string::String>,
        pub(crate) identification_hints: std::option::Option<crate::model::IdentificationHints>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        pub(crate) disks: std::option::Option<std::vec::Vec<crate::model::Disk>>,
        pub(crate) cpus: std::option::Option<std::vec::Vec<crate::model::Cpu>>,
        pub(crate) ram_bytes: std::option::Option<i64>,
        pub(crate) os: std::option::Option<crate::model::Os>,
    }
    impl Builder {
        /// <p>The date and time the Source Properties were last updated on.</p>
        pub fn last_updated_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_date_time = Some(input.into());
            self
        }
        /// <p>The date and time the Source Properties were last updated on.</p>
        pub fn set_last_updated_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_date_time = input;
            self
        }
        /// <p>The recommended EC2 instance type that will be used when recovering the Source Server.</p>
        pub fn recommended_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommended_instance_type = Some(input.into());
            self
        }
        /// <p>The recommended EC2 instance type that will be used when recovering the Source Server.</p>
        pub fn set_recommended_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommended_instance_type = input;
            self
        }
        /// <p>Hints used to uniquely identify a machine.</p>
        pub fn identification_hints(mut self, input: crate::model::IdentificationHints) -> Self {
            self.identification_hints = Some(input);
            self
        }
        /// <p>Hints used to uniquely identify a machine.</p>
        pub fn set_identification_hints(
            mut self,
            input: std::option::Option<crate::model::IdentificationHints>,
        ) -> Self {
            self.identification_hints = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>An array of network interfaces.</p>
        pub fn network_interfaces(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p>An array of network interfaces.</p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Appends an item to `disks`.
        ///
        /// To override the contents of this collection use [`set_disks`](Self::set_disks).
        ///
        /// <p>An array of disks.</p>
        pub fn disks(mut self, input: crate::model::Disk) -> Self {
            let mut v = self.disks.unwrap_or_default();
            v.push(input);
            self.disks = Some(v);
            self
        }
        /// <p>An array of disks.</p>
        pub fn set_disks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Disk>>,
        ) -> Self {
            self.disks = input;
            self
        }
        /// Appends an item to `cpus`.
        ///
        /// To override the contents of this collection use [`set_cpus`](Self::set_cpus).
        ///
        /// <p>An array of CPUs.</p>
        pub fn cpus(mut self, input: crate::model::Cpu) -> Self {
            let mut v = self.cpus.unwrap_or_default();
            v.push(input);
            self.cpus = Some(v);
            self
        }
        /// <p>An array of CPUs.</p>
        pub fn set_cpus(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Cpu>>,
        ) -> Self {
            self.cpus = input;
            self
        }
        /// <p>The amount of RAM in bytes.</p>
        pub fn ram_bytes(mut self, input: i64) -> Self {
            self.ram_bytes = Some(input);
            self
        }
        /// <p>The amount of RAM in bytes.</p>
        pub fn set_ram_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.ram_bytes = input;
            self
        }
        /// <p>Operating system.</p>
        pub fn os(mut self, input: crate::model::Os) -> Self {
            self.os = Some(input);
            self
        }
        /// <p>Operating system.</p>
        pub fn set_os(mut self, input: std::option::Option<crate::model::Os>) -> Self {
            self.os = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceProperties`](crate::model::SourceProperties).
        pub fn build(self) -> crate::model::SourceProperties {
            crate::model::SourceProperties {
                last_updated_date_time: self.last_updated_date_time,
                recommended_instance_type: self.recommended_instance_type,
                identification_hints: self.identification_hints,
                network_interfaces: self.network_interfaces,
                disks: self.disks,
                cpus: self.cpus,
                ram_bytes: self.ram_bytes.unwrap_or_default(),
                os: self.os,
            }
        }
    }
}
impl SourceProperties {
    /// Creates a new builder-style object to manufacture [`SourceProperties`](crate::model::SourceProperties).
    pub fn builder() -> crate::model::source_properties::Builder {
        crate::model::source_properties::Builder::default()
    }
}

/// <p>Operating System.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Os {
    /// <p>The long name of the Operating System.</p>
    #[doc(hidden)]
    pub full_string: std::option::Option<std::string::String>,
}
impl Os {
    /// <p>The long name of the Operating System.</p>
    pub fn full_string(&self) -> std::option::Option<&str> {
        self.full_string.as_deref()
    }
}
/// See [`Os`](crate::model::Os).
pub mod os {

    /// A builder for [`Os`](crate::model::Os).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) full_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The long name of the Operating System.</p>
        pub fn full_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.full_string = Some(input.into());
            self
        }
        /// <p>The long name of the Operating System.</p>
        pub fn set_full_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.full_string = input;
            self
        }
        /// Consumes the builder and constructs a [`Os`](crate::model::Os).
        pub fn build(self) -> crate::model::Os {
            crate::model::Os {
                full_string: self.full_string,
            }
        }
    }
}
impl Os {
    /// Creates a new builder-style object to manufacture [`Os`](crate::model::Os).
    pub fn builder() -> crate::model::os::Builder {
        crate::model::os::Builder::default()
    }
}

/// <p>Information about a server's CPU.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Cpu {
    /// <p>The number of CPU cores.</p>
    #[doc(hidden)]
    pub cores: i64,
    /// <p>The model name of the CPU.</p>
    #[doc(hidden)]
    pub model_name: std::option::Option<std::string::String>,
}
impl Cpu {
    /// <p>The number of CPU cores.</p>
    pub fn cores(&self) -> i64 {
        self.cores
    }
    /// <p>The model name of the CPU.</p>
    pub fn model_name(&self) -> std::option::Option<&str> {
        self.model_name.as_deref()
    }
}
/// See [`Cpu`](crate::model::Cpu).
pub mod cpu {

    /// A builder for [`Cpu`](crate::model::Cpu).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cores: std::option::Option<i64>,
        pub(crate) model_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of CPU cores.</p>
        pub fn cores(mut self, input: i64) -> Self {
            self.cores = Some(input);
            self
        }
        /// <p>The number of CPU cores.</p>
        pub fn set_cores(mut self, input: std::option::Option<i64>) -> Self {
            self.cores = input;
            self
        }
        /// <p>The model name of the CPU.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The model name of the CPU.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// Consumes the builder and constructs a [`Cpu`](crate::model::Cpu).
        pub fn build(self) -> crate::model::Cpu {
            crate::model::Cpu {
                cores: self.cores.unwrap_or_default(),
                model_name: self.model_name,
            }
        }
    }
}
impl Cpu {
    /// Creates a new builder-style object to manufacture [`Cpu`](crate::model::Cpu).
    pub fn builder() -> crate::model::cpu::Builder {
        crate::model::cpu::Builder::default()
    }
}

/// <p>An object representing a data storage device on a server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Disk {
    /// <p>The disk or device name.</p>
    #[doc(hidden)]
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The amount of storage on the disk in bytes.</p>
    #[doc(hidden)]
    pub bytes: i64,
}
impl Disk {
    /// <p>The disk or device name.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>The amount of storage on the disk in bytes.</p>
    pub fn bytes(&self) -> i64 {
        self.bytes
    }
}
/// See [`Disk`](crate::model::Disk).
pub mod disk {

    /// A builder for [`Disk`](crate::model::Disk).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The disk or device name.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The disk or device name.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The amount of storage on the disk in bytes.</p>
        pub fn bytes(mut self, input: i64) -> Self {
            self.bytes = Some(input);
            self
        }
        /// <p>The amount of storage on the disk in bytes.</p>
        pub fn set_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`Disk`](crate::model::Disk).
        pub fn build(self) -> crate::model::Disk {
            crate::model::Disk {
                device_name: self.device_name,
                bytes: self.bytes.unwrap_or_default(),
            }
        }
    }
}
impl Disk {
    /// Creates a new builder-style object to manufacture [`Disk`](crate::model::Disk).
    pub fn builder() -> crate::model::disk::Builder {
        crate::model::disk::Builder::default()
    }
}

/// <p>Network interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkInterface {
    /// <p>The MAC address of the network interface.</p>
    #[doc(hidden)]
    pub mac_address: std::option::Option<std::string::String>,
    /// <p>Network interface IPs.</p>
    #[doc(hidden)]
    pub ips: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Whether this is the primary network interface.</p>
    #[doc(hidden)]
    pub is_primary: std::option::Option<bool>,
}
impl NetworkInterface {
    /// <p>The MAC address of the network interface.</p>
    pub fn mac_address(&self) -> std::option::Option<&str> {
        self.mac_address.as_deref()
    }
    /// <p>Network interface IPs.</p>
    pub fn ips(&self) -> std::option::Option<&[std::string::String]> {
        self.ips.as_deref()
    }
    /// <p>Whether this is the primary network interface.</p>
    pub fn is_primary(&self) -> std::option::Option<bool> {
        self.is_primary
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface).
pub mod network_interface {

    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mac_address: std::option::Option<std::string::String>,
        pub(crate) ips: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) is_primary: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The MAC address of the network interface.</p>
        pub fn mac_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.mac_address = Some(input.into());
            self
        }
        /// <p>The MAC address of the network interface.</p>
        pub fn set_mac_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mac_address = input;
            self
        }
        /// Appends an item to `ips`.
        ///
        /// To override the contents of this collection use [`set_ips`](Self::set_ips).
        ///
        /// <p>Network interface IPs.</p>
        pub fn ips(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ips.unwrap_or_default();
            v.push(input.into());
            self.ips = Some(v);
            self
        }
        /// <p>Network interface IPs.</p>
        pub fn set_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ips = input;
            self
        }
        /// <p>Whether this is the primary network interface.</p>
        pub fn is_primary(mut self, input: bool) -> Self {
            self.is_primary = Some(input);
            self
        }
        /// <p>Whether this is the primary network interface.</p>
        pub fn set_is_primary(mut self, input: std::option::Option<bool>) -> Self {
            self.is_primary = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface).
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                mac_address: self.mac_address,
                ips: self.ips,
                is_primary: self.is_primary,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface).
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// <p>Hints used to uniquely identify a machine.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IdentificationHints {
    /// <p>Fully Qualified Domain Name identification hint.</p>
    #[doc(hidden)]
    pub fqdn: std::option::Option<std::string::String>,
    /// <p>Hostname identification hint.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>vCenter VM path identification hint.</p>
    #[doc(hidden)]
    pub vm_ware_uuid: std::option::Option<std::string::String>,
    /// <p>AWS Instance ID identification hint.</p>
    #[doc(hidden)]
    pub aws_instance_id: std::option::Option<std::string::String>,
}
impl IdentificationHints {
    /// <p>Fully Qualified Domain Name identification hint.</p>
    pub fn fqdn(&self) -> std::option::Option<&str> {
        self.fqdn.as_deref()
    }
    /// <p>Hostname identification hint.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>vCenter VM path identification hint.</p>
    pub fn vm_ware_uuid(&self) -> std::option::Option<&str> {
        self.vm_ware_uuid.as_deref()
    }
    /// <p>AWS Instance ID identification hint.</p>
    pub fn aws_instance_id(&self) -> std::option::Option<&str> {
        self.aws_instance_id.as_deref()
    }
}
/// See [`IdentificationHints`](crate::model::IdentificationHints).
pub mod identification_hints {

    /// A builder for [`IdentificationHints`](crate::model::IdentificationHints).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fqdn: std::option::Option<std::string::String>,
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) vm_ware_uuid: std::option::Option<std::string::String>,
        pub(crate) aws_instance_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Fully Qualified Domain Name identification hint.</p>
        pub fn fqdn(mut self, input: impl Into<std::string::String>) -> Self {
            self.fqdn = Some(input.into());
            self
        }
        /// <p>Fully Qualified Domain Name identification hint.</p>
        pub fn set_fqdn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fqdn = input;
            self
        }
        /// <p>Hostname identification hint.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>Hostname identification hint.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>vCenter VM path identification hint.</p>
        pub fn vm_ware_uuid(mut self, input: impl Into<std::string::String>) -> Self {
            self.vm_ware_uuid = Some(input.into());
            self
        }
        /// <p>vCenter VM path identification hint.</p>
        pub fn set_vm_ware_uuid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vm_ware_uuid = input;
            self
        }
        /// <p>AWS Instance ID identification hint.</p>
        pub fn aws_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_instance_id = Some(input.into());
            self
        }
        /// <p>AWS Instance ID identification hint.</p>
        pub fn set_aws_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.aws_instance_id = input;
            self
        }
        /// Consumes the builder and constructs a [`IdentificationHints`](crate::model::IdentificationHints).
        pub fn build(self) -> crate::model::IdentificationHints {
            crate::model::IdentificationHints {
                fqdn: self.fqdn,
                hostname: self.hostname,
                vm_ware_uuid: self.vm_ware_uuid,
                aws_instance_id: self.aws_instance_id,
            }
        }
    }
}
impl IdentificationHints {
    /// Creates a new builder-style object to manufacture [`IdentificationHints`](crate::model::IdentificationHints).
    pub fn builder() -> crate::model::identification_hints::Builder {
        crate::model::identification_hints::Builder::default()
    }
}

/// <p>An object representing the Source Server Lifecycle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LifeCycle {
    /// <p>The date and time of when the Source Server was added to the service.</p>
    #[doc(hidden)]
    pub added_to_service_date_time: std::option::Option<std::string::String>,
    /// <p>The date and time of the first byte that was replicated from the Source Server.</p>
    #[doc(hidden)]
    pub first_byte_date_time: std::option::Option<std::string::String>,
    /// <p>The amount of time that the Source Server has been replicating for.</p>
    #[doc(hidden)]
    pub elapsed_replication_duration: std::option::Option<std::string::String>,
    /// <p>The date and time this Source Server was last seen by the service.</p>
    #[doc(hidden)]
    pub last_seen_by_service_date_time: std::option::Option<std::string::String>,
    /// <p>An object containing information regarding the last launch of the Source Server.</p>
    #[doc(hidden)]
    pub last_launch: std::option::Option<crate::model::LifeCycleLastLaunch>,
}
impl LifeCycle {
    /// <p>The date and time of when the Source Server was added to the service.</p>
    pub fn added_to_service_date_time(&self) -> std::option::Option<&str> {
        self.added_to_service_date_time.as_deref()
    }
    /// <p>The date and time of the first byte that was replicated from the Source Server.</p>
    pub fn first_byte_date_time(&self) -> std::option::Option<&str> {
        self.first_byte_date_time.as_deref()
    }
    /// <p>The amount of time that the Source Server has been replicating for.</p>
    pub fn elapsed_replication_duration(&self) -> std::option::Option<&str> {
        self.elapsed_replication_duration.as_deref()
    }
    /// <p>The date and time this Source Server was last seen by the service.</p>
    pub fn last_seen_by_service_date_time(&self) -> std::option::Option<&str> {
        self.last_seen_by_service_date_time.as_deref()
    }
    /// <p>An object containing information regarding the last launch of the Source Server.</p>
    pub fn last_launch(&self) -> std::option::Option<&crate::model::LifeCycleLastLaunch> {
        self.last_launch.as_ref()
    }
}
/// See [`LifeCycle`](crate::model::LifeCycle).
pub mod life_cycle {

    /// A builder for [`LifeCycle`](crate::model::LifeCycle).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) added_to_service_date_time: std::option::Option<std::string::String>,
        pub(crate) first_byte_date_time: std::option::Option<std::string::String>,
        pub(crate) elapsed_replication_duration: std::option::Option<std::string::String>,
        pub(crate) last_seen_by_service_date_time: std::option::Option<std::string::String>,
        pub(crate) last_launch: std::option::Option<crate::model::LifeCycleLastLaunch>,
    }
    impl Builder {
        /// <p>The date and time of when the Source Server was added to the service.</p>
        pub fn added_to_service_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.added_to_service_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of when the Source Server was added to the service.</p>
        pub fn set_added_to_service_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.added_to_service_date_time = input;
            self
        }
        /// <p>The date and time of the first byte that was replicated from the Source Server.</p>
        pub fn first_byte_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_byte_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of the first byte that was replicated from the Source Server.</p>
        pub fn set_first_byte_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.first_byte_date_time = input;
            self
        }
        /// <p>The amount of time that the Source Server has been replicating for.</p>
        pub fn elapsed_replication_duration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elapsed_replication_duration = Some(input.into());
            self
        }
        /// <p>The amount of time that the Source Server has been replicating for.</p>
        pub fn set_elapsed_replication_duration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elapsed_replication_duration = input;
            self
        }
        /// <p>The date and time this Source Server was last seen by the service.</p>
        pub fn last_seen_by_service_date_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_seen_by_service_date_time = Some(input.into());
            self
        }
        /// <p>The date and time this Source Server was last seen by the service.</p>
        pub fn set_last_seen_by_service_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_seen_by_service_date_time = input;
            self
        }
        /// <p>An object containing information regarding the last launch of the Source Server.</p>
        pub fn last_launch(mut self, input: crate::model::LifeCycleLastLaunch) -> Self {
            self.last_launch = Some(input);
            self
        }
        /// <p>An object containing information regarding the last launch of the Source Server.</p>
        pub fn set_last_launch(
            mut self,
            input: std::option::Option<crate::model::LifeCycleLastLaunch>,
        ) -> Self {
            self.last_launch = input;
            self
        }
        /// Consumes the builder and constructs a [`LifeCycle`](crate::model::LifeCycle).
        pub fn build(self) -> crate::model::LifeCycle {
            crate::model::LifeCycle {
                added_to_service_date_time: self.added_to_service_date_time,
                first_byte_date_time: self.first_byte_date_time,
                elapsed_replication_duration: self.elapsed_replication_duration,
                last_seen_by_service_date_time: self.last_seen_by_service_date_time,
                last_launch: self.last_launch,
            }
        }
    }
}
impl LifeCycle {
    /// Creates a new builder-style object to manufacture [`LifeCycle`](crate::model::LifeCycle).
    pub fn builder() -> crate::model::life_cycle::Builder {
        crate::model::life_cycle::Builder::default()
    }
}

/// <p>An object containing information regarding the last launch of a Source Server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LifeCycleLastLaunch {
    /// <p>An object containing information regarding the initiation of the last launch of a Source Server.</p>
    #[doc(hidden)]
    pub initiated: std::option::Option<crate::model::LifeCycleLastLaunchInitiated>,
}
impl LifeCycleLastLaunch {
    /// <p>An object containing information regarding the initiation of the last launch of a Source Server.</p>
    pub fn initiated(&self) -> std::option::Option<&crate::model::LifeCycleLastLaunchInitiated> {
        self.initiated.as_ref()
    }
}
/// See [`LifeCycleLastLaunch`](crate::model::LifeCycleLastLaunch).
pub mod life_cycle_last_launch {

    /// A builder for [`LifeCycleLastLaunch`](crate::model::LifeCycleLastLaunch).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) initiated: std::option::Option<crate::model::LifeCycleLastLaunchInitiated>,
    }
    impl Builder {
        /// <p>An object containing information regarding the initiation of the last launch of a Source Server.</p>
        pub fn initiated(mut self, input: crate::model::LifeCycleLastLaunchInitiated) -> Self {
            self.initiated = Some(input);
            self
        }
        /// <p>An object containing information regarding the initiation of the last launch of a Source Server.</p>
        pub fn set_initiated(
            mut self,
            input: std::option::Option<crate::model::LifeCycleLastLaunchInitiated>,
        ) -> Self {
            self.initiated = input;
            self
        }
        /// Consumes the builder and constructs a [`LifeCycleLastLaunch`](crate::model::LifeCycleLastLaunch).
        pub fn build(self) -> crate::model::LifeCycleLastLaunch {
            crate::model::LifeCycleLastLaunch {
                initiated: self.initiated,
            }
        }
    }
}
impl LifeCycleLastLaunch {
    /// Creates a new builder-style object to manufacture [`LifeCycleLastLaunch`](crate::model::LifeCycleLastLaunch).
    pub fn builder() -> crate::model::life_cycle_last_launch::Builder {
        crate::model::life_cycle_last_launch::Builder::default()
    }
}

/// <p>An object containing information regarding the initiation of the last launch of a Source Server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LifeCycleLastLaunchInitiated {
    /// <p>The date and time the last Source Server launch was initiated.</p>
    #[doc(hidden)]
    pub api_call_date_time: std::option::Option<std::string::String>,
    /// <p>The ID of the Job that was used to last launch the Source Server.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The Job type that was used to last launch the Source Server.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::LastLaunchType>,
}
impl LifeCycleLastLaunchInitiated {
    /// <p>The date and time the last Source Server launch was initiated.</p>
    pub fn api_call_date_time(&self) -> std::option::Option<&str> {
        self.api_call_date_time.as_deref()
    }
    /// <p>The ID of the Job that was used to last launch the Source Server.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The Job type that was used to last launch the Source Server.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::LastLaunchType> {
        self.r#type.as_ref()
    }
}
/// See [`LifeCycleLastLaunchInitiated`](crate::model::LifeCycleLastLaunchInitiated).
pub mod life_cycle_last_launch_initiated {

    /// A builder for [`LifeCycleLastLaunchInitiated`](crate::model::LifeCycleLastLaunchInitiated).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) api_call_date_time: std::option::Option<std::string::String>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::LastLaunchType>,
    }
    impl Builder {
        /// <p>The date and time the last Source Server launch was initiated.</p>
        pub fn api_call_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_call_date_time = Some(input.into());
            self
        }
        /// <p>The date and time the last Source Server launch was initiated.</p>
        pub fn set_api_call_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.api_call_date_time = input;
            self
        }
        /// <p>The ID of the Job that was used to last launch the Source Server.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the Job that was used to last launch the Source Server.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The Job type that was used to last launch the Source Server.</p>
        pub fn r#type(mut self, input: crate::model::LastLaunchType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The Job type that was used to last launch the Source Server.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::LastLaunchType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`LifeCycleLastLaunchInitiated`](crate::model::LifeCycleLastLaunchInitiated).
        pub fn build(self) -> crate::model::LifeCycleLastLaunchInitiated {
            crate::model::LifeCycleLastLaunchInitiated {
                api_call_date_time: self.api_call_date_time,
                job_id: self.job_id,
                r#type: self.r#type,
            }
        }
    }
}
impl LifeCycleLastLaunchInitiated {
    /// Creates a new builder-style object to manufacture [`LifeCycleLastLaunchInitiated`](crate::model::LifeCycleLastLaunchInitiated).
    pub fn builder() -> crate::model::life_cycle_last_launch_initiated::Builder {
        crate::model::life_cycle_last_launch_initiated::Builder::default()
    }
}

/// When writing a match expression against `LastLaunchType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lastlaunchtype = unimplemented!();
/// match lastlaunchtype {
///     LastLaunchType::Drill => { /* ... */ },
///     LastLaunchType::Recovery => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lastlaunchtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LastLaunchType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LastLaunchType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LastLaunchType::NewFeature` is defined.
/// Specifically, when `lastlaunchtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LastLaunchType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastLaunchType {
    #[allow(missing_docs)] // documentation missing in model
    Drill,
    #[allow(missing_docs)] // documentation missing in model
    Recovery,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LastLaunchType {
    fn from(s: &str) -> Self {
        match s {
            "DRILL" => LastLaunchType::Drill,
            "RECOVERY" => LastLaunchType::Recovery,
            other => LastLaunchType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LastLaunchType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LastLaunchType::from(s))
    }
}
impl LastLaunchType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LastLaunchType::Drill => "DRILL",
            LastLaunchType::Recovery => "RECOVERY",
            LastLaunchType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DRILL", "RECOVERY"]
    }
}
impl AsRef<str> for LastLaunchType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about Data Replication</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataReplicationInfo {
    /// <p>Data replication lag duration.</p>
    #[doc(hidden)]
    pub lag_duration: std::option::Option<std::string::String>,
    /// <p>An estimate of when the data replication will be completed.</p>
    #[doc(hidden)]
    pub eta_date_time: std::option::Option<std::string::String>,
    /// <p>The disks that should be replicated.</p>
    #[doc(hidden)]
    pub replicated_disks:
        std::option::Option<std::vec::Vec<crate::model::DataReplicationInfoReplicatedDisk>>,
    /// <p>The state of the data replication.</p>
    #[doc(hidden)]
    pub data_replication_state: std::option::Option<crate::model::DataReplicationState>,
    /// <p>Information about whether the data replication has been initiated.</p>
    #[doc(hidden)]
    pub data_replication_initiation: std::option::Option<crate::model::DataReplicationInitiation>,
    /// <p>Error in data replication.</p>
    #[doc(hidden)]
    pub data_replication_error: std::option::Option<crate::model::DataReplicationError>,
}
impl DataReplicationInfo {
    /// <p>Data replication lag duration.</p>
    pub fn lag_duration(&self) -> std::option::Option<&str> {
        self.lag_duration.as_deref()
    }
    /// <p>An estimate of when the data replication will be completed.</p>
    pub fn eta_date_time(&self) -> std::option::Option<&str> {
        self.eta_date_time.as_deref()
    }
    /// <p>The disks that should be replicated.</p>
    pub fn replicated_disks(
        &self,
    ) -> std::option::Option<&[crate::model::DataReplicationInfoReplicatedDisk]> {
        self.replicated_disks.as_deref()
    }
    /// <p>The state of the data replication.</p>
    pub fn data_replication_state(
        &self,
    ) -> std::option::Option<&crate::model::DataReplicationState> {
        self.data_replication_state.as_ref()
    }
    /// <p>Information about whether the data replication has been initiated.</p>
    pub fn data_replication_initiation(
        &self,
    ) -> std::option::Option<&crate::model::DataReplicationInitiation> {
        self.data_replication_initiation.as_ref()
    }
    /// <p>Error in data replication.</p>
    pub fn data_replication_error(
        &self,
    ) -> std::option::Option<&crate::model::DataReplicationError> {
        self.data_replication_error.as_ref()
    }
}
/// See [`DataReplicationInfo`](crate::model::DataReplicationInfo).
pub mod data_replication_info {

    /// A builder for [`DataReplicationInfo`](crate::model::DataReplicationInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lag_duration: std::option::Option<std::string::String>,
        pub(crate) eta_date_time: std::option::Option<std::string::String>,
        pub(crate) replicated_disks:
            std::option::Option<std::vec::Vec<crate::model::DataReplicationInfoReplicatedDisk>>,
        pub(crate) data_replication_state: std::option::Option<crate::model::DataReplicationState>,
        pub(crate) data_replication_initiation:
            std::option::Option<crate::model::DataReplicationInitiation>,
        pub(crate) data_replication_error: std::option::Option<crate::model::DataReplicationError>,
    }
    impl Builder {
        /// <p>Data replication lag duration.</p>
        pub fn lag_duration(mut self, input: impl Into<std::string::String>) -> Self {
            self.lag_duration = Some(input.into());
            self
        }
        /// <p>Data replication lag duration.</p>
        pub fn set_lag_duration(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lag_duration = input;
            self
        }
        /// <p>An estimate of when the data replication will be completed.</p>
        pub fn eta_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.eta_date_time = Some(input.into());
            self
        }
        /// <p>An estimate of when the data replication will be completed.</p>
        pub fn set_eta_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.eta_date_time = input;
            self
        }
        /// Appends an item to `replicated_disks`.
        ///
        /// To override the contents of this collection use [`set_replicated_disks`](Self::set_replicated_disks).
        ///
        /// <p>The disks that should be replicated.</p>
        pub fn replicated_disks(
            mut self,
            input: crate::model::DataReplicationInfoReplicatedDisk,
        ) -> Self {
            let mut v = self.replicated_disks.unwrap_or_default();
            v.push(input);
            self.replicated_disks = Some(v);
            self
        }
        /// <p>The disks that should be replicated.</p>
        pub fn set_replicated_disks(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::DataReplicationInfoReplicatedDisk>,
            >,
        ) -> Self {
            self.replicated_disks = input;
            self
        }
        /// <p>The state of the data replication.</p>
        pub fn data_replication_state(mut self, input: crate::model::DataReplicationState) -> Self {
            self.data_replication_state = Some(input);
            self
        }
        /// <p>The state of the data replication.</p>
        pub fn set_data_replication_state(
            mut self,
            input: std::option::Option<crate::model::DataReplicationState>,
        ) -> Self {
            self.data_replication_state = input;
            self
        }
        /// <p>Information about whether the data replication has been initiated.</p>
        pub fn data_replication_initiation(
            mut self,
            input: crate::model::DataReplicationInitiation,
        ) -> Self {
            self.data_replication_initiation = Some(input);
            self
        }
        /// <p>Information about whether the data replication has been initiated.</p>
        pub fn set_data_replication_initiation(
            mut self,
            input: std::option::Option<crate::model::DataReplicationInitiation>,
        ) -> Self {
            self.data_replication_initiation = input;
            self
        }
        /// <p>Error in data replication.</p>
        pub fn data_replication_error(mut self, input: crate::model::DataReplicationError) -> Self {
            self.data_replication_error = Some(input);
            self
        }
        /// <p>Error in data replication.</p>
        pub fn set_data_replication_error(
            mut self,
            input: std::option::Option<crate::model::DataReplicationError>,
        ) -> Self {
            self.data_replication_error = input;
            self
        }
        /// Consumes the builder and constructs a [`DataReplicationInfo`](crate::model::DataReplicationInfo).
        pub fn build(self) -> crate::model::DataReplicationInfo {
            crate::model::DataReplicationInfo {
                lag_duration: self.lag_duration,
                eta_date_time: self.eta_date_time,
                replicated_disks: self.replicated_disks,
                data_replication_state: self.data_replication_state,
                data_replication_initiation: self.data_replication_initiation,
                data_replication_error: self.data_replication_error,
            }
        }
    }
}
impl DataReplicationInfo {
    /// Creates a new builder-style object to manufacture [`DataReplicationInfo`](crate::model::DataReplicationInfo).
    pub fn builder() -> crate::model::data_replication_info::Builder {
        crate::model::data_replication_info::Builder::default()
    }
}

/// <p>Error in data replication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataReplicationError {
    /// <p>Error in data replication.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::DataReplicationErrorString>,
    /// <p>Error in data replication.</p>
    #[doc(hidden)]
    pub raw_error: std::option::Option<std::string::String>,
}
impl DataReplicationError {
    /// <p>Error in data replication.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::DataReplicationErrorString> {
        self.error.as_ref()
    }
    /// <p>Error in data replication.</p>
    pub fn raw_error(&self) -> std::option::Option<&str> {
        self.raw_error.as_deref()
    }
}
/// See [`DataReplicationError`](crate::model::DataReplicationError).
pub mod data_replication_error {

    /// A builder for [`DataReplicationError`](crate::model::DataReplicationError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::DataReplicationErrorString>,
        pub(crate) raw_error: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error in data replication.</p>
        pub fn error(mut self, input: crate::model::DataReplicationErrorString) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Error in data replication.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::DataReplicationErrorString>,
        ) -> Self {
            self.error = input;
            self
        }
        /// <p>Error in data replication.</p>
        pub fn raw_error(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_error = Some(input.into());
            self
        }
        /// <p>Error in data replication.</p>
        pub fn set_raw_error(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_error = input;
            self
        }
        /// Consumes the builder and constructs a [`DataReplicationError`](crate::model::DataReplicationError).
        pub fn build(self) -> crate::model::DataReplicationError {
            crate::model::DataReplicationError {
                error: self.error,
                raw_error: self.raw_error,
            }
        }
    }
}
impl DataReplicationError {
    /// Creates a new builder-style object to manufacture [`DataReplicationError`](crate::model::DataReplicationError).
    pub fn builder() -> crate::model::data_replication_error::Builder {
        crate::model::data_replication_error::Builder::default()
    }
}

/// When writing a match expression against `DataReplicationErrorString`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datareplicationerrorstring = unimplemented!();
/// match datareplicationerrorstring {
///     DataReplicationErrorString::AgentNotSeen => { /* ... */ },
///     DataReplicationErrorString::FailedToAttachStagingDisks => { /* ... */ },
///     DataReplicationErrorString::FailedToAuthenticateWithService => { /* ... */ },
///     DataReplicationErrorString::FailedToBootReplicationServer => { /* ... */ },
///     DataReplicationErrorString::FailedToConnectAgentToReplicationServer => { /* ... */ },
///     DataReplicationErrorString::FailedToCreateSecurityGroup => { /* ... */ },
///     DataReplicationErrorString::FailedToCreateStagingDisks => { /* ... */ },
///     DataReplicationErrorString::FailedToDownloadReplicationSoftware => { /* ... */ },
///     DataReplicationErrorString::FailedToLaunchReplicationServer => { /* ... */ },
///     DataReplicationErrorString::FailedToPairReplicationServerWithAgent => { /* ... */ },
///     DataReplicationErrorString::FailedToStartDataTransfer => { /* ... */ },
///     DataReplicationErrorString::NotConverging => { /* ... */ },
///     DataReplicationErrorString::SnapshotsFailure => { /* ... */ },
///     DataReplicationErrorString::UnstableNetwork => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datareplicationerrorstring` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataReplicationErrorString::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataReplicationErrorString::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataReplicationErrorString::NewFeature` is defined.
/// Specifically, when `datareplicationerrorstring` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataReplicationErrorString::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataReplicationErrorString {
    #[allow(missing_docs)] // documentation missing in model
    AgentNotSeen,
    #[allow(missing_docs)] // documentation missing in model
    FailedToAttachStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    FailedToAuthenticateWithService,
    #[allow(missing_docs)] // documentation missing in model
    FailedToBootReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    FailedToConnectAgentToReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    FailedToCreateSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    FailedToCreateStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    FailedToDownloadReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    FailedToLaunchReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    FailedToPairReplicationServerWithAgent,
    #[allow(missing_docs)] // documentation missing in model
    FailedToStartDataTransfer,
    #[allow(missing_docs)] // documentation missing in model
    NotConverging,
    #[allow(missing_docs)] // documentation missing in model
    SnapshotsFailure,
    #[allow(missing_docs)] // documentation missing in model
    UnstableNetwork,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataReplicationErrorString {
    fn from(s: &str) -> Self {
        match s {
            "AGENT_NOT_SEEN" => DataReplicationErrorString::AgentNotSeen,
            "FAILED_TO_ATTACH_STAGING_DISKS" => {
                DataReplicationErrorString::FailedToAttachStagingDisks
            }
            "FAILED_TO_AUTHENTICATE_WITH_SERVICE" => {
                DataReplicationErrorString::FailedToAuthenticateWithService
            }
            "FAILED_TO_BOOT_REPLICATION_SERVER" => {
                DataReplicationErrorString::FailedToBootReplicationServer
            }
            "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER" => {
                DataReplicationErrorString::FailedToConnectAgentToReplicationServer
            }
            "FAILED_TO_CREATE_SECURITY_GROUP" => {
                DataReplicationErrorString::FailedToCreateSecurityGroup
            }
            "FAILED_TO_CREATE_STAGING_DISKS" => {
                DataReplicationErrorString::FailedToCreateStagingDisks
            }
            "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE" => {
                DataReplicationErrorString::FailedToDownloadReplicationSoftware
            }
            "FAILED_TO_LAUNCH_REPLICATION_SERVER" => {
                DataReplicationErrorString::FailedToLaunchReplicationServer
            }
            "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT" => {
                DataReplicationErrorString::FailedToPairReplicationServerWithAgent
            }
            "FAILED_TO_START_DATA_TRANSFER" => {
                DataReplicationErrorString::FailedToStartDataTransfer
            }
            "NOT_CONVERGING" => DataReplicationErrorString::NotConverging,
            "SNAPSHOTS_FAILURE" => DataReplicationErrorString::SnapshotsFailure,
            "UNSTABLE_NETWORK" => DataReplicationErrorString::UnstableNetwork,
            other => DataReplicationErrorString::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DataReplicationErrorString {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataReplicationErrorString::from(s))
    }
}
impl DataReplicationErrorString {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataReplicationErrorString::AgentNotSeen => "AGENT_NOT_SEEN",
            DataReplicationErrorString::FailedToAttachStagingDisks => {
                "FAILED_TO_ATTACH_STAGING_DISKS"
            }
            DataReplicationErrorString::FailedToAuthenticateWithService => {
                "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            }
            DataReplicationErrorString::FailedToBootReplicationServer => {
                "FAILED_TO_BOOT_REPLICATION_SERVER"
            }
            DataReplicationErrorString::FailedToConnectAgentToReplicationServer => {
                "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            }
            DataReplicationErrorString::FailedToCreateSecurityGroup => {
                "FAILED_TO_CREATE_SECURITY_GROUP"
            }
            DataReplicationErrorString::FailedToCreateStagingDisks => {
                "FAILED_TO_CREATE_STAGING_DISKS"
            }
            DataReplicationErrorString::FailedToDownloadReplicationSoftware => {
                "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            }
            DataReplicationErrorString::FailedToLaunchReplicationServer => {
                "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            }
            DataReplicationErrorString::FailedToPairReplicationServerWithAgent => {
                "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            }
            DataReplicationErrorString::FailedToStartDataTransfer => {
                "FAILED_TO_START_DATA_TRANSFER"
            }
            DataReplicationErrorString::NotConverging => "NOT_CONVERGING",
            DataReplicationErrorString::SnapshotsFailure => "SNAPSHOTS_FAILURE",
            DataReplicationErrorString::UnstableNetwork => "UNSTABLE_NETWORK",
            DataReplicationErrorString::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AGENT_NOT_SEEN",
            "FAILED_TO_ATTACH_STAGING_DISKS",
            "FAILED_TO_AUTHENTICATE_WITH_SERVICE",
            "FAILED_TO_BOOT_REPLICATION_SERVER",
            "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER",
            "FAILED_TO_CREATE_SECURITY_GROUP",
            "FAILED_TO_CREATE_STAGING_DISKS",
            "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE",
            "FAILED_TO_LAUNCH_REPLICATION_SERVER",
            "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT",
            "FAILED_TO_START_DATA_TRANSFER",
            "NOT_CONVERGING",
            "SNAPSHOTS_FAILURE",
            "UNSTABLE_NETWORK",
        ]
    }
}
impl AsRef<str> for DataReplicationErrorString {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Data replication initiation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataReplicationInitiation {
    /// <p>The date and time of the current attempt to initiate data replication.</p>
    #[doc(hidden)]
    pub start_date_time: std::option::Option<std::string::String>,
    /// <p>The date and time of the next attempt to initiate data replication.</p>
    #[doc(hidden)]
    pub next_attempt_date_time: std::option::Option<std::string::String>,
    /// <p>The steps of the current attempt to initiate data replication.</p>
    #[doc(hidden)]
    pub steps: std::option::Option<std::vec::Vec<crate::model::DataReplicationInitiationStep>>,
}
impl DataReplicationInitiation {
    /// <p>The date and time of the current attempt to initiate data replication.</p>
    pub fn start_date_time(&self) -> std::option::Option<&str> {
        self.start_date_time.as_deref()
    }
    /// <p>The date and time of the next attempt to initiate data replication.</p>
    pub fn next_attempt_date_time(&self) -> std::option::Option<&str> {
        self.next_attempt_date_time.as_deref()
    }
    /// <p>The steps of the current attempt to initiate data replication.</p>
    pub fn steps(&self) -> std::option::Option<&[crate::model::DataReplicationInitiationStep]> {
        self.steps.as_deref()
    }
}
/// See [`DataReplicationInitiation`](crate::model::DataReplicationInitiation).
pub mod data_replication_initiation {

    /// A builder for [`DataReplicationInitiation`](crate::model::DataReplicationInitiation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_date_time: std::option::Option<std::string::String>,
        pub(crate) next_attempt_date_time: std::option::Option<std::string::String>,
        pub(crate) steps:
            std::option::Option<std::vec::Vec<crate::model::DataReplicationInitiationStep>>,
    }
    impl Builder {
        /// <p>The date and time of the current attempt to initiate data replication.</p>
        pub fn start_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of the current attempt to initiate data replication.</p>
        pub fn set_start_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_date_time = input;
            self
        }
        /// <p>The date and time of the next attempt to initiate data replication.</p>
        pub fn next_attempt_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_attempt_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of the next attempt to initiate data replication.</p>
        pub fn set_next_attempt_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_attempt_date_time = input;
            self
        }
        /// Appends an item to `steps`.
        ///
        /// To override the contents of this collection use [`set_steps`](Self::set_steps).
        ///
        /// <p>The steps of the current attempt to initiate data replication.</p>
        pub fn steps(mut self, input: crate::model::DataReplicationInitiationStep) -> Self {
            let mut v = self.steps.unwrap_or_default();
            v.push(input);
            self.steps = Some(v);
            self
        }
        /// <p>The steps of the current attempt to initiate data replication.</p>
        pub fn set_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataReplicationInitiationStep>>,
        ) -> Self {
            self.steps = input;
            self
        }
        /// Consumes the builder and constructs a [`DataReplicationInitiation`](crate::model::DataReplicationInitiation).
        pub fn build(self) -> crate::model::DataReplicationInitiation {
            crate::model::DataReplicationInitiation {
                start_date_time: self.start_date_time,
                next_attempt_date_time: self.next_attempt_date_time,
                steps: self.steps,
            }
        }
    }
}
impl DataReplicationInitiation {
    /// Creates a new builder-style object to manufacture [`DataReplicationInitiation`](crate::model::DataReplicationInitiation).
    pub fn builder() -> crate::model::data_replication_initiation::Builder {
        crate::model::data_replication_initiation::Builder::default()
    }
}

/// <p>Data replication initiation step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataReplicationInitiationStep {
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::DataReplicationInitiationStepName>,
    /// <p>The status of the step.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DataReplicationInitiationStepStatus>,
}
impl DataReplicationInitiationStep {
    /// <p>The name of the step.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::DataReplicationInitiationStepName> {
        self.name.as_ref()
    }
    /// <p>The status of the step.</p>
    pub fn status(
        &self,
    ) -> std::option::Option<&crate::model::DataReplicationInitiationStepStatus> {
        self.status.as_ref()
    }
}
/// See [`DataReplicationInitiationStep`](crate::model::DataReplicationInitiationStep).
pub mod data_replication_initiation_step {

    /// A builder for [`DataReplicationInitiationStep`](crate::model::DataReplicationInitiationStep).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::DataReplicationInitiationStepName>,
        pub(crate) status: std::option::Option<crate::model::DataReplicationInitiationStepStatus>,
    }
    impl Builder {
        /// <p>The name of the step.</p>
        pub fn name(mut self, input: crate::model::DataReplicationInitiationStepName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DataReplicationInitiationStepName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the step.</p>
        pub fn status(mut self, input: crate::model::DataReplicationInitiationStepStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the step.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataReplicationInitiationStepStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`DataReplicationInitiationStep`](crate::model::DataReplicationInitiationStep).
        pub fn build(self) -> crate::model::DataReplicationInitiationStep {
            crate::model::DataReplicationInitiationStep {
                name: self.name,
                status: self.status,
            }
        }
    }
}
impl DataReplicationInitiationStep {
    /// Creates a new builder-style object to manufacture [`DataReplicationInitiationStep`](crate::model::DataReplicationInitiationStep).
    pub fn builder() -> crate::model::data_replication_initiation_step::Builder {
        crate::model::data_replication_initiation_step::Builder::default()
    }
}

/// When writing a match expression against `DataReplicationInitiationStepStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datareplicationinitiationstepstatus = unimplemented!();
/// match datareplicationinitiationstepstatus {
///     DataReplicationInitiationStepStatus::Failed => { /* ... */ },
///     DataReplicationInitiationStepStatus::InProgress => { /* ... */ },
///     DataReplicationInitiationStepStatus::NotStarted => { /* ... */ },
///     DataReplicationInitiationStepStatus::Skipped => { /* ... */ },
///     DataReplicationInitiationStepStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datareplicationinitiationstepstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataReplicationInitiationStepStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataReplicationInitiationStepStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataReplicationInitiationStepStatus::NewFeature` is defined.
/// Specifically, when `datareplicationinitiationstepstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataReplicationInitiationStepStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataReplicationInitiationStepStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    #[allow(missing_docs)] // documentation missing in model
    Skipped,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataReplicationInitiationStepStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => DataReplicationInitiationStepStatus::Failed,
            "IN_PROGRESS" => DataReplicationInitiationStepStatus::InProgress,
            "NOT_STARTED" => DataReplicationInitiationStepStatus::NotStarted,
            "SKIPPED" => DataReplicationInitiationStepStatus::Skipped,
            "SUCCEEDED" => DataReplicationInitiationStepStatus::Succeeded,
            other => DataReplicationInitiationStepStatus::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for DataReplicationInitiationStepStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataReplicationInitiationStepStatus::from(s))
    }
}
impl DataReplicationInitiationStepStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataReplicationInitiationStepStatus::Failed => "FAILED",
            DataReplicationInitiationStepStatus::InProgress => "IN_PROGRESS",
            DataReplicationInitiationStepStatus::NotStarted => "NOT_STARTED",
            DataReplicationInitiationStepStatus::Skipped => "SKIPPED",
            DataReplicationInitiationStepStatus::Succeeded => "SUCCEEDED",
            DataReplicationInitiationStepStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "SKIPPED",
            "SUCCEEDED",
        ]
    }
}
impl AsRef<str> for DataReplicationInitiationStepStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataReplicationInitiationStepName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datareplicationinitiationstepname = unimplemented!();
/// match datareplicationinitiationstepname {
///     DataReplicationInitiationStepName::AttachStagingDisks => { /* ... */ },
///     DataReplicationInitiationStepName::AuthenticateWithService => { /* ... */ },
///     DataReplicationInitiationStepName::BootReplicationServer => { /* ... */ },
///     DataReplicationInitiationStepName::ConnectAgentToReplicationServer => { /* ... */ },
///     DataReplicationInitiationStepName::CreateSecurityGroup => { /* ... */ },
///     DataReplicationInitiationStepName::CreateStagingDisks => { /* ... */ },
///     DataReplicationInitiationStepName::DownloadReplicationSoftware => { /* ... */ },
///     DataReplicationInitiationStepName::LaunchReplicationServer => { /* ... */ },
///     DataReplicationInitiationStepName::PairReplicationServerWithAgent => { /* ... */ },
///     DataReplicationInitiationStepName::StartDataTransfer => { /* ... */ },
///     DataReplicationInitiationStepName::Wait => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datareplicationinitiationstepname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataReplicationInitiationStepName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataReplicationInitiationStepName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataReplicationInitiationStepName::NewFeature` is defined.
/// Specifically, when `datareplicationinitiationstepname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataReplicationInitiationStepName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataReplicationInitiationStepName {
    #[allow(missing_docs)] // documentation missing in model
    AttachStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    AuthenticateWithService,
    #[allow(missing_docs)] // documentation missing in model
    BootReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    ConnectAgentToReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    CreateSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    CreateStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    DownloadReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    LaunchReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    PairReplicationServerWithAgent,
    #[allow(missing_docs)] // documentation missing in model
    StartDataTransfer,
    #[allow(missing_docs)] // documentation missing in model
    Wait,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataReplicationInitiationStepName {
    fn from(s: &str) -> Self {
        match s {
            "ATTACH_STAGING_DISKS" => DataReplicationInitiationStepName::AttachStagingDisks,
            "AUTHENTICATE_WITH_SERVICE" => {
                DataReplicationInitiationStepName::AuthenticateWithService
            }
            "BOOT_REPLICATION_SERVER" => DataReplicationInitiationStepName::BootReplicationServer,
            "CONNECT_AGENT_TO_REPLICATION_SERVER" => {
                DataReplicationInitiationStepName::ConnectAgentToReplicationServer
            }
            "CREATE_SECURITY_GROUP" => DataReplicationInitiationStepName::CreateSecurityGroup,
            "CREATE_STAGING_DISKS" => DataReplicationInitiationStepName::CreateStagingDisks,
            "DOWNLOAD_REPLICATION_SOFTWARE" => {
                DataReplicationInitiationStepName::DownloadReplicationSoftware
            }
            "LAUNCH_REPLICATION_SERVER" => {
                DataReplicationInitiationStepName::LaunchReplicationServer
            }
            "PAIR_REPLICATION_SERVER_WITH_AGENT" => {
                DataReplicationInitiationStepName::PairReplicationServerWithAgent
            }
            "START_DATA_TRANSFER" => DataReplicationInitiationStepName::StartDataTransfer,
            "WAIT" => DataReplicationInitiationStepName::Wait,
            other => DataReplicationInitiationStepName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DataReplicationInitiationStepName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataReplicationInitiationStepName::from(s))
    }
}
impl DataReplicationInitiationStepName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataReplicationInitiationStepName::AttachStagingDisks => "ATTACH_STAGING_DISKS",
            DataReplicationInitiationStepName::AuthenticateWithService => {
                "AUTHENTICATE_WITH_SERVICE"
            }
            DataReplicationInitiationStepName::BootReplicationServer => "BOOT_REPLICATION_SERVER",
            DataReplicationInitiationStepName::ConnectAgentToReplicationServer => {
                "CONNECT_AGENT_TO_REPLICATION_SERVER"
            }
            DataReplicationInitiationStepName::CreateSecurityGroup => "CREATE_SECURITY_GROUP",
            DataReplicationInitiationStepName::CreateStagingDisks => "CREATE_STAGING_DISKS",
            DataReplicationInitiationStepName::DownloadReplicationSoftware => {
                "DOWNLOAD_REPLICATION_SOFTWARE"
            }
            DataReplicationInitiationStepName::LaunchReplicationServer => {
                "LAUNCH_REPLICATION_SERVER"
            }
            DataReplicationInitiationStepName::PairReplicationServerWithAgent => {
                "PAIR_REPLICATION_SERVER_WITH_AGENT"
            }
            DataReplicationInitiationStepName::StartDataTransfer => "START_DATA_TRANSFER",
            DataReplicationInitiationStepName::Wait => "WAIT",
            DataReplicationInitiationStepName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ATTACH_STAGING_DISKS",
            "AUTHENTICATE_WITH_SERVICE",
            "BOOT_REPLICATION_SERVER",
            "CONNECT_AGENT_TO_REPLICATION_SERVER",
            "CREATE_SECURITY_GROUP",
            "CREATE_STAGING_DISKS",
            "DOWNLOAD_REPLICATION_SOFTWARE",
            "LAUNCH_REPLICATION_SERVER",
            "PAIR_REPLICATION_SERVER_WITH_AGENT",
            "START_DATA_TRANSFER",
            "WAIT",
        ]
    }
}
impl AsRef<str> for DataReplicationInitiationStepName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataReplicationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datareplicationstate = unimplemented!();
/// match datareplicationstate {
///     DataReplicationState::Backlog => { /* ... */ },
///     DataReplicationState::Continuous => { /* ... */ },
///     DataReplicationState::CreatingSnapshot => { /* ... */ },
///     DataReplicationState::Disconnected => { /* ... */ },
///     DataReplicationState::InitialSync => { /* ... */ },
///     DataReplicationState::Initiating => { /* ... */ },
///     DataReplicationState::Paused => { /* ... */ },
///     DataReplicationState::Rescan => { /* ... */ },
///     DataReplicationState::Stalled => { /* ... */ },
///     DataReplicationState::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datareplicationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataReplicationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataReplicationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataReplicationState::NewFeature` is defined.
/// Specifically, when `datareplicationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataReplicationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataReplicationState {
    #[allow(missing_docs)] // documentation missing in model
    Backlog,
    #[allow(missing_docs)] // documentation missing in model
    Continuous,
    #[allow(missing_docs)] // documentation missing in model
    CreatingSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    Disconnected,
    #[allow(missing_docs)] // documentation missing in model
    InitialSync,
    #[allow(missing_docs)] // documentation missing in model
    Initiating,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    #[allow(missing_docs)] // documentation missing in model
    Rescan,
    #[allow(missing_docs)] // documentation missing in model
    Stalled,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataReplicationState {
    fn from(s: &str) -> Self {
        match s {
            "BACKLOG" => DataReplicationState::Backlog,
            "CONTINUOUS" => DataReplicationState::Continuous,
            "CREATING_SNAPSHOT" => DataReplicationState::CreatingSnapshot,
            "DISCONNECTED" => DataReplicationState::Disconnected,
            "INITIAL_SYNC" => DataReplicationState::InitialSync,
            "INITIATING" => DataReplicationState::Initiating,
            "PAUSED" => DataReplicationState::Paused,
            "RESCAN" => DataReplicationState::Rescan,
            "STALLED" => DataReplicationState::Stalled,
            "STOPPED" => DataReplicationState::Stopped,
            other => {
                DataReplicationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DataReplicationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataReplicationState::from(s))
    }
}
impl DataReplicationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataReplicationState::Backlog => "BACKLOG",
            DataReplicationState::Continuous => "CONTINUOUS",
            DataReplicationState::CreatingSnapshot => "CREATING_SNAPSHOT",
            DataReplicationState::Disconnected => "DISCONNECTED",
            DataReplicationState::InitialSync => "INITIAL_SYNC",
            DataReplicationState::Initiating => "INITIATING",
            DataReplicationState::Paused => "PAUSED",
            DataReplicationState::Rescan => "RESCAN",
            DataReplicationState::Stalled => "STALLED",
            DataReplicationState::Stopped => "STOPPED",
            DataReplicationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BACKLOG",
            "CONTINUOUS",
            "CREATING_SNAPSHOT",
            "DISCONNECTED",
            "INITIAL_SYNC",
            "INITIATING",
            "PAUSED",
            "RESCAN",
            "STALLED",
            "STOPPED",
        ]
    }
}
impl AsRef<str> for DataReplicationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A disk that should be replicated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataReplicationInfoReplicatedDisk {
    /// <p>The name of the device.</p>
    #[doc(hidden)]
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The total amount of data to be replicated in bytes.</p>
    #[doc(hidden)]
    pub total_storage_bytes: i64,
    /// <p>The amount of data replicated so far in bytes.</p>
    #[doc(hidden)]
    pub replicated_storage_bytes: i64,
    /// <p>The amount of data to be rescanned in bytes.</p>
    #[doc(hidden)]
    pub rescanned_storage_bytes: i64,
    /// <p>The size of the replication backlog in bytes.</p>
    #[doc(hidden)]
    pub backlogged_storage_bytes: i64,
}
impl DataReplicationInfoReplicatedDisk {
    /// <p>The name of the device.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>The total amount of data to be replicated in bytes.</p>
    pub fn total_storage_bytes(&self) -> i64 {
        self.total_storage_bytes
    }
    /// <p>The amount of data replicated so far in bytes.</p>
    pub fn replicated_storage_bytes(&self) -> i64 {
        self.replicated_storage_bytes
    }
    /// <p>The amount of data to be rescanned in bytes.</p>
    pub fn rescanned_storage_bytes(&self) -> i64 {
        self.rescanned_storage_bytes
    }
    /// <p>The size of the replication backlog in bytes.</p>
    pub fn backlogged_storage_bytes(&self) -> i64 {
        self.backlogged_storage_bytes
    }
}
/// See [`DataReplicationInfoReplicatedDisk`](crate::model::DataReplicationInfoReplicatedDisk).
pub mod data_replication_info_replicated_disk {

    /// A builder for [`DataReplicationInfoReplicatedDisk`](crate::model::DataReplicationInfoReplicatedDisk).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) total_storage_bytes: std::option::Option<i64>,
        pub(crate) replicated_storage_bytes: std::option::Option<i64>,
        pub(crate) rescanned_storage_bytes: std::option::Option<i64>,
        pub(crate) backlogged_storage_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The name of the device.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The total amount of data to be replicated in bytes.</p>
        pub fn total_storage_bytes(mut self, input: i64) -> Self {
            self.total_storage_bytes = Some(input);
            self
        }
        /// <p>The total amount of data to be replicated in bytes.</p>
        pub fn set_total_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.total_storage_bytes = input;
            self
        }
        /// <p>The amount of data replicated so far in bytes.</p>
        pub fn replicated_storage_bytes(mut self, input: i64) -> Self {
            self.replicated_storage_bytes = Some(input);
            self
        }
        /// <p>The amount of data replicated so far in bytes.</p>
        pub fn set_replicated_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.replicated_storage_bytes = input;
            self
        }
        /// <p>The amount of data to be rescanned in bytes.</p>
        pub fn rescanned_storage_bytes(mut self, input: i64) -> Self {
            self.rescanned_storage_bytes = Some(input);
            self
        }
        /// <p>The amount of data to be rescanned in bytes.</p>
        pub fn set_rescanned_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.rescanned_storage_bytes = input;
            self
        }
        /// <p>The size of the replication backlog in bytes.</p>
        pub fn backlogged_storage_bytes(mut self, input: i64) -> Self {
            self.backlogged_storage_bytes = Some(input);
            self
        }
        /// <p>The size of the replication backlog in bytes.</p>
        pub fn set_backlogged_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.backlogged_storage_bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`DataReplicationInfoReplicatedDisk`](crate::model::DataReplicationInfoReplicatedDisk).
        pub fn build(self) -> crate::model::DataReplicationInfoReplicatedDisk {
            crate::model::DataReplicationInfoReplicatedDisk {
                device_name: self.device_name,
                total_storage_bytes: self.total_storage_bytes.unwrap_or_default(),
                replicated_storage_bytes: self.replicated_storage_bytes.unwrap_or_default(),
                rescanned_storage_bytes: self.rescanned_storage_bytes.unwrap_or_default(),
                backlogged_storage_bytes: self.backlogged_storage_bytes.unwrap_or_default(),
            }
        }
    }
}
impl DataReplicationInfoReplicatedDisk {
    /// Creates a new builder-style object to manufacture [`DataReplicationInfoReplicatedDisk`](crate::model::DataReplicationInfoReplicatedDisk).
    pub fn builder() -> crate::model::data_replication_info_replicated_disk::Builder {
        crate::model::data_replication_info_replicated_disk::Builder::default()
    }
}

/// When writing a match expression against `LastLaunchResult`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lastlaunchresult = unimplemented!();
/// match lastlaunchresult {
///     LastLaunchResult::Failed => { /* ... */ },
///     LastLaunchResult::NotStarted => { /* ... */ },
///     LastLaunchResult::Pending => { /* ... */ },
///     LastLaunchResult::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lastlaunchresult` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LastLaunchResult::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LastLaunchResult::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LastLaunchResult::NewFeature` is defined.
/// Specifically, when `lastlaunchresult` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LastLaunchResult::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastLaunchResult {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LastLaunchResult {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => LastLaunchResult::Failed,
            "NOT_STARTED" => LastLaunchResult::NotStarted,
            "PENDING" => LastLaunchResult::Pending,
            "SUCCEEDED" => LastLaunchResult::Succeeded,
            other => LastLaunchResult::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LastLaunchResult {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LastLaunchResult::from(s))
    }
}
impl LastLaunchResult {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LastLaunchResult::Failed => "FAILED",
            LastLaunchResult::NotStarted => "NOT_STARTED",
            LastLaunchResult::Pending => "PENDING",
            LastLaunchResult::Succeeded => "SUCCEEDED",
            LastLaunchResult::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "NOT_STARTED", "PENDING", "SUCCEEDED"]
    }
}
impl AsRef<str> for LastLaunchResult {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A snapshot of a Source Server used during recovery.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoverySnapshot {
    /// <p>The ID of the Recovery Snapshot.</p>
    #[doc(hidden)]
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Source Server that the snapshot was taken for.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>The timestamp of when we expect the snapshot to be taken.</p>
    #[doc(hidden)]
    pub expected_timestamp: std::option::Option<std::string::String>,
    /// <p>The actual timestamp that the snapshot was taken.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<std::string::String>,
    /// <p>A list of EBS snapshots.</p>
    #[doc(hidden)]
    pub ebs_snapshots: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RecoverySnapshot {
    /// <p>The ID of the Recovery Snapshot.</p>
    pub fn snapshot_id(&self) -> std::option::Option<&str> {
        self.snapshot_id.as_deref()
    }
    /// <p>The ID of the Source Server that the snapshot was taken for.</p>
    pub fn source_server_id(&self) -> std::option::Option<&str> {
        self.source_server_id.as_deref()
    }
    /// <p>The timestamp of when we expect the snapshot to be taken.</p>
    pub fn expected_timestamp(&self) -> std::option::Option<&str> {
        self.expected_timestamp.as_deref()
    }
    /// <p>The actual timestamp that the snapshot was taken.</p>
    pub fn timestamp(&self) -> std::option::Option<&str> {
        self.timestamp.as_deref()
    }
    /// <p>A list of EBS snapshots.</p>
    pub fn ebs_snapshots(&self) -> std::option::Option<&[std::string::String]> {
        self.ebs_snapshots.as_deref()
    }
}
/// See [`RecoverySnapshot`](crate::model::RecoverySnapshot).
pub mod recovery_snapshot {

    /// A builder for [`RecoverySnapshot`](crate::model::RecoverySnapshot).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) expected_timestamp: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<std::string::String>,
        pub(crate) ebs_snapshots: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ID of the Recovery Snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        /// <p>The ID of the Recovery Snapshot.</p>
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The ID of the Source Server that the snapshot was taken for.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>The ID of the Source Server that the snapshot was taken for.</p>
        pub fn set_source_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_server_id = input;
            self
        }
        /// <p>The timestamp of when we expect the snapshot to be taken.</p>
        pub fn expected_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_timestamp = Some(input.into());
            self
        }
        /// <p>The timestamp of when we expect the snapshot to be taken.</p>
        pub fn set_expected_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_timestamp = input;
            self
        }
        /// <p>The actual timestamp that the snapshot was taken.</p>
        pub fn timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestamp = Some(input.into());
            self
        }
        /// <p>The actual timestamp that the snapshot was taken.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timestamp = input;
            self
        }
        /// Appends an item to `ebs_snapshots`.
        ///
        /// To override the contents of this collection use [`set_ebs_snapshots`](Self::set_ebs_snapshots).
        ///
        /// <p>A list of EBS snapshots.</p>
        pub fn ebs_snapshots(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ebs_snapshots.unwrap_or_default();
            v.push(input.into());
            self.ebs_snapshots = Some(v);
            self
        }
        /// <p>A list of EBS snapshots.</p>
        pub fn set_ebs_snapshots(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ebs_snapshots = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoverySnapshot`](crate::model::RecoverySnapshot).
        pub fn build(self) -> crate::model::RecoverySnapshot {
            crate::model::RecoverySnapshot {
                snapshot_id: self.snapshot_id,
                source_server_id: self.source_server_id,
                expected_timestamp: self.expected_timestamp,
                timestamp: self.timestamp,
                ebs_snapshots: self.ebs_snapshots,
            }
        }
    }
}
impl RecoverySnapshot {
    /// Creates a new builder-style object to manufacture [`RecoverySnapshot`](crate::model::RecoverySnapshot).
    pub fn builder() -> crate::model::recovery_snapshot::Builder {
        crate::model::recovery_snapshot::Builder::default()
    }
}

/// When writing a match expression against `RecoverySnapshotsOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recoverysnapshotsorder = unimplemented!();
/// match recoverysnapshotsorder {
///     RecoverySnapshotsOrder::Asc => { /* ... */ },
///     RecoverySnapshotsOrder::Desc => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recoverysnapshotsorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecoverySnapshotsOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecoverySnapshotsOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecoverySnapshotsOrder::NewFeature` is defined.
/// Specifically, when `recoverysnapshotsorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecoverySnapshotsOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecoverySnapshotsOrder {
    #[allow(missing_docs)] // documentation missing in model
    Asc,
    #[allow(missing_docs)] // documentation missing in model
    Desc,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecoverySnapshotsOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASC" => RecoverySnapshotsOrder::Asc,
            "DESC" => RecoverySnapshotsOrder::Desc,
            other => {
                RecoverySnapshotsOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RecoverySnapshotsOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecoverySnapshotsOrder::from(s))
    }
}
impl RecoverySnapshotsOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecoverySnapshotsOrder::Asc => "ASC",
            RecoverySnapshotsOrder::Desc => "DESC",
            RecoverySnapshotsOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl AsRef<str> for RecoverySnapshotsOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A set of filters by which to return Recovery Snapshots.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRecoverySnapshotsRequestFilters {
    /// <p>The start date in a date range query.</p>
    #[doc(hidden)]
    pub from_date_time: std::option::Option<std::string::String>,
    /// <p>The end date in a date range query.</p>
    #[doc(hidden)]
    pub to_date_time: std::option::Option<std::string::String>,
}
impl DescribeRecoverySnapshotsRequestFilters {
    /// <p>The start date in a date range query.</p>
    pub fn from_date_time(&self) -> std::option::Option<&str> {
        self.from_date_time.as_deref()
    }
    /// <p>The end date in a date range query.</p>
    pub fn to_date_time(&self) -> std::option::Option<&str> {
        self.to_date_time.as_deref()
    }
}
/// See [`DescribeRecoverySnapshotsRequestFilters`](crate::model::DescribeRecoverySnapshotsRequestFilters).
pub mod describe_recovery_snapshots_request_filters {

    /// A builder for [`DescribeRecoverySnapshotsRequestFilters`](crate::model::DescribeRecoverySnapshotsRequestFilters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_date_time: std::option::Option<std::string::String>,
        pub(crate) to_date_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The start date in a date range query.</p>
        pub fn from_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_date_time = Some(input.into());
            self
        }
        /// <p>The start date in a date range query.</p>
        pub fn set_from_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.from_date_time = input;
            self
        }
        /// <p>The end date in a date range query.</p>
        pub fn to_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.to_date_time = Some(input.into());
            self
        }
        /// <p>The end date in a date range query.</p>
        pub fn set_to_date_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.to_date_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRecoverySnapshotsRequestFilters`](crate::model::DescribeRecoverySnapshotsRequestFilters).
        pub fn build(self) -> crate::model::DescribeRecoverySnapshotsRequestFilters {
            crate::model::DescribeRecoverySnapshotsRequestFilters {
                from_date_time: self.from_date_time,
                to_date_time: self.to_date_time,
            }
        }
    }
}
impl DescribeRecoverySnapshotsRequestFilters {
    /// Creates a new builder-style object to manufacture [`DescribeRecoverySnapshotsRequestFilters`](crate::model::DescribeRecoverySnapshotsRequestFilters).
    pub fn builder() -> crate::model::describe_recovery_snapshots_request_filters::Builder {
        crate::model::describe_recovery_snapshots_request_filters::Builder::default()
    }
}

/// <p>A job is an asynchronous workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Job {
    /// <p>The ID of the Job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a Job.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of the Job.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::JobType>,
    /// <p>A string representing who initiated the Job.</p>
    #[doc(hidden)]
    pub initiated_by: std::option::Option<crate::model::InitiatedBy>,
    /// <p>The date and time of when the Job was created.</p>
    #[doc(hidden)]
    pub creation_date_time: std::option::Option<std::string::String>,
    /// <p>The date and time of when the Job ended.</p>
    #[doc(hidden)]
    pub end_date_time: std::option::Option<std::string::String>,
    /// <p>The status of the Job.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::JobStatus>,
    /// <p>A list of servers that the Job is acting upon.</p>
    #[doc(hidden)]
    pub participating_servers:
        std::option::Option<std::vec::Vec<crate::model::ParticipatingServer>>,
    /// <p>A list of tags associated with the Job.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Job {
    /// <p>The ID of the Job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The ARN of a Job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of the Job.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::JobType> {
        self.r#type.as_ref()
    }
    /// <p>A string representing who initiated the Job.</p>
    pub fn initiated_by(&self) -> std::option::Option<&crate::model::InitiatedBy> {
        self.initiated_by.as_ref()
    }
    /// <p>The date and time of when the Job was created.</p>
    pub fn creation_date_time(&self) -> std::option::Option<&str> {
        self.creation_date_time.as_deref()
    }
    /// <p>The date and time of when the Job ended.</p>
    pub fn end_date_time(&self) -> std::option::Option<&str> {
        self.end_date_time.as_deref()
    }
    /// <p>The status of the Job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::JobStatus> {
        self.status.as_ref()
    }
    /// <p>A list of servers that the Job is acting upon.</p>
    pub fn participating_servers(
        &self,
    ) -> std::option::Option<&[crate::model::ParticipatingServer]> {
        self.participating_servers.as_deref()
    }
    /// <p>A list of tags associated with the Job.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Job");
        formatter.field("job_id", &self.job_id);
        formatter.field("arn", &self.arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("initiated_by", &self.initiated_by);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("end_date_time", &self.end_date_time);
        formatter.field("status", &self.status);
        formatter.field("participating_servers", &self.participating_servers);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Job`](crate::model::Job).
pub mod job {

    /// A builder for [`Job`](crate::model::Job).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::JobType>,
        pub(crate) initiated_by: std::option::Option<crate::model::InitiatedBy>,
        pub(crate) creation_date_time: std::option::Option<std::string::String>,
        pub(crate) end_date_time: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::JobStatus>,
        pub(crate) participating_servers:
            std::option::Option<std::vec::Vec<crate::model::ParticipatingServer>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID of the Job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the Job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The ARN of a Job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of a Job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of the Job.</p>
        pub fn r#type(mut self, input: crate::model::JobType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the Job.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::JobType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A string representing who initiated the Job.</p>
        pub fn initiated_by(mut self, input: crate::model::InitiatedBy) -> Self {
            self.initiated_by = Some(input);
            self
        }
        /// <p>A string representing who initiated the Job.</p>
        pub fn set_initiated_by(
            mut self,
            input: std::option::Option<crate::model::InitiatedBy>,
        ) -> Self {
            self.initiated_by = input;
            self
        }
        /// <p>The date and time of when the Job was created.</p>
        pub fn creation_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of when the Job was created.</p>
        pub fn set_creation_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date_time = input;
            self
        }
        /// <p>The date and time of when the Job ended.</p>
        pub fn end_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of when the Job ended.</p>
        pub fn set_end_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.end_date_time = input;
            self
        }
        /// <p>The status of the Job.</p>
        pub fn status(mut self, input: crate::model::JobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the Job.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::JobStatus>) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `participating_servers`.
        ///
        /// To override the contents of this collection use [`set_participating_servers`](Self::set_participating_servers).
        ///
        /// <p>A list of servers that the Job is acting upon.</p>
        pub fn participating_servers(mut self, input: crate::model::ParticipatingServer) -> Self {
            let mut v = self.participating_servers.unwrap_or_default();
            v.push(input);
            self.participating_servers = Some(v);
            self
        }
        /// <p>A list of servers that the Job is acting upon.</p>
        pub fn set_participating_servers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ParticipatingServer>>,
        ) -> Self {
            self.participating_servers = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tags associated with the Job.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A list of tags associated with the Job.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Job`](crate::model::Job).
        pub fn build(self) -> crate::model::Job {
            crate::model::Job {
                job_id: self.job_id,
                arn: self.arn,
                r#type: self.r#type,
                initiated_by: self.initiated_by,
                creation_date_time: self.creation_date_time,
                end_date_time: self.end_date_time,
                status: self.status,
                participating_servers: self.participating_servers,
                tags: self.tags,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("job_id", &self.job_id);
            formatter.field("arn", &self.arn);
            formatter.field("r#type", &self.r#type);
            formatter.field("initiated_by", &self.initiated_by);
            formatter.field("creation_date_time", &self.creation_date_time);
            formatter.field("end_date_time", &self.end_date_time);
            formatter.field("status", &self.status);
            formatter.field("participating_servers", &self.participating_servers);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Job {
    /// Creates a new builder-style object to manufacture [`Job`](crate::model::Job).
    pub fn builder() -> crate::model::job::Builder {
        crate::model::job::Builder::default()
    }
}

/// <p>Represents a server participating in an asynchronous Job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParticipatingServer {
    /// <p>The Source Server ID of a participating server.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>The Recovery Instance ID of a participating server.</p>
    #[doc(hidden)]
    pub recovery_instance_id: std::option::Option<std::string::String>,
    /// <p>The launch status of a participating server.</p>
    #[doc(hidden)]
    pub launch_status: std::option::Option<crate::model::LaunchStatus>,
}
impl ParticipatingServer {
    /// <p>The Source Server ID of a participating server.</p>
    pub fn source_server_id(&self) -> std::option::Option<&str> {
        self.source_server_id.as_deref()
    }
    /// <p>The Recovery Instance ID of a participating server.</p>
    pub fn recovery_instance_id(&self) -> std::option::Option<&str> {
        self.recovery_instance_id.as_deref()
    }
    /// <p>The launch status of a participating server.</p>
    pub fn launch_status(&self) -> std::option::Option<&crate::model::LaunchStatus> {
        self.launch_status.as_ref()
    }
}
/// See [`ParticipatingServer`](crate::model::ParticipatingServer).
pub mod participating_server {

    /// A builder for [`ParticipatingServer`](crate::model::ParticipatingServer).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) recovery_instance_id: std::option::Option<std::string::String>,
        pub(crate) launch_status: std::option::Option<crate::model::LaunchStatus>,
    }
    impl Builder {
        /// <p>The Source Server ID of a participating server.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>The Source Server ID of a participating server.</p>
        pub fn set_source_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_server_id = input;
            self
        }
        /// <p>The Recovery Instance ID of a participating server.</p>
        pub fn recovery_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_instance_id = Some(input.into());
            self
        }
        /// <p>The Recovery Instance ID of a participating server.</p>
        pub fn set_recovery_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_instance_id = input;
            self
        }
        /// <p>The launch status of a participating server.</p>
        pub fn launch_status(mut self, input: crate::model::LaunchStatus) -> Self {
            self.launch_status = Some(input);
            self
        }
        /// <p>The launch status of a participating server.</p>
        pub fn set_launch_status(
            mut self,
            input: std::option::Option<crate::model::LaunchStatus>,
        ) -> Self {
            self.launch_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ParticipatingServer`](crate::model::ParticipatingServer).
        pub fn build(self) -> crate::model::ParticipatingServer {
            crate::model::ParticipatingServer {
                source_server_id: self.source_server_id,
                recovery_instance_id: self.recovery_instance_id,
                launch_status: self.launch_status,
            }
        }
    }
}
impl ParticipatingServer {
    /// Creates a new builder-style object to manufacture [`ParticipatingServer`](crate::model::ParticipatingServer).
    pub fn builder() -> crate::model::participating_server::Builder {
        crate::model::participating_server::Builder::default()
    }
}

/// When writing a match expression against `LaunchStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchstatus = unimplemented!();
/// match launchstatus {
///     LaunchStatus::Failed => { /* ... */ },
///     LaunchStatus::InProgress => { /* ... */ },
///     LaunchStatus::Launched => { /* ... */ },
///     LaunchStatus::Pending => { /* ... */ },
///     LaunchStatus::Terminated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchStatus::NewFeature` is defined.
/// Specifically, when `launchstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Launched,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => LaunchStatus::Failed,
            "IN_PROGRESS" => LaunchStatus::InProgress,
            "LAUNCHED" => LaunchStatus::Launched,
            "PENDING" => LaunchStatus::Pending,
            "TERMINATED" => LaunchStatus::Terminated,
            other => LaunchStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LaunchStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchStatus::from(s))
    }
}
impl LaunchStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchStatus::Failed => "FAILED",
            LaunchStatus::InProgress => "IN_PROGRESS",
            LaunchStatus::Launched => "LAUNCHED",
            LaunchStatus::Pending => "PENDING",
            LaunchStatus::Terminated => "TERMINATED",
            LaunchStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "LAUNCHED", "PENDING", "TERMINATED"]
    }
}
impl AsRef<str> for LaunchStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `JobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobstatus = unimplemented!();
/// match jobstatus {
///     JobStatus::Completed => { /* ... */ },
///     JobStatus::Pending => { /* ... */ },
///     JobStatus::Started => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobStatus::NewFeature` is defined.
/// Specifically, when `jobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => JobStatus::Completed,
            "PENDING" => JobStatus::Pending,
            "STARTED" => JobStatus::Started,
            other => JobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobStatus::from(s))
    }
}
impl JobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobStatus::Completed => "COMPLETED",
            JobStatus::Pending => "PENDING",
            JobStatus::Started => "STARTED",
            JobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "PENDING", "STARTED"]
    }
}
impl AsRef<str> for JobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `InitiatedBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let initiatedby = unimplemented!();
/// match initiatedby {
///     InitiatedBy::Diagnostic => { /* ... */ },
///     InitiatedBy::Failback => { /* ... */ },
///     InitiatedBy::StartDrill => { /* ... */ },
///     InitiatedBy::StartRecovery => { /* ... */ },
///     InitiatedBy::TargetAccount => { /* ... */ },
///     InitiatedBy::TerminateRecoveryInstances => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `initiatedby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `InitiatedBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `InitiatedBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `InitiatedBy::NewFeature` is defined.
/// Specifically, when `initiatedby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `InitiatedBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InitiatedBy {
    #[allow(missing_docs)] // documentation missing in model
    Diagnostic,
    #[allow(missing_docs)] // documentation missing in model
    Failback,
    #[allow(missing_docs)] // documentation missing in model
    StartDrill,
    #[allow(missing_docs)] // documentation missing in model
    StartRecovery,
    #[allow(missing_docs)] // documentation missing in model
    TargetAccount,
    #[allow(missing_docs)] // documentation missing in model
    TerminateRecoveryInstances,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for InitiatedBy {
    fn from(s: &str) -> Self {
        match s {
            "DIAGNOSTIC" => InitiatedBy::Diagnostic,
            "FAILBACK" => InitiatedBy::Failback,
            "START_DRILL" => InitiatedBy::StartDrill,
            "START_RECOVERY" => InitiatedBy::StartRecovery,
            "TARGET_ACCOUNT" => InitiatedBy::TargetAccount,
            "TERMINATE_RECOVERY_INSTANCES" => InitiatedBy::TerminateRecoveryInstances,
            other => InitiatedBy::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for InitiatedBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InitiatedBy::from(s))
    }
}
impl InitiatedBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            InitiatedBy::Diagnostic => "DIAGNOSTIC",
            InitiatedBy::Failback => "FAILBACK",
            InitiatedBy::StartDrill => "START_DRILL",
            InitiatedBy::StartRecovery => "START_RECOVERY",
            InitiatedBy::TargetAccount => "TARGET_ACCOUNT",
            InitiatedBy::TerminateRecoveryInstances => "TERMINATE_RECOVERY_INSTANCES",
            InitiatedBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DIAGNOSTIC",
            "FAILBACK",
            "START_DRILL",
            "START_RECOVERY",
            "TARGET_ACCOUNT",
            "TERMINATE_RECOVERY_INSTANCES",
        ]
    }
}
impl AsRef<str> for InitiatedBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `JobType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobtype = unimplemented!();
/// match jobtype {
///     JobType::CreateConvertedSnapshot => { /* ... */ },
///     JobType::Launch => { /* ... */ },
///     JobType::Terminate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobType::NewFeature` is defined.
/// Specifically, when `jobtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobType {
    #[allow(missing_docs)] // documentation missing in model
    CreateConvertedSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    Launch,
    #[allow(missing_docs)] // documentation missing in model
    Terminate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_CONVERTED_SNAPSHOT" => JobType::CreateConvertedSnapshot,
            "LAUNCH" => JobType::Launch,
            "TERMINATE" => JobType::Terminate,
            other => JobType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobType::from(s))
    }
}
impl JobType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobType::CreateConvertedSnapshot => "CREATE_CONVERTED_SNAPSHOT",
            JobType::Launch => "LAUNCH",
            JobType::Terminate => "TERMINATE",
            JobType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATE_CONVERTED_SNAPSHOT", "LAUNCH", "TERMINATE"]
    }
}
impl AsRef<str> for JobType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object representing the Source Server to recover.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartRecoveryRequestSourceServer {
    /// <p>The ID of the Source Server you want to recover.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.</p>
    #[doc(hidden)]
    pub recovery_snapshot_id: std::option::Option<std::string::String>,
}
impl StartRecoveryRequestSourceServer {
    /// <p>The ID of the Source Server you want to recover.</p>
    pub fn source_server_id(&self) -> std::option::Option<&str> {
        self.source_server_id.as_deref()
    }
    /// <p>The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.</p>
    pub fn recovery_snapshot_id(&self) -> std::option::Option<&str> {
        self.recovery_snapshot_id.as_deref()
    }
}
/// See [`StartRecoveryRequestSourceServer`](crate::model::StartRecoveryRequestSourceServer).
pub mod start_recovery_request_source_server {

    /// A builder for [`StartRecoveryRequestSourceServer`](crate::model::StartRecoveryRequestSourceServer).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) recovery_snapshot_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Source Server you want to recover.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>The ID of the Source Server you want to recover.</p>
        pub fn set_source_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_server_id = input;
            self
        }
        /// <p>The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.</p>
        pub fn recovery_snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_snapshot_id = Some(input.into());
            self
        }
        /// <p>The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.</p>
        pub fn set_recovery_snapshot_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_snapshot_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRecoveryRequestSourceServer`](crate::model::StartRecoveryRequestSourceServer).
        pub fn build(self) -> crate::model::StartRecoveryRequestSourceServer {
            crate::model::StartRecoveryRequestSourceServer {
                source_server_id: self.source_server_id,
                recovery_snapshot_id: self.recovery_snapshot_id,
            }
        }
    }
}
impl StartRecoveryRequestSourceServer {
    /// Creates a new builder-style object to manufacture [`StartRecoveryRequestSourceServer`](crate::model::StartRecoveryRequestSourceServer).
    pub fn builder() -> crate::model::start_recovery_request_source_server::Builder {
        crate::model::start_recovery_request_source_server::Builder::default()
    }
}

/// <p>A set of filters by which to return Source Servers.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeSourceServersRequestFilters {
    /// <p>An array of Source Servers IDs that should be returned. An empty array means all Source Servers.</p>
    #[doc(hidden)]
    pub source_server_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.</p>
    #[doc(hidden)]
    pub hardware_id: std::option::Option<std::string::String>,
    /// <p>An array of staging account IDs that extended source servers belong to. An empty array means all source servers will be shown.</p>
    #[doc(hidden)]
    pub staging_account_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DescribeSourceServersRequestFilters {
    /// <p>An array of Source Servers IDs that should be returned. An empty array means all Source Servers.</p>
    pub fn source_server_i_ds(&self) -> std::option::Option<&[std::string::String]> {
        self.source_server_i_ds.as_deref()
    }
    /// <p>An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.</p>
    pub fn hardware_id(&self) -> std::option::Option<&str> {
        self.hardware_id.as_deref()
    }
    /// <p>An array of staging account IDs that extended source servers belong to. An empty array means all source servers will be shown.</p>
    pub fn staging_account_i_ds(&self) -> std::option::Option<&[std::string::String]> {
        self.staging_account_i_ds.as_deref()
    }
}
/// See [`DescribeSourceServersRequestFilters`](crate::model::DescribeSourceServersRequestFilters).
pub mod describe_source_servers_request_filters {

    /// A builder for [`DescribeSourceServersRequestFilters`](crate::model::DescribeSourceServersRequestFilters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_server_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) hardware_id: std::option::Option<std::string::String>,
        pub(crate) staging_account_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `source_server_i_ds`.
        ///
        /// To override the contents of this collection use [`set_source_server_i_ds`](Self::set_source_server_i_ds).
        ///
        /// <p>An array of Source Servers IDs that should be returned. An empty array means all Source Servers.</p>
        pub fn source_server_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_server_i_ds.unwrap_or_default();
            v.push(input.into());
            self.source_server_i_ds = Some(v);
            self
        }
        /// <p>An array of Source Servers IDs that should be returned. An empty array means all Source Servers.</p>
        pub fn set_source_server_i_ds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_server_i_ds = input;
            self
        }
        /// <p>An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.</p>
        pub fn hardware_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hardware_id = Some(input.into());
            self
        }
        /// <p>An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.</p>
        pub fn set_hardware_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hardware_id = input;
            self
        }
        /// Appends an item to `staging_account_i_ds`.
        ///
        /// To override the contents of this collection use [`set_staging_account_i_ds`](Self::set_staging_account_i_ds).
        ///
        /// <p>An array of staging account IDs that extended source servers belong to. An empty array means all source servers will be shown.</p>
        pub fn staging_account_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.staging_account_i_ds.unwrap_or_default();
            v.push(input.into());
            self.staging_account_i_ds = Some(v);
            self
        }
        /// <p>An array of staging account IDs that extended source servers belong to. An empty array means all source servers will be shown.</p>
        pub fn set_staging_account_i_ds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.staging_account_i_ds = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSourceServersRequestFilters`](crate::model::DescribeSourceServersRequestFilters).
        pub fn build(self) -> crate::model::DescribeSourceServersRequestFilters {
            crate::model::DescribeSourceServersRequestFilters {
                source_server_i_ds: self.source_server_i_ds,
                hardware_id: self.hardware_id,
                staging_account_i_ds: self.staging_account_i_ds,
            }
        }
    }
}
impl DescribeSourceServersRequestFilters {
    /// Creates a new builder-style object to manufacture [`DescribeSourceServersRequestFilters`](crate::model::DescribeSourceServersRequestFilters).
    pub fn builder() -> crate::model::describe_source_servers_request_filters::Builder {
        crate::model::describe_source_servers_request_filters::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationConfigurationTemplate {
    /// <p>The Replication Configuration Template ID.</p>
    #[doc(hidden)]
    pub replication_configuration_template_id: std::option::Option<std::string::String>,
    /// <p>The Replication Configuration Template ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The subnet to be used by the replication staging area.</p>
    #[doc(hidden)]
    pub staging_area_subnet_id: std::option::Option<std::string::String>,
    /// <p>Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.</p>
    #[doc(hidden)]
    pub associate_default_security_group: std::option::Option<bool>,
    /// <p>The security group IDs that will be used by the replication server.</p>
    #[doc(hidden)]
    pub replication_servers_security_groups_i_ds:
        std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The instance type to be used for the replication server.</p>
    #[doc(hidden)]
    pub replication_server_instance_type: std::option::Option<std::string::String>,
    /// <p>Whether to use a dedicated Replication Server in the replication staging area.</p>
    #[doc(hidden)]
    pub use_dedicated_replication_server: std::option::Option<bool>,
    /// <p>The Staging Disk EBS volume type to be used during replication.</p>
    #[doc(hidden)]
    pub default_large_staging_disk_type:
        std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
    /// <p>The type of EBS encryption to be used during replication.</p>
    #[doc(hidden)]
    pub ebs_encryption: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
    /// <p>The ARN of the EBS encryption key to be used during replication.</p>
    #[doc(hidden)]
    pub ebs_encryption_key_arn: std::option::Option<std::string::String>,
    /// <p>Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.</p>
    #[doc(hidden)]
    pub bandwidth_throttling: i64,
    /// <p>The data plane routing mechanism that will be used for replication.</p>
    #[doc(hidden)]
    pub data_plane_routing:
        std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
    /// <p>Whether to create a Public IP for the Recovery Instance by default.</p>
    #[doc(hidden)]
    pub create_public_ip: std::option::Option<bool>,
    /// <p>A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.</p>
    #[doc(hidden)]
    pub staging_area_tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A set of tags to be associated with the Replication Configuration Template resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Point in time (PIT) policy to manage snapshots taken during replication.</p>
    #[doc(hidden)]
    pub pit_policy: std::option::Option<std::vec::Vec<crate::model::PitPolicyRule>>,
}
impl ReplicationConfigurationTemplate {
    /// <p>The Replication Configuration Template ID.</p>
    pub fn replication_configuration_template_id(&self) -> std::option::Option<&str> {
        self.replication_configuration_template_id.as_deref()
    }
    /// <p>The Replication Configuration Template ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The subnet to be used by the replication staging area.</p>
    pub fn staging_area_subnet_id(&self) -> std::option::Option<&str> {
        self.staging_area_subnet_id.as_deref()
    }
    /// <p>Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.</p>
    pub fn associate_default_security_group(&self) -> std::option::Option<bool> {
        self.associate_default_security_group
    }
    /// <p>The security group IDs that will be used by the replication server.</p>
    pub fn replication_servers_security_groups_i_ds(
        &self,
    ) -> std::option::Option<&[std::string::String]> {
        self.replication_servers_security_groups_i_ds.as_deref()
    }
    /// <p>The instance type to be used for the replication server.</p>
    pub fn replication_server_instance_type(&self) -> std::option::Option<&str> {
        self.replication_server_instance_type.as_deref()
    }
    /// <p>Whether to use a dedicated Replication Server in the replication staging area.</p>
    pub fn use_dedicated_replication_server(&self) -> std::option::Option<bool> {
        self.use_dedicated_replication_server
    }
    /// <p>The Staging Disk EBS volume type to be used during replication.</p>
    pub fn default_large_staging_disk_type(
        &self,
    ) -> std::option::Option<&crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>
    {
        self.default_large_staging_disk_type.as_ref()
    }
    /// <p>The type of EBS encryption to be used during replication.</p>
    pub fn ebs_encryption(
        &self,
    ) -> std::option::Option<&crate::model::ReplicationConfigurationEbsEncryption> {
        self.ebs_encryption.as_ref()
    }
    /// <p>The ARN of the EBS encryption key to be used during replication.</p>
    pub fn ebs_encryption_key_arn(&self) -> std::option::Option<&str> {
        self.ebs_encryption_key_arn.as_deref()
    }
    /// <p>Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.</p>
    pub fn bandwidth_throttling(&self) -> i64 {
        self.bandwidth_throttling
    }
    /// <p>The data plane routing mechanism that will be used for replication.</p>
    pub fn data_plane_routing(
        &self,
    ) -> std::option::Option<&crate::model::ReplicationConfigurationDataPlaneRouting> {
        self.data_plane_routing.as_ref()
    }
    /// <p>Whether to create a Public IP for the Recovery Instance by default.</p>
    pub fn create_public_ip(&self) -> std::option::Option<bool> {
        self.create_public_ip
    }
    /// <p>A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.</p>
    pub fn staging_area_tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.staging_area_tags.as_ref()
    }
    /// <p>A set of tags to be associated with the Replication Configuration Template resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The Point in time (PIT) policy to manage snapshots taken during replication.</p>
    pub fn pit_policy(&self) -> std::option::Option<&[crate::model::PitPolicyRule]> {
        self.pit_policy.as_deref()
    }
}
impl std::fmt::Debug for ReplicationConfigurationTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationConfigurationTemplate");
        formatter.field(
            "replication_configuration_template_id",
            &self.replication_configuration_template_id,
        );
        formatter.field("arn", &self.arn);
        formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
        formatter.field(
            "associate_default_security_group",
            &self.associate_default_security_group,
        );
        formatter.field(
            "replication_servers_security_groups_i_ds",
            &self.replication_servers_security_groups_i_ds,
        );
        formatter.field(
            "replication_server_instance_type",
            &self.replication_server_instance_type,
        );
        formatter.field(
            "use_dedicated_replication_server",
            &self.use_dedicated_replication_server,
        );
        formatter.field(
            "default_large_staging_disk_type",
            &self.default_large_staging_disk_type,
        );
        formatter.field("ebs_encryption", &self.ebs_encryption);
        formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
        formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
        formatter.field("data_plane_routing", &self.data_plane_routing);
        formatter.field("create_public_ip", &self.create_public_ip);
        formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("pit_policy", &self.pit_policy);
        formatter.finish()
    }
}
/// See [`ReplicationConfigurationTemplate`](crate::model::ReplicationConfigurationTemplate).
pub mod replication_configuration_template {

    /// A builder for [`ReplicationConfigurationTemplate`](crate::model::ReplicationConfigurationTemplate).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) replication_configuration_template_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) staging_area_subnet_id: std::option::Option<std::string::String>,
        pub(crate) associate_default_security_group: std::option::Option<bool>,
        pub(crate) replication_servers_security_groups_i_ds:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) replication_server_instance_type: std::option::Option<std::string::String>,
        pub(crate) use_dedicated_replication_server: std::option::Option<bool>,
        pub(crate) default_large_staging_disk_type:
            std::option::Option<crate::model::ReplicationConfigurationDefaultLargeStagingDiskType>,
        pub(crate) ebs_encryption:
            std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
        pub(crate) ebs_encryption_key_arn: std::option::Option<std::string::String>,
        pub(crate) bandwidth_throttling: std::option::Option<i64>,
        pub(crate) data_plane_routing:
            std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
        pub(crate) create_public_ip: std::option::Option<bool>,
        pub(crate) staging_area_tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) pit_policy: std::option::Option<std::vec::Vec<crate::model::PitPolicyRule>>,
    }
    impl Builder {
        /// <p>The Replication Configuration Template ID.</p>
        pub fn replication_configuration_template_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.replication_configuration_template_id = Some(input.into());
            self
        }
        /// <p>The Replication Configuration Template ID.</p>
        pub fn set_replication_configuration_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replication_configuration_template_id = input;
            self
        }
        /// <p>The Replication Configuration Template ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Replication Configuration Template ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The subnet to be used by the replication staging area.</p>
        pub fn staging_area_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.staging_area_subnet_id = Some(input.into());
            self
        }
        /// <p>The subnet to be used by the replication staging area.</p>
        pub fn set_staging_area_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.staging_area_subnet_id = input;
            self
        }
        /// <p>Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.</p>
        pub fn associate_default_security_group(mut self, input: bool) -> Self {
            self.associate_default_security_group = Some(input);
            self
        }
        /// <p>Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.</p>
        pub fn set_associate_default_security_group(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.associate_default_security_group = input;
            self
        }
        /// Appends an item to `replication_servers_security_groups_i_ds`.
        ///
        /// To override the contents of this collection use [`set_replication_servers_security_groups_i_ds`](Self::set_replication_servers_security_groups_i_ds).
        ///
        /// <p>The security group IDs that will be used by the replication server.</p>
        pub fn replication_servers_security_groups_i_ds(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self
                .replication_servers_security_groups_i_ds
                .unwrap_or_default();
            v.push(input.into());
            self.replication_servers_security_groups_i_ds = Some(v);
            self
        }
        /// <p>The security group IDs that will be used by the replication server.</p>
        pub fn set_replication_servers_security_groups_i_ds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.replication_servers_security_groups_i_ds = input;
            self
        }
        /// <p>The instance type to be used for the replication server.</p>
        pub fn replication_server_instance_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.replication_server_instance_type = Some(input.into());
            self
        }
        /// <p>The instance type to be used for the replication server.</p>
        pub fn set_replication_server_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.replication_server_instance_type = input;
            self
        }
        /// <p>Whether to use a dedicated Replication Server in the replication staging area.</p>
        pub fn use_dedicated_replication_server(mut self, input: bool) -> Self {
            self.use_dedicated_replication_server = Some(input);
            self
        }
        /// <p>Whether to use a dedicated Replication Server in the replication staging area.</p>
        pub fn set_use_dedicated_replication_server(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.use_dedicated_replication_server = input;
            self
        }
        /// <p>The Staging Disk EBS volume type to be used during replication.</p>
        pub fn default_large_staging_disk_type(
            mut self,
            input: crate::model::ReplicationConfigurationDefaultLargeStagingDiskType,
        ) -> Self {
            self.default_large_staging_disk_type = Some(input);
            self
        }
        /// <p>The Staging Disk EBS volume type to be used during replication.</p>
        pub fn set_default_large_staging_disk_type(
            mut self,
            input: std::option::Option<
                crate::model::ReplicationConfigurationDefaultLargeStagingDiskType,
            >,
        ) -> Self {
            self.default_large_staging_disk_type = input;
            self
        }
        /// <p>The type of EBS encryption to be used during replication.</p>
        pub fn ebs_encryption(
            mut self,
            input: crate::model::ReplicationConfigurationEbsEncryption,
        ) -> Self {
            self.ebs_encryption = Some(input);
            self
        }
        /// <p>The type of EBS encryption to be used during replication.</p>
        pub fn set_ebs_encryption(
            mut self,
            input: std::option::Option<crate::model::ReplicationConfigurationEbsEncryption>,
        ) -> Self {
            self.ebs_encryption = input;
            self
        }
        /// <p>The ARN of the EBS encryption key to be used during replication.</p>
        pub fn ebs_encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_encryption_key_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the EBS encryption key to be used during replication.</p>
        pub fn set_ebs_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ebs_encryption_key_arn = input;
            self
        }
        /// <p>Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.</p>
        pub fn bandwidth_throttling(mut self, input: i64) -> Self {
            self.bandwidth_throttling = Some(input);
            self
        }
        /// <p>Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.</p>
        pub fn set_bandwidth_throttling(mut self, input: std::option::Option<i64>) -> Self {
            self.bandwidth_throttling = input;
            self
        }
        /// <p>The data plane routing mechanism that will be used for replication.</p>
        pub fn data_plane_routing(
            mut self,
            input: crate::model::ReplicationConfigurationDataPlaneRouting,
        ) -> Self {
            self.data_plane_routing = Some(input);
            self
        }
        /// <p>The data plane routing mechanism that will be used for replication.</p>
        pub fn set_data_plane_routing(
            mut self,
            input: std::option::Option<crate::model::ReplicationConfigurationDataPlaneRouting>,
        ) -> Self {
            self.data_plane_routing = input;
            self
        }
        /// <p>Whether to create a Public IP for the Recovery Instance by default.</p>
        pub fn create_public_ip(mut self, input: bool) -> Self {
            self.create_public_ip = Some(input);
            self
        }
        /// <p>Whether to create a Public IP for the Recovery Instance by default.</p>
        pub fn set_create_public_ip(mut self, input: std::option::Option<bool>) -> Self {
            self.create_public_ip = input;
            self
        }
        /// Adds a key-value pair to `staging_area_tags`.
        ///
        /// To override the contents of this collection use [`set_staging_area_tags`](Self::set_staging_area_tags).
        ///
        /// <p>A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.</p>
        pub fn staging_area_tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.staging_area_tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.staging_area_tags = Some(hash_map);
            self
        }
        /// <p>A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.</p>
        pub fn set_staging_area_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.staging_area_tags = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A set of tags to be associated with the Replication Configuration Template resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A set of tags to be associated with the Replication Configuration Template resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `pit_policy`.
        ///
        /// To override the contents of this collection use [`set_pit_policy`](Self::set_pit_policy).
        ///
        /// <p>The Point in time (PIT) policy to manage snapshots taken during replication.</p>
        pub fn pit_policy(mut self, input: crate::model::PitPolicyRule) -> Self {
            let mut v = self.pit_policy.unwrap_or_default();
            v.push(input);
            self.pit_policy = Some(v);
            self
        }
        /// <p>The Point in time (PIT) policy to manage snapshots taken during replication.</p>
        pub fn set_pit_policy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PitPolicyRule>>,
        ) -> Self {
            self.pit_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationConfigurationTemplate`](crate::model::ReplicationConfigurationTemplate).
        pub fn build(self) -> crate::model::ReplicationConfigurationTemplate {
            crate::model::ReplicationConfigurationTemplate {
                replication_configuration_template_id: self.replication_configuration_template_id,
                arn: self.arn,
                staging_area_subnet_id: self.staging_area_subnet_id,
                associate_default_security_group: self.associate_default_security_group,
                replication_servers_security_groups_i_ds: self
                    .replication_servers_security_groups_i_ds,
                replication_server_instance_type: self.replication_server_instance_type,
                use_dedicated_replication_server: self.use_dedicated_replication_server,
                default_large_staging_disk_type: self.default_large_staging_disk_type,
                ebs_encryption: self.ebs_encryption,
                ebs_encryption_key_arn: self.ebs_encryption_key_arn,
                bandwidth_throttling: self.bandwidth_throttling.unwrap_or_default(),
                data_plane_routing: self.data_plane_routing,
                create_public_ip: self.create_public_ip,
                staging_area_tags: self.staging_area_tags,
                tags: self.tags,
                pit_policy: self.pit_policy,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field(
                "replication_configuration_template_id",
                &self.replication_configuration_template_id,
            );
            formatter.field("arn", &self.arn);
            formatter.field("staging_area_subnet_id", &self.staging_area_subnet_id);
            formatter.field(
                "associate_default_security_group",
                &self.associate_default_security_group,
            );
            formatter.field(
                "replication_servers_security_groups_i_ds",
                &self.replication_servers_security_groups_i_ds,
            );
            formatter.field(
                "replication_server_instance_type",
                &self.replication_server_instance_type,
            );
            formatter.field(
                "use_dedicated_replication_server",
                &self.use_dedicated_replication_server,
            );
            formatter.field(
                "default_large_staging_disk_type",
                &self.default_large_staging_disk_type,
            );
            formatter.field("ebs_encryption", &self.ebs_encryption);
            formatter.field("ebs_encryption_key_arn", &self.ebs_encryption_key_arn);
            formatter.field("bandwidth_throttling", &self.bandwidth_throttling);
            formatter.field("data_plane_routing", &self.data_plane_routing);
            formatter.field("create_public_ip", &self.create_public_ip);
            formatter.field("staging_area_tags", &"*** Sensitive Data Redacted ***");
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("pit_policy", &self.pit_policy);
            formatter.finish()
        }
    }
}
impl ReplicationConfigurationTemplate {
    /// Creates a new builder-style object to manufacture [`ReplicationConfigurationTemplate`](crate::model::ReplicationConfigurationTemplate).
    pub fn builder() -> crate::model::replication_configuration_template::Builder {
        crate::model::replication_configuration_template::Builder::default()
    }
}

/// <p>A Recovery Instance is a replica of a Source Server running on EC2.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecoveryInstance {
    /// <p>The EC2 instance ID of the Recovery Instance.</p>
    #[doc(hidden)]
    pub ec2_instance_id: std::option::Option<std::string::String>,
    /// <p>The state of the EC2 instance for this Recovery Instance.</p>
    #[doc(hidden)]
    pub ec2_instance_state: std::option::Option<crate::model::Ec2InstanceState>,
    /// <p>The ID of the Job that created the Recovery Instance.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Recovery Instance.</p>
    #[doc(hidden)]
    pub recovery_instance_id: std::option::Option<std::string::String>,
    /// <p>The Source Server ID that this Recovery Instance is associated with.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the Recovery Instance.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>An array of tags that are associated with the Recovery Instance.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An object representing failback related information of the Recovery Instance.</p>
    #[doc(hidden)]
    pub failback: std::option::Option<crate::model::RecoveryInstanceFailback>,
    /// <p>The Data Replication Info of the Recovery Instance.</p>
    #[doc(hidden)]
    pub data_replication_info:
        std::option::Option<crate::model::RecoveryInstanceDataReplicationInfo>,
    /// <p>Properties of the Recovery Instance machine.</p>
    #[doc(hidden)]
    pub recovery_instance_properties: std::option::Option<crate::model::RecoveryInstanceProperties>,
    /// <p>The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.</p>
    #[doc(hidden)]
    pub point_in_time_snapshot_date_time: std::option::Option<std::string::String>,
    /// <p>Whether this Recovery Instance was created for a drill or for an actual Recovery event.</p>
    #[doc(hidden)]
    pub is_drill: std::option::Option<bool>,
    /// <p>Environment (On Premises / AWS) of the instance that the recovery instance originated from. </p>
    #[doc(hidden)]
    pub origin_environment: std::option::Option<crate::model::OriginEnvironment>,
}
impl RecoveryInstance {
    /// <p>The EC2 instance ID of the Recovery Instance.</p>
    pub fn ec2_instance_id(&self) -> std::option::Option<&str> {
        self.ec2_instance_id.as_deref()
    }
    /// <p>The state of the EC2 instance for this Recovery Instance.</p>
    pub fn ec2_instance_state(&self) -> std::option::Option<&crate::model::Ec2InstanceState> {
        self.ec2_instance_state.as_ref()
    }
    /// <p>The ID of the Job that created the Recovery Instance.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The ID of the Recovery Instance.</p>
    pub fn recovery_instance_id(&self) -> std::option::Option<&str> {
        self.recovery_instance_id.as_deref()
    }
    /// <p>The Source Server ID that this Recovery Instance is associated with.</p>
    pub fn source_server_id(&self) -> std::option::Option<&str> {
        self.source_server_id.as_deref()
    }
    /// <p>The ARN of the Recovery Instance.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>An array of tags that are associated with the Recovery Instance.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>An object representing failback related information of the Recovery Instance.</p>
    pub fn failback(&self) -> std::option::Option<&crate::model::RecoveryInstanceFailback> {
        self.failback.as_ref()
    }
    /// <p>The Data Replication Info of the Recovery Instance.</p>
    pub fn data_replication_info(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceDataReplicationInfo> {
        self.data_replication_info.as_ref()
    }
    /// <p>Properties of the Recovery Instance machine.</p>
    pub fn recovery_instance_properties(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceProperties> {
        self.recovery_instance_properties.as_ref()
    }
    /// <p>The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.</p>
    pub fn point_in_time_snapshot_date_time(&self) -> std::option::Option<&str> {
        self.point_in_time_snapshot_date_time.as_deref()
    }
    /// <p>Whether this Recovery Instance was created for a drill or for an actual Recovery event.</p>
    pub fn is_drill(&self) -> std::option::Option<bool> {
        self.is_drill
    }
    /// <p>Environment (On Premises / AWS) of the instance that the recovery instance originated from. </p>
    pub fn origin_environment(&self) -> std::option::Option<&crate::model::OriginEnvironment> {
        self.origin_environment.as_ref()
    }
}
impl std::fmt::Debug for RecoveryInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecoveryInstance");
        formatter.field("ec2_instance_id", &self.ec2_instance_id);
        formatter.field("ec2_instance_state", &self.ec2_instance_state);
        formatter.field("job_id", &self.job_id);
        formatter.field("recovery_instance_id", &self.recovery_instance_id);
        formatter.field("source_server_id", &self.source_server_id);
        formatter.field("arn", &self.arn);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.field("failback", &self.failback);
        formatter.field("data_replication_info", &self.data_replication_info);
        formatter.field(
            "recovery_instance_properties",
            &self.recovery_instance_properties,
        );
        formatter.field(
            "point_in_time_snapshot_date_time",
            &self.point_in_time_snapshot_date_time,
        );
        formatter.field("is_drill", &self.is_drill);
        formatter.field("origin_environment", &self.origin_environment);
        formatter.finish()
    }
}
/// See [`RecoveryInstance`](crate::model::RecoveryInstance).
pub mod recovery_instance {

    /// A builder for [`RecoveryInstance`](crate::model::RecoveryInstance).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) ec2_instance_id: std::option::Option<std::string::String>,
        pub(crate) ec2_instance_state: std::option::Option<crate::model::Ec2InstanceState>,
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) recovery_instance_id: std::option::Option<std::string::String>,
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) failback: std::option::Option<crate::model::RecoveryInstanceFailback>,
        pub(crate) data_replication_info:
            std::option::Option<crate::model::RecoveryInstanceDataReplicationInfo>,
        pub(crate) recovery_instance_properties:
            std::option::Option<crate::model::RecoveryInstanceProperties>,
        pub(crate) point_in_time_snapshot_date_time: std::option::Option<std::string::String>,
        pub(crate) is_drill: std::option::Option<bool>,
        pub(crate) origin_environment: std::option::Option<crate::model::OriginEnvironment>,
    }
    impl Builder {
        /// <p>The EC2 instance ID of the Recovery Instance.</p>
        pub fn ec2_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_instance_id = Some(input.into());
            self
        }
        /// <p>The EC2 instance ID of the Recovery Instance.</p>
        pub fn set_ec2_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_instance_id = input;
            self
        }
        /// <p>The state of the EC2 instance for this Recovery Instance.</p>
        pub fn ec2_instance_state(mut self, input: crate::model::Ec2InstanceState) -> Self {
            self.ec2_instance_state = Some(input);
            self
        }
        /// <p>The state of the EC2 instance for this Recovery Instance.</p>
        pub fn set_ec2_instance_state(
            mut self,
            input: std::option::Option<crate::model::Ec2InstanceState>,
        ) -> Self {
            self.ec2_instance_state = input;
            self
        }
        /// <p>The ID of the Job that created the Recovery Instance.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the Job that created the Recovery Instance.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The ID of the Recovery Instance.</p>
        pub fn recovery_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recovery_instance_id = Some(input.into());
            self
        }
        /// <p>The ID of the Recovery Instance.</p>
        pub fn set_recovery_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recovery_instance_id = input;
            self
        }
        /// <p>The Source Server ID that this Recovery Instance is associated with.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>The Source Server ID that this Recovery Instance is associated with.</p>
        pub fn set_source_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_server_id = input;
            self
        }
        /// <p>The ARN of the Recovery Instance.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Recovery Instance.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An array of tags that are associated with the Recovery Instance.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>An array of tags that are associated with the Recovery Instance.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>An object representing failback related information of the Recovery Instance.</p>
        pub fn failback(mut self, input: crate::model::RecoveryInstanceFailback) -> Self {
            self.failback = Some(input);
            self
        }
        /// <p>An object representing failback related information of the Recovery Instance.</p>
        pub fn set_failback(
            mut self,
            input: std::option::Option<crate::model::RecoveryInstanceFailback>,
        ) -> Self {
            self.failback = input;
            self
        }
        /// <p>The Data Replication Info of the Recovery Instance.</p>
        pub fn data_replication_info(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationInfo,
        ) -> Self {
            self.data_replication_info = Some(input);
            self
        }
        /// <p>The Data Replication Info of the Recovery Instance.</p>
        pub fn set_data_replication_info(
            mut self,
            input: std::option::Option<crate::model::RecoveryInstanceDataReplicationInfo>,
        ) -> Self {
            self.data_replication_info = input;
            self
        }
        /// <p>Properties of the Recovery Instance machine.</p>
        pub fn recovery_instance_properties(
            mut self,
            input: crate::model::RecoveryInstanceProperties,
        ) -> Self {
            self.recovery_instance_properties = Some(input);
            self
        }
        /// <p>Properties of the Recovery Instance machine.</p>
        pub fn set_recovery_instance_properties(
            mut self,
            input: std::option::Option<crate::model::RecoveryInstanceProperties>,
        ) -> Self {
            self.recovery_instance_properties = input;
            self
        }
        /// <p>The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.</p>
        pub fn point_in_time_snapshot_date_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.point_in_time_snapshot_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.</p>
        pub fn set_point_in_time_snapshot_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.point_in_time_snapshot_date_time = input;
            self
        }
        /// <p>Whether this Recovery Instance was created for a drill or for an actual Recovery event.</p>
        pub fn is_drill(mut self, input: bool) -> Self {
            self.is_drill = Some(input);
            self
        }
        /// <p>Whether this Recovery Instance was created for a drill or for an actual Recovery event.</p>
        pub fn set_is_drill(mut self, input: std::option::Option<bool>) -> Self {
            self.is_drill = input;
            self
        }
        /// <p>Environment (On Premises / AWS) of the instance that the recovery instance originated from. </p>
        pub fn origin_environment(mut self, input: crate::model::OriginEnvironment) -> Self {
            self.origin_environment = Some(input);
            self
        }
        /// <p>Environment (On Premises / AWS) of the instance that the recovery instance originated from. </p>
        pub fn set_origin_environment(
            mut self,
            input: std::option::Option<crate::model::OriginEnvironment>,
        ) -> Self {
            self.origin_environment = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstance`](crate::model::RecoveryInstance).
        pub fn build(self) -> crate::model::RecoveryInstance {
            crate::model::RecoveryInstance {
                ec2_instance_id: self.ec2_instance_id,
                ec2_instance_state: self.ec2_instance_state,
                job_id: self.job_id,
                recovery_instance_id: self.recovery_instance_id,
                source_server_id: self.source_server_id,
                arn: self.arn,
                tags: self.tags,
                failback: self.failback,
                data_replication_info: self.data_replication_info,
                recovery_instance_properties: self.recovery_instance_properties,
                point_in_time_snapshot_date_time: self.point_in_time_snapshot_date_time,
                is_drill: self.is_drill,
                origin_environment: self.origin_environment,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("ec2_instance_id", &self.ec2_instance_id);
            formatter.field("ec2_instance_state", &self.ec2_instance_state);
            formatter.field("job_id", &self.job_id);
            formatter.field("recovery_instance_id", &self.recovery_instance_id);
            formatter.field("source_server_id", &self.source_server_id);
            formatter.field("arn", &self.arn);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.field("failback", &self.failback);
            formatter.field("data_replication_info", &self.data_replication_info);
            formatter.field(
                "recovery_instance_properties",
                &self.recovery_instance_properties,
            );
            formatter.field(
                "point_in_time_snapshot_date_time",
                &self.point_in_time_snapshot_date_time,
            );
            formatter.field("is_drill", &self.is_drill);
            formatter.field("origin_environment", &self.origin_environment);
            formatter.finish()
        }
    }
}
impl RecoveryInstance {
    /// Creates a new builder-style object to manufacture [`RecoveryInstance`](crate::model::RecoveryInstance).
    pub fn builder() -> crate::model::recovery_instance::Builder {
        crate::model::recovery_instance::Builder::default()
    }
}

/// When writing a match expression against `OriginEnvironment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let originenvironment = unimplemented!();
/// match originenvironment {
///     OriginEnvironment::Aws => { /* ... */ },
///     OriginEnvironment::OnPremises => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `originenvironment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OriginEnvironment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OriginEnvironment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OriginEnvironment::NewFeature` is defined.
/// Specifically, when `originenvironment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OriginEnvironment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OriginEnvironment {
    #[allow(missing_docs)] // documentation missing in model
    Aws,
    #[allow(missing_docs)] // documentation missing in model
    OnPremises,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OriginEnvironment {
    fn from(s: &str) -> Self {
        match s {
            "AWS" => OriginEnvironment::Aws,
            "ON_PREMISES" => OriginEnvironment::OnPremises,
            other => {
                OriginEnvironment::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OriginEnvironment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OriginEnvironment::from(s))
    }
}
impl OriginEnvironment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OriginEnvironment::Aws => "AWS",
            OriginEnvironment::OnPremises => "ON_PREMISES",
            OriginEnvironment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS", "ON_PREMISES"]
    }
}
impl AsRef<str> for OriginEnvironment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Properties of the Recovery Instance machine.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceProperties {
    /// <p>The date and time the Recovery Instance properties were last updated on.</p>
    #[doc(hidden)]
    pub last_updated_date_time: std::option::Option<std::string::String>,
    /// <p>Hints used to uniquely identify a machine.</p>
    #[doc(hidden)]
    pub identification_hints: std::option::Option<crate::model::IdentificationHints>,
    /// <p>An array of network interfaces.</p>
    #[doc(hidden)]
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    /// <p>An array of disks.</p>
    #[doc(hidden)]
    pub disks: std::option::Option<std::vec::Vec<crate::model::RecoveryInstanceDisk>>,
    /// <p>An array of CPUs.</p>
    #[doc(hidden)]
    pub cpus: std::option::Option<std::vec::Vec<crate::model::Cpu>>,
    /// <p>The amount of RAM in bytes.</p>
    #[doc(hidden)]
    pub ram_bytes: i64,
    /// <p>Operating system.</p>
    #[doc(hidden)]
    pub os: std::option::Option<crate::model::Os>,
}
impl RecoveryInstanceProperties {
    /// <p>The date and time the Recovery Instance properties were last updated on.</p>
    pub fn last_updated_date_time(&self) -> std::option::Option<&str> {
        self.last_updated_date_time.as_deref()
    }
    /// <p>Hints used to uniquely identify a machine.</p>
    pub fn identification_hints(&self) -> std::option::Option<&crate::model::IdentificationHints> {
        self.identification_hints.as_ref()
    }
    /// <p>An array of network interfaces.</p>
    pub fn network_interfaces(&self) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces.as_deref()
    }
    /// <p>An array of disks.</p>
    pub fn disks(&self) -> std::option::Option<&[crate::model::RecoveryInstanceDisk]> {
        self.disks.as_deref()
    }
    /// <p>An array of CPUs.</p>
    pub fn cpus(&self) -> std::option::Option<&[crate::model::Cpu]> {
        self.cpus.as_deref()
    }
    /// <p>The amount of RAM in bytes.</p>
    pub fn ram_bytes(&self) -> i64 {
        self.ram_bytes
    }
    /// <p>Operating system.</p>
    pub fn os(&self) -> std::option::Option<&crate::model::Os> {
        self.os.as_ref()
    }
}
/// See [`RecoveryInstanceProperties`](crate::model::RecoveryInstanceProperties).
pub mod recovery_instance_properties {

    /// A builder for [`RecoveryInstanceProperties`](crate::model::RecoveryInstanceProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_updated_date_time: std::option::Option<std::string::String>,
        pub(crate) identification_hints: std::option::Option<crate::model::IdentificationHints>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        pub(crate) disks: std::option::Option<std::vec::Vec<crate::model::RecoveryInstanceDisk>>,
        pub(crate) cpus: std::option::Option<std::vec::Vec<crate::model::Cpu>>,
        pub(crate) ram_bytes: std::option::Option<i64>,
        pub(crate) os: std::option::Option<crate::model::Os>,
    }
    impl Builder {
        /// <p>The date and time the Recovery Instance properties were last updated on.</p>
        pub fn last_updated_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_date_time = Some(input.into());
            self
        }
        /// <p>The date and time the Recovery Instance properties were last updated on.</p>
        pub fn set_last_updated_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_date_time = input;
            self
        }
        /// <p>Hints used to uniquely identify a machine.</p>
        pub fn identification_hints(mut self, input: crate::model::IdentificationHints) -> Self {
            self.identification_hints = Some(input);
            self
        }
        /// <p>Hints used to uniquely identify a machine.</p>
        pub fn set_identification_hints(
            mut self,
            input: std::option::Option<crate::model::IdentificationHints>,
        ) -> Self {
            self.identification_hints = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>An array of network interfaces.</p>
        pub fn network_interfaces(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p>An array of network interfaces.</p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Appends an item to `disks`.
        ///
        /// To override the contents of this collection use [`set_disks`](Self::set_disks).
        ///
        /// <p>An array of disks.</p>
        pub fn disks(mut self, input: crate::model::RecoveryInstanceDisk) -> Self {
            let mut v = self.disks.unwrap_or_default();
            v.push(input);
            self.disks = Some(v);
            self
        }
        /// <p>An array of disks.</p>
        pub fn set_disks(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecoveryInstanceDisk>>,
        ) -> Self {
            self.disks = input;
            self
        }
        /// Appends an item to `cpus`.
        ///
        /// To override the contents of this collection use [`set_cpus`](Self::set_cpus).
        ///
        /// <p>An array of CPUs.</p>
        pub fn cpus(mut self, input: crate::model::Cpu) -> Self {
            let mut v = self.cpus.unwrap_or_default();
            v.push(input);
            self.cpus = Some(v);
            self
        }
        /// <p>An array of CPUs.</p>
        pub fn set_cpus(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Cpu>>,
        ) -> Self {
            self.cpus = input;
            self
        }
        /// <p>The amount of RAM in bytes.</p>
        pub fn ram_bytes(mut self, input: i64) -> Self {
            self.ram_bytes = Some(input);
            self
        }
        /// <p>The amount of RAM in bytes.</p>
        pub fn set_ram_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.ram_bytes = input;
            self
        }
        /// <p>Operating system.</p>
        pub fn os(mut self, input: crate::model::Os) -> Self {
            self.os = Some(input);
            self
        }
        /// <p>Operating system.</p>
        pub fn set_os(mut self, input: std::option::Option<crate::model::Os>) -> Self {
            self.os = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceProperties`](crate::model::RecoveryInstanceProperties).
        pub fn build(self) -> crate::model::RecoveryInstanceProperties {
            crate::model::RecoveryInstanceProperties {
                last_updated_date_time: self.last_updated_date_time,
                identification_hints: self.identification_hints,
                network_interfaces: self.network_interfaces,
                disks: self.disks,
                cpus: self.cpus,
                ram_bytes: self.ram_bytes.unwrap_or_default(),
                os: self.os,
            }
        }
    }
}
impl RecoveryInstanceProperties {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceProperties`](crate::model::RecoveryInstanceProperties).
    pub fn builder() -> crate::model::recovery_instance_properties::Builder {
        crate::model::recovery_instance_properties::Builder::default()
    }
}

/// <p>An object representing a block storage device on the Recovery Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceDisk {
    /// <p>The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.</p>
    #[doc(hidden)]
    pub internal_device_name: std::option::Option<std::string::String>,
    /// <p>The amount of storage on the disk in bytes.</p>
    #[doc(hidden)]
    pub bytes: i64,
    /// <p>The EBS Volume ID of this disk.</p>
    #[doc(hidden)]
    pub ebs_volume_id: std::option::Option<std::string::String>,
}
impl RecoveryInstanceDisk {
    /// <p>The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.</p>
    pub fn internal_device_name(&self) -> std::option::Option<&str> {
        self.internal_device_name.as_deref()
    }
    /// <p>The amount of storage on the disk in bytes.</p>
    pub fn bytes(&self) -> i64 {
        self.bytes
    }
    /// <p>The EBS Volume ID of this disk.</p>
    pub fn ebs_volume_id(&self) -> std::option::Option<&str> {
        self.ebs_volume_id.as_deref()
    }
}
/// See [`RecoveryInstanceDisk`](crate::model::RecoveryInstanceDisk).
pub mod recovery_instance_disk {

    /// A builder for [`RecoveryInstanceDisk`](crate::model::RecoveryInstanceDisk).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) internal_device_name: std::option::Option<std::string::String>,
        pub(crate) bytes: std::option::Option<i64>,
        pub(crate) ebs_volume_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.</p>
        pub fn internal_device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.internal_device_name = Some(input.into());
            self
        }
        /// <p>The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.</p>
        pub fn set_internal_device_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.internal_device_name = input;
            self
        }
        /// <p>The amount of storage on the disk in bytes.</p>
        pub fn bytes(mut self, input: i64) -> Self {
            self.bytes = Some(input);
            self
        }
        /// <p>The amount of storage on the disk in bytes.</p>
        pub fn set_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.bytes = input;
            self
        }
        /// <p>The EBS Volume ID of this disk.</p>
        pub fn ebs_volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_volume_id = Some(input.into());
            self
        }
        /// <p>The EBS Volume ID of this disk.</p>
        pub fn set_ebs_volume_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ebs_volume_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceDisk`](crate::model::RecoveryInstanceDisk).
        pub fn build(self) -> crate::model::RecoveryInstanceDisk {
            crate::model::RecoveryInstanceDisk {
                internal_device_name: self.internal_device_name,
                bytes: self.bytes.unwrap_or_default(),
                ebs_volume_id: self.ebs_volume_id,
            }
        }
    }
}
impl RecoveryInstanceDisk {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceDisk`](crate::model::RecoveryInstanceDisk).
    pub fn builder() -> crate::model::recovery_instance_disk::Builder {
        crate::model::recovery_instance_disk::Builder::default()
    }
}

/// <p>Information about Data Replication</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceDataReplicationInfo {
    /// <p>Data replication lag duration.</p>
    #[doc(hidden)]
    pub lag_duration: std::option::Option<std::string::String>,
    /// <p>An estimate of when the data replication will be completed.</p>
    #[doc(hidden)]
    pub eta_date_time: std::option::Option<std::string::String>,
    /// <p>The disks that should be replicated.</p>
    #[doc(hidden)]
    pub replicated_disks: std::option::Option<
        std::vec::Vec<crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk>,
    >,
    /// <p>The state of the data replication.</p>
    #[doc(hidden)]
    pub data_replication_state:
        std::option::Option<crate::model::RecoveryInstanceDataReplicationState>,
    /// <p>Information about whether the data replication has been initiated.</p>
    #[doc(hidden)]
    pub data_replication_initiation:
        std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiation>,
    /// <p>Information about Data Replication</p>
    #[doc(hidden)]
    pub data_replication_error:
        std::option::Option<crate::model::RecoveryInstanceDataReplicationError>,
}
impl RecoveryInstanceDataReplicationInfo {
    /// <p>Data replication lag duration.</p>
    pub fn lag_duration(&self) -> std::option::Option<&str> {
        self.lag_duration.as_deref()
    }
    /// <p>An estimate of when the data replication will be completed.</p>
    pub fn eta_date_time(&self) -> std::option::Option<&str> {
        self.eta_date_time.as_deref()
    }
    /// <p>The disks that should be replicated.</p>
    pub fn replicated_disks(
        &self,
    ) -> std::option::Option<&[crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk]>
    {
        self.replicated_disks.as_deref()
    }
    /// <p>The state of the data replication.</p>
    pub fn data_replication_state(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceDataReplicationState> {
        self.data_replication_state.as_ref()
    }
    /// <p>Information about whether the data replication has been initiated.</p>
    pub fn data_replication_initiation(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceDataReplicationInitiation> {
        self.data_replication_initiation.as_ref()
    }
    /// <p>Information about Data Replication</p>
    pub fn data_replication_error(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceDataReplicationError> {
        self.data_replication_error.as_ref()
    }
}
/// See [`RecoveryInstanceDataReplicationInfo`](crate::model::RecoveryInstanceDataReplicationInfo).
pub mod recovery_instance_data_replication_info {

    /// A builder for [`RecoveryInstanceDataReplicationInfo`](crate::model::RecoveryInstanceDataReplicationInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lag_duration: std::option::Option<std::string::String>,
        pub(crate) eta_date_time: std::option::Option<std::string::String>,
        pub(crate) replicated_disks: std::option::Option<
            std::vec::Vec<crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk>,
        >,
        pub(crate) data_replication_state:
            std::option::Option<crate::model::RecoveryInstanceDataReplicationState>,
        pub(crate) data_replication_initiation:
            std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiation>,
        pub(crate) data_replication_error:
            std::option::Option<crate::model::RecoveryInstanceDataReplicationError>,
    }
    impl Builder {
        /// <p>Data replication lag duration.</p>
        pub fn lag_duration(mut self, input: impl Into<std::string::String>) -> Self {
            self.lag_duration = Some(input.into());
            self
        }
        /// <p>Data replication lag duration.</p>
        pub fn set_lag_duration(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lag_duration = input;
            self
        }
        /// <p>An estimate of when the data replication will be completed.</p>
        pub fn eta_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.eta_date_time = Some(input.into());
            self
        }
        /// <p>An estimate of when the data replication will be completed.</p>
        pub fn set_eta_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.eta_date_time = input;
            self
        }
        /// Appends an item to `replicated_disks`.
        ///
        /// To override the contents of this collection use [`set_replicated_disks`](Self::set_replicated_disks).
        ///
        /// <p>The disks that should be replicated.</p>
        pub fn replicated_disks(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk,
        ) -> Self {
            let mut v = self.replicated_disks.unwrap_or_default();
            v.push(input);
            self.replicated_disks = Some(v);
            self
        }
        /// <p>The disks that should be replicated.</p>
        pub fn set_replicated_disks(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk>,
            >,
        ) -> Self {
            self.replicated_disks = input;
            self
        }
        /// <p>The state of the data replication.</p>
        pub fn data_replication_state(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationState,
        ) -> Self {
            self.data_replication_state = Some(input);
            self
        }
        /// <p>The state of the data replication.</p>
        pub fn set_data_replication_state(
            mut self,
            input: std::option::Option<crate::model::RecoveryInstanceDataReplicationState>,
        ) -> Self {
            self.data_replication_state = input;
            self
        }
        /// <p>Information about whether the data replication has been initiated.</p>
        pub fn data_replication_initiation(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationInitiation,
        ) -> Self {
            self.data_replication_initiation = Some(input);
            self
        }
        /// <p>Information about whether the data replication has been initiated.</p>
        pub fn set_data_replication_initiation(
            mut self,
            input: std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiation>,
        ) -> Self {
            self.data_replication_initiation = input;
            self
        }
        /// <p>Information about Data Replication</p>
        pub fn data_replication_error(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationError,
        ) -> Self {
            self.data_replication_error = Some(input);
            self
        }
        /// <p>Information about Data Replication</p>
        pub fn set_data_replication_error(
            mut self,
            input: std::option::Option<crate::model::RecoveryInstanceDataReplicationError>,
        ) -> Self {
            self.data_replication_error = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceDataReplicationInfo`](crate::model::RecoveryInstanceDataReplicationInfo).
        pub fn build(self) -> crate::model::RecoveryInstanceDataReplicationInfo {
            crate::model::RecoveryInstanceDataReplicationInfo {
                lag_duration: self.lag_duration,
                eta_date_time: self.eta_date_time,
                replicated_disks: self.replicated_disks,
                data_replication_state: self.data_replication_state,
                data_replication_initiation: self.data_replication_initiation,
                data_replication_error: self.data_replication_error,
            }
        }
    }
}
impl RecoveryInstanceDataReplicationInfo {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceDataReplicationInfo`](crate::model::RecoveryInstanceDataReplicationInfo).
    pub fn builder() -> crate::model::recovery_instance_data_replication_info::Builder {
        crate::model::recovery_instance_data_replication_info::Builder::default()
    }
}

/// <p>Error in data replication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceDataReplicationError {
    /// <p>Error in data replication.</p>
    #[doc(hidden)]
    pub error: std::option::Option<crate::model::FailbackReplicationError>,
    /// <p>Error in data replication.</p>
    #[doc(hidden)]
    pub raw_error: std::option::Option<std::string::String>,
}
impl RecoveryInstanceDataReplicationError {
    /// <p>Error in data replication.</p>
    pub fn error(&self) -> std::option::Option<&crate::model::FailbackReplicationError> {
        self.error.as_ref()
    }
    /// <p>Error in data replication.</p>
    pub fn raw_error(&self) -> std::option::Option<&str> {
        self.raw_error.as_deref()
    }
}
/// See [`RecoveryInstanceDataReplicationError`](crate::model::RecoveryInstanceDataReplicationError).
pub mod recovery_instance_data_replication_error {

    /// A builder for [`RecoveryInstanceDataReplicationError`](crate::model::RecoveryInstanceDataReplicationError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::FailbackReplicationError>,
        pub(crate) raw_error: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error in data replication.</p>
        pub fn error(mut self, input: crate::model::FailbackReplicationError) -> Self {
            self.error = Some(input);
            self
        }
        /// <p>Error in data replication.</p>
        pub fn set_error(
            mut self,
            input: std::option::Option<crate::model::FailbackReplicationError>,
        ) -> Self {
            self.error = input;
            self
        }
        /// <p>Error in data replication.</p>
        pub fn raw_error(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_error = Some(input.into());
            self
        }
        /// <p>Error in data replication.</p>
        pub fn set_raw_error(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_error = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceDataReplicationError`](crate::model::RecoveryInstanceDataReplicationError).
        pub fn build(self) -> crate::model::RecoveryInstanceDataReplicationError {
            crate::model::RecoveryInstanceDataReplicationError {
                error: self.error,
                raw_error: self.raw_error,
            }
        }
    }
}
impl RecoveryInstanceDataReplicationError {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceDataReplicationError`](crate::model::RecoveryInstanceDataReplicationError).
    pub fn builder() -> crate::model::recovery_instance_data_replication_error::Builder {
        crate::model::recovery_instance_data_replication_error::Builder::default()
    }
}

/// When writing a match expression against `FailbackReplicationError`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let failbackreplicationerror = unimplemented!();
/// match failbackreplicationerror {
///     FailbackReplicationError::AgentNotSeen => { /* ... */ },
///     FailbackReplicationError::FailbackClientNotSeen => { /* ... */ },
///     FailbackReplicationError::FailedGettingReplicationState => { /* ... */ },
///     FailbackReplicationError::FailedToAttachStagingDisks => { /* ... */ },
///     FailbackReplicationError::FailedToAuthenticateWithService => { /* ... */ },
///     FailbackReplicationError::FailedToBootReplicationServer => { /* ... */ },
///     FailbackReplicationError::FailedToConfigureReplicationSoftware => { /* ... */ },
///     FailbackReplicationError::FailedToConnectAgentToReplicationServer => { /* ... */ },
///     FailbackReplicationError::FailedToCreateSecurityGroup => { /* ... */ },
///     FailbackReplicationError::FailedToCreateStagingDisks => { /* ... */ },
///     FailbackReplicationError::FailedToDownloadReplicationSoftware => { /* ... */ },
///     FailbackReplicationError::FailedToDownloadReplicationSoftwareToFailbackClient => { /* ... */ },
///     FailbackReplicationError::FailedToEstablishAgentReplicatorSoftwareCommunication => { /* ... */ },
///     FailbackReplicationError::FailedToEstablishRecoveryInstanceCommunication => { /* ... */ },
///     FailbackReplicationError::FailedToLaunchReplicationServer => { /* ... */ },
///     FailbackReplicationError::FailedToPairAgentWithReplicationSoftware => { /* ... */ },
///     FailbackReplicationError::FailedToPairReplicationServerWithAgent => { /* ... */ },
///     FailbackReplicationError::FailedToStartDataTransfer => { /* ... */ },
///     FailbackReplicationError::NotConverging => { /* ... */ },
///     FailbackReplicationError::SnapshotsFailure => { /* ... */ },
///     FailbackReplicationError::UnstableNetwork => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `failbackreplicationerror` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FailbackReplicationError::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FailbackReplicationError::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FailbackReplicationError::NewFeature` is defined.
/// Specifically, when `failbackreplicationerror` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FailbackReplicationError::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailbackReplicationError {
    #[allow(missing_docs)] // documentation missing in model
    AgentNotSeen,
    #[allow(missing_docs)] // documentation missing in model
    FailbackClientNotSeen,
    #[allow(missing_docs)] // documentation missing in model
    FailedGettingReplicationState,
    #[allow(missing_docs)] // documentation missing in model
    FailedToAttachStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    FailedToAuthenticateWithService,
    #[allow(missing_docs)] // documentation missing in model
    FailedToBootReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    FailedToConfigureReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    FailedToConnectAgentToReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    FailedToCreateSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    FailedToCreateStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    FailedToDownloadReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    FailedToDownloadReplicationSoftwareToFailbackClient,
    #[allow(missing_docs)] // documentation missing in model
    FailedToEstablishAgentReplicatorSoftwareCommunication,
    #[allow(missing_docs)] // documentation missing in model
    FailedToEstablishRecoveryInstanceCommunication,
    #[allow(missing_docs)] // documentation missing in model
    FailedToLaunchReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    FailedToPairAgentWithReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    FailedToPairReplicationServerWithAgent,
    #[allow(missing_docs)] // documentation missing in model
    FailedToStartDataTransfer,
    #[allow(missing_docs)] // documentation missing in model
    NotConverging,
    #[allow(missing_docs)] // documentation missing in model
    SnapshotsFailure,
    #[allow(missing_docs)] // documentation missing in model
    UnstableNetwork,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FailbackReplicationError {
    fn from(s: &str) -> Self {
        match s {
            "AGENT_NOT_SEEN" => FailbackReplicationError::AgentNotSeen,
            "FAILBACK_CLIENT_NOT_SEEN" => FailbackReplicationError::FailbackClientNotSeen,
            "FAILED_GETTING_REPLICATION_STATE" => {
                FailbackReplicationError::FailedGettingReplicationState
            }
            "FAILED_TO_ATTACH_STAGING_DISKS" => {
                FailbackReplicationError::FailedToAttachStagingDisks
            }
            "FAILED_TO_AUTHENTICATE_WITH_SERVICE" => {
                FailbackReplicationError::FailedToAuthenticateWithService
            }
            "FAILED_TO_BOOT_REPLICATION_SERVER" => {
                FailbackReplicationError::FailedToBootReplicationServer
            }
            "FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE" => {
                FailbackReplicationError::FailedToConfigureReplicationSoftware
            }
            "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER" => {
                FailbackReplicationError::FailedToConnectAgentToReplicationServer
            }
            "FAILED_TO_CREATE_SECURITY_GROUP" => {
                FailbackReplicationError::FailedToCreateSecurityGroup
            }
            "FAILED_TO_CREATE_STAGING_DISKS" => {
                FailbackReplicationError::FailedToCreateStagingDisks
            }
            "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE" => {
                FailbackReplicationError::FailedToDownloadReplicationSoftware
            }
            "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT" => {
                FailbackReplicationError::FailedToDownloadReplicationSoftwareToFailbackClient
            }
            "FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION" => {
                FailbackReplicationError::FailedToEstablishAgentReplicatorSoftwareCommunication
            }
            "FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION" => {
                FailbackReplicationError::FailedToEstablishRecoveryInstanceCommunication
            }
            "FAILED_TO_LAUNCH_REPLICATION_SERVER" => {
                FailbackReplicationError::FailedToLaunchReplicationServer
            }
            "FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE" => {
                FailbackReplicationError::FailedToPairAgentWithReplicationSoftware
            }
            "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT" => {
                FailbackReplicationError::FailedToPairReplicationServerWithAgent
            }
            "FAILED_TO_START_DATA_TRANSFER" => FailbackReplicationError::FailedToStartDataTransfer,
            "NOT_CONVERGING" => FailbackReplicationError::NotConverging,
            "SNAPSHOTS_FAILURE" => FailbackReplicationError::SnapshotsFailure,
            "UNSTABLE_NETWORK" => FailbackReplicationError::UnstableNetwork,
            other => FailbackReplicationError::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for FailbackReplicationError {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailbackReplicationError::from(s))
    }
}
impl FailbackReplicationError {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailbackReplicationError::AgentNotSeen => "AGENT_NOT_SEEN",
            FailbackReplicationError::FailbackClientNotSeen => "FAILBACK_CLIENT_NOT_SEEN",
            FailbackReplicationError::FailedGettingReplicationState => {
                "FAILED_GETTING_REPLICATION_STATE"
            }
            FailbackReplicationError::FailedToAttachStagingDisks => {
                "FAILED_TO_ATTACH_STAGING_DISKS"
            }
            FailbackReplicationError::FailedToAuthenticateWithService => {
                "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            }
            FailbackReplicationError::FailedToBootReplicationServer => {
                "FAILED_TO_BOOT_REPLICATION_SERVER"
            }
            FailbackReplicationError::FailedToConfigureReplicationSoftware => {
                "FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE"
            }
            FailbackReplicationError::FailedToConnectAgentToReplicationServer => {
                "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            }
            FailbackReplicationError::FailedToCreateSecurityGroup => {
                "FAILED_TO_CREATE_SECURITY_GROUP"
            }
            FailbackReplicationError::FailedToCreateStagingDisks => {
                "FAILED_TO_CREATE_STAGING_DISKS"
            }
            FailbackReplicationError::FailedToDownloadReplicationSoftware => {
                "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            }
            FailbackReplicationError::FailedToDownloadReplicationSoftwareToFailbackClient => {
                "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
            }
            FailbackReplicationError::FailedToEstablishAgentReplicatorSoftwareCommunication => {
                "FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
            }
            FailbackReplicationError::FailedToEstablishRecoveryInstanceCommunication => {
                "FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
            }
            FailbackReplicationError::FailedToLaunchReplicationServer => {
                "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            }
            FailbackReplicationError::FailedToPairAgentWithReplicationSoftware => {
                "FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
            }
            FailbackReplicationError::FailedToPairReplicationServerWithAgent => {
                "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            }
            FailbackReplicationError::FailedToStartDataTransfer => "FAILED_TO_START_DATA_TRANSFER",
            FailbackReplicationError::NotConverging => "NOT_CONVERGING",
            FailbackReplicationError::SnapshotsFailure => "SNAPSHOTS_FAILURE",
            FailbackReplicationError::UnstableNetwork => "UNSTABLE_NETWORK",
            FailbackReplicationError::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AGENT_NOT_SEEN",
            "FAILBACK_CLIENT_NOT_SEEN",
            "FAILED_GETTING_REPLICATION_STATE",
            "FAILED_TO_ATTACH_STAGING_DISKS",
            "FAILED_TO_AUTHENTICATE_WITH_SERVICE",
            "FAILED_TO_BOOT_REPLICATION_SERVER",
            "FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE",
            "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER",
            "FAILED_TO_CREATE_SECURITY_GROUP",
            "FAILED_TO_CREATE_STAGING_DISKS",
            "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE",
            "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT",
            "FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION",
            "FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION",
            "FAILED_TO_LAUNCH_REPLICATION_SERVER",
            "FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE",
            "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT",
            "FAILED_TO_START_DATA_TRANSFER",
            "NOT_CONVERGING",
            "SNAPSHOTS_FAILURE",
            "UNSTABLE_NETWORK",
        ]
    }
}
impl AsRef<str> for FailbackReplicationError {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Data replication initiation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceDataReplicationInitiation {
    /// <p>The date and time of the current attempt to initiate data replication.</p>
    #[doc(hidden)]
    pub start_date_time: std::option::Option<std::string::String>,
    /// <p>The steps of the current attempt to initiate data replication.</p>
    #[doc(hidden)]
    pub steps: std::option::Option<
        std::vec::Vec<crate::model::RecoveryInstanceDataReplicationInitiationStep>,
    >,
}
impl RecoveryInstanceDataReplicationInitiation {
    /// <p>The date and time of the current attempt to initiate data replication.</p>
    pub fn start_date_time(&self) -> std::option::Option<&str> {
        self.start_date_time.as_deref()
    }
    /// <p>The steps of the current attempt to initiate data replication.</p>
    pub fn steps(
        &self,
    ) -> std::option::Option<&[crate::model::RecoveryInstanceDataReplicationInitiationStep]> {
        self.steps.as_deref()
    }
}
/// See [`RecoveryInstanceDataReplicationInitiation`](crate::model::RecoveryInstanceDataReplicationInitiation).
pub mod recovery_instance_data_replication_initiation {

    /// A builder for [`RecoveryInstanceDataReplicationInitiation`](crate::model::RecoveryInstanceDataReplicationInitiation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_date_time: std::option::Option<std::string::String>,
        pub(crate) steps: std::option::Option<
            std::vec::Vec<crate::model::RecoveryInstanceDataReplicationInitiationStep>,
        >,
    }
    impl Builder {
        /// <p>The date and time of the current attempt to initiate data replication.</p>
        pub fn start_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of the current attempt to initiate data replication.</p>
        pub fn set_start_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_date_time = input;
            self
        }
        /// Appends an item to `steps`.
        ///
        /// To override the contents of this collection use [`set_steps`](Self::set_steps).
        ///
        /// <p>The steps of the current attempt to initiate data replication.</p>
        pub fn steps(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationInitiationStep,
        ) -> Self {
            let mut v = self.steps.unwrap_or_default();
            v.push(input);
            self.steps = Some(v);
            self
        }
        /// <p>The steps of the current attempt to initiate data replication.</p>
        pub fn set_steps(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RecoveryInstanceDataReplicationInitiationStep>,
            >,
        ) -> Self {
            self.steps = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceDataReplicationInitiation`](crate::model::RecoveryInstanceDataReplicationInitiation).
        pub fn build(self) -> crate::model::RecoveryInstanceDataReplicationInitiation {
            crate::model::RecoveryInstanceDataReplicationInitiation {
                start_date_time: self.start_date_time,
                steps: self.steps,
            }
        }
    }
}
impl RecoveryInstanceDataReplicationInitiation {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceDataReplicationInitiation`](crate::model::RecoveryInstanceDataReplicationInitiation).
    pub fn builder() -> crate::model::recovery_instance_data_replication_initiation::Builder {
        crate::model::recovery_instance_data_replication_initiation::Builder::default()
    }
}

/// <p>Data replication initiation step.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceDataReplicationInitiationStep {
    /// <p>The name of the step.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiationStepName>,
    /// <p>The status of the step.</p>
    #[doc(hidden)]
    pub status:
        std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiationStepStatus>,
}
impl RecoveryInstanceDataReplicationInitiationStep {
    /// <p>The name of the step.</p>
    pub fn name(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceDataReplicationInitiationStepName> {
        self.name.as_ref()
    }
    /// <p>The status of the step.</p>
    pub fn status(
        &self,
    ) -> std::option::Option<&crate::model::RecoveryInstanceDataReplicationInitiationStepStatus>
    {
        self.status.as_ref()
    }
}
/// See [`RecoveryInstanceDataReplicationInitiationStep`](crate::model::RecoveryInstanceDataReplicationInitiationStep).
pub mod recovery_instance_data_replication_initiation_step {

    /// A builder for [`RecoveryInstanceDataReplicationInitiationStep`](crate::model::RecoveryInstanceDataReplicationInitiationStep).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name:
            std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiationStepName>,
        pub(crate) status:
            std::option::Option<crate::model::RecoveryInstanceDataReplicationInitiationStepStatus>,
    }
    impl Builder {
        /// <p>The name of the step.</p>
        pub fn name(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationInitiationStepName,
        ) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the step.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<
                crate::model::RecoveryInstanceDataReplicationInitiationStepName,
            >,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the step.</p>
        pub fn status(
            mut self,
            input: crate::model::RecoveryInstanceDataReplicationInitiationStepStatus,
        ) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the step.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<
                crate::model::RecoveryInstanceDataReplicationInitiationStepStatus,
            >,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceDataReplicationInitiationStep`](crate::model::RecoveryInstanceDataReplicationInitiationStep).
        pub fn build(self) -> crate::model::RecoveryInstanceDataReplicationInitiationStep {
            crate::model::RecoveryInstanceDataReplicationInitiationStep {
                name: self.name,
                status: self.status,
            }
        }
    }
}
impl RecoveryInstanceDataReplicationInitiationStep {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceDataReplicationInitiationStep`](crate::model::RecoveryInstanceDataReplicationInitiationStep).
    pub fn builder() -> crate::model::recovery_instance_data_replication_initiation_step::Builder {
        crate::model::recovery_instance_data_replication_initiation_step::Builder::default()
    }
}

/// When writing a match expression against `RecoveryInstanceDataReplicationInitiationStepStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recoveryinstancedatareplicationinitiationstepstatus = unimplemented!();
/// match recoveryinstancedatareplicationinitiationstepstatus {
///     RecoveryInstanceDataReplicationInitiationStepStatus::Failed => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepStatus::InProgress => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepStatus::NotStarted => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepStatus::Skipped => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recoveryinstancedatareplicationinitiationstepstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecoveryInstanceDataReplicationInitiationStepStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecoveryInstanceDataReplicationInitiationStepStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecoveryInstanceDataReplicationInitiationStepStatus::NewFeature` is defined.
/// Specifically, when `recoveryinstancedatareplicationinitiationstepstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecoveryInstanceDataReplicationInitiationStepStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecoveryInstanceDataReplicationInitiationStepStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    #[allow(missing_docs)] // documentation missing in model
    Skipped,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecoveryInstanceDataReplicationInitiationStepStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => RecoveryInstanceDataReplicationInitiationStepStatus::Failed,
            "IN_PROGRESS" => RecoveryInstanceDataReplicationInitiationStepStatus::InProgress,
            "NOT_STARTED" => RecoveryInstanceDataReplicationInitiationStepStatus::NotStarted,
            "SKIPPED" => RecoveryInstanceDataReplicationInitiationStepStatus::Skipped,
            "SUCCEEDED" => RecoveryInstanceDataReplicationInitiationStepStatus::Succeeded,
            other => RecoveryInstanceDataReplicationInitiationStepStatus::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for RecoveryInstanceDataReplicationInitiationStepStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecoveryInstanceDataReplicationInitiationStepStatus::from(s))
    }
}
impl RecoveryInstanceDataReplicationInitiationStepStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecoveryInstanceDataReplicationInitiationStepStatus::Failed => "FAILED",
            RecoveryInstanceDataReplicationInitiationStepStatus::InProgress => "IN_PROGRESS",
            RecoveryInstanceDataReplicationInitiationStepStatus::NotStarted => "NOT_STARTED",
            RecoveryInstanceDataReplicationInitiationStepStatus::Skipped => "SKIPPED",
            RecoveryInstanceDataReplicationInitiationStepStatus::Succeeded => "SUCCEEDED",
            RecoveryInstanceDataReplicationInitiationStepStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILED",
            "IN_PROGRESS",
            "NOT_STARTED",
            "SKIPPED",
            "SUCCEEDED",
        ]
    }
}
impl AsRef<str> for RecoveryInstanceDataReplicationInitiationStepStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RecoveryInstanceDataReplicationInitiationStepName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recoveryinstancedatareplicationinitiationstepname = unimplemented!();
/// match recoveryinstancedatareplicationinitiationstepname {
///     RecoveryInstanceDataReplicationInitiationStepName::AttachStagingDisks => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::AuthenticateWithService => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::BootReplicationServer => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::CompleteVolumeMapping => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::ConfigureReplicationSoftware => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::ConnectAgentToReplicationServer => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::CreateSecurityGroup => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::CreateStagingDisks => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::DownloadReplicationSoftware => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::DownloadReplicationSoftwareToFailbackClient => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::EstablishAgentReplicatorSoftwareCommunication => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::EstablishRecoveryInstanceCommunication => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::LaunchReplicationServer => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::LinkFailbackClientWithRecoveryInstance => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::PairAgentWithReplicationSoftware => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::PairReplicationServerWithAgent => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::StartDataTransfer => { /* ... */ },
///     RecoveryInstanceDataReplicationInitiationStepName::Wait => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recoveryinstancedatareplicationinitiationstepname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecoveryInstanceDataReplicationInitiationStepName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecoveryInstanceDataReplicationInitiationStepName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecoveryInstanceDataReplicationInitiationStepName::NewFeature` is defined.
/// Specifically, when `recoveryinstancedatareplicationinitiationstepname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecoveryInstanceDataReplicationInitiationStepName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecoveryInstanceDataReplicationInitiationStepName {
    #[allow(missing_docs)] // documentation missing in model
    AttachStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    AuthenticateWithService,
    #[allow(missing_docs)] // documentation missing in model
    BootReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    CompleteVolumeMapping,
    #[allow(missing_docs)] // documentation missing in model
    ConfigureReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    ConnectAgentToReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    CreateSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    CreateStagingDisks,
    #[allow(missing_docs)] // documentation missing in model
    DownloadReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    DownloadReplicationSoftwareToFailbackClient,
    #[allow(missing_docs)] // documentation missing in model
    EstablishAgentReplicatorSoftwareCommunication,
    #[allow(missing_docs)] // documentation missing in model
    EstablishRecoveryInstanceCommunication,
    #[allow(missing_docs)] // documentation missing in model
    LaunchReplicationServer,
    #[allow(missing_docs)] // documentation missing in model
    LinkFailbackClientWithRecoveryInstance,
    #[allow(missing_docs)] // documentation missing in model
    PairAgentWithReplicationSoftware,
    #[allow(missing_docs)] // documentation missing in model
    PairReplicationServerWithAgent,
    #[allow(missing_docs)] // documentation missing in model
    StartDataTransfer,
    #[allow(missing_docs)] // documentation missing in model
    Wait,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecoveryInstanceDataReplicationInitiationStepName {
    fn from(s: &str) -> Self {
        match s {
                        "ATTACH_STAGING_DISKS" => RecoveryInstanceDataReplicationInitiationStepName::AttachStagingDisks,
"AUTHENTICATE_WITH_SERVICE" => RecoveryInstanceDataReplicationInitiationStepName::AuthenticateWithService,
"BOOT_REPLICATION_SERVER" => RecoveryInstanceDataReplicationInitiationStepName::BootReplicationServer,
"COMPLETE_VOLUME_MAPPING" => RecoveryInstanceDataReplicationInitiationStepName::CompleteVolumeMapping,
"CONFIGURE_REPLICATION_SOFTWARE" => RecoveryInstanceDataReplicationInitiationStepName::ConfigureReplicationSoftware,
"CONNECT_AGENT_TO_REPLICATION_SERVER" => RecoveryInstanceDataReplicationInitiationStepName::ConnectAgentToReplicationServer,
"CREATE_SECURITY_GROUP" => RecoveryInstanceDataReplicationInitiationStepName::CreateSecurityGroup,
"CREATE_STAGING_DISKS" => RecoveryInstanceDataReplicationInitiationStepName::CreateStagingDisks,
"DOWNLOAD_REPLICATION_SOFTWARE" => RecoveryInstanceDataReplicationInitiationStepName::DownloadReplicationSoftware,
"DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT" => RecoveryInstanceDataReplicationInitiationStepName::DownloadReplicationSoftwareToFailbackClient,
"ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION" => RecoveryInstanceDataReplicationInitiationStepName::EstablishAgentReplicatorSoftwareCommunication,
"ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION" => RecoveryInstanceDataReplicationInitiationStepName::EstablishRecoveryInstanceCommunication,
"LAUNCH_REPLICATION_SERVER" => RecoveryInstanceDataReplicationInitiationStepName::LaunchReplicationServer,
"LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE" => RecoveryInstanceDataReplicationInitiationStepName::LinkFailbackClientWithRecoveryInstance,
"PAIR_AGENT_WITH_REPLICATION_SOFTWARE" => RecoveryInstanceDataReplicationInitiationStepName::PairAgentWithReplicationSoftware,
"PAIR_REPLICATION_SERVER_WITH_AGENT" => RecoveryInstanceDataReplicationInitiationStepName::PairReplicationServerWithAgent,
"START_DATA_TRANSFER" => RecoveryInstanceDataReplicationInitiationStepName::StartDataTransfer,
"WAIT" => RecoveryInstanceDataReplicationInitiationStepName::Wait,
other => RecoveryInstanceDataReplicationInitiationStepName::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
                    }
    }
}
impl std::str::FromStr for RecoveryInstanceDataReplicationInitiationStepName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecoveryInstanceDataReplicationInitiationStepName::from(s))
    }
}
impl RecoveryInstanceDataReplicationInitiationStepName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
    RecoveryInstanceDataReplicationInitiationStepName::AttachStagingDisks => "ATTACH_STAGING_DISKS",
    RecoveryInstanceDataReplicationInitiationStepName::AuthenticateWithService => "AUTHENTICATE_WITH_SERVICE",
    RecoveryInstanceDataReplicationInitiationStepName::BootReplicationServer => "BOOT_REPLICATION_SERVER",
    RecoveryInstanceDataReplicationInitiationStepName::CompleteVolumeMapping => "COMPLETE_VOLUME_MAPPING",
    RecoveryInstanceDataReplicationInitiationStepName::ConfigureReplicationSoftware => "CONFIGURE_REPLICATION_SOFTWARE",
    RecoveryInstanceDataReplicationInitiationStepName::ConnectAgentToReplicationServer => "CONNECT_AGENT_TO_REPLICATION_SERVER",
    RecoveryInstanceDataReplicationInitiationStepName::CreateSecurityGroup => "CREATE_SECURITY_GROUP",
    RecoveryInstanceDataReplicationInitiationStepName::CreateStagingDisks => "CREATE_STAGING_DISKS",
    RecoveryInstanceDataReplicationInitiationStepName::DownloadReplicationSoftware => "DOWNLOAD_REPLICATION_SOFTWARE",
    RecoveryInstanceDataReplicationInitiationStepName::DownloadReplicationSoftwareToFailbackClient => "DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT",
    RecoveryInstanceDataReplicationInitiationStepName::EstablishAgentReplicatorSoftwareCommunication => "ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION",
    RecoveryInstanceDataReplicationInitiationStepName::EstablishRecoveryInstanceCommunication => "ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION",
    RecoveryInstanceDataReplicationInitiationStepName::LaunchReplicationServer => "LAUNCH_REPLICATION_SERVER",
    RecoveryInstanceDataReplicationInitiationStepName::LinkFailbackClientWithRecoveryInstance => "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE",
    RecoveryInstanceDataReplicationInitiationStepName::PairAgentWithReplicationSoftware => "PAIR_AGENT_WITH_REPLICATION_SOFTWARE",
    RecoveryInstanceDataReplicationInitiationStepName::PairReplicationServerWithAgent => "PAIR_REPLICATION_SERVER_WITH_AGENT",
    RecoveryInstanceDataReplicationInitiationStepName::StartDataTransfer => "START_DATA_TRANSFER",
    RecoveryInstanceDataReplicationInitiationStepName::Wait => "WAIT",
    RecoveryInstanceDataReplicationInitiationStepName::Unknown(value) => value.as_str()
}
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ATTACH_STAGING_DISKS",
            "AUTHENTICATE_WITH_SERVICE",
            "BOOT_REPLICATION_SERVER",
            "COMPLETE_VOLUME_MAPPING",
            "CONFIGURE_REPLICATION_SOFTWARE",
            "CONNECT_AGENT_TO_REPLICATION_SERVER",
            "CREATE_SECURITY_GROUP",
            "CREATE_STAGING_DISKS",
            "DOWNLOAD_REPLICATION_SOFTWARE",
            "DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT",
            "ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION",
            "ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION",
            "LAUNCH_REPLICATION_SERVER",
            "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE",
            "PAIR_AGENT_WITH_REPLICATION_SOFTWARE",
            "PAIR_REPLICATION_SERVER_WITH_AGENT",
            "START_DATA_TRANSFER",
            "WAIT",
        ]
    }
}
impl AsRef<str> for RecoveryInstanceDataReplicationInitiationStepName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RecoveryInstanceDataReplicationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recoveryinstancedatareplicationstate = unimplemented!();
/// match recoveryinstancedatareplicationstate {
///     RecoveryInstanceDataReplicationState::Backlog => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Continuous => { /* ... */ },
///     RecoveryInstanceDataReplicationState::CreatingSnapshot => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Disconnected => { /* ... */ },
///     RecoveryInstanceDataReplicationState::InitialSync => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Initiating => { /* ... */ },
///     RecoveryInstanceDataReplicationState::NotStarted => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Paused => { /* ... */ },
///     RecoveryInstanceDataReplicationState::ReplicationStateNotAvailable => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Rescan => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Stalled => { /* ... */ },
///     RecoveryInstanceDataReplicationState::Stopped => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recoveryinstancedatareplicationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecoveryInstanceDataReplicationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecoveryInstanceDataReplicationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecoveryInstanceDataReplicationState::NewFeature` is defined.
/// Specifically, when `recoveryinstancedatareplicationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecoveryInstanceDataReplicationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecoveryInstanceDataReplicationState {
    #[allow(missing_docs)] // documentation missing in model
    Backlog,
    #[allow(missing_docs)] // documentation missing in model
    Continuous,
    #[allow(missing_docs)] // documentation missing in model
    CreatingSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    Disconnected,
    #[allow(missing_docs)] // documentation missing in model
    InitialSync,
    #[allow(missing_docs)] // documentation missing in model
    Initiating,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    #[allow(missing_docs)] // documentation missing in model
    ReplicationStateNotAvailable,
    #[allow(missing_docs)] // documentation missing in model
    Rescan,
    #[allow(missing_docs)] // documentation missing in model
    Stalled,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecoveryInstanceDataReplicationState {
    fn from(s: &str) -> Self {
        match s {
            "BACKLOG" => RecoveryInstanceDataReplicationState::Backlog,
            "CONTINUOUS" => RecoveryInstanceDataReplicationState::Continuous,
            "CREATING_SNAPSHOT" => RecoveryInstanceDataReplicationState::CreatingSnapshot,
            "DISCONNECTED" => RecoveryInstanceDataReplicationState::Disconnected,
            "INITIAL_SYNC" => RecoveryInstanceDataReplicationState::InitialSync,
            "INITIATING" => RecoveryInstanceDataReplicationState::Initiating,
            "NOT_STARTED" => RecoveryInstanceDataReplicationState::NotStarted,
            "PAUSED" => RecoveryInstanceDataReplicationState::Paused,
            "REPLICATION_STATE_NOT_AVAILABLE" => {
                RecoveryInstanceDataReplicationState::ReplicationStateNotAvailable
            }
            "RESCAN" => RecoveryInstanceDataReplicationState::Rescan,
            "STALLED" => RecoveryInstanceDataReplicationState::Stalled,
            "STOPPED" => RecoveryInstanceDataReplicationState::Stopped,
            other => RecoveryInstanceDataReplicationState::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for RecoveryInstanceDataReplicationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecoveryInstanceDataReplicationState::from(s))
    }
}
impl RecoveryInstanceDataReplicationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecoveryInstanceDataReplicationState::Backlog => "BACKLOG",
            RecoveryInstanceDataReplicationState::Continuous => "CONTINUOUS",
            RecoveryInstanceDataReplicationState::CreatingSnapshot => "CREATING_SNAPSHOT",
            RecoveryInstanceDataReplicationState::Disconnected => "DISCONNECTED",
            RecoveryInstanceDataReplicationState::InitialSync => "INITIAL_SYNC",
            RecoveryInstanceDataReplicationState::Initiating => "INITIATING",
            RecoveryInstanceDataReplicationState::NotStarted => "NOT_STARTED",
            RecoveryInstanceDataReplicationState::Paused => "PAUSED",
            RecoveryInstanceDataReplicationState::ReplicationStateNotAvailable => {
                "REPLICATION_STATE_NOT_AVAILABLE"
            }
            RecoveryInstanceDataReplicationState::Rescan => "RESCAN",
            RecoveryInstanceDataReplicationState::Stalled => "STALLED",
            RecoveryInstanceDataReplicationState::Stopped => "STOPPED",
            RecoveryInstanceDataReplicationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BACKLOG",
            "CONTINUOUS",
            "CREATING_SNAPSHOT",
            "DISCONNECTED",
            "INITIAL_SYNC",
            "INITIATING",
            "NOT_STARTED",
            "PAUSED",
            "REPLICATION_STATE_NOT_AVAILABLE",
            "RESCAN",
            "STALLED",
            "STOPPED",
        ]
    }
}
impl AsRef<str> for RecoveryInstanceDataReplicationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A disk that should be replicated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceDataReplicationInfoReplicatedDisk {
    /// <p>The name of the device.</p>
    #[doc(hidden)]
    pub device_name: std::option::Option<std::string::String>,
    /// <p>The total amount of data to be replicated in bytes.</p>
    #[doc(hidden)]
    pub total_storage_bytes: i64,
    /// <p>The amount of data replicated so far in bytes.</p>
    #[doc(hidden)]
    pub replicated_storage_bytes: i64,
    /// <p>The amount of data to be rescanned in bytes.</p>
    #[doc(hidden)]
    pub rescanned_storage_bytes: i64,
    /// <p>The size of the replication backlog in bytes.</p>
    #[doc(hidden)]
    pub backlogged_storage_bytes: i64,
}
impl RecoveryInstanceDataReplicationInfoReplicatedDisk {
    /// <p>The name of the device.</p>
    pub fn device_name(&self) -> std::option::Option<&str> {
        self.device_name.as_deref()
    }
    /// <p>The total amount of data to be replicated in bytes.</p>
    pub fn total_storage_bytes(&self) -> i64 {
        self.total_storage_bytes
    }
    /// <p>The amount of data replicated so far in bytes.</p>
    pub fn replicated_storage_bytes(&self) -> i64 {
        self.replicated_storage_bytes
    }
    /// <p>The amount of data to be rescanned in bytes.</p>
    pub fn rescanned_storage_bytes(&self) -> i64 {
        self.rescanned_storage_bytes
    }
    /// <p>The size of the replication backlog in bytes.</p>
    pub fn backlogged_storage_bytes(&self) -> i64 {
        self.backlogged_storage_bytes
    }
}
/// See [`RecoveryInstanceDataReplicationInfoReplicatedDisk`](crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk).
pub mod recovery_instance_data_replication_info_replicated_disk {

    /// A builder for [`RecoveryInstanceDataReplicationInfoReplicatedDisk`](crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) total_storage_bytes: std::option::Option<i64>,
        pub(crate) replicated_storage_bytes: std::option::Option<i64>,
        pub(crate) rescanned_storage_bytes: std::option::Option<i64>,
        pub(crate) backlogged_storage_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the device.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        /// <p>The name of the device.</p>
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>The total amount of data to be replicated in bytes.</p>
        pub fn total_storage_bytes(mut self, input: i64) -> Self {
            self.total_storage_bytes = Some(input);
            self
        }
        /// <p>The total amount of data to be replicated in bytes.</p>
        pub fn set_total_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.total_storage_bytes = input;
            self
        }
        /// <p>The amount of data replicated so far in bytes.</p>
        pub fn replicated_storage_bytes(mut self, input: i64) -> Self {
            self.replicated_storage_bytes = Some(input);
            self
        }
        /// <p>The amount of data replicated so far in bytes.</p>
        pub fn set_replicated_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.replicated_storage_bytes = input;
            self
        }
        /// <p>The amount of data to be rescanned in bytes.</p>
        pub fn rescanned_storage_bytes(mut self, input: i64) -> Self {
            self.rescanned_storage_bytes = Some(input);
            self
        }
        /// <p>The amount of data to be rescanned in bytes.</p>
        pub fn set_rescanned_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.rescanned_storage_bytes = input;
            self
        }
        /// <p>The size of the replication backlog in bytes.</p>
        pub fn backlogged_storage_bytes(mut self, input: i64) -> Self {
            self.backlogged_storage_bytes = Some(input);
            self
        }
        /// <p>The size of the replication backlog in bytes.</p>
        pub fn set_backlogged_storage_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.backlogged_storage_bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceDataReplicationInfoReplicatedDisk`](crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk).
        pub fn build(self) -> crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk {
            crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk {
                device_name: self.device_name,
                total_storage_bytes: self.total_storage_bytes.unwrap_or_default(),
                replicated_storage_bytes: self.replicated_storage_bytes.unwrap_or_default(),
                rescanned_storage_bytes: self.rescanned_storage_bytes.unwrap_or_default(),
                backlogged_storage_bytes: self.backlogged_storage_bytes.unwrap_or_default(),
            }
        }
    }
}
impl RecoveryInstanceDataReplicationInfoReplicatedDisk {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceDataReplicationInfoReplicatedDisk`](crate::model::RecoveryInstanceDataReplicationInfoReplicatedDisk).
    pub fn builder(
    ) -> crate::model::recovery_instance_data_replication_info_replicated_disk::Builder {
        crate::model::recovery_instance_data_replication_info_replicated_disk::Builder::default()
    }
}

/// <p>An object representing failback related information of the Recovery Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecoveryInstanceFailback {
    /// <p>The ID of the failback client that this Recovery Instance is associated with.</p>
    #[doc(hidden)]
    pub failback_client_id: std::option::Option<std::string::String>,
    /// <p>The Job ID of the last failback log for this Recovery Instance.</p>
    #[doc(hidden)]
    pub failback_job_id: std::option::Option<std::string::String>,
    /// <p>The date and time that the failback initiation started.</p>
    #[doc(hidden)]
    pub failback_initiation_time: std::option::Option<std::string::String>,
    /// <p>The state of the failback process that this Recovery Instance is in.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::FailbackState>,
    /// <p>The date and time the agent on the Recovery Instance was last seen by the service.</p>
    #[doc(hidden)]
    pub agent_last_seen_by_service_date_time: std::option::Option<std::string::String>,
    /// <p>The date and time that the failback client was last seen by the service.</p>
    #[doc(hidden)]
    pub failback_client_last_seen_by_service_date_time: std::option::Option<std::string::String>,
    /// <p>Whether we are failing back to the original Source Server for this Recovery Instance.</p>
    #[doc(hidden)]
    pub failback_to_original_server: std::option::Option<bool>,
    /// <p>The date and time of the first byte that was replicated from the Recovery Instance.</p>
    #[doc(hidden)]
    pub first_byte_date_time: std::option::Option<std::string::String>,
    /// <p>The amount of time that the Recovery Instance has been replicating for.</p>
    #[doc(hidden)]
    pub elapsed_replication_duration: std::option::Option<std::string::String>,
    /// <p>The launch type (Recovery / Drill) of the last launch for the failback replication of this recovery instance.</p>
    #[doc(hidden)]
    pub failback_launch_type: std::option::Option<crate::model::FailbackLaunchType>,
}
impl RecoveryInstanceFailback {
    /// <p>The ID of the failback client that this Recovery Instance is associated with.</p>
    pub fn failback_client_id(&self) -> std::option::Option<&str> {
        self.failback_client_id.as_deref()
    }
    /// <p>The Job ID of the last failback log for this Recovery Instance.</p>
    pub fn failback_job_id(&self) -> std::option::Option<&str> {
        self.failback_job_id.as_deref()
    }
    /// <p>The date and time that the failback initiation started.</p>
    pub fn failback_initiation_time(&self) -> std::option::Option<&str> {
        self.failback_initiation_time.as_deref()
    }
    /// <p>The state of the failback process that this Recovery Instance is in.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::FailbackState> {
        self.state.as_ref()
    }
    /// <p>The date and time the agent on the Recovery Instance was last seen by the service.</p>
    pub fn agent_last_seen_by_service_date_time(&self) -> std::option::Option<&str> {
        self.agent_last_seen_by_service_date_time.as_deref()
    }
    /// <p>The date and time that the failback client was last seen by the service.</p>
    pub fn failback_client_last_seen_by_service_date_time(&self) -> std::option::Option<&str> {
        self.failback_client_last_seen_by_service_date_time
            .as_deref()
    }
    /// <p>Whether we are failing back to the original Source Server for this Recovery Instance.</p>
    pub fn failback_to_original_server(&self) -> std::option::Option<bool> {
        self.failback_to_original_server
    }
    /// <p>The date and time of the first byte that was replicated from the Recovery Instance.</p>
    pub fn first_byte_date_time(&self) -> std::option::Option<&str> {
        self.first_byte_date_time.as_deref()
    }
    /// <p>The amount of time that the Recovery Instance has been replicating for.</p>
    pub fn elapsed_replication_duration(&self) -> std::option::Option<&str> {
        self.elapsed_replication_duration.as_deref()
    }
    /// <p>The launch type (Recovery / Drill) of the last launch for the failback replication of this recovery instance.</p>
    pub fn failback_launch_type(&self) -> std::option::Option<&crate::model::FailbackLaunchType> {
        self.failback_launch_type.as_ref()
    }
}
/// See [`RecoveryInstanceFailback`](crate::model::RecoveryInstanceFailback).
pub mod recovery_instance_failback {

    /// A builder for [`RecoveryInstanceFailback`](crate::model::RecoveryInstanceFailback).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) failback_client_id: std::option::Option<std::string::String>,
        pub(crate) failback_job_id: std::option::Option<std::string::String>,
        pub(crate) failback_initiation_time: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::FailbackState>,
        pub(crate) agent_last_seen_by_service_date_time: std::option::Option<std::string::String>,
        pub(crate) failback_client_last_seen_by_service_date_time:
            std::option::Option<std::string::String>,
        pub(crate) failback_to_original_server: std::option::Option<bool>,
        pub(crate) first_byte_date_time: std::option::Option<std::string::String>,
        pub(crate) elapsed_replication_duration: std::option::Option<std::string::String>,
        pub(crate) failback_launch_type: std::option::Option<crate::model::FailbackLaunchType>,
    }
    impl Builder {
        /// <p>The ID of the failback client that this Recovery Instance is associated with.</p>
        pub fn failback_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.failback_client_id = Some(input.into());
            self
        }
        /// <p>The ID of the failback client that this Recovery Instance is associated with.</p>
        pub fn set_failback_client_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failback_client_id = input;
            self
        }
        /// <p>The Job ID of the last failback log for this Recovery Instance.</p>
        pub fn failback_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.failback_job_id = Some(input.into());
            self
        }
        /// <p>The Job ID of the last failback log for this Recovery Instance.</p>
        pub fn set_failback_job_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failback_job_id = input;
            self
        }
        /// <p>The date and time that the failback initiation started.</p>
        pub fn failback_initiation_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.failback_initiation_time = Some(input.into());
            self
        }
        /// <p>The date and time that the failback initiation started.</p>
        pub fn set_failback_initiation_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failback_initiation_time = input;
            self
        }
        /// <p>The state of the failback process that this Recovery Instance is in.</p>
        pub fn state(mut self, input: crate::model::FailbackState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the failback process that this Recovery Instance is in.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::FailbackState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The date and time the agent on the Recovery Instance was last seen by the service.</p>
        pub fn agent_last_seen_by_service_date_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.agent_last_seen_by_service_date_time = Some(input.into());
            self
        }
        /// <p>The date and time the agent on the Recovery Instance was last seen by the service.</p>
        pub fn set_agent_last_seen_by_service_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.agent_last_seen_by_service_date_time = input;
            self
        }
        /// <p>The date and time that the failback client was last seen by the service.</p>
        pub fn failback_client_last_seen_by_service_date_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.failback_client_last_seen_by_service_date_time = Some(input.into());
            self
        }
        /// <p>The date and time that the failback client was last seen by the service.</p>
        pub fn set_failback_client_last_seen_by_service_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failback_client_last_seen_by_service_date_time = input;
            self
        }
        /// <p>Whether we are failing back to the original Source Server for this Recovery Instance.</p>
        pub fn failback_to_original_server(mut self, input: bool) -> Self {
            self.failback_to_original_server = Some(input);
            self
        }
        /// <p>Whether we are failing back to the original Source Server for this Recovery Instance.</p>
        pub fn set_failback_to_original_server(mut self, input: std::option::Option<bool>) -> Self {
            self.failback_to_original_server = input;
            self
        }
        /// <p>The date and time of the first byte that was replicated from the Recovery Instance.</p>
        pub fn first_byte_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_byte_date_time = Some(input.into());
            self
        }
        /// <p>The date and time of the first byte that was replicated from the Recovery Instance.</p>
        pub fn set_first_byte_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.first_byte_date_time = input;
            self
        }
        /// <p>The amount of time that the Recovery Instance has been replicating for.</p>
        pub fn elapsed_replication_duration(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elapsed_replication_duration = Some(input.into());
            self
        }
        /// <p>The amount of time that the Recovery Instance has been replicating for.</p>
        pub fn set_elapsed_replication_duration(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elapsed_replication_duration = input;
            self
        }
        /// <p>The launch type (Recovery / Drill) of the last launch for the failback replication of this recovery instance.</p>
        pub fn failback_launch_type(mut self, input: crate::model::FailbackLaunchType) -> Self {
            self.failback_launch_type = Some(input);
            self
        }
        /// <p>The launch type (Recovery / Drill) of the last launch for the failback replication of this recovery instance.</p>
        pub fn set_failback_launch_type(
            mut self,
            input: std::option::Option<crate::model::FailbackLaunchType>,
        ) -> Self {
            self.failback_launch_type = input;
            self
        }
        /// Consumes the builder and constructs a [`RecoveryInstanceFailback`](crate::model::RecoveryInstanceFailback).
        pub fn build(self) -> crate::model::RecoveryInstanceFailback {
            crate::model::RecoveryInstanceFailback {
                failback_client_id: self.failback_client_id,
                failback_job_id: self.failback_job_id,
                failback_initiation_time: self.failback_initiation_time,
                state: self.state,
                agent_last_seen_by_service_date_time: self.agent_last_seen_by_service_date_time,
                failback_client_last_seen_by_service_date_time: self
                    .failback_client_last_seen_by_service_date_time,
                failback_to_original_server: self.failback_to_original_server,
                first_byte_date_time: self.first_byte_date_time,
                elapsed_replication_duration: self.elapsed_replication_duration,
                failback_launch_type: self.failback_launch_type,
            }
        }
    }
}
impl RecoveryInstanceFailback {
    /// Creates a new builder-style object to manufacture [`RecoveryInstanceFailback`](crate::model::RecoveryInstanceFailback).
    pub fn builder() -> crate::model::recovery_instance_failback::Builder {
        crate::model::recovery_instance_failback::Builder::default()
    }
}

/// When writing a match expression against `FailbackLaunchType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let failbacklaunchtype = unimplemented!();
/// match failbacklaunchtype {
///     FailbackLaunchType::Drill => { /* ... */ },
///     FailbackLaunchType::Recovery => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `failbacklaunchtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FailbackLaunchType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FailbackLaunchType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FailbackLaunchType::NewFeature` is defined.
/// Specifically, when `failbacklaunchtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FailbackLaunchType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailbackLaunchType {
    #[allow(missing_docs)] // documentation missing in model
    Drill,
    #[allow(missing_docs)] // documentation missing in model
    Recovery,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FailbackLaunchType {
    fn from(s: &str) -> Self {
        match s {
            "DRILL" => FailbackLaunchType::Drill,
            "RECOVERY" => FailbackLaunchType::Recovery,
            other => {
                FailbackLaunchType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FailbackLaunchType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailbackLaunchType::from(s))
    }
}
impl FailbackLaunchType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailbackLaunchType::Drill => "DRILL",
            FailbackLaunchType::Recovery => "RECOVERY",
            FailbackLaunchType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DRILL", "RECOVERY"]
    }
}
impl AsRef<str> for FailbackLaunchType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FailbackState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let failbackstate = unimplemented!();
/// match failbackstate {
///     FailbackState::FailbackCompleted => { /* ... */ },
///     FailbackState::FailbackError => { /* ... */ },
///     FailbackState::FailbackInProgress => { /* ... */ },
///     FailbackState::FailbackLaunchStateNotAvailable => { /* ... */ },
///     FailbackState::FailbackNotReadyForLaunch => { /* ... */ },
///     FailbackState::FailbackNotStarted => { /* ... */ },
///     FailbackState::FailbackReadyForLaunch => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `failbackstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FailbackState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FailbackState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FailbackState::NewFeature` is defined.
/// Specifically, when `failbackstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FailbackState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FailbackState {
    #[allow(missing_docs)] // documentation missing in model
    FailbackCompleted,
    #[allow(missing_docs)] // documentation missing in model
    FailbackError,
    #[allow(missing_docs)] // documentation missing in model
    FailbackInProgress,
    #[allow(missing_docs)] // documentation missing in model
    FailbackLaunchStateNotAvailable,
    #[allow(missing_docs)] // documentation missing in model
    FailbackNotReadyForLaunch,
    #[allow(missing_docs)] // documentation missing in model
    FailbackNotStarted,
    #[allow(missing_docs)] // documentation missing in model
    FailbackReadyForLaunch,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FailbackState {
    fn from(s: &str) -> Self {
        match s {
            "FAILBACK_COMPLETED" => FailbackState::FailbackCompleted,
            "FAILBACK_ERROR" => FailbackState::FailbackError,
            "FAILBACK_IN_PROGRESS" => FailbackState::FailbackInProgress,
            "FAILBACK_LAUNCH_STATE_NOT_AVAILABLE" => FailbackState::FailbackLaunchStateNotAvailable,
            "FAILBACK_NOT_READY_FOR_LAUNCH" => FailbackState::FailbackNotReadyForLaunch,
            "FAILBACK_NOT_STARTED" => FailbackState::FailbackNotStarted,
            "FAILBACK_READY_FOR_LAUNCH" => FailbackState::FailbackReadyForLaunch,
            other => FailbackState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FailbackState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FailbackState::from(s))
    }
}
impl FailbackState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FailbackState::FailbackCompleted => "FAILBACK_COMPLETED",
            FailbackState::FailbackError => "FAILBACK_ERROR",
            FailbackState::FailbackInProgress => "FAILBACK_IN_PROGRESS",
            FailbackState::FailbackLaunchStateNotAvailable => "FAILBACK_LAUNCH_STATE_NOT_AVAILABLE",
            FailbackState::FailbackNotReadyForLaunch => "FAILBACK_NOT_READY_FOR_LAUNCH",
            FailbackState::FailbackNotStarted => "FAILBACK_NOT_STARTED",
            FailbackState::FailbackReadyForLaunch => "FAILBACK_READY_FOR_LAUNCH",
            FailbackState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FAILBACK_COMPLETED",
            "FAILBACK_ERROR",
            "FAILBACK_IN_PROGRESS",
            "FAILBACK_LAUNCH_STATE_NOT_AVAILABLE",
            "FAILBACK_NOT_READY_FOR_LAUNCH",
            "FAILBACK_NOT_STARTED",
            "FAILBACK_READY_FOR_LAUNCH",
        ]
    }
}
impl AsRef<str> for FailbackState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Ec2InstanceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ec2instancestate = unimplemented!();
/// match ec2instancestate {
///     Ec2InstanceState::NotFound => { /* ... */ },
///     Ec2InstanceState::Pending => { /* ... */ },
///     Ec2InstanceState::Running => { /* ... */ },
///     Ec2InstanceState::ShuttingDown => { /* ... */ },
///     Ec2InstanceState::Stopped => { /* ... */ },
///     Ec2InstanceState::Stopping => { /* ... */ },
///     Ec2InstanceState::Terminated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ec2instancestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Ec2InstanceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Ec2InstanceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Ec2InstanceState::NewFeature` is defined.
/// Specifically, when `ec2instancestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Ec2InstanceState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Ec2InstanceState {
    #[allow(missing_docs)] // documentation missing in model
    NotFound,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    ShuttingDown,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Ec2InstanceState {
    fn from(s: &str) -> Self {
        match s {
            "NOT_FOUND" => Ec2InstanceState::NotFound,
            "PENDING" => Ec2InstanceState::Pending,
            "RUNNING" => Ec2InstanceState::Running,
            "SHUTTING-DOWN" => Ec2InstanceState::ShuttingDown,
            "STOPPED" => Ec2InstanceState::Stopped,
            "STOPPING" => Ec2InstanceState::Stopping,
            "TERMINATED" => Ec2InstanceState::Terminated,
            other => Ec2InstanceState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Ec2InstanceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Ec2InstanceState::from(s))
    }
}
impl Ec2InstanceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Ec2InstanceState::NotFound => "NOT_FOUND",
            Ec2InstanceState::Pending => "PENDING",
            Ec2InstanceState::Running => "RUNNING",
            Ec2InstanceState::ShuttingDown => "SHUTTING-DOWN",
            Ec2InstanceState::Stopped => "STOPPED",
            Ec2InstanceState::Stopping => "STOPPING",
            Ec2InstanceState::Terminated => "TERMINATED",
            Ec2InstanceState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "NOT_FOUND",
            "PENDING",
            "RUNNING",
            "SHUTTING-DOWN",
            "STOPPED",
            "STOPPING",
            "TERMINATED",
        ]
    }
}
impl AsRef<str> for Ec2InstanceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A set of filters by which to return Recovery Instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeRecoveryInstancesRequestFilters {
    /// <p>An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.</p>
    #[doc(hidden)]
    pub recovery_instance_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An array of Source Server IDs for which associated Recovery Instances should be returned.</p>
    #[doc(hidden)]
    pub source_server_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl DescribeRecoveryInstancesRequestFilters {
    /// <p>An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.</p>
    pub fn recovery_instance_i_ds(&self) -> std::option::Option<&[std::string::String]> {
        self.recovery_instance_i_ds.as_deref()
    }
    /// <p>An array of Source Server IDs for which associated Recovery Instances should be returned.</p>
    pub fn source_server_i_ds(&self) -> std::option::Option<&[std::string::String]> {
        self.source_server_i_ds.as_deref()
    }
}
/// See [`DescribeRecoveryInstancesRequestFilters`](crate::model::DescribeRecoveryInstancesRequestFilters).
pub mod describe_recovery_instances_request_filters {

    /// A builder for [`DescribeRecoveryInstancesRequestFilters`](crate::model::DescribeRecoveryInstancesRequestFilters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recovery_instance_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) source_server_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `recovery_instance_i_ds`.
        ///
        /// To override the contents of this collection use [`set_recovery_instance_i_ds`](Self::set_recovery_instance_i_ds).
        ///
        /// <p>An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.</p>
        pub fn recovery_instance_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.recovery_instance_i_ds.unwrap_or_default();
            v.push(input.into());
            self.recovery_instance_i_ds = Some(v);
            self
        }
        /// <p>An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.</p>
        pub fn set_recovery_instance_i_ds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.recovery_instance_i_ds = input;
            self
        }
        /// Appends an item to `source_server_i_ds`.
        ///
        /// To override the contents of this collection use [`set_source_server_i_ds`](Self::set_source_server_i_ds).
        ///
        /// <p>An array of Source Server IDs for which associated Recovery Instances should be returned.</p>
        pub fn source_server_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_server_i_ds.unwrap_or_default();
            v.push(input.into());
            self.source_server_i_ds = Some(v);
            self
        }
        /// <p>An array of Source Server IDs for which associated Recovery Instances should be returned.</p>
        pub fn set_source_server_i_ds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_server_i_ds = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRecoveryInstancesRequestFilters`](crate::model::DescribeRecoveryInstancesRequestFilters).
        pub fn build(self) -> crate::model::DescribeRecoveryInstancesRequestFilters {
            crate::model::DescribeRecoveryInstancesRequestFilters {
                recovery_instance_i_ds: self.recovery_instance_i_ds,
                source_server_i_ds: self.source_server_i_ds,
            }
        }
    }
}
impl DescribeRecoveryInstancesRequestFilters {
    /// Creates a new builder-style object to manufacture [`DescribeRecoveryInstancesRequestFilters`](crate::model::DescribeRecoveryInstancesRequestFilters).
    pub fn builder() -> crate::model::describe_recovery_instances_request_filters::Builder {
        crate::model::describe_recovery_instances_request_filters::Builder::default()
    }
}

/// <p>A log outputted by a Job.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobLog {
    /// <p>The date and time the log was taken.</p>
    #[doc(hidden)]
    pub log_date_time: std::option::Option<std::string::String>,
    /// <p>The event represents the type of a log.</p>
    #[doc(hidden)]
    pub event: std::option::Option<crate::model::JobLogEvent>,
    /// <p>Metadata associated with a Job log.</p>
    #[doc(hidden)]
    pub event_data: std::option::Option<crate::model::JobLogEventData>,
}
impl JobLog {
    /// <p>The date and time the log was taken.</p>
    pub fn log_date_time(&self) -> std::option::Option<&str> {
        self.log_date_time.as_deref()
    }
    /// <p>The event represents the type of a log.</p>
    pub fn event(&self) -> std::option::Option<&crate::model::JobLogEvent> {
        self.event.as_ref()
    }
    /// <p>Metadata associated with a Job log.</p>
    pub fn event_data(&self) -> std::option::Option<&crate::model::JobLogEventData> {
        self.event_data.as_ref()
    }
}
/// See [`JobLog`](crate::model::JobLog).
pub mod job_log {

    /// A builder for [`JobLog`](crate::model::JobLog).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_date_time: std::option::Option<std::string::String>,
        pub(crate) event: std::option::Option<crate::model::JobLogEvent>,
        pub(crate) event_data: std::option::Option<crate::model::JobLogEventData>,
    }
    impl Builder {
        /// <p>The date and time the log was taken.</p>
        pub fn log_date_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_date_time = Some(input.into());
            self
        }
        /// <p>The date and time the log was taken.</p>
        pub fn set_log_date_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_date_time = input;
            self
        }
        /// <p>The event represents the type of a log.</p>
        pub fn event(mut self, input: crate::model::JobLogEvent) -> Self {
            self.event = Some(input);
            self
        }
        /// <p>The event represents the type of a log.</p>
        pub fn set_event(mut self, input: std::option::Option<crate::model::JobLogEvent>) -> Self {
            self.event = input;
            self
        }
        /// <p>Metadata associated with a Job log.</p>
        pub fn event_data(mut self, input: crate::model::JobLogEventData) -> Self {
            self.event_data = Some(input);
            self
        }
        /// <p>Metadata associated with a Job log.</p>
        pub fn set_event_data(
            mut self,
            input: std::option::Option<crate::model::JobLogEventData>,
        ) -> Self {
            self.event_data = input;
            self
        }
        /// Consumes the builder and constructs a [`JobLog`](crate::model::JobLog).
        pub fn build(self) -> crate::model::JobLog {
            crate::model::JobLog {
                log_date_time: self.log_date_time,
                event: self.event,
                event_data: self.event_data,
            }
        }
    }
}
impl JobLog {
    /// Creates a new builder-style object to manufacture [`JobLog`](crate::model::JobLog).
    pub fn builder() -> crate::model::job_log::Builder {
        crate::model::job_log::Builder::default()
    }
}

/// <p>Metadata associated with a Job log.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobLogEventData {
    /// <p>The ID of a Source Server.</p>
    #[doc(hidden)]
    pub source_server_id: std::option::Option<std::string::String>,
    /// <p>The ID of a conversion server.</p>
    #[doc(hidden)]
    pub conversion_server_id: std::option::Option<std::string::String>,
    /// <p>The ID of a Recovery Instance.</p>
    #[doc(hidden)]
    pub target_instance_id: std::option::Option<std::string::String>,
    /// <p>A string representing a job error.</p>
    #[doc(hidden)]
    pub raw_error: std::option::Option<std::string::String>,
    /// <p>Properties of a conversion job</p>
    #[doc(hidden)]
    pub conversion_properties: std::option::Option<crate::model::ConversionProperties>,
}
impl JobLogEventData {
    /// <p>The ID of a Source Server.</p>
    pub fn source_server_id(&self) -> std::option::Option<&str> {
        self.source_server_id.as_deref()
    }
    /// <p>The ID of a conversion server.</p>
    pub fn conversion_server_id(&self) -> std::option::Option<&str> {
        self.conversion_server_id.as_deref()
    }
    /// <p>The ID of a Recovery Instance.</p>
    pub fn target_instance_id(&self) -> std::option::Option<&str> {
        self.target_instance_id.as_deref()
    }
    /// <p>A string representing a job error.</p>
    pub fn raw_error(&self) -> std::option::Option<&str> {
        self.raw_error.as_deref()
    }
    /// <p>Properties of a conversion job</p>
    pub fn conversion_properties(
        &self,
    ) -> std::option::Option<&crate::model::ConversionProperties> {
        self.conversion_properties.as_ref()
    }
}
/// See [`JobLogEventData`](crate::model::JobLogEventData).
pub mod job_log_event_data {

    /// A builder for [`JobLogEventData`](crate::model::JobLogEventData).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_server_id: std::option::Option<std::string::String>,
        pub(crate) conversion_server_id: std::option::Option<std::string::String>,
        pub(crate) target_instance_id: std::option::Option<std::string::String>,
        pub(crate) raw_error: std::option::Option<std::string::String>,
        pub(crate) conversion_properties: std::option::Option<crate::model::ConversionProperties>,
    }
    impl Builder {
        /// <p>The ID of a Source Server.</p>
        pub fn source_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_server_id = Some(input.into());
            self
        }
        /// <p>The ID of a Source Server.</p>
        pub fn set_source_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_server_id = input;
            self
        }
        /// <p>The ID of a conversion server.</p>
        pub fn conversion_server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.conversion_server_id = Some(input.into());
            self
        }
        /// <p>The ID of a conversion server.</p>
        pub fn set_conversion_server_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.conversion_server_id = input;
            self
        }
        /// <p>The ID of a Recovery Instance.</p>
        pub fn target_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_instance_id = Some(input.into());
            self
        }
        /// <p>The ID of a Recovery Instance.</p>
        pub fn set_target_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_instance_id = input;
            self
        }
        /// <p>A string representing a job error.</p>
        pub fn raw_error(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_error = Some(input.into());
            self
        }
        /// <p>A string representing a job error.</p>
        pub fn set_raw_error(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_error = input;
            self
        }
        /// <p>Properties of a conversion job</p>
        pub fn conversion_properties(mut self, input: crate::model::ConversionProperties) -> Self {
            self.conversion_properties = Some(input);
            self
        }
        /// <p>Properties of a conversion job</p>
        pub fn set_conversion_properties(
            mut self,
            input: std::option::Option<crate::model::ConversionProperties>,
        ) -> Self {
            self.conversion_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`JobLogEventData`](crate::model::JobLogEventData).
        pub fn build(self) -> crate::model::JobLogEventData {
            crate::model::JobLogEventData {
                source_server_id: self.source_server_id,
                conversion_server_id: self.conversion_server_id,
                target_instance_id: self.target_instance_id,
                raw_error: self.raw_error,
                conversion_properties: self.conversion_properties,
            }
        }
    }
}
impl JobLogEventData {
    /// Creates a new builder-style object to manufacture [`JobLogEventData`](crate::model::JobLogEventData).
    pub fn builder() -> crate::model::job_log_event_data::Builder {
        crate::model::job_log_event_data::Builder::default()
    }
}

/// <p>Properties of a conversion job</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConversionProperties {
    /// <p>A mapping between the volumes being converted and the converted snapshot ids</p>
    #[doc(hidden)]
    pub volume_to_conversion_map: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    >,
    /// <p>The root volume name of a conversion job</p>
    #[doc(hidden)]
    pub root_volume_name: std::option::Option<std::string::String>,
    /// <p>Whether the volume being converted uses UEFI or not</p>
    #[doc(hidden)]
    pub force_uefi: std::option::Option<bool>,
    /// <p>The timestamp of when the snapshot being converted was taken</p>
    #[doc(hidden)]
    pub data_timestamp: std::option::Option<std::string::String>,
    /// <p>A mapping between the volumes and their sizes</p>
    #[doc(hidden)]
    pub volume_to_volume_size:
        std::option::Option<std::collections::HashMap<std::string::String, i64>>,
}
impl ConversionProperties {
    /// <p>A mapping between the volumes being converted and the converted snapshot ids</p>
    pub fn volume_to_conversion_map(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    > {
        self.volume_to_conversion_map.as_ref()
    }
    /// <p>The root volume name of a conversion job</p>
    pub fn root_volume_name(&self) -> std::option::Option<&str> {
        self.root_volume_name.as_deref()
    }
    /// <p>Whether the volume being converted uses UEFI or not</p>
    pub fn force_uefi(&self) -> std::option::Option<bool> {
        self.force_uefi
    }
    /// <p>The timestamp of when the snapshot being converted was taken</p>
    pub fn data_timestamp(&self) -> std::option::Option<&str> {
        self.data_timestamp.as_deref()
    }
    /// <p>A mapping between the volumes and their sizes</p>
    pub fn volume_to_volume_size(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, i64>> {
        self.volume_to_volume_size.as_ref()
    }
}
/// See [`ConversionProperties`](crate::model::ConversionProperties).
pub mod conversion_properties {

    /// A builder for [`ConversionProperties`](crate::model::ConversionProperties).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) volume_to_conversion_map: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        >,
        pub(crate) root_volume_name: std::option::Option<std::string::String>,
        pub(crate) force_uefi: std::option::Option<bool>,
        pub(crate) data_timestamp: std::option::Option<std::string::String>,
        pub(crate) volume_to_volume_size:
            std::option::Option<std::collections::HashMap<std::string::String, i64>>,
    }
    impl Builder {
        /// Adds a key-value pair to `volume_to_conversion_map`.
        ///
        /// To override the contents of this collection use [`set_volume_to_conversion_map`](Self::set_volume_to_conversion_map).
        ///
        /// <p>A mapping between the volumes being converted and the converted snapshot ids</p>
        pub fn volume_to_conversion_map(
            mut self,
            k: impl Into<std::string::String>,
            v: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut hash_map = self.volume_to_conversion_map.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.volume_to_conversion_map = Some(hash_map);
            self
        }
        /// <p>A mapping between the volumes being converted and the converted snapshot ids</p>
        pub fn set_volume_to_conversion_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<std::string::String, std::string::String>,
                >,
            >,
        ) -> Self {
            self.volume_to_conversion_map = input;
            self
        }
        /// <p>The root volume name of a conversion job</p>
        pub fn root_volume_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.root_volume_name = Some(input.into());
            self
        }
        /// <p>The root volume name of a conversion job</p>
        pub fn set_root_volume_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.root_volume_name = input;
            self
        }
        /// <p>Whether the volume being converted uses UEFI or not</p>
        pub fn force_uefi(mut self, input: bool) -> Self {
            self.force_uefi = Some(input);
            self
        }
        /// <p>Whether the volume being converted uses UEFI or not</p>
        pub fn set_force_uefi(mut self, input: std::option::Option<bool>) -> Self {
            self.force_uefi = input;
            self
        }
        /// <p>The timestamp of when the snapshot being converted was taken</p>
        pub fn data_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_timestamp = Some(input.into());
            self
        }
        /// <p>The timestamp of when the snapshot being converted was taken</p>
        pub fn set_data_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_timestamp = input;
            self
        }
        /// Adds a key-value pair to `volume_to_volume_size`.
        ///
        /// To override the contents of this collection use [`set_volume_to_volume_size`](Self::set_volume_to_volume_size).
        ///
        /// <p>A mapping between the volumes and their sizes</p>
        pub fn volume_to_volume_size(mut self, k: impl Into<std::string::String>, v: i64) -> Self {
            let mut hash_map = self.volume_to_volume_size.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.volume_to_volume_size = Some(hash_map);
            self
        }
        /// <p>A mapping between the volumes and their sizes</p>
        pub fn set_volume_to_volume_size(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, i64>>,
        ) -> Self {
            self.volume_to_volume_size = input;
            self
        }
        /// Consumes the builder and constructs a [`ConversionProperties`](crate::model::ConversionProperties).
        pub fn build(self) -> crate::model::ConversionProperties {
            crate::model::ConversionProperties {
                volume_to_conversion_map: self.volume_to_conversion_map,
                root_volume_name: self.root_volume_name,
                force_uefi: self.force_uefi,
                data_timestamp: self.data_timestamp,
                volume_to_volume_size: self.volume_to_volume_size,
            }
        }
    }
}
impl ConversionProperties {
    /// Creates a new builder-style object to manufacture [`ConversionProperties`](crate::model::ConversionProperties).
    pub fn builder() -> crate::model::conversion_properties::Builder {
        crate::model::conversion_properties::Builder::default()
    }
}

/// When writing a match expression against `JobLogEvent`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let joblogevent = unimplemented!();
/// match joblogevent {
///     JobLogEvent::CleanupEnd => { /* ... */ },
///     JobLogEvent::CleanupFail => { /* ... */ },
///     JobLogEvent::CleanupStart => { /* ... */ },
///     JobLogEvent::ConversionEnd => { /* ... */ },
///     JobLogEvent::ConversionFail => { /* ... */ },
///     JobLogEvent::ConversionStart => { /* ... */ },
///     JobLogEvent::JobCancel => { /* ... */ },
///     JobLogEvent::JobEnd => { /* ... */ },
///     JobLogEvent::JobStart => { /* ... */ },
///     JobLogEvent::LaunchFailed => { /* ... */ },
///     JobLogEvent::LaunchStart => { /* ... */ },
///     JobLogEvent::ServerSkipped => { /* ... */ },
///     JobLogEvent::SnapshotEnd => { /* ... */ },
///     JobLogEvent::SnapshotFail => { /* ... */ },
///     JobLogEvent::SnapshotStart => { /* ... */ },
///     JobLogEvent::UsingPreviousSnapshot => { /* ... */ },
///     JobLogEvent::UsingPreviousSnapshotFailed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `joblogevent` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobLogEvent::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobLogEvent::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobLogEvent::NewFeature` is defined.
/// Specifically, when `joblogevent` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobLogEvent::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobLogEvent {
    #[allow(missing_docs)] // documentation missing in model
    CleanupEnd,
    #[allow(missing_docs)] // documentation missing in model
    CleanupFail,
    #[allow(missing_docs)] // documentation missing in model
    CleanupStart,
    #[allow(missing_docs)] // documentation missing in model
    ConversionEnd,
    #[allow(missing_docs)] // documentation missing in model
    ConversionFail,
    #[allow(missing_docs)] // documentation missing in model
    ConversionStart,
    #[allow(missing_docs)] // documentation missing in model
    JobCancel,
    #[allow(missing_docs)] // documentation missing in model
    JobEnd,
    #[allow(missing_docs)] // documentation missing in model
    JobStart,
    #[allow(missing_docs)] // documentation missing in model
    LaunchFailed,
    #[allow(missing_docs)] // documentation missing in model
    LaunchStart,
    #[allow(missing_docs)] // documentation missing in model
    ServerSkipped,
    #[allow(missing_docs)] // documentation missing in model
    SnapshotEnd,
    #[allow(missing_docs)] // documentation missing in model
    SnapshotFail,
    #[allow(missing_docs)] // documentation missing in model
    SnapshotStart,
    #[allow(missing_docs)] // documentation missing in model
    UsingPreviousSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    UsingPreviousSnapshotFailed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobLogEvent {
    fn from(s: &str) -> Self {
        match s {
            "CLEANUP_END" => JobLogEvent::CleanupEnd,
            "CLEANUP_FAIL" => JobLogEvent::CleanupFail,
            "CLEANUP_START" => JobLogEvent::CleanupStart,
            "CONVERSION_END" => JobLogEvent::ConversionEnd,
            "CONVERSION_FAIL" => JobLogEvent::ConversionFail,
            "CONVERSION_START" => JobLogEvent::ConversionStart,
            "JOB_CANCEL" => JobLogEvent::JobCancel,
            "JOB_END" => JobLogEvent::JobEnd,
            "JOB_START" => JobLogEvent::JobStart,
            "LAUNCH_FAILED" => JobLogEvent::LaunchFailed,
            "LAUNCH_START" => JobLogEvent::LaunchStart,
            "SERVER_SKIPPED" => JobLogEvent::ServerSkipped,
            "SNAPSHOT_END" => JobLogEvent::SnapshotEnd,
            "SNAPSHOT_FAIL" => JobLogEvent::SnapshotFail,
            "SNAPSHOT_START" => JobLogEvent::SnapshotStart,
            "USING_PREVIOUS_SNAPSHOT" => JobLogEvent::UsingPreviousSnapshot,
            "USING_PREVIOUS_SNAPSHOT_FAILED" => JobLogEvent::UsingPreviousSnapshotFailed,
            other => JobLogEvent::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobLogEvent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobLogEvent::from(s))
    }
}
impl JobLogEvent {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobLogEvent::CleanupEnd => "CLEANUP_END",
            JobLogEvent::CleanupFail => "CLEANUP_FAIL",
            JobLogEvent::CleanupStart => "CLEANUP_START",
            JobLogEvent::ConversionEnd => "CONVERSION_END",
            JobLogEvent::ConversionFail => "CONVERSION_FAIL",
            JobLogEvent::ConversionStart => "CONVERSION_START",
            JobLogEvent::JobCancel => "JOB_CANCEL",
            JobLogEvent::JobEnd => "JOB_END",
            JobLogEvent::JobStart => "JOB_START",
            JobLogEvent::LaunchFailed => "LAUNCH_FAILED",
            JobLogEvent::LaunchStart => "LAUNCH_START",
            JobLogEvent::ServerSkipped => "SERVER_SKIPPED",
            JobLogEvent::SnapshotEnd => "SNAPSHOT_END",
            JobLogEvent::SnapshotFail => "SNAPSHOT_FAIL",
            JobLogEvent::SnapshotStart => "SNAPSHOT_START",
            JobLogEvent::UsingPreviousSnapshot => "USING_PREVIOUS_SNAPSHOT",
            JobLogEvent::UsingPreviousSnapshotFailed => "USING_PREVIOUS_SNAPSHOT_FAILED",
            JobLogEvent::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CLEANUP_END",
            "CLEANUP_FAIL",
            "CLEANUP_START",
            "CONVERSION_END",
            "CONVERSION_FAIL",
            "CONVERSION_START",
            "JOB_CANCEL",
            "JOB_END",
            "JOB_START",
            "LAUNCH_FAILED",
            "LAUNCH_START",
            "SERVER_SKIPPED",
            "SNAPSHOT_END",
            "SNAPSHOT_FAIL",
            "SNAPSHOT_START",
            "USING_PREVIOUS_SNAPSHOT",
            "USING_PREVIOUS_SNAPSHOT_FAILED",
        ]
    }
}
impl AsRef<str> for JobLogEvent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A set of filters by which to return Jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeJobsRequestFilters {
    /// <p>An array of Job IDs that should be returned. An empty array means all jobs.</p>
    #[doc(hidden)]
    pub job_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The start date in a date range query.</p>
    #[doc(hidden)]
    pub from_date: std::option::Option<std::string::String>,
    /// <p>The end date in a date range query.</p>
    #[doc(hidden)]
    pub to_date: std::option::Option<std::string::String>,
}
impl DescribeJobsRequestFilters {
    /// <p>An array of Job IDs that should be returned. An empty array means all jobs.</p>
    pub fn job_i_ds(&self) -> std::option::Option<&[std::string::String]> {
        self.job_i_ds.as_deref()
    }
    /// <p>The start date in a date range query.</p>
    pub fn from_date(&self) -> std::option::Option<&str> {
        self.from_date.as_deref()
    }
    /// <p>The end date in a date range query.</p>
    pub fn to_date(&self) -> std::option::Option<&str> {
        self.to_date.as_deref()
    }
}
/// See [`DescribeJobsRequestFilters`](crate::model::DescribeJobsRequestFilters).
pub mod describe_jobs_request_filters {

    /// A builder for [`DescribeJobsRequestFilters`](crate::model::DescribeJobsRequestFilters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_i_ds: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) from_date: std::option::Option<std::string::String>,
        pub(crate) to_date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `job_i_ds`.
        ///
        /// To override the contents of this collection use [`set_job_i_ds`](Self::set_job_i_ds).
        ///
        /// <p>An array of Job IDs that should be returned. An empty array means all jobs.</p>
        pub fn job_i_ds(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.job_i_ds.unwrap_or_default();
            v.push(input.into());
            self.job_i_ds = Some(v);
            self
        }
        /// <p>An array of Job IDs that should be returned. An empty array means all jobs.</p>
        pub fn set_job_i_ds(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.job_i_ds = input;
            self
        }
        /// <p>The start date in a date range query.</p>
        pub fn from_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_date = Some(input.into());
            self
        }
        /// <p>The start date in a date range query.</p>
        pub fn set_from_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_date = input;
            self
        }
        /// <p>The end date in a date range query.</p>
        pub fn to_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.to_date = Some(input.into());
            self
        }
        /// <p>The end date in a date range query.</p>
        pub fn set_to_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.to_date = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeJobsRequestFilters`](crate::model::DescribeJobsRequestFilters).
        pub fn build(self) -> crate::model::DescribeJobsRequestFilters {
            crate::model::DescribeJobsRequestFilters {
                job_i_ds: self.job_i_ds,
                from_date: self.from_date,
                to_date: self.to_date,
            }
        }
    }
}
impl DescribeJobsRequestFilters {
    /// Creates a new builder-style object to manufacture [`DescribeJobsRequestFilters`](crate::model::DescribeJobsRequestFilters).
    pub fn builder() -> crate::model::describe_jobs_request_filters::Builder {
        crate::model::describe_jobs_request_filters::Builder::default()
    }
}

/// <p>AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Account {
    /// <p>Account ID of AWS account.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
}
impl Account {
    /// <p>Account ID of AWS account.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
}
/// See [`Account`](crate::model::Account).
pub mod account {

    /// A builder for [`Account`](crate::model::Account).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Account ID of AWS account.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>Account ID of AWS account.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Account`](crate::model::Account).
        pub fn build(self) -> crate::model::Account {
            crate::model::Account {
                account_id: self.account_id,
            }
        }
    }
}
impl Account {
    /// Creates a new builder-style object to manufacture [`Account`](crate::model::Account).
    pub fn builder() -> crate::model::account::Builder {
        crate::model::account::Builder::default()
    }
}

/// <p>Source server in staging account that extended source server connected to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StagingSourceServer {
    /// <p>Hostname of staging source server.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The ARN of the source server.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A list of tags associated with the staging source server.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StagingSourceServer {
    /// <p>Hostname of staging source server.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The ARN of the source server.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A list of tags associated with the staging source server.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for StagingSourceServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StagingSourceServer");
        formatter.field("hostname", &self.hostname);
        formatter.field("arn", &self.arn);
        formatter.field("tags", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`StagingSourceServer`](crate::model::StagingSourceServer).
pub mod staging_source_server {

    /// A builder for [`StagingSourceServer`](crate::model::StagingSourceServer).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Hostname of staging source server.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>Hostname of staging source server.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The ARN of the source server.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the source server.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tags associated with the staging source server.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A list of tags associated with the staging source server.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StagingSourceServer`](crate::model::StagingSourceServer).
        pub fn build(self) -> crate::model::StagingSourceServer {
            crate::model::StagingSourceServer {
                hostname: self.hostname,
                arn: self.arn,
                tags: self.tags,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("hostname", &self.hostname);
            formatter.field("arn", &self.arn);
            formatter.field("tags", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl StagingSourceServer {
    /// Creates a new builder-style object to manufacture [`StagingSourceServer`](crate::model::StagingSourceServer).
    pub fn builder() -> crate::model::staging_source_server::Builder {
        crate::model::staging_source_server::Builder::default()
    }
}
