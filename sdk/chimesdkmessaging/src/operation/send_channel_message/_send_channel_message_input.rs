// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SendChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: ::std::option::Option<::std::string::String>,
    /// <p>The content of the channel message.</p>
    pub content: ::std::option::Option<::std::string::String>,
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p> <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub r#type: ::std::option::Option<crate::types::ChannelMessageType>,
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub persistence: ::std::option::Option<crate::types::ChannelMessagePersistenceType>,
    /// <p>The optional metadata for each message.</p>
    pub metadata: ::std::option::Option<::std::string::String>,
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub client_request_token: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub chime_bearer: ::std::option::Option<::std::string::String>,
    /// <p>The push notification configuration of the message.</p>
    pub push_notification: ::std::option::Option<crate::types::PushNotificationConfiguration>,
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub message_attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>>,
    /// <p>The ID of the SubChannel in the request.</p>
    pub sub_channel_id: ::std::option::Option<::std::string::String>,
    /// <p>The content type of the channel message.</p>
    pub content_type: ::std::option::Option<::std::string::String>,
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see. </p>
    pub target: ::std::option::Option<::std::vec::Vec<crate::types::Target>>,
}
impl SendChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(&self) -> ::std::option::Option<&str> {
        self.channel_arn.as_deref()
    }
    /// <p>The content of the channel message.</p>
    pub fn content(&self) -> ::std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p> <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::ChannelMessageType> {
        self.r#type.as_ref()
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn persistence(&self) -> ::std::option::Option<&crate::types::ChannelMessagePersistenceType> {
        self.persistence.as_ref()
    }
    /// <p>The optional metadata for each message.</p>
    pub fn metadata(&self) -> ::std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn client_request_token(&self) -> ::std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub fn chime_bearer(&self) -> ::std::option::Option<&str> {
        self.chime_bearer.as_deref()
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn push_notification(&self) -> ::std::option::Option<&crate::types::PushNotificationConfiguration> {
        self.push_notification.as_ref()
    }
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn message_attributes(
        &self,
    ) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>> {
        self.message_attributes.as_ref()
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn sub_channel_id(&self) -> ::std::option::Option<&str> {
        self.sub_channel_id.as_deref()
    }
    /// <p>The content type of the channel message.</p>
    pub fn content_type(&self) -> ::std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see. </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.target.is_none()`.
    pub fn target(&self) -> &[crate::types::Target] {
        self.target.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for SendChannelMessageInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SendChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &self.r#type);
        formatter.field("persistence", &self.persistence);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.field("push_notification", &self.push_notification);
        formatter.field("message_attributes", &self.message_attributes);
        formatter.field("sub_channel_id", &self.sub_channel_id);
        formatter.field("content_type", &"*** Sensitive Data Redacted ***");
        formatter.field("target", &self.target);
        formatter.finish()
    }
}
impl SendChannelMessageInput {
    /// Creates a new builder-style object to manufacture [`SendChannelMessageInput`](crate::operation::send_channel_message::SendChannelMessageInput).
    pub fn builder() -> crate::operation::send_channel_message::builders::SendChannelMessageInputBuilder {
        crate::operation::send_channel_message::builders::SendChannelMessageInputBuilder::default()
    }
}

/// A builder for [`SendChannelMessageInput`](crate::operation::send_channel_message::SendChannelMessageInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct SendChannelMessageInputBuilder {
    pub(crate) channel_arn: ::std::option::Option<::std::string::String>,
    pub(crate) content: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<crate::types::ChannelMessageType>,
    pub(crate) persistence: ::std::option::Option<crate::types::ChannelMessagePersistenceType>,
    pub(crate) metadata: ::std::option::Option<::std::string::String>,
    pub(crate) client_request_token: ::std::option::Option<::std::string::String>,
    pub(crate) chime_bearer: ::std::option::Option<::std::string::String>,
    pub(crate) push_notification: ::std::option::Option<crate::types::PushNotificationConfiguration>,
    pub(crate) message_attributes: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>>,
    pub(crate) sub_channel_id: ::std::option::Option<::std::string::String>,
    pub(crate) content_type: ::std::option::Option<::std::string::String>,
    pub(crate) target: ::std::option::Option<::std::vec::Vec<crate::types::Target>>,
}
impl SendChannelMessageInputBuilder {
    /// <p>The ARN of the channel.</p>
    /// This field is required.
    pub fn channel_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.channel_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the channel.</p>
    pub fn set_channel_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.channel_arn = input;
        self
    }
    /// <p>The ARN of the channel.</p>
    pub fn get_channel_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.channel_arn
    }
    /// <p>The content of the channel message.</p>
    /// This field is required.
    pub fn content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The content of the channel message.</p>
    pub fn set_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content = input;
        self
    }
    /// <p>The content of the channel message.</p>
    pub fn get_content(&self) -> &::std::option::Option<::std::string::String> {
        &self.content
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p> <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    /// This field is required.
    pub fn r#type(mut self, input: crate::types::ChannelMessageType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p> <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::ChannelMessageType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p> <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p> <code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::ChannelMessageType> {
        &self.r#type
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    /// This field is required.
    pub fn persistence(mut self, input: crate::types::ChannelMessagePersistenceType) -> Self {
        self.persistence = ::std::option::Option::Some(input);
        self
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn set_persistence(mut self, input: ::std::option::Option<crate::types::ChannelMessagePersistenceType>) -> Self {
        self.persistence = input;
        self
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn get_persistence(&self) -> &::std::option::Option<crate::types::ChannelMessagePersistenceType> {
        &self.persistence
    }
    /// <p>The optional metadata for each message.</p>
    pub fn metadata(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.metadata = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The optional metadata for each message.</p>
    pub fn set_metadata(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.metadata = input;
        self
    }
    /// <p>The optional metadata for each message.</p>
    pub fn get_metadata(&self) -> &::std::option::Option<::std::string::String> {
        &self.metadata
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    /// This field is required.
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_request_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_request_token = input;
        self
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_request_token
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    /// This field is required.
    pub fn chime_bearer(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.chime_bearer = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub fn set_chime_bearer(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.chime_bearer = input;
        self
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub fn get_chime_bearer(&self) -> &::std::option::Option<::std::string::String> {
        &self.chime_bearer
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn push_notification(mut self, input: crate::types::PushNotificationConfiguration) -> Self {
        self.push_notification = ::std::option::Option::Some(input);
        self
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn set_push_notification(mut self, input: ::std::option::Option<crate::types::PushNotificationConfiguration>) -> Self {
        self.push_notification = input;
        self
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn get_push_notification(&self) -> &::std::option::Option<crate::types::PushNotificationConfiguration> {
        &self.push_notification
    }
    /// Adds a key-value pair to `message_attributes`.
    ///
    /// To override the contents of this collection use [`set_message_attributes`](Self::set_message_attributes).
    ///
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn message_attributes(mut self, k: impl ::std::convert::Into<::std::string::String>, v: crate::types::MessageAttributeValue) -> Self {
        let mut hash_map = self.message_attributes.unwrap_or_default();
        hash_map.insert(k.into(), v);
        self.message_attributes = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn set_message_attributes(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>>,
    ) -> Self {
        self.message_attributes = input;
        self
    }
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn get_message_attributes(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>> {
        &self.message_attributes
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn sub_channel_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.sub_channel_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn set_sub_channel_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.sub_channel_id = input;
        self
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn get_sub_channel_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.sub_channel_id
    }
    /// <p>The content type of the channel message.</p>
    pub fn content_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The content type of the channel message.</p>
    pub fn set_content_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_type = input;
        self
    }
    /// <p>The content type of the channel message.</p>
    pub fn get_content_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_type
    }
    /// Appends an item to `target`.
    ///
    /// To override the contents of this collection use [`set_target`](Self::set_target).
    ///
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see. </p>
    pub fn target(mut self, input: crate::types::Target) -> Self {
        let mut v = self.target.unwrap_or_default();
        v.push(input);
        self.target = ::std::option::Option::Some(v);
        self
    }
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see. </p>
    pub fn set_target(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Target>>) -> Self {
        self.target = input;
        self
    }
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see. </p>
    pub fn get_target(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Target>> {
        &self.target
    }
    /// Consumes the builder and constructs a [`SendChannelMessageInput`](crate::operation::send_channel_message::SendChannelMessageInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::send_channel_message::SendChannelMessageInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::send_channel_message::SendChannelMessageInput {
            channel_arn: self.channel_arn,
            content: self.content,
            r#type: self.r#type,
            persistence: self.persistence,
            metadata: self.metadata,
            client_request_token: self.client_request_token,
            chime_bearer: self.chime_bearer,
            push_notification: self.push_notification,
            message_attributes: self.message_attributes,
            sub_channel_id: self.sub_channel_id,
            content_type: self.content_type,
            target: self.target,
        })
    }
}
impl ::std::fmt::Debug for SendChannelMessageInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SendChannelMessageInputBuilder");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &self.r#type);
        formatter.field("persistence", &self.persistence);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.field("push_notification", &self.push_notification);
        formatter.field("message_attributes", &self.message_attributes);
        formatter.field("sub_channel_id", &self.sub_channel_id);
        formatter.field("content_type", &"*** Sensitive Data Redacted ***");
        formatter.field("target", &self.target);
        formatter.finish()
    }
}
