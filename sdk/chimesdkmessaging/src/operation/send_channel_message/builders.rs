// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::send_channel_message::_send_channel_message_output::SendChannelMessageOutputBuilder;

pub use crate::operation::send_channel_message::_send_channel_message_input::SendChannelMessageInputBuilder;

impl crate::operation::send_channel_message::builders::SendChannelMessageInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::send_channel_message::SendChannelMessageOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::send_channel_message::SendChannelMessageError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.send_channel_message();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `SendChannelMessage`.
///
/// <p>Sends a message to a particular channel that the member is a part of.</p><note>
/// <p>The <code>x-amz-chime-bearer</code> request header is mandatory. Use the ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call as the value in the header.</p>
/// <p>Also, <code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
/// <p><code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
/// </note>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct SendChannelMessageFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::send_channel_message::builders::SendChannelMessageInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::send_channel_message::SendChannelMessageOutput,
        crate::operation::send_channel_message::SendChannelMessageError,
    > for SendChannelMessageFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::send_channel_message::SendChannelMessageOutput,
            crate::operation::send_channel_message::SendChannelMessageError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl SendChannelMessageFluentBuilder {
    /// Creates a new `SendChannelMessageFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the SendChannelMessage as a reference.
    pub fn as_input(&self) -> &crate::operation::send_channel_message::builders::SendChannelMessageInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::send_channel_message::SendChannelMessageOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::send_channel_message::SendChannelMessageError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::send_channel_message::SendChannelMessage::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::send_channel_message::SendChannelMessage::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::send_channel_message::SendChannelMessageOutput,
        crate::operation::send_channel_message::SendChannelMessageError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The ARN of the channel.</p>
    pub fn channel_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.channel_arn(input.into());
        self
    }
    /// <p>The ARN of the channel.</p>
    pub fn set_channel_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_channel_arn(input);
        self
    }
    /// <p>The ARN of the channel.</p>
    pub fn get_channel_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_channel_arn()
    }
    /// <p>The content of the channel message.</p>
    pub fn content(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.content(input.into());
        self
    }
    /// <p>The content of the channel message.</p>
    pub fn set_content(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_content(input);
        self
    }
    /// <p>The content of the channel message.</p>
    pub fn get_content(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_content()
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p><code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p><code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub fn r#type(mut self, input: crate::types::ChannelMessageType) -> Self {
        self.inner = self.inner.r#type(input);
        self
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p><code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p><code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::ChannelMessageType>) -> Self {
        self.inner = self.inner.set_type(input);
        self
    }
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    /// <p><code>STANDARD</code> messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment.</p>
    /// <p><code>CONTROL</code> messages are limited to 30 bytes and do not contain metadata.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::ChannelMessageType> {
        self.inner.get_type()
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn persistence(mut self, input: crate::types::ChannelMessagePersistenceType) -> Self {
        self.inner = self.inner.persistence(input);
        self
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn set_persistence(mut self, input: ::std::option::Option<crate::types::ChannelMessagePersistenceType>) -> Self {
        self.inner = self.inner.set_persistence(input);
        self
    }
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub fn get_persistence(&self) -> &::std::option::Option<crate::types::ChannelMessagePersistenceType> {
        self.inner.get_persistence()
    }
    /// <p>The optional metadata for each message.</p>
    pub fn metadata(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.metadata(input.into());
        self
    }
    /// <p>The optional metadata for each message.</p>
    pub fn set_metadata(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_metadata(input);
        self
    }
    /// <p>The optional metadata for each message.</p>
    pub fn get_metadata(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_metadata()
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_request_token(input.into());
        self
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_request_token(input);
        self
    }
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_request_token()
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub fn chime_bearer(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.chime_bearer(input.into());
        self
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub fn set_chime_bearer(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_chime_bearer(input);
        self
    }
    /// <p>The ARN of the <code>AppInstanceUser</code> or <code>AppInstanceBot</code> that makes the API call.</p>
    pub fn get_chime_bearer(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_chime_bearer()
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn push_notification(mut self, input: crate::types::PushNotificationConfiguration) -> Self {
        self.inner = self.inner.push_notification(input);
        self
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn set_push_notification(mut self, input: ::std::option::Option<crate::types::PushNotificationConfiguration>) -> Self {
        self.inner = self.inner.set_push_notification(input);
        self
    }
    /// <p>The push notification configuration of the message.</p>
    pub fn get_push_notification(&self) -> &::std::option::Option<crate::types::PushNotificationConfiguration> {
        self.inner.get_push_notification()
    }
    ///
    /// Adds a key-value pair to `MessageAttributes`.
    ///
    /// To override the contents of this collection use [`set_message_attributes`](Self::set_message_attributes).
    ///
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn message_attributes(mut self, k: impl ::std::convert::Into<::std::string::String>, v: crate::types::MessageAttributeValue) -> Self {
        self.inner = self.inner.message_attributes(k.into(), v);
        self
    }
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn set_message_attributes(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>>,
    ) -> Self {
        self.inner = self.inner.set_message_attributes(input);
        self
    }
    /// <p>The attributes for the message, used for message filtering along with a <code>FilterRule</code> defined in the <code>PushNotificationPreferences</code>.</p>
    pub fn get_message_attributes(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, crate::types::MessageAttributeValue>> {
        self.inner.get_message_attributes()
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn sub_channel_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.sub_channel_id(input.into());
        self
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn set_sub_channel_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_sub_channel_id(input);
        self
    }
    /// <p>The ID of the SubChannel in the request.</p>
    pub fn get_sub_channel_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_sub_channel_id()
    }
    /// <p>The content type of the channel message.</p>
    pub fn content_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.content_type(input.into());
        self
    }
    /// <p>The content type of the channel message.</p>
    pub fn set_content_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_content_type(input);
        self
    }
    /// <p>The content type of the channel message.</p>
    pub fn get_content_type(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_content_type()
    }
    ///
    /// Appends an item to `Target`.
    ///
    /// To override the contents of this collection use [`set_target`](Self::set_target).
    ///
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.</p>
    pub fn target(mut self, input: crate::types::Target) -> Self {
        self.inner = self.inner.target(input);
        self
    }
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.</p>
    pub fn set_target(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Target>>) -> Self {
        self.inner = self.inner.set_target(input);
        self
    }
    /// <p>The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.</p>
    pub fn get_target(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Target>> {
        self.inner.get_target()
    }
}
