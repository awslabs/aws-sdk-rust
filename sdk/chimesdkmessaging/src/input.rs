// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
pub mod batch_create_channel_membership_input {
    /// A builder for [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMembershipType>,
        pub(crate) member_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel to which you're adding users.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default
        /// members are always returned as part of <code>ListChannelMemberships</code>. Hidden members
        /// are only returned if the type filter in <code>ListChannelMemberships</code> equals
        /// <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported
        /// by moderators.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMembershipType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMembershipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        pub fn member_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.member_arns.unwrap_or_default();
            v.push(input.into());
            self.member_arns = Some(v);
            self
        }
        pub fn set_member_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.member_arns = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::BatchCreateChannelMembershipInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::BatchCreateChannelMembershipInput {
                channel_arn: self.channel_arn,
                r#type: self.r#type,
                member_arns: self.member_arns,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type BatchCreateChannelMembershipInputOperationOutputAlias =
    crate::operation::BatchCreateChannelMembership;
#[doc(hidden)]
pub type BatchCreateChannelMembershipInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl BatchCreateChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateChannelMembership`](crate::operation::BatchCreateChannelMembership)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::BatchCreateChannelMembership,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::BatchCreateChannelMembershipInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_1 = &_input.channel_arn;
            let input_1 =
                input_1
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_1, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/memberships",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::BatchCreateChannelMembershipInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_2) = &_input.chime_bearer {
                let formatted_3 = AsRef::<str>::as_ref(inner_2);
                if !formatted_3.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_3;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::BatchCreateChannelMembershipInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("operation", "batch-create");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::BatchCreateChannelMembershipInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::BatchCreateChannelMembershipInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_batch_create_channel_membership(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchCreateChannelMembership::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "BatchCreateChannelMembership",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`BatchCreateChannelMembershipInput`](crate::input::BatchCreateChannelMembershipInput)
    pub fn builder() -> crate::input::batch_create_channel_membership_input::Builder {
        crate::input::batch_create_channel_membership_input::Builder::default()
    }
}

/// See [`CreateChannelInput`](crate::input::CreateChannelInput)
pub mod create_channel_input {
    /// A builder for [`CreateChannelInput`](crate::input::CreateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::ChannelMode>,
        pub(crate) privacy: std::option::Option<crate::model::ChannelPrivacy>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel request.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators,
        /// moderators, and channel members can add themselves and other members to unrestricted
        /// channels. Only administrators and moderators can add members to restricted channels.</p>
        pub fn mode(mut self, input: crate::model::ChannelMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ChannelMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private
        /// channels aren't discoverable by users outside the channel. Public channels are discoverable
        /// by anyone in the <code>AppInstance</code>.</p>
        pub fn privacy(mut self, input: crate::model::ChannelPrivacy) -> Self {
            self.privacy = Some(input);
            self
        }
        pub fn set_privacy(
            mut self,
            input: std::option::Option<crate::model::ChannelPrivacy>,
        ) -> Self {
            self.privacy = input;
            self
        }
        /// <p>The metadata of the creation request. Limited to 1KB and UTF-8.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The client token for the request. An <code>Idempotency</code> token.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelInput`](crate::input::CreateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::CreateChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CreateChannelInput {
                app_instance_arn: self.app_instance_arn,
                name: self.name,
                mode: self.mode,
                privacy: self.privacy,
                metadata: self.metadata,
                client_request_token: self.client_request_token,
                tags: self.tags,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelInputOperationOutputAlias = crate::operation::CreateChannel;
#[doc(hidden)]
pub type CreateChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateChannelInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannel`](crate::operation::CreateChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateChannelInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/channels").expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CreateChannelInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_4) = &_input.chime_bearer {
                let formatted_5 = AsRef::<str>::as_ref(inner_4);
                if !formatted_5.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_5;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateChannelInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_channel(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::CreateChannel::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "CreateChannel",
                    "chimesdkmessaging",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelInput`](crate::input::CreateChannelInput)
    pub fn builder() -> crate::input::create_channel_input::Builder {
        crate::input::create_channel_input::Builder::default()
    }
}

/// See [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
pub mod create_channel_ban_input {
    /// A builder for [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the ban request.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member being banned.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelBanInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelBanInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelBanInputOperationOutputAlias = crate::operation::CreateChannelBan;
#[doc(hidden)]
pub type CreateChannelBanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateChannelBanInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannelBan`](crate::operation::CreateChannelBan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateChannelBan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateChannelBanInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_6 = &_input.channel_arn;
            let input_6 =
                input_6
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_6, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/bans",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CreateChannelBanInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_7) = &_input.chime_bearer {
                let formatted_8 = AsRef::<str>::as_ref(inner_7);
                if !formatted_8.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_8;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateChannelBanInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateChannelBanInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_channel_ban(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannelBan::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateChannelBan",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelBanInput`](crate::input::CreateChannelBanInput)
    pub fn builder() -> crate::input::create_channel_ban_input::Builder {
        crate::input::create_channel_ban_input::Builder::default()
    }
}

/// See [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
pub mod create_channel_membership_input {
    /// A builder for [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMembershipType>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel to which you're adding users.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member you want to add to the channel.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default
        /// members are always returned as part of <code>ListChannelMemberships</code>. Hidden members
        /// are only returned if the type filter in <code>ListChannelMemberships</code> equals
        /// <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported
        /// by moderators.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMembershipType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMembershipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelMembershipInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelMembershipInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                r#type: self.r#type,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelMembershipInputOperationOutputAlias =
    crate::operation::CreateChannelMembership;
#[doc(hidden)]
pub type CreateChannelMembershipInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannelMembership`](crate::operation::CreateChannelMembership)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateChannelMembership,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateChannelMembershipInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_9 = &_input.channel_arn;
            let input_9 =
                input_9
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_9, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/memberships",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CreateChannelMembershipInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_10) = &_input.chime_bearer {
                let formatted_11 = AsRef::<str>::as_ref(inner_10);
                if !formatted_11.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_11;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateChannelMembershipInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateChannelMembershipInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_channel_membership(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannelMembership::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateChannelMembership",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelMembershipInput`](crate::input::CreateChannelMembershipInput)
    pub fn builder() -> crate::input::create_channel_membership_input::Builder {
        crate::input::create_channel_membership_input::Builder::default()
    }
}

/// See [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
pub mod create_channel_moderator_input {
    /// A builder for [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_moderator_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the moderator.</p>
        pub fn channel_moderator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_moderator_arn = Some(input.into());
            self
        }
        pub fn set_channel_moderator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_moderator_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateChannelModeratorInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateChannelModeratorInput {
                channel_arn: self.channel_arn,
                channel_moderator_arn: self.channel_moderator_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateChannelModeratorInputOperationOutputAlias = crate::operation::CreateChannelModerator;
#[doc(hidden)]
pub type CreateChannelModeratorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateChannelModeratorInput {
    /// Consumes the builder and constructs an Operation<[`CreateChannelModerator`](crate::operation::CreateChannelModerator)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateChannelModerator,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateChannelModeratorInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_12 = &_input.channel_arn;
            let input_12 =
                input_12
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_12, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/moderators",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::CreateChannelModeratorInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_13) = &_input.chime_bearer {
                let formatted_14 = AsRef::<str>::as_ref(inner_13);
                if !formatted_14.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_14;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateChannelModeratorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateChannelModeratorInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_channel_moderator(
                &self,
            )
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateChannelModerator::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "CreateChannelModerator",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateChannelModeratorInput`](crate::input::CreateChannelModeratorInput)
    pub fn builder() -> crate::input::create_channel_moderator_input::Builder {
        crate::input::create_channel_moderator_input::Builder::default()
    }
}

/// See [`DeleteChannelInput`](crate::input::DeleteChannelInput)
pub mod delete_channel_input {
    /// A builder for [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel being deleted.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelInput`](crate::input::DeleteChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::DeleteChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteChannelInput {
                channel_arn: self.channel_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelInputOperationOutputAlias = crate::operation::DeleteChannel;
#[doc(hidden)]
pub type DeleteChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannel`](crate::operation::DeleteChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_15 = &_input.channel_arn;
            let input_15 =
                input_15
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_15, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteChannelInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_16) = &_input.chime_bearer {
                let formatted_17 = AsRef::<str>::as_ref(inner_16);
                if !formatted_17.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_17;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::DeleteChannel::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "DeleteChannel",
                    "chimesdkmessaging",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelInput`](crate::input::DeleteChannelInput)
    pub fn builder() -> crate::input::delete_channel_input::Builder {
        crate::input::delete_channel_input::Builder::default()
    }
}

/// See [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
pub mod delete_channel_ban_input {
    /// A builder for [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel from which the <code>AppInstanceUser</code> was banned.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code> that you want to reinstate.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelBanInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelBanInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelBanInputOperationOutputAlias = crate::operation::DeleteChannelBan;
#[doc(hidden)]
pub type DeleteChannelBanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelBanInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelBan`](crate::operation::DeleteChannelBan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannelBan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelBanInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_18 = &_input.channel_arn;
            let input_18 =
                input_18
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_18, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_19 = &_input.member_arn;
            let input_19 =
                input_19
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    })?;
            let member_arn = smithy_http::label::fmt_string(input_19, false);
            if member_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "member_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/bans/{MemberArn}",
                ChannelArn = channel_arn,
                MemberArn = member_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteChannelBanInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_20) = &_input.chime_bearer {
                let formatted_21 = AsRef::<str>::as_ref(inner_20);
                if !formatted_21.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_21;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelBanInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelBanInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelBan::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteChannelBan",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelBanInput`](crate::input::DeleteChannelBanInput)
    pub fn builder() -> crate::input::delete_channel_ban_input::Builder {
        crate::input::delete_channel_ban_input::Builder::default()
    }
}

/// See [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
pub mod delete_channel_membership_input {
    /// A builder for [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel from which you want to remove the user.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member that you're removing from the channel.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelMembershipInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelMembershipInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelMembershipInputOperationOutputAlias =
    crate::operation::DeleteChannelMembership;
#[doc(hidden)]
pub type DeleteChannelMembershipInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelMembership`](crate::operation::DeleteChannelMembership)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannelMembership,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelMembershipInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_22 = &_input.channel_arn;
            let input_22 =
                input_22
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_22, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_23 = &_input.member_arn;
            let input_23 =
                input_23
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    })?;
            let member_arn = smithy_http::label::fmt_string(input_23, false);
            if member_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "member_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/memberships/{MemberArn}",
                ChannelArn = channel_arn,
                MemberArn = member_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteChannelMembershipInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_24) = &_input.chime_bearer {
                let formatted_25 = AsRef::<str>::as_ref(inner_24);
                if !formatted_25.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_25;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelMembershipInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelMembershipInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelMembership::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteChannelMembership",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelMembershipInput`](crate::input::DeleteChannelMembershipInput)
    pub fn builder() -> crate::input::delete_channel_membership_input::Builder {
        crate::input::delete_channel_membership_input::Builder::default()
    }
}

/// See [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
pub mod delete_channel_message_input {
    /// A builder for [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID of the message being deleted.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelMessageInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelMessageInputOperationOutputAlias = crate::operation::DeleteChannelMessage;
#[doc(hidden)]
pub type DeleteChannelMessageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelMessage`](crate::operation::DeleteChannelMessage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannelMessage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelMessageInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_26 = &_input.channel_arn;
            let input_26 =
                input_26
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_26, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_27 = &_input.message_id;
            let input_27 =
                input_27
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    })?;
            let message_id = smithy_http::label::fmt_string(input_27, false);
            if message_id.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "message_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/messages/{MessageId}",
                ChannelArn = channel_arn,
                MessageId = message_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteChannelMessageInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_28) = &_input.chime_bearer {
                let formatted_29 = AsRef::<str>::as_ref(inner_28);
                if !formatted_29.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_29;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelMessageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelMessageInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelMessage::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteChannelMessage",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelMessageInput`](crate::input::DeleteChannelMessageInput)
    pub fn builder() -> crate::input::delete_channel_message_input::Builder {
        crate::input::delete_channel_message_input::Builder::default()
    }
}

/// See [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
pub mod delete_channel_moderator_input {
    /// A builder for [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_moderator_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the moderator being deleted.</p>
        pub fn channel_moderator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_moderator_arn = Some(input.into());
            self
        }
        pub fn set_channel_moderator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_moderator_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteChannelModeratorInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteChannelModeratorInput {
                channel_arn: self.channel_arn,
                channel_moderator_arn: self.channel_moderator_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteChannelModeratorInputOperationOutputAlias = crate::operation::DeleteChannelModerator;
#[doc(hidden)]
pub type DeleteChannelModeratorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteChannelModeratorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteChannelModerator`](crate::operation::DeleteChannelModerator)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteChannelModerator,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteChannelModeratorInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_30 = &_input.channel_arn;
            let input_30 =
                input_30
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_30, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_31 = &_input.channel_moderator_arn;
            let input_31 =
                input_31
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_moderator_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_moderator_arn = smithy_http::label::fmt_string(input_31, false);
            if channel_moderator_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_moderator_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}",
                ChannelArn = channel_arn,
                ChannelModeratorArn = channel_moderator_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DeleteChannelModeratorInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_32) = &_input.chime_bearer {
                let formatted_33 = AsRef::<str>::as_ref(inner_32);
                if !formatted_33.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_33;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteChannelModeratorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteChannelModeratorInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteChannelModerator::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DeleteChannelModerator",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteChannelModeratorInput`](crate::input::DeleteChannelModeratorInput)
    pub fn builder() -> crate::input::delete_channel_moderator_input::Builder {
        crate::input::delete_channel_moderator_input::Builder::default()
    }
}

/// See [`DescribeChannelInput`](crate::input::DescribeChannelInput)
pub mod describe_channel_input {
    /// A builder for [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelInput`](crate::input::DescribeChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelInput {
                channel_arn: self.channel_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelInputOperationOutputAlias = crate::operation::DescribeChannel;
#[doc(hidden)]
pub type DescribeChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeChannelInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannel`](crate::operation::DescribeChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_34 = &_input.channel_arn;
            let input_34 =
                input_34
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_34, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DescribeChannelInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_35) = &_input.chime_bearer {
                let formatted_36 = AsRef::<str>::as_ref(inner_35);
                if !formatted_36.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_36;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannel::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeChannel",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelInput`](crate::input::DescribeChannelInput)
    pub fn builder() -> crate::input::describe_channel_input::Builder {
        crate::input::describe_channel_input::Builder::default()
    }
}

/// See [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
pub mod describe_channel_ban_input {
    /// A builder for [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel from which the user is banned.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member being banned.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelBanInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelBanInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelBanInputOperationOutputAlias = crate::operation::DescribeChannelBan;
#[doc(hidden)]
pub type DescribeChannelBanInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeChannelBanInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelBan`](crate::operation::DescribeChannelBan)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannelBan,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelBanInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_37 = &_input.channel_arn;
            let input_37 =
                input_37
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_37, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_38 = &_input.member_arn;
            let input_38 =
                input_38
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    })?;
            let member_arn = smithy_http::label::fmt_string(input_38, false);
            if member_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "member_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/bans/{MemberArn}",
                ChannelArn = channel_arn,
                MemberArn = member_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DescribeChannelBanInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_39) = &_input.chime_bearer {
                let formatted_40 = AsRef::<str>::as_ref(inner_39);
                if !formatted_40.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_40;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelBanInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelBanInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelBan::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeChannelBan",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelBanInput`](crate::input::DescribeChannelBanInput)
    pub fn builder() -> crate::input::describe_channel_ban_input::Builder {
        crate::input::describe_channel_ban_input::Builder::default()
    }
}

/// See [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
pub mod describe_channel_membership_input {
    /// A builder for [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) member_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the member.</p>
        pub fn member_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.member_arn = Some(input.into());
            self
        }
        pub fn set_member_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.member_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelMembershipInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelMembershipInput {
                channel_arn: self.channel_arn,
                member_arn: self.member_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelMembershipInputOperationOutputAlias =
    crate::operation::DescribeChannelMembership;
#[doc(hidden)]
pub type DescribeChannelMembershipInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeChannelMembershipInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelMembership`](crate::operation::DescribeChannelMembership)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannelMembership,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelMembershipInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_41 = &_input.channel_arn;
            let input_41 =
                input_41
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_41, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_42 = &_input.member_arn;
            let input_42 =
                input_42
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "member_arn",
                        details: "cannot be empty or unset",
                    })?;
            let member_arn = smithy_http::label::fmt_string(input_42, false);
            if member_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "member_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/memberships/{MemberArn}",
                ChannelArn = channel_arn,
                MemberArn = member_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DescribeChannelMembershipInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_43) = &_input.chime_bearer {
                let formatted_44 = AsRef::<str>::as_ref(inner_43);
                if !formatted_44.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_44;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelMembershipInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelMembershipInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelMembership::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeChannelMembership",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelMembershipInput`](crate::input::DescribeChannelMembershipInput)
    pub fn builder() -> crate::input::describe_channel_membership_input::Builder {
        crate::input::describe_channel_membership_input::Builder::default()
    }
}

/// See [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
pub mod describe_channel_membership_for_app_instance_user_input {
    /// A builder for [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel to which the user belongs.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the user in a channel.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelMembershipForAppInstanceUserInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DescribeChannelMembershipForAppInstanceUserInput {
                    channel_arn: self.channel_arn,
                    app_instance_user_arn: self.app_instance_user_arn,
                    chime_bearer: self.chime_bearer,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelMembershipForAppInstanceUserInputOperationOutputAlias =
    crate::operation::DescribeChannelMembershipForAppInstanceUser;
#[doc(hidden)]
pub type DescribeChannelMembershipForAppInstanceUserInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DescribeChannelMembershipForAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelMembershipForAppInstanceUser`](crate::operation::DescribeChannelMembershipForAppInstanceUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannelMembershipForAppInstanceUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_45 = &_input.channel_arn;
            let input_45 =
                input_45
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_45, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_46) = &_input.chime_bearer {
                let formatted_47 = AsRef::<str>::as_ref(inner_46);
                if !formatted_47.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_47;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("scope", "app-instance-user-membership");
            if let Some(inner_48) = &_input.app_instance_user_arn {
                query.push_kv(
                    "app-instance-user-arn",
                    &smithy_http::query::fmt_string(&inner_48),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelMembershipForAppInstanceUserInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelMembershipForAppInstanceUser::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeChannelMembershipForAppInstanceUser",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelMembershipForAppInstanceUserInput`](crate::input::DescribeChannelMembershipForAppInstanceUserInput)
    pub fn builder(
    ) -> crate::input::describe_channel_membership_for_app_instance_user_input::Builder {
        crate::input::describe_channel_membership_for_app_instance_user_input::Builder::default()
    }
}

/// See [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
pub mod describe_channel_moderated_by_app_instance_user_input {
    /// A builder for [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the moderated channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the <code>AppInstanceUser</code> in the moderated channel.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelModeratedByAppInstanceUserInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::DescribeChannelModeratedByAppInstanceUserInput {
                    channel_arn: self.channel_arn,
                    app_instance_user_arn: self.app_instance_user_arn,
                    chime_bearer: self.chime_bearer,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelModeratedByAppInstanceUserInputOperationOutputAlias =
    crate::operation::DescribeChannelModeratedByAppInstanceUser;
#[doc(hidden)]
pub type DescribeChannelModeratedByAppInstanceUserInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl DescribeChannelModeratedByAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelModeratedByAppInstanceUser`](crate::operation::DescribeChannelModeratedByAppInstanceUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannelModeratedByAppInstanceUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_49 = &_input.channel_arn;
            let input_49 =
                input_49
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_49, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_50) = &_input.chime_bearer {
                let formatted_51 = AsRef::<str>::as_ref(inner_50);
                if !formatted_51.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_51;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("scope", "app-instance-user-moderated-channel");
            if let Some(inner_52) = &_input.app_instance_user_arn {
                query.push_kv(
                    "app-instance-user-arn",
                    &smithy_http::query::fmt_string(&inner_52),
                );
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelModeratedByAppInstanceUserInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelModeratedByAppInstanceUser::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeChannelModeratedByAppInstanceUser",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelModeratedByAppInstanceUserInput`](crate::input::DescribeChannelModeratedByAppInstanceUserInput)
    pub fn builder() -> crate::input::describe_channel_moderated_by_app_instance_user_input::Builder
    {
        crate::input::describe_channel_moderated_by_app_instance_user_input::Builder::default()
    }
}

/// See [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
pub mod describe_channel_moderator_input {
    /// A builder for [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) channel_moderator_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ARN of the channel moderator.</p>
        pub fn channel_moderator_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_moderator_arn = Some(input.into());
            self
        }
        pub fn set_channel_moderator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.channel_moderator_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeChannelModeratorInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeChannelModeratorInput {
                channel_arn: self.channel_arn,
                channel_moderator_arn: self.channel_moderator_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeChannelModeratorInputOperationOutputAlias =
    crate::operation::DescribeChannelModerator;
#[doc(hidden)]
pub type DescribeChannelModeratorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeChannelModeratorInput {
    /// Consumes the builder and constructs an Operation<[`DescribeChannelModerator`](crate::operation::DescribeChannelModerator)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeChannelModerator,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeChannelModeratorInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_53 = &_input.channel_arn;
            let input_53 =
                input_53
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_53, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_54 = &_input.channel_moderator_arn;
            let input_54 =
                input_54
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_moderator_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_moderator_arn = smithy_http::label::fmt_string(input_54, false);
            if channel_moderator_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_moderator_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}",
                ChannelArn = channel_arn,
                ChannelModeratorArn = channel_moderator_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::DescribeChannelModeratorInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_55) = &_input.chime_bearer {
                let formatted_56 = AsRef::<str>::as_ref(inner_55);
                if !formatted_56.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_56;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeChannelModeratorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeChannelModeratorInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeChannelModerator::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "DescribeChannelModerator",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeChannelModeratorInput`](crate::input::DescribeChannelModeratorInput)
    pub fn builder() -> crate::input::describe_channel_moderator_input::Builder {
        crate::input::describe_channel_moderator_input::Builder::default()
    }
}

/// See [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
pub mod get_channel_message_input {
    /// A builder for [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID of the message.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetChannelMessageInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type GetChannelMessageInputOperationOutputAlias = crate::operation::GetChannelMessage;
#[doc(hidden)]
pub type GetChannelMessageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`GetChannelMessage`](crate::operation::GetChannelMessage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetChannelMessage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetChannelMessageInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_57 = &_input.channel_arn;
            let input_57 =
                input_57
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_57, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_58 = &_input.message_id;
            let input_58 =
                input_58
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    })?;
            let message_id = smithy_http::label::fmt_string(input_58, false);
            if message_id.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "message_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/messages/{MessageId}",
                ChannelArn = channel_arn,
                MessageId = message_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::GetChannelMessageInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_59) = &_input.chime_bearer {
                let formatted_60 = AsRef::<str>::as_ref(inner_59);
                if !formatted_60.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_60;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetChannelMessageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetChannelMessageInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetChannelMessage::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetChannelMessage",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetChannelMessageInput`](crate::input::GetChannelMessageInput)
    pub fn builder() -> crate::input::get_channel_message_input::Builder {
        crate::input::get_channel_message_input::Builder::default()
    }
}

/// See [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
pub mod get_messaging_session_endpoint_input {
    /// A builder for [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMessagingSessionEndpointInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMessagingSessionEndpointInput {})
        }
    }
}
#[doc(hidden)]
pub type GetMessagingSessionEndpointInputOperationOutputAlias =
    crate::operation::GetMessagingSessionEndpoint;
#[doc(hidden)]
pub type GetMessagingSessionEndpointInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMessagingSessionEndpointInput {
    /// Consumes the builder and constructs an Operation<[`GetMessagingSessionEndpoint`](crate::operation::GetMessagingSessionEndpoint)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetMessagingSessionEndpoint,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMessagingSessionEndpointInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/endpoints/messaging-session").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMessagingSessionEndpointInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMessagingSessionEndpointInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMessagingSessionEndpoint::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "GetMessagingSessionEndpoint",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMessagingSessionEndpointInput`](crate::input::GetMessagingSessionEndpointInput)
    pub fn builder() -> crate::input::get_messaging_session_endpoint_input::Builder {
        crate::input::get_messaging_session_endpoint_input::Builder::default()
    }
}

/// See [`ListChannelBansInput`](crate::input::ListChannelBansInput)
pub mod list_channel_bans_input {
    /// A builder for [`ListChannelBansInput`](crate::input::ListChannelBansInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The maximum number of bans that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested bans are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelBansInput`](crate::input::ListChannelBansInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelBansInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelBansInput {
                channel_arn: self.channel_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelBansInputOperationOutputAlias = crate::operation::ListChannelBans;
#[doc(hidden)]
pub type ListChannelBansInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelBansInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelBans`](crate::operation::ListChannelBans)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannelBans,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelBansInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_61 = &_input.channel_arn;
            let input_61 =
                input_61
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_61, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/bans",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelBansInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_62) = &_input.chime_bearer {
                let formatted_63 = AsRef::<str>::as_ref(inner_62);
                if !formatted_63.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_63;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListChannelBansInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_64) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_64).encode(),
                );
            }
            if let Some(inner_65) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_65));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelBansInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelBansInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelBans::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListChannelBans",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelBansInput`](crate::input::ListChannelBansInput)
    pub fn builder() -> crate::input::list_channel_bans_input::Builder {
        crate::input::list_channel_bans_input::Builder::default()
    }
}

/// See [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
pub mod list_channel_memberships_input {
    /// A builder for [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMembershipType>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of channel memberships that you want returned.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default
        /// members are always returned as part of <code>ListChannelMemberships</code>. Hidden members
        /// are only returned if the type filter in <code>ListChannelMemberships</code> equals
        /// <code>HIDDEN</code>. Otherwise hidden members are not returned.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMembershipType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMembershipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The maximum number of channel memberships that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested channel memberships are
        /// returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelMembershipsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelMembershipsInput {
                channel_arn: self.channel_arn,
                r#type: self.r#type,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelMembershipsInputOperationOutputAlias = crate::operation::ListChannelMemberships;
#[doc(hidden)]
pub type ListChannelMembershipsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelMembershipsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelMemberships`](crate::operation::ListChannelMemberships)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannelMemberships,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelMembershipsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_66 = &_input.channel_arn;
            let input_66 =
                input_66
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_66, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/memberships",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelMembershipsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_67) = &_input.chime_bearer {
                let formatted_68 = AsRef::<str>::as_ref(inner_67);
                if !formatted_68.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_68;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListChannelMembershipsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_69) = &_input.r#type {
                query.push_kv("type", &smithy_http::query::fmt_string(&inner_69));
            }
            if let Some(inner_70) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_70).encode(),
                );
            }
            if let Some(inner_71) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_71));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelMembershipsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelMembershipsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelMemberships::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListChannelMemberships",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelMembershipsInput`](crate::input::ListChannelMembershipsInput)
    pub fn builder() -> crate::input::list_channel_memberships_input::Builder {
        crate::input::list_channel_memberships_input::Builder::default()
    }
}

/// See [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
pub mod list_channel_memberships_for_app_instance_user_input {
    /// A builder for [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstanceUser</code>s</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The maximum number of users that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token returned from previous API requests until the number of channel memberships is
        /// reached.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelMembershipsForAppInstanceUserInput,
            smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::ListChannelMembershipsForAppInstanceUserInput {
                    app_instance_user_arn: self.app_instance_user_arn,
                    max_results: self.max_results,
                    next_token: self.next_token,
                    chime_bearer: self.chime_bearer,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type ListChannelMembershipsForAppInstanceUserInputOperationOutputAlias =
    crate::operation::ListChannelMembershipsForAppInstanceUser;
#[doc(hidden)]
pub type ListChannelMembershipsForAppInstanceUserInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl ListChannelMembershipsForAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelMembershipsForAppInstanceUser`](crate::operation::ListChannelMembershipsForAppInstanceUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannelMembershipsForAppInstanceUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/channels").expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_72) = &_input.chime_bearer {
                let formatted_73 = AsRef::<str>::as_ref(inner_72);
                if !formatted_73.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_73;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("scope", "app-instance-user-memberships");
            if let Some(inner_74) = &_input.app_instance_user_arn {
                query.push_kv(
                    "app-instance-user-arn",
                    &smithy_http::query::fmt_string(&inner_74),
                );
            }
            if let Some(inner_75) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_75).encode(),
                );
            }
            if let Some(inner_76) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_76));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelMembershipsForAppInstanceUserInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelMembershipsForAppInstanceUser::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListChannelMembershipsForAppInstanceUser",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelMembershipsForAppInstanceUserInput`](crate::input::ListChannelMembershipsForAppInstanceUserInput)
    pub fn builder() -> crate::input::list_channel_memberships_for_app_instance_user_input::Builder
    {
        crate::input::list_channel_memberships_for_app_instance_user_input::Builder::default()
    }
}

/// See [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
pub mod list_channel_messages_input {
    /// A builder for [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<crate::model::SortOrder>,
        pub(crate) not_before: std::option::Option<smithy_types::Instant>,
        pub(crate) not_after: std::option::Option<smithy_types::Instant>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The order in which you want messages sorted. Default is Descending, based on time
        /// created.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// <p>The initial or starting time stamp for your requested messages.</p>
        pub fn not_before(mut self, input: smithy_types::Instant) -> Self {
            self.not_before = Some(input);
            self
        }
        pub fn set_not_before(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.not_before = input;
            self
        }
        /// <p>The final or ending time stamp for your requested messages.</p>
        pub fn not_after(mut self, input: smithy_types::Instant) -> Self {
            self.not_after = Some(input);
            self
        }
        pub fn set_not_after(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.not_after = input;
            self
        }
        /// <p>The maximum number of messages that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested messages are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelMessagesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelMessagesInput {
                channel_arn: self.channel_arn,
                sort_order: self.sort_order,
                not_before: self.not_before,
                not_after: self.not_after,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelMessagesInputOperationOutputAlias = crate::operation::ListChannelMessages;
#[doc(hidden)]
pub type ListChannelMessagesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelMessagesInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelMessages`](crate::operation::ListChannelMessages)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannelMessages,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelMessagesInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_77 = &_input.channel_arn;
            let input_77 =
                input_77
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_77, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/messages",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelMessagesInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_78) = &_input.chime_bearer {
                let formatted_79 = AsRef::<str>::as_ref(inner_78);
                if !formatted_79.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_79;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListChannelMessagesInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_80) = &_input.sort_order {
                query.push_kv("sort-order", &smithy_http::query::fmt_string(&inner_80));
            }
            if let Some(inner_81) = &_input.not_before {
                query.push_kv(
                    "not-before",
                    &smithy_http::query::fmt_timestamp(
                        inner_81,
                        smithy_types::instant::Format::DateTime,
                    ),
                );
            }
            if let Some(inner_82) = &_input.not_after {
                query.push_kv(
                    "not-after",
                    &smithy_http::query::fmt_timestamp(
                        inner_82,
                        smithy_types::instant::Format::DateTime,
                    ),
                );
            }
            if let Some(inner_83) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_83).encode(),
                );
            }
            if let Some(inner_84) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_84));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelMessagesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelMessagesInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelMessages::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListChannelMessages",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelMessagesInput`](crate::input::ListChannelMessagesInput)
    pub fn builder() -> crate::input::list_channel_messages_input::Builder {
        crate::input::list_channel_messages_input::Builder::default()
    }
}

/// See [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
pub mod list_channel_moderators_input {
    /// A builder for [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The maximum number of moderators that you want returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested moderators are
        /// returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelModeratorsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelModeratorsInput {
                channel_arn: self.channel_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelModeratorsInputOperationOutputAlias = crate::operation::ListChannelModerators;
#[doc(hidden)]
pub type ListChannelModeratorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelModeratorsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelModerators`](crate::operation::ListChannelModerators)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannelModerators,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelModeratorsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_85 = &_input.channel_arn;
            let input_85 =
                input_85
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_85, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/moderators",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelModeratorsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_86) = &_input.chime_bearer {
                let formatted_87 = AsRef::<str>::as_ref(inner_86);
                if !formatted_87.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_87;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListChannelModeratorsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_88) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_88).encode(),
                );
            }
            if let Some(inner_89) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_89));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelModeratorsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelModeratorsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelModerators::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListChannelModerators",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelModeratorsInput`](crate::input::ListChannelModeratorsInput)
    pub fn builder() -> crate::input::list_channel_moderators_input::Builder {
        crate::input::list_channel_moderators_input::Builder::default()
    }
}

/// See [`ListChannelsInput`](crate::input::ListChannelsInput)
pub mod list_channels_input {
    /// A builder for [`ListChannelsInput`](crate::input::ListChannelsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_arn: std::option::Option<std::string::String>,
        pub(crate) privacy: std::option::Option<crate::model::ChannelPrivacy>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the <code>AppInstance</code>.</p>
        pub fn app_instance_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_arn = Some(input.into());
            self
        }
        pub fn set_app_instance_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_arn = input;
            self
        }
        /// <p>The privacy setting. <code>PUBLIC</code> retrieves all the public channels.
        /// <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code>
        /// can retrieve private channels. </p>
        pub fn privacy(mut self, input: crate::model::ChannelPrivacy) -> Self {
            self.privacy = Some(input);
            self
        }
        pub fn set_privacy(
            mut self,
            input: std::option::Option<crate::model::ChannelPrivacy>,
        ) -> Self {
            self.privacy = input;
            self
        }
        /// <p>The maximum number of channels that you want to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token passed by previous API calls until all requested channels are returned.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsInput`](crate::input::ListChannelsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::ListChannelsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListChannelsInput {
                app_instance_arn: self.app_instance_arn,
                privacy: self.privacy,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelsInputOperationOutputAlias = crate::operation::ListChannels;
#[doc(hidden)]
pub type ListChannelsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListChannelsInput {
    /// Consumes the builder and constructs an Operation<[`ListChannels`](crate::operation::ListChannels)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannels,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelsInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/channels").expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelsInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_90) = &_input.chime_bearer {
                let formatted_91 = AsRef::<str>::as_ref(inner_90);
                if !formatted_91.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_91;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::ListChannelsInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            if let Some(inner_92) = &_input.app_instance_arn {
                query.push_kv(
                    "app-instance-arn",
                    &smithy_http::query::fmt_string(&inner_92),
                );
            }
            if let Some(inner_93) = &_input.privacy {
                query.push_kv("privacy", &smithy_http::query::fmt_string(&inner_93));
            }
            if let Some(inner_94) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_94).encode(),
                );
            }
            if let Some(inner_95) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_95));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelsInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::ListChannels::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "ListChannels",
                    "chimesdkmessaging",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelsInput`](crate::input::ListChannelsInput)
    pub fn builder() -> crate::input::list_channels_input::Builder {
        crate::input::list_channels_input::Builder::default()
    }
}

/// See [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
pub mod list_channels_moderated_by_app_instance_user_input {
    /// A builder for [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_instance_user_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the user in the moderated channel.</p>
        pub fn app_instance_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_instance_user_arn = Some(input.into());
            self
        }
        pub fn set_app_instance_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_instance_user_arn = input;
            self
        }
        /// <p>The maximum number of channels in the request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token returned from previous API requests until the number of channels moderated by
        /// the user is reached.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListChannelsModeratedByAppInstanceUserInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListChannelsModeratedByAppInstanceUserInput {
                app_instance_user_arn: self.app_instance_user_arn,
                max_results: self.max_results,
                next_token: self.next_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type ListChannelsModeratedByAppInstanceUserInputOperationOutputAlias =
    crate::operation::ListChannelsModeratedByAppInstanceUser;
#[doc(hidden)]
pub type ListChannelsModeratedByAppInstanceUserInputOperationRetryAlias =
    aws_http::AwsErrorRetryPolicy;
impl ListChannelsModeratedByAppInstanceUserInput {
    /// Consumes the builder and constructs an Operation<[`ListChannelsModeratedByAppInstanceUser`](crate::operation::ListChannelsModeratedByAppInstanceUser)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListChannelsModeratedByAppInstanceUser,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            write!(output, "/channels").expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_96) = &_input.chime_bearer {
                let formatted_97 = AsRef::<str>::as_ref(inner_96);
                if !formatted_97.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_97;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(
            _input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
            mut output: &mut String,
        ) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("scope", "app-instance-user-moderated-channels");
            if let Some(inner_98) = &_input.app_instance_user_arn {
                query.push_kv(
                    "app-instance-user-arn",
                    &smithy_http::query::fmt_string(&inner_98),
                );
            }
            if let Some(inner_99) = &_input.max_results {
                query.push_kv(
                    "max-results",
                    &smithy_types::primitive::Encoder::from(*inner_99).encode(),
                );
            }
            if let Some(inner_100) = &_input.next_token {
                query.push_kv("next-token", &smithy_http::query::fmt_string(&inner_100));
            }
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListChannelsModeratedByAppInstanceUserInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::ListChannelsModeratedByAppInstanceUser::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "ListChannelsModeratedByAppInstanceUser",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListChannelsModeratedByAppInstanceUserInput`](crate::input::ListChannelsModeratedByAppInstanceUserInput)
    pub fn builder() -> crate::input::list_channels_moderated_by_app_instance_user_input::Builder {
        crate::input::list_channels_moderated_by_app_instance_user_input::Builder::default()
    }
}

/// See [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
pub mod redact_channel_message_input {
    /// A builder for [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel containing the messages that you want to redact.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID of the message being redacted.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RedactChannelMessageInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RedactChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type RedactChannelMessageInputOperationOutputAlias = crate::operation::RedactChannelMessage;
#[doc(hidden)]
pub type RedactChannelMessageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl RedactChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`RedactChannelMessage`](crate::operation::RedactChannelMessage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::RedactChannelMessage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RedactChannelMessageInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_101 = &_input.channel_arn;
            let input_101 =
                input_101
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_101, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_102 = &_input.message_id;
            let input_102 =
                input_102
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    })?;
            let message_id = smithy_http::label::fmt_string(input_102, false);
            if message_id.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "message_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/messages/{MessageId}",
                ChannelArn = channel_arn,
                MessageId = message_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::RedactChannelMessageInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_103) = &_input.chime_bearer {
                let formatted_104 = AsRef::<str>::as_ref(inner_103);
                if !formatted_104.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_104;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        fn uri_query(_input: &crate::input::RedactChannelMessageInput, mut output: &mut String) {
            let mut query = smithy_http::query::Writer::new(&mut output);
            query.push_kv("operation", "redact");
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RedactChannelMessageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri);
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RedactChannelMessageInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::RedactChannelMessage::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "RedactChannelMessage",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RedactChannelMessageInput`](crate::input::RedactChannelMessageInput)
    pub fn builder() -> crate::input::redact_channel_message_input::Builder {
        crate::input::redact_channel_message_input::Builder::default()
    }
}

/// See [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
pub mod send_channel_message_input {
    /// A builder for [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChannelMessageType>,
        pub(crate) persistence: std::option::Option<crate::model::ChannelMessagePersistenceType>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The content of the message.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
        pub fn r#type(mut self, input: crate::model::ChannelMessageType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ChannelMessageType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
        pub fn persistence(mut self, input: crate::model::ChannelMessagePersistenceType) -> Self {
            self.persistence = Some(input);
            self
        }
        pub fn set_persistence(
            mut self,
            input: std::option::Option<crate::model::ChannelMessagePersistenceType>,
        ) -> Self {
            self.persistence = input;
            self
        }
        /// <p>The optional metadata for each message.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>Idempotency</code> token for each client request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(input.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SendChannelMessageInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SendChannelMessageInput {
                channel_arn: self.channel_arn,
                content: self.content,
                r#type: self.r#type,
                persistence: self.persistence,
                metadata: self.metadata,
                client_request_token: self.client_request_token,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type SendChannelMessageInputOperationOutputAlias = crate::operation::SendChannelMessage;
#[doc(hidden)]
pub type SendChannelMessageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SendChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`SendChannelMessage`](crate::operation::SendChannelMessage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::SendChannelMessage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SendChannelMessageInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_105 = &_input.channel_arn;
            let input_105 =
                input_105
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_105, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/messages",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::SendChannelMessageInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_106) = &_input.chime_bearer {
                let formatted_107 = AsRef::<str>::as_ref(inner_106);
                if !formatted_107.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_107;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SendChannelMessageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SendChannelMessageInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_request_token.is_none() {
            self.client_request_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_send_channel_message(&self)
                .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::SendChannelMessage::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "SendChannelMessage",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SendChannelMessageInput`](crate::input::SendChannelMessageInput)
    pub fn builder() -> crate::input::send_channel_message_input::Builder {
        crate::input::send_channel_message_input::Builder::default()
    }
}

/// See [`UpdateChannelInput`](crate::input::UpdateChannelInput)
pub mod update_channel_input {
    /// A builder for [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::ChannelMode>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The name of the channel.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The mode of the update request.</p>
        pub fn mode(mut self, input: crate::model::ChannelMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(mut self, input: std::option::Option<crate::model::ChannelMode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The metadata for the update request.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelInput`](crate::input::UpdateChannelInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UpdateChannelInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateChannelInput {
                channel_arn: self.channel_arn,
                name: self.name,
                mode: self.mode,
                metadata: self.metadata,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelInputOperationOutputAlias = crate::operation::UpdateChannel;
#[doc(hidden)]
pub type UpdateChannelInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateChannelInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannel`](crate::operation::UpdateChannel)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateChannel,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateChannelInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_108 = &_input.channel_arn;
            let input_108 =
                input_108
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_108, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/channels/{ChannelArn}", ChannelArn = channel_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::UpdateChannelInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_109) = &_input.chime_bearer {
                let formatted_110 = AsRef::<str>::as_ref(inner_109);
                if !formatted_110.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_110;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateChannelInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateChannelInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_channel(&self)
            .map_err(|err| smithy_http::operation::BuildError::SerializationError(err.into()))?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            smithy_http::operation::Operation::new(request, crate::operation::UpdateChannel::new())
                .with_metadata(smithy_http::operation::Metadata::new(
                    "UpdateChannel",
                    "chimesdkmessaging",
                ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelInput`](crate::input::UpdateChannelInput)
    pub fn builder() -> crate::input::update_channel_input::Builder {
        crate::input::update_channel_input::Builder::default()
    }
}

/// See [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
pub mod update_channel_message_input {
    /// A builder for [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The ID string of the message being updated.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The content of the message being updated.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The metadata of the message being updated.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateChannelMessageInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateChannelMessageInput {
                channel_arn: self.channel_arn,
                message_id: self.message_id,
                content: self.content,
                metadata: self.metadata,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelMessageInputOperationOutputAlias = crate::operation::UpdateChannelMessage;
#[doc(hidden)]
pub type UpdateChannelMessageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateChannelMessageInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannelMessage`](crate::operation::UpdateChannelMessage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateChannelMessage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateChannelMessageInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_111 = &_input.channel_arn;
            let input_111 =
                input_111
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_111, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            let input_112 = &_input.message_id;
            let input_112 =
                input_112
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "message_id",
                        details: "cannot be empty or unset",
                    })?;
            let message_id = smithy_http::label::fmt_string(input_112, false);
            if message_id.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "message_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/messages/{MessageId}",
                ChannelArn = channel_arn,
                MessageId = message_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::UpdateChannelMessageInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_113) = &_input.chime_bearer {
                let formatted_114 = AsRef::<str>::as_ref(inner_113);
                if !formatted_114.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_114;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateChannelMessageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateChannelMessageInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_channel_message(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateChannelMessage::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateChannelMessage",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelMessageInput`](crate::input::UpdateChannelMessageInput)
    pub fn builder() -> crate::input::update_channel_message_input::Builder {
        crate::input::update_channel_message_input::Builder::default()
    }
}

/// See [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
pub mod update_channel_read_marker_input {
    /// A builder for [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_arn: std::option::Option<std::string::String>,
        pub(crate) chime_bearer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the channel.</p>
        pub fn channel_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_arn = Some(input.into());
            self
        }
        pub fn set_channel_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_arn = input;
            self
        }
        /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
        pub fn chime_bearer(mut self, input: impl Into<std::string::String>) -> Self {
            self.chime_bearer = Some(input.into());
            self
        }
        pub fn set_chime_bearer(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chime_bearer = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateChannelReadMarkerInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateChannelReadMarkerInput {
                channel_arn: self.channel_arn,
                chime_bearer: self.chime_bearer,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateChannelReadMarkerInputOperationOutputAlias =
    crate::operation::UpdateChannelReadMarker;
#[doc(hidden)]
pub type UpdateChannelReadMarkerInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UpdateChannelReadMarkerInput {
    /// Consumes the builder and constructs an Operation<[`UpdateChannelReadMarker`](crate::operation::UpdateChannelReadMarker)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateChannelReadMarker,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateChannelReadMarkerInput,
            output: &mut String,
        ) -> Result<(), smithy_http::operation::BuildError> {
            let input_115 = &_input.channel_arn;
            let input_115 =
                input_115
                    .as_ref()
                    .ok_or(smithy_http::operation::BuildError::MissingField {
                        field: "channel_arn",
                        details: "cannot be empty or unset",
                    })?;
            let channel_arn = smithy_http::label::fmt_string(input_115, false);
            if channel_arn.is_empty() {
                return Err(smithy_http::operation::BuildError::MissingField {
                    field: "channel_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/channels/{ChannelArn}/readMarker",
                ChannelArn = channel_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn add_headers(
            _input: &crate::input::UpdateChannelReadMarkerInput,
            mut builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            if let Some(inner_116) = &_input.chime_bearer {
                let formatted_117 = AsRef::<str>::as_ref(inner_116);
                if !formatted_117.is_empty() {
                    use std::convert::TryFrom;
                    let header_value = formatted_117;
                    let header_value = http::header::HeaderValue::try_from(&*header_value)
                        .map_err(|err| smithy_http::operation::BuildError::InvalidField {
                            field: "chime_bearer",
                            details: format!(
                                "`{}` cannot be used as a header value: {}",
                                &header_value, err
                            ),
                        })?;
                    builder = builder.header("x-amz-chime-bearer", header_value);
                }
            }
            Ok(builder)
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateChannelReadMarkerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            let builder = add_headers(input, builder)?;
            Ok(builder.method("PUT").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateChannelReadMarkerInput,
        ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = smithy_http::operation::Request::from_parts(
            request.map(smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateChannelReadMarker::new(),
        )
        .with_metadata(smithy_http::operation::Metadata::new(
            "UpdateChannelReadMarker",
            "chimesdkmessaging",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateChannelReadMarkerInput`](crate::input::UpdateChannelReadMarkerInput)
    pub fn builder() -> crate::input::update_channel_read_marker_input::Builder {
        crate::input::update_channel_read_marker_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelReadMarkerInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateChannelReadMarkerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelReadMarkerInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID string of the message being updated.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The content of the message being updated.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The metadata of the message being updated.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateChannelInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The mode of the update request.</p>
    pub mode: std::option::Option<crate::model::ChannelMode>,
    /// <p>The metadata for the update request.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateChannelInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("mode", &self.mode);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The content of the message.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The type of message, <code>STANDARD</code> or <code>CONTROL</code>.</p>
    pub r#type: std::option::Option<crate::model::ChannelMessageType>,
    /// <p>Boolean that controls whether the message is persisted on the back end. Required.</p>
    pub persistence: std::option::Option<crate::model::ChannelMessagePersistenceType>,
    /// <p>The optional metadata for each message.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The <code>Idempotency</code> token for each client request.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("content", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &self.r#type);
        formatter.field("persistence", &self.persistence);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedactChannelMessageInput {
    /// <p>The ARN of the channel containing the messages that you want to redact.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the message being redacted.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RedactChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedactChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsModeratedByAppInstanceUserInput {
    /// <p>The ARN of the user in the moderated channel.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of channels in the request.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token returned from previous API requests until the number of channels moderated by
    /// the user is reached.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelsModeratedByAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsModeratedByAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelsInput {
    /// <p>The ARN of the <code>AppInstance</code>.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The privacy setting. <code>PUBLIC</code> retrieves all the public channels.
    /// <code>PRIVATE</code> retrieves private channels. Only an <code>AppInstanceAdmin</code>
    /// can retrieve private channels. </p>
    pub privacy: std::option::Option<crate::model::ChannelPrivacy>,
    /// <p>The maximum number of channels that you want to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested channels are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelsInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("privacy", &self.privacy);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelModeratorsInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of moderators that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested moderators are
    /// returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelModeratorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelModeratorsInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelMessagesInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The order in which you want messages sorted. Default is Descending, based on time
    /// created.</p>
    pub sort_order: std::option::Option<crate::model::SortOrder>,
    /// <p>The initial or starting time stamp for your requested messages.</p>
    pub not_before: std::option::Option<smithy_types::Instant>,
    /// <p>The final or ending time stamp for your requested messages.</p>
    pub not_after: std::option::Option<smithy_types::Instant>,
    /// <p>The maximum number of messages that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested messages are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelMessagesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelMessagesInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("not_before", &self.not_before);
        formatter.field("not_after", &self.not_after);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelMembershipsForAppInstanceUserInput {
    /// <p>The ARN of the <code>AppInstanceUser</code>s</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of users that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token returned from previous API requests until the number of channel memberships is
    /// reached.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelMembershipsForAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelMembershipsForAppInstanceUserInput");
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelMembershipsInput {
    /// <p>The maximum number of channel memberships that you want returned.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default
    /// members are always returned as part of <code>ListChannelMemberships</code>. Hidden members
    /// are only returned if the type filter in <code>ListChannelMemberships</code> equals
    /// <code>HIDDEN</code>. Otherwise hidden members are not returned.</p>
    pub r#type: std::option::Option<crate::model::ChannelMembershipType>,
    /// <p>The maximum number of channel memberships that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested channel memberships are
    /// returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelMembershipsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelMembershipsInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListChannelBansInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of bans that you want returned.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token passed by previous API calls until all requested bans are returned.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListChannelBansInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListChannelBansInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &"*** Sensitive Data Redacted ***");
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMessagingSessionEndpointInput {}
impl std::fmt::Debug for GetMessagingSessionEndpointInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMessagingSessionEndpointInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the message.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the channel moderator.</p>
    pub channel_moderator_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelModeratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelModeratorInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("channel_moderator_arn", &self.channel_moderator_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelModeratedByAppInstanceUserInput {
    /// <p>The ARN of the moderated channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstanceUser</code> in the moderated channel.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelModeratedByAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelModeratedByAppInstanceUserInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelMembershipForAppInstanceUserInput {
    /// <p>The ARN of the channel to which the user belongs.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the user in a channel.</p>
    pub app_instance_user_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelMembershipForAppInstanceUserInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelMembershipForAppInstanceUserInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("app_instance_user_arn", &self.app_instance_user_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelMembershipInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelBanInput {
    /// <p>The ARN of the channel from which the user is banned.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member being banned.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelBanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelBanInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeChannelInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeChannelInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the moderator being deleted.</p>
    pub channel_moderator_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelModeratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelModeratorInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("channel_moderator_arn", &self.channel_moderator_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelMessageInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the message being deleted.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelMessageInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("message_id", &self.message_id);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelMembershipInput {
    /// <p>The ARN of the channel from which you want to remove the user.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member that you're removing from the channel.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelBanInput {
    /// <p>The ARN of the channel from which the <code>AppInstanceUser</code> was banned.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the <code>AppInstanceUser</code> that you want to reinstate.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelBanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelBanInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteChannelInput {
    /// <p>The ARN of the channel being deleted.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteChannelInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelModeratorInput {
    /// <p>The ARN of the channel.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the moderator.</p>
    pub channel_moderator_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateChannelModeratorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelModeratorInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("channel_moderator_arn", &self.channel_moderator_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelMembershipInput {
    /// <p>The ARN of the channel to which you're adding users.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member you want to add to the channel.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default
    /// members are always returned as part of <code>ListChannelMemberships</code>. Hidden members
    /// are only returned if the type filter in <code>ListChannelMemberships</code> equals
    /// <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported
    /// by moderators.</p>
    pub r#type: std::option::Option<crate::model::ChannelMembershipType>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelBanInput {
    /// <p>The ARN of the ban request.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the member being banned.</p>
    pub member_arn: std::option::Option<std::string::String>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateChannelBanInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelBanInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("member_arn", &self.member_arn);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateChannelInput {
    /// <p>The ARN of the channel request.</p>
    pub app_instance_arn: std::option::Option<std::string::String>,
    /// <p>The name of the channel.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The channel mode: <code>UNRESTRICTED</code> or <code>RESTRICTED</code>. Administrators,
    /// moderators, and channel members can add themselves and other members to unrestricted
    /// channels. Only administrators and moderators can add members to restricted channels.</p>
    pub mode: std::option::Option<crate::model::ChannelMode>,
    /// <p>The channel's privacy level: <code>PUBLIC</code> or <code>PRIVATE</code>. Private
    /// channels aren't discoverable by users outside the channel. Public channels are discoverable
    /// by anyone in the <code>AppInstance</code>.</p>
    pub privacy: std::option::Option<crate::model::ChannelPrivacy>,
    /// <p>The metadata of the creation request. Limited to 1KB and UTF-8.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>The client token for the request. An <code>Idempotency</code> token.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>The tags for the creation request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateChannelInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateChannelInput");
        formatter.field("app_instance_arn", &self.app_instance_arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("mode", &self.mode);
        formatter.field("privacy", &self.privacy);
        formatter.field("metadata", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchCreateChannelMembershipInput {
    /// <p>The ARN of the channel to which you're adding users.</p>
    pub channel_arn: std::option::Option<std::string::String>,
    /// <p>The membership type of a user, <code>DEFAULT</code> or <code>HIDDEN</code>. Default
    /// members are always returned as part of <code>ListChannelMemberships</code>. Hidden members
    /// are only returned if the type filter in <code>ListChannelMemberships</code> equals
    /// <code>HIDDEN</code>. Otherwise hidden members are not returned. This is only supported
    /// by moderators.</p>
    pub r#type: std::option::Option<crate::model::ChannelMembershipType>,
    /// <p>The ARNs of the members you want to add to the channel.</p>
    pub member_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The <code>AppInstanceUserArn</code> of the user that makes the API call.</p>
    pub chime_bearer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BatchCreateChannelMembershipInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchCreateChannelMembershipInput");
        formatter.field("channel_arn", &self.channel_arn);
        formatter.field("r#type", &self.r#type);
        formatter.field("member_arns", &self.member_arns);
        formatter.field("chime_bearer", &self.chime_bearer);
        formatter.finish()
    }
}
